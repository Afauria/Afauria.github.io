<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>知识体系构建中......</title>
    <url>/2021/04/04/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>迁移说明：</p>
<ol>
<li>关联的知识和文章越来越多，由于不是同时写的，放在博客中很散乱，难以关联阅读。</li>
<li>另外就是文章日期的维护和管理太麻烦了。</li>
</ol>
<center><a href="https://blog.afauria.xyz/KnowledgeTree/" style="font-size:30px">点此进入</a></center>

]]></content>
  </entry>
  <entry>
    <title>WordPress建站教程</title>
    <url>/2022/11/17/blog-2022-11-17-WordPress/</url>
    <content><![CDATA[<h1 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h1><p>全球使用最广泛、最成熟的建站平台之一</p>
<p>特点（列举部分）：</p>
<ul>
<li>控制台管理：统计和看板、修改主题、设置等功能。</li>
<li>拥有众多特殊功能的插件，除了博客之外，还可以做电商、官网、社区等。</li>
<li>功能丰富，定制个性化页面：可以添加评论、视频、表单、付款等控件（区块）</li>
<li>网页在线编辑，所见即所得</li>
<li>基于PHP+MySQL，导出导入不是很方便，需要安装插件从其他博客迁移导入</li>
</ul>
<p>常说的WordPress主要指两个产品</p>
<ul>
<li><strong><a href="https://wordpress.org/">WordPress.org</a>、<a href="https://cn.wordpress.org/">WordPress.org中文网</a><strong>：</strong>是一个开源软件</strong>，自带几千个免费主题，需要自行购买主机、搭建PHP环境部署。</li>
<li><strong><a href="https://wordpress.com/">WordPress.com</a><strong>：</strong>是一个WordPress主机服务</strong>（有免费版，功能受限），类似的还有Bluehost、DreamHost、SiteGround等（收费服务）。本质就是上面提到的第三方博客平台，只不过功能更丰富，可以安装主题、插件、绑定域名等。</li>
</ul>
<h1 id="WordPress-com"><a href="#WordPress-com" class="headerlink" title="WordPress.com"></a>WordPress.com</h1><ol>
<li>选择免费版，注册账号登录（后续有需要可以升级）</li>
<li>选择wordpress子域名，例如<code>afauria.wordpress.com</code></li>
<li>进入网页端控制台（也可以下载控制台的客户端），直接编辑文章、发布即可。访问站点效果如下</li>
</ol>
<p><img src="/2022/11/17/blog-2022-11-17-WordPress/WordPress%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C.png"></p>
<p>优点：不需要部署环境，直接登入账号即可</p>
<p>缺点：由于是国外的主机，国内访问可能受限，免费版只有几十个主题，1GB存储空间、还会带广告或者横幅。</p>
<p>价格如下：</p>
<p><img src="/2022/11/17/blog-2022-11-17-WordPress/WordPress%E4%BB%B7%E6%A0%BC%E8%A1%A8.png"></p>
<h1 id="WordPress-org"><a href="#WordPress-org" class="headerlink" title="WordPress.org"></a>WordPress.org</h1><p>WordPress环境介绍：</p>
<ul>
<li><p>主机：</p>
<ul>
<li>云主机：需购买云服务或者VPS</li>
<li>本地的主机：自己的电脑、或者使用树莓派作为服务器，需要公网ip或者使用内网穿透供外部访问</li>
</ul>
</li>
<li><p>PHP（<strong>H</strong>ypertext <strong>P</strong>reprocessor，超文本预处理器）：WordPress使用PHP进行开发</p>
</li>
<li><p>MySQL：WordPress所有信息都存储在数据库中，例如文章、站点配置等。</p>
</li>
<li><p>Apache或者Nginx：Web服务器，用于部署PHP页面。</p>
</li>
<li><p>phpMyAdmin（非必需）：PHP编写的数据库管理工具</p>
</li>
<li><p>WordPress.org：php应用，下载之后解压即可，需要部署到Web容器中</p>
</li>
</ul>
<blockquote>
<p>PHP是一种服务器端脚本语言，可以嵌入HTML、CSS、JS。PHP是一种解释性语言，不需要编译打包。</p>
<p>个人理解WordPress是一种前后端不分离的开发模式，PHP操作数据库，并且通过内嵌HTML显示动态网页，前后端一起部署到Apache上。</p>
<p>类似JSP应用，但是原理不同，JSP会被编译成Servlet执行，而PHP是解释执行。最终都需要部署到Web容器中运行。</p>
</blockquote>
<h2 id="云主机环境搭建"><a href="#云主机环境搭建" class="headerlink" title="云主机环境搭建"></a>云主机环境搭建</h2><p>针对VPS或者云服务，最简单的就是使用<strong>宝塔面板</strong>（服务器管理软件）安装环境，可以一键安装LNMP或者LAMP环境</p>
<blockquote>
<ul>
<li>LNMP：Linux+Nginx+MySQL+PHP</li>
<li>LAMP：Linux+Apache+MySQL+PHP</li>
</ul>
</blockquote>
<p><img src="/2022/11/17/blog-2022-11-17-WordPress/LNMP%E5%92%8CLAMP.png"></p>
<p>参考网上的教程即可：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/37896471">WordPress搭建教程：手把手教你搭建WordPress博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/534537871">WordPress建站步骤详细图文教程</a></li>
</ul>
<h2 id="本地主机环境搭建"><a href="#本地主机环境搭建" class="headerlink" title="本地主机环境搭建"></a>本地主机环境搭建</h2><p>自行搭建环境。通常本地仅用于调试，真正部署还是要用专门的主机。</p>
<p>基本步骤相同，只不过每个环节都有多种方式实现。</p>
<ol>
<li>安装PHP+Apache+MySQL环境，phpMyAdmin选择性安装。</li>
<li>下载<a href="https://cn.wordpress.org/download/#download-install">WordPress.org</a>应用程序。</li>
<li>将WordPress应用部署到服务器：Apache或者Nginx。</li>
<li>访问<code>localhost</code>网址，打开WordPress首页，默认是80端口。如果新建了子目录，则访问对应的路径，例如<code>localhost/wordpress</code>。</li>
<li>创建数据库，WordPress配置数据库连接信息。如果数据库和WordPress不在同一台主机，需要修改配置并授权其他host访问（下面会介绍）</li>
<li>数据库连接成功后进入登录页面，注册账号后即可登录到控制台</li>
<li>至此，WordPress本地已经部署成功，和<code>WordPress.com</code>一样在控制台编辑和发布文章，所有数据都保存在MySQL中。</li>
</ol>
<p><strong>不同OS前面几个环节有些差异，进入WordPress首页之后的流程都是相同的</strong></p>
<p>推荐使用Docker部署，具有跨平台和隔离的特性。</p>
<h1 id="MacOS环境搭建"><a href="#MacOS环境搭建" class="headerlink" title="MacOS环境搭建"></a>MacOS环境搭建</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>安装Apache环境：Mac自带Apache，使用<code>sudo apachectl start</code>开启服务，访问<code>localhost</code>，如图表示Apache服务启动成功。</p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/Mac启动Apache服务.png" style="zoom: 50%;">

<p>安装MySQL：<code>brew install mysql</code>。</p>
<p>安装PHP：<code>brew install php</code>，MacOS 12之前自带PHP，新版本移除了PHP。</p>
<p>根据提示修改apache配置文件<code>sudo vim /etc/apache2/httpd.conf</code>，支持php模块</p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/Mac Apache配置PHP模块.png" style="zoom: 50%;">

<p>修改完之后使用<code>apachectl -t</code>验证配置文件是否正确</p>
<h2 id="下载WordPress应用并部署"><a href="#下载WordPress应用并部署" class="headerlink" title="下载WordPress应用并部署"></a>下载WordPress应用并部署</h2><p>下载<a href="https://cn.wordpress.org/download/#download-install">WordPress.org</a>应用程序并解压（中文版）</p>
<p>将wordpress文件夹拷贝到到Apache的网站根目录：</p>
<ul>
<li>MacOS上的网站根目录<code>/Library/WebServer/Documents/</code></li>
<li>Windows上的网站根目录一般是<code>&lt;phpStudy路径&gt;/WWW</code></li>
<li>Linux上Apache的网站根目录为<code>/var/www/html/</code></li>
</ul>
<p>Apache网站根目录一般在<code>httpd.conf</code>中配置，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> MacOS上/etc/apache2/httpd.conf</span></span><br><span class="line">DocumentRoot &quot;/Library/WebServer/Documents&quot;</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost/wordpress</code>打开WordPress首页</p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/WordPress首页.png" style="zoom: 33%;">

<h2 id="WordPress配置"><a href="#WordPress配置" class="headerlink" title="WordPress配置"></a>WordPress配置</h2><p>先创建数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录数据库</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database db_word_press;</span></span><br></pre></td></tr></table></figure>

<p>根据提示填写数据库连接信息，如图：</p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/WordPress数据库配置.png" style="zoom: 33%;">

<p>配置完成后会生成<code>wp-config.php</code>文件，也可以手动修改<code>wp-config-sample.php</code>，并另存为<code>wp-config.php</code></p>
<p>接着注册账号并登录到控制台</p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/WordPress控制台.png" style="zoom: 33%;">

<h1 id="Docker搭建"><a href="#Docker搭建" class="headerlink" title="Docker搭建"></a>Docker搭建</h1><p>可以使用单纯的Linux镜像，自行安装PHP、Apache、MySQL、WordPress。这里直接使用wordpress镜像</p>
<ol>
<li>下载wordpress镜像，内置了PHP+Apache+WordPress：<code>docker pull wordpress</code></li>
<li>运行wordpress容器：<code>docker run --name my-wordpress -p 8080:80 -d wordpress</code></li>
<li>WordPress已经下载并部署在了<code>/var/www/html/</code></li>
<li>访问网址<code>localhost:8080</code>，选择语言之后进入WordPress首页。</li>
</ol>
<h2 id="Docker运行phpMyAdmin"><a href="#Docker运行phpMyAdmin" class="headerlink" title="Docker运行phpMyAdmin"></a>Docker运行phpMyAdmin</h2><p>phpMyAdmin用于数据库管理，可以根据需求安装。</p>
<p>参考：<a href="https://docs.phpmyadmin.net/zh_CN/latest/setup.html#installing-using-docker">phpMyAdmin官方文档</a></p>
<ol>
<li>下载phpmyadmin镜像：<code>docker pull phpmyadmin</code></li>
<li>运行phpmyadmin容器：<code>docker run --name phpmyadmin -d -e PMA_HOST=&lt;本机IP地址&gt; -p 8081:80 phpmyadmin</code>。</li>
<li>进入容器环境：<code>docker exec -it phpmyadmin /bin/bash</code></li>
</ol>
<blockquote>
<p><code>-e PMA_HOST</code>是配置环境变量，表示phpMyAdmin要连接的数据库Host。</p>
</blockquote>
<h1 id="Windows搭建"><a href="#Windows搭建" class="headerlink" title="Windows搭建"></a>Windows搭建</h1><p>推荐使用<strong>phpStudy集成环境</strong>，自带PHP+MySQL+Apache+phpMyAdmin。其他流程和MacOS类似</p>
<p>下载phpStudy并点击启动，如图</p>
<p><img src="/2022/11/17/blog-2022-11-17-WordPress/phpStudy.png"></p>
<p>将WordPress文件夹拷贝到网站根目录，默认为<code>&lt;phpStudy&gt;/WWW</code></p>
<p><img src="/2022/11/17/blog-2022-11-17-WordPress/phpStudy%E7%BD%91%E7%AB%99%E6%A0%B9%E7%9B%AE%E5%BD%95.png"></p>
<p>访问<code>localhost/wordpress</code>，打开WordPress首页。</p>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="无法连接MySQL"><a href="#无法连接MySQL" class="headerlink" title="无法连接MySQL"></a>无法连接MySQL</h2><p>使用Docker搭建环境，由于WordPress镜像不包含MySQL，因此需要连接宿主机或者其他容器的MySQL。</p>
<p>默认情况下，数据库只能在本地访问，远程或容器内无法访问，因此需要开启远程访问权限。</p>
<p>查看当前用户信息如下</p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/MySQL用户列表.png" style="zoom: 50%;">

<p>修改<code>/usr/local/etc/my.cnf</code>配置，注释掉绑定配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bind-address = 127.0.0.1</span></span><br></pre></td></tr></table></figure>

<p>授予用户权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新用户：CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;</span></span><br><span class="line">CREATE USER <span class="string">&#x27;afauria&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="comment"># 更新host字段为%，如果已经是%则不需要</span></span><br><span class="line">update user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user =<span class="string">&#x27;afauria&#x27;</span>;</span><br><span class="line"><span class="comment"># 授予权限：GRANT privileges ON databasename.tablename TO &#x27;username&#x27;@&#x27;host&#x27;;</span></span><br><span class="line">GRANT ALL ON *.* TO <span class="string">&#x27;afauria&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="comment"># 重启mysql服务</span></span><br><span class="line">brew services restart mysql</span><br></pre></td></tr></table></figure>

<p>WordPress数据库主机需要填宿主机的IP地址。</p>
<h2 id="PHP模块签名问题"><a href="#PHP模块签名问题" class="headerlink" title="PHP模块签名问题"></a>PHP模块签名问题</h2><p>MacOS部署PHP到Apache，<code>apachectl -t</code>出现异常：<code>No code signing authority for module at xxx</code></p>
<p>原因：macOS Monterey开始，强制要求应用程序签名，使用brew安装的PHP模块没有签名</p>
<p>解决方法：参考<a href="https://www.simplified.guide/macos/apache-php-homebrew-codesign">How to sign homebrew PHP module in macOS</a></p>
<ol>
<li>打开【钥匙串访问-证书助理】，先创建证书颁发机构<code>Afauria&#39;s CA</code>，再创建证书<code>Afauria</code></li>
</ol>
<img src="/2022/11/17/blog-2022-11-17-WordPress/Mac证书助理.png" style="zoom: 40%;">

<ol start="2">
<li><p>创建证书颁发机构<code>Afauria&#39;s CA</code>，类型为<strong>自签名根CA</strong></p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/Mac创建证书机构.png" style="zoom: 40%;"></li>
<li><p>信任证书机构</p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/Mac信任证书.png" style="zoom: 40%;"></li>
<li><p>创建证书Afauria，类型为<strong>叶证书</strong></p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/Mac创建证书.png" style="zoom: 40%;"></li>
<li><p>证书签发者选择刚才创建的根证书机构</p>
<img src="/2022/11/17/blog-2022-11-17-WordPress/Mac选择证书签发者.png" style="zoom: 40%;"></li>
<li><p>对PHP模块签名：<code>codesign --sign &quot;Afauria&quot; --force --keychain ~/Library/Keychains/login.keychain-db /usr/local/opt/php/lib/httpd/modules/libphp.so</code></p>
</li>
<li><p>修改<code>httpd.conf</code>配置，添加证书名称：<code>LoadModule php_module /usr/local/opt/php/lib/httpd/modules/libphp.so &quot;Afauria&quot;</code></p>
</li>
<li><p>再次<code>apachectl -t</code>验证成功</p>
</li>
</ol>
<h2 id="PHP架构问题"><a href="#PHP架构问题" class="headerlink" title="PHP架构问题"></a>PHP架构问题</h2><p>Mac部署PHP到apache，<code>apachectl -t</code>出现异常：<code>&#39;xxx libphp.so&#39; (mach-o file, but is an incompatible architecture (have (x86_64), need (arm64e))</code></p>
<p>原因：下载的php是x86_64的，使用的Mac是M1芯片（arm64架构），无法兼容。</p>
<blockquote>
<p>M1芯片暂时无法通过brew下载php，<code>brew search php</code>找不到对应的软件</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈个人博客</title>
    <url>/2022/11/15/blog-2022-11-15-%E6%B5%85%E8%B0%88%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最早是大二在CSDN上写过两篇文章，因为每次修改都要联网登录比较麻烦就放弃了，晾了这么多年再去看，没想到浏览量还蛮多的。</p>
<p>大三实习期间用Jekyll搭建了个人博客，用了几个月转战Hexo了，一直持续到现在。</p>
<p>回过头看，收获还是蛮多的，有水文，也有熬夜写的技术文章。内容总的来说更擅长记录总结，不擅长发表感悟，也不喜欢在文章中掺杂太多废话和闲聊，希望每一句都是干货，知识点尽可能简洁、清晰。</p>
<p>写作过程中最令人头疼的就是文章结构如何组织，一旦写的不好就会出现“上文xxx”，“下文xxx”。好的文章还是要不断打磨修改。</p>
<p>因为最近打算搞团队能力建设，所以梳理了下博客相关的内容，也补充一些没用过的博客框架的搭建教程，带领大家入门折腾。</p>
<h1 id="为什么你需要一个博客？"><a href="#为什么你需要一个博客？" class="headerlink" title="为什么你需要一个博客？"></a>为什么你需要一个博客？</h1><p>如果此前有写些东西，那么博客可以帮你发布到互联网，让更多人能够看到。并且养成良好的写作习惯，提高效率。</p>
<p>如果此前未写过东西，可以思考下写作能带来的益处，每一篇文章都是自己积累的财富，也是一路成长的脚印。</p>
<ol>
<li>知识积累：作为程序员有太多要学习的东西了，光靠记忆效率是很低的，需要一个专门的平台来归档、管理。</li>
<li>偶发感悟，或者有开心的事、人生大事，苦于没有平台记录和分享。</li>
<li>能力提升：专业知识、写作表达、逻辑条理。</li>
<li>倒逼自己输出：例如有用户提问或者评论，会推动自己去更新内容。</li>
<li>紧跟互联网时代：就像当年大家都玩QQ空间，你不玩就OUT了。</li>
<li>从知识获取者转变为知识创作者、贡献者。</li>
<li>打造个人品牌，行业影响力，副业创收…</li>
<li>元宇宙时代每个人都应该建设自己的一亩三分地，和装修一样，有满满的成就感。</li>
<li>组织角度：可以作为团队培训资料，减少重复工作和踩坑。</li>
<li>…</li>
</ol>
<p>坏处嘛，除了需要投入时间精力外，也想不到其他的了。</p>
<blockquote>
<ul>
<li>Web1.0：用户只能查看内容</li>
<li>Web2.0：用户可以贡献内容，平台所有、平台控制、平台支配，平台化</li>
<li>Web3.0（元宇宙）：用户贡献内容，用户所有、用户支配，去中心化</li>
</ul>
</blockquote>
<p>推荐阅读：<a href="https://sspai.com/post/73934">2022 年了，聊聊我为什么还在写博客</a></p>
<h1 id="可以写些什么？"><a href="#可以写些什么？" class="headerlink" title="可以写些什么？"></a>可以写些什么？</h1><p>博客内容可以是专业技术、美好记忆、心得感悟、晒娃撒狗粮、读书观影旅游分享等等。</p>
<p>根据自己的想法划分了几个境界：</p>
<ul>
<li>初出茅庐：阅读+收藏网址，参与评论和提问、长期关注他人、付费阅读、付费下载</li>
<li>小试牛刀（入门）：注册博客平台账户，或者搭建了个人网站，在上面发布过文章</li>
<li>持之以恒（活跃度）：个人博客有较多输出，长期维护</li>
<li>小有名气（知名度）：有较多的点赞和关注，评论或者加好友互动，有人愿意为你的知识买单打赏</li>
<li>传道授业（专业度）：发布过系列知识、专题、开课</li>
<li>声名远扬：出书，业内大佬</li>
</ul>
<h1 id="博客搭建的方式"><a href="#博客搭建的方式" class="headerlink" title="博客搭建的方式"></a>博客搭建的方式</h1><p>博客主要分为三种方式：</p>
<ol>
<li>使用第三方博客平台（中心化、平台化）：在三方平台创作和发布。</li>
<li>使用静态框架搭建博客，生成静态页面发布：本地编写Markdown，通过工具转换成html，发布到静态网页托管服务。</li>
<li>使用动态框架搭建博客，部署动态页面，运行时请求数据库：自行部署平台服务，在平台上创作和发布。使用和第三方博客平台类似，但是自由度更高。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>第三方博客平台</th>
<th>静态框架</th>
<th>动态框架</th>
</tr>
</thead>
<tbody><tr>
<td>搜索引擎优化</td>
<td>便于SEO，例如百度搜索结果前排基本都是CSDN</td>
<td>需要自行优化、推广</td>
<td>需要自行优化、推广</td>
</tr>
<tr>
<td>技术门槛</td>
<td>无</td>
<td>有一定门槛，视框架和功能而定</td>
<td>有一定门槛，视框架和功能而定</td>
</tr>
<tr>
<td>成本</td>
<td>无</td>
<td>GitHub Pages、Gitee Pages免费。自建空间需要云服务或者主机+域名费用</td>
<td>云服务或者主机+域名费用</td>
</tr>
<tr>
<td>编辑器</td>
<td>在线编辑</td>
<td>Markdown，可以嵌入HTML。不同框架解析可能会出现异常。</td>
<td>在线编辑，可以插入不同控件，所见即所得</td>
</tr>
<tr>
<td>数据存储</td>
<td>和账号绑定，不需要自己存档。但有数据丢失、隐私泄漏的风险</td>
<td>自行维护原文档，可以使用Git管理</td>
<td>数据库存储，不便于导出导入和迁移</td>
</tr>
<tr>
<td>可移植性</td>
<td>弱，大部分不支持导入导出</td>
<td>强，直接部署静态页面即可</td>
<td>弱，难以迁移数据到其他框架</td>
</tr>
<tr>
<td>主题样式</td>
<td>大多数无法选择</td>
<td>主题丰富，可以定制布局和样式。</td>
<td>主题丰富，可以定制布局和样式。</td>
</tr>
<tr>
<td>环境配置</td>
<td>和账号绑定，网页在线编辑</td>
<td>新电脑需要重新配置环境</td>
<td>自建服务，部署在服务器</td>
</tr>
<tr>
<td>部署发布</td>
<td>在线发布，平台托管</td>
<td>GitHub Pages、Gitee Pages，或者自行购买云服务或者主机</td>
<td>自行购买云服务或者主机</td>
</tr>
<tr>
<td>自由度</td>
<td>低，开发者只能上传内容，平台审核</td>
<td>高</td>
<td>高，除了博客之外，还可以做论坛、电商等站点</td>
</tr>
<tr>
<td>域名</td>
<td>使用平台子域名</td>
<td>绑定自己的域名，便于记忆和宣传</td>
<td>绑定自己的域名，便于记忆和宣传</td>
</tr>
<tr>
<td>代表产品</td>
<td>CSDN、简书、掘金等</td>
<td>Hexo、Hugo、Jekyll、VuePress、Docsify、mkdocs、Sphinx等</td>
<td>WordPress、Typecho、Halo、Solo等</td>
</tr>
<tr>
<td>优点</td>
<td>无门槛、0成本、利于SEO</td>
<td>低成本、主题丰富</td>
<td>功能丰富、扩展性、交互能力强</td>
</tr>
</tbody></table>
<h2 id="从写作方式上划分"><a href="#从写作方式上划分" class="headerlink" title="从写作方式上划分"></a>从写作方式上划分</h2><ol>
<li>本地编写Markdown。</li>
<li>客户端或者网页在线编辑器，富文本编辑器。</li>
</ol>
<h2 id="从发布方式上划分"><a href="#从发布方式上划分" class="headerlink" title="从发布方式上划分"></a>从发布方式上划分</h2><ol>
<li>三方提供主机服务（平台）：国内平台大部分免费，国外平台大部分需要付费，免费的功能受限。一般是子域名，部分提供域名绑定功能。</li>
<li>购买云服务器，自行搭建环境、配置域名、管理数据，同时可以开放给其他人使用。</li>
<li>购买本地主机，自行搭建环境、配置域名、管理数据，同时可以开放给其他人使用。</li>
<li>纯静态网页托管服务：GitHub Pages、Gitee Pages，一般是子域名，也提供域名绑定功能。</li>
</ol>
<h1 id="选择合适的框架"><a href="#选择合适的框架" class="headerlink" title="选择合适的框架"></a>选择合适的框架</h1><p><strong>没有最好的框架，只有最合适的框架。</strong></p>
<p>可以从以下几个纬度对比：</p>
<ol>
<li>成本：第三方博客&lt;静态框架&lt;动态框架</li>
<li>功能和可扩展性：第三方博客&lt;静态框架&lt;动态框架</li>
<li>上手难度：第三方博客&lt;自建博客</li>
<li>主题和样式：第三方博客&lt;自建博客，看个人喜好，静态和动态框架都有大量主题，够用就行</li>
<li>写作方式、发布方式。</li>
</ol>
<h2 id="为什么不选择第三方平台？"><a href="#为什么不选择第三方平台？" class="headerlink" title="为什么不选择第三方平台？"></a>为什么不选择第三方平台？</h2><p>第三方博客相比自建博客，存在很多痛点：</p>
<ol>
<li>自由度低：样式固定，无法设置个性化主题</li>
<li>需要联网在线编辑</li>
<li>频繁提示登录</li>
<li>大量的广告插入</li>
<li>内容受平台管控和审核，评论限制，例如不允许转发到其他平台</li>
<li>关服整改：例如博客园整改</li>
<li>存在数据丢失、泄漏的风险</li>
<li>链接跳转会有安全提示，例如即将离开CSDN、掘金页面…</li>
<li>浏览门槛：例如CSDN很多精华文章和专栏都需要购买或者关注</li>
<li>文章质量参差不齐，浪里淘金：吐槽CSDN垃圾堆。一部分是由于面向大众，非程序员社区，一部分是爬虫、转载导致很多格式错乱。</li>
</ol>
<h2 id="静态网站的优势"><a href="#静态网站的优势" class="headerlink" title="静态网站的优势"></a>静态网站的优势</h2><p>静态网站相比动态网站有几点优势：</p>
<ol>
<li>利于SEO</li>
<li>运行高效：纯静态网站可以通过CDN加速，动态网站还受限于服务端处理能力</li>
<li>更加安全：难以被攻击</li>
<li>部署简单，成本低廉：使用GitHub Pages、Gitee Pages免费托管</li>
<li>本地生成，实时预览</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对样式没有太大要求、图省事的、不确定是否能持续产出，推荐用第三方博客平台。</strong></p>
<p><strong>有一定追求和想法的，想进一步打造个人品牌，推荐自建博客。希望低成本的选择静态框架，希望拥有更多功能和玩法的选择动态框架</strong></p>
<p><strong>话说回来，博客内容才是关键，样式那些花里胡哨的可有可无，当然设计精美的博客总是能更吸引人眼球。</strong></p>
<p>有精力的话可以运营多平台，扩大影响力，通过一键同步脚本简化操作。</p>
<h1 id="第三方博客平台"><a href="#第三方博客平台" class="headerlink" title="第三方博客平台"></a>第三方博客平台</h1><p>使用较简单，注册账号，在网页上编辑文章即可，这里不多做介绍。</p>
<p>国内主流博客平台：</p>
<ol>
<li><a href="https://juejin.cn/">稀土掘金</a>：如其名，文章质量较高</li>
<li><a href="https://www.csdn.net/">CSDN</a>：用来搜Bug和解决方案比较多，好的学习文章浪里淘金，同时充斥大量广告，资本化严重</li>
<li><a href="https://www.jianshu.com/">简书</a>：和CSDN类似，内容相对优质一些，广告稍微少点</li>
<li><a href="https://www.cnblogs.com/">博客园</a>：国内较早的博客平台</li>
<li><a href="https://www.51cto.com/">51CTO</a>：IT技术社区</li>
<li><a href="https://www.oschina.net/">开源中国</a>：国内最大的开源社区</li>
<li><a href="https://segmentfault.com/">思否Segmentfault</a>：技术问答为主</li>
<li>…</li>
</ol>
<p>小众社区：</p>
<ol>
<li><a href="https://cloud.tencent.com/developer">腾讯云社区</a>：云开发为主，大咖较多</li>
<li><a href="https://gitbook.cn/">GitChat</a>：技术博客社区</li>
<li><a href="https://ld246.com/">链滴</a></li>
<li><a href="https://sspai.com/">少数派</a></li>
<li>当然QQ空间、公司的KB也算一个社区</li>
<li>…</li>
</ol>
<h1 id="自建博客"><a href="#自建博客" class="headerlink" title="自建博客"></a>自建博客</h1><p>大致流程如下，后面会挑几个单独介绍：</p>
<ol>
<li>确定博客框架，下载并安装对应的环境</li>
<li>配置主题模版，有需要的话可以安装插件，修改配置和样式。</li>
<li>写作：<ol>
<li>动态框架：在客户端或者网页端写作，保存在数据库中，动态请求服务端数据进行显示</li>
<li>静态框架：使用Markdown写作，保存为md文件，最终生成静态html部署</li>
</ol>
</li>
<li>管理文章中引用到图片：<ol>
<li>可以通过相对路径引用，静态打包一起部署</li>
<li>可以创建图床，通过url链接引用。（可以直接放在GitHub中，如果嫌图片访问慢，可以使用云服务）</li>
</ol>
</li>
<li>部署：<ol>
<li>免费的<strong>静态网页托管</strong>服务：GitHub Pages、Gitee Pages。</li>
<li>购买云服务器，自行部署：阿里云、腾讯云，使用服务器公网IP</li>
<li>本地主机：可以使用树莓派作为小型服务器。外网访问需要申请公网IP。如果没有公网IP，可以使用内网穿透服务。</li>
</ol>
</li>
<li>绑定域名：<ol>
<li>使用子域名：部署到GitHub Pages、Gitee Pages、WordPress.com等服务，可以直接使用它们的子域名。</li>
<li>自行购买：阿里云、腾讯云都可以购买域名，根据不同框架说明绑定域名即可。</li>
</ol>
</li>
<li>如果部署在国内的主机，需要备案</li>
</ol>
<blockquote>
<p>域名本身不需要备案，但需要实名认证。</p>
<p>域名指向国内的服务器需要备案，指向国外的服务器不需要备案。</p>
<p>GitHub Pages是国外主机，因此不需要备案。</p>
</blockquote>
<h1 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h1><p>除了上面提到的几种方式之外，还有专门的电子书、笔记等框架。不同于博客的随意性，电子书更适合创作专题内容和系列文章。</p>
<p>常用的如</p>
<ul>
<li><a href="https://www.gitbook.com/">GitBook</a>：<ul>
<li>gitbook-cli：一个基于Node的命令行工具，用于生成静态网页，可以托管到GitPages，支持本地运行预览。<strong>相比gitbook.com更加轻量，可惜已经不再维护</strong></li>
<li>gitbook.com：一个写作平台，发布到gitbook子域名，例如<code>https://afauria.gitbook.io/</code>，优点是可以GitHub仓库同步。缺点是国内访问慢</li>
</ul>
</li>
<li><a href="https://www.kancloud.cn/">看云</a>：电子书阅读和创作平台，可以设置付费，已迁移到顶想云知识管理。</li>
<li><a href="https://www.yuque.com/dashboard">语雀</a>：文档与知识库工具，写作体验好，功能丰富，包括文档、表格、笔记、待办、团队协作、项目管理等。类似印象笔记、有道云笔记、Notion等笔记工具</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>GitBook</th>
<th>看云</th>
<th>语雀</th>
</tr>
</thead>
<tbody><tr>
<td>使用</td>
<td>本地Markdown写作，Git版本管理，生成静态网页发布</td>
<td>使用Markdown编辑器、Git版本管理</td>
<td>客户端或者网页在线编辑</td>
</tr>
<tr>
<td>价格</td>
<td>命令行工具免费，平台专业版收费</td>
<td>价格免费版功能受限，私有文档需要会员</td>
<td>免费版功能受限，公开笔记需要会员</td>
</tr>
<tr>
<td>可移植性</td>
<td>Markdown文档</td>
<td>可移植性支持导出电子书</td>
<td>支持导入导出Markdown、电子书等格式，可能存在兼容性问题</td>
</tr>
</tbody></table>
<blockquote>
<p>注：hexo需要新版本node，gitbook-cli只能通过旧版本node运行，因此无法共存。</p>
<p>使用n管理node版本：使用hexo时切换到<code>n node/14.17.6</code>，使用gitbook-cli时切换到<code>n node/10.24.0</code></p>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文介绍了几种博客搭建的方式，可以明显看到个人倾向是静态框架。</p>
<p>我个人用的是Hexo+GitHub Pages，平常用Markdown写作，使用Git管理源文件，写完一键发布。</p>
<p>电子书使用的是GitBook，主要用来构建知识体系。</p>
<p>基本没有做推广和运营，导致曝光率不高，后续可能会同步到其他平台，提高曝光率，当然创作水平也有待提升。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://staticsitegenerators.net/">静态站点生成器列表</a>：（SSG，Static Site Generator）</li>
</ul>
<p><a href="https://blog.csdn.net/Java_stud/article/details/120046606">https://blog.csdn.net/Java_stud/article/details/120046606</a></p>
<p><a href="https://www.helloworld.net/p/9060295773">https://www.helloworld.net/p/9060295773</a></p>
<p><a href="https://www.yingxiaoo.com/161181.html">https://www.yingxiaoo.com/161181.html</a></p>
<p><a href="https://www.wbolt.com/best-blogging-platform.html">https://www.wbolt.com/best-blogging-platform.html</a></p>
<p><a href="https://www.websiteplanet.com/zh-hans/blog/%E5%A4%A7%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%E5%BB%BA%E7%AB%99%E5%B7%A5%E5%85%B7/">https://www.websiteplanet.com/zh-hans/blog/%E5%A4%A7%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%E5%BB%BA%E7%AB%99%E5%B7%A5%E5%85%B7/</a></p>
<p><a href="https://www.lsbin.com/9294.html">https://www.lsbin.com/9294.html</a></p>
<p><a href="https://blog.51cto.com/lovebetterworld/4796485">https://blog.51cto.com/lovebetterworld/4796485</a></p>
<p><a href="https://juejin.cn/post/7125083795023691812">https://juejin.cn/post/7125083795023691812</a></p>
<p><a href="https://blog.csdn.net/twg666/article/details/124748337">https://blog.csdn.net/twg666/article/details/124748337</a></p>
<p>Wix、SquareSpace、Joomla、Medium.com、Ghost、Weebly、Blogger、Tumblr</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>RetroPie复古游戏机</title>
    <url>/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="RetroPie使用"><a href="#RetroPie使用" class="headerlink" title="RetroPie使用"></a>RetroPie使用</h1><p>RetroPie是一个复古的游戏机操作系统，包含各种街机、家用游戏机、掌机的模拟器。</p>
<p>有两种安装方式</p>
<ol>
<li>运行在现有的Raspbian系统上：暂不支持最新的Bullseye版本的系统</li>
<li>烧录完整的操作系统镜像</li>
</ol>
<p>由于我装的是Bullseye版本的系统，而且只有32G，怕不够用，所以另外买了张TF卡专门运行RetroPie。</p>
<blockquote>
<p>除了树莓派之外，RetroPie也可以运行在PC上</p>
</blockquote>
<h2 id="系统烧录"><a href="#系统烧录" class="headerlink" title="系统烧录"></a>系统烧录</h2><ol>
<li>下载烧录工具：<a href="https://downloads.raspberrypi.org/imager/imager_latest.exe">Raspberry Pi Imager（Windows版）</a></li>
<li>下载<a href="https://retropie.org.uk/download/">Retropie系统镜像</a></li>
<li>使用Imager打开RetroPie系统镜像，选择存储卡，点击烧录，耐心等待即可。</li>
<li>烧录完成后将TF卡插入树莓派，通电启动</li>
</ol>
<p><img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%BD%95.png"></p>
<h2 id="按键配置"><a href="#按键配置" class="headerlink" title="按键配置"></a>按键配置</h2><p>参考<a href="https://retropie.org.uk/docs/Controller-Configuration/">官方文档</a></p>
<p>首次启动需要配置按键，长按任意键进入按键配置页面</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie首次启动按键配置.png" style="zoom: 50%">

<p>如果手柄的按钮不够用，则长按任意键跳过该键的设置</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie按键配置.png" style="zoom: 50%">

<p>NES手柄配置如下：</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie按键配置NES手柄.png" style="zoom: 40%">

<p>XBox手柄配置如下：</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie按键配置XBox手柄.png" style="zoom: 40%">

<p>最后一个按键是热键，可以和其他键组合，一般使用select按钮作为热键</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie热键组合.png" style="zoom: 100%">

<p>配置成功后进入RetroPie主界面（EmulationStation）</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie控制台.jpg" style="zoom: 100%">

<h2 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h2><p>启用SSH：打开RetroPi菜单，【raspi-config&gt;Interface Options&gt;SSH】</p>
<p>登录SSH：用户名为pi，<code>ssh pi@IP地址</code>，输入密码<code>raspberry</code></p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie登录SSH.png" style="zoom: 100%">

<h2 id="安装模拟器"><a href="#安装模拟器" class="headerlink" title="安装模拟器"></a>安装模拟器</h2><p>RetroPie系统默认只安装了部分模拟器，如果需要安装其他模拟器，可以在【RetroPie-&gt;RetroPie-Setup-&gt;Manage Packages】中选择安装、升级、卸载等</p>
<h2 id="传输ROM文件"><a href="#传输ROM文件" class="headerlink" title="传输ROM文件"></a>传输ROM文件</h2><p>所有ROM文件存放在<code>~/RetroPie/roms/$CONSOLE</code>下，<code>$CONSOLE</code>表示不同的模拟器目录。</p>
<ul>
<li>使用U盘传输：将ROM文件拷贝到U盘<code>retropie/roms</code>中对应的模拟器目录下，插入树莓派，等待自行拷贝，指示灯完成闪烁。U盘需要设置为FAT32或者NTFS格式</li>
<li>SFTP：使用ssh，通过scp命令拷贝</li>
<li>Samba：连接同一局域网，Windows上，在计算机中输入<code>\\RETROPIE</code>或者<code>\\IP地址</code>访问文件系统</li>
</ul>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie登录Samba.png" style="zoom: 100%">

<p>拷贝完成后按F4刷新列表，或者重启Emulation Station。</p>
<p>拷贝了GBA和NES的ROMs之后，主界面会出现模拟器图标，下方会显示有多少个游戏</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/RetroPie模拟器.jpg" style="zoom: 100%">

<p>FC游戏：《影子传说》</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/影子传说截图.jpg" style="zoom: 100%">

<p>GBA游戏：《宝可梦绿宝石》</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/宝可梦绿宝石截图.jpg" style="zoom: 100%">

<h2 id="Runcommand"><a href="#Runcommand" class="headerlink" title="Runcommand"></a>Runcommand</h2><p>负责启动模拟器和游戏的脚本，打开游戏的时候会显示下图页面</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/Runcommand启动.png" style="zoom: 100%">

<p>在上图中按任意键打开Runcommand菜单，可以为ROM配置启动的模拟器，选择输出详细日志等。</p>
<blockquote>
<p>同一个ROM在不同模拟器上表现可能会不一样，因此有时候需要手动为ROM配置特定的模拟器运行。</p>
</blockquote>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/Runcommand页面.png" style="zoom: 100%">

<h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><p>游戏中文乱码：<code>sudo apt-get -y install fonts-droid-fallback </code></p>
<p>游戏无法运行可能有两个原因：</p>
<ol>
<li><strong>模拟器版本和ROM版本不匹配</strong>：需要换一个版本的模拟器</li>
<li><strong>缺少相关的BIOS文件</strong>：例如neogeo和ngp（Neo Geo Pocket）的游戏需要BIOS</li>
</ol>
<h1 id="RetroPie介绍"><a href="#RetroPie介绍" class="headerlink" title="RetroPie介绍"></a>RetroPie介绍</h1><p>RetroPie基于多个项目，例如RetroArch、Emulation Station、MAME等。</p>
<ul>
<li><strong>Emulator（模拟器）</strong>：RetroPie中预装了部分模拟器，也可以在<strong>【RetroPie-Setup&gt;Manage Packages】</strong>中下载安装其他模拟器</li>
<li><strong>ROM</strong>：游戏卡带的数字版本，由于版权保护，不包含在RetroPie中，<strong>需要自行下载，拷贝到系统中</strong></li>
<li>BIOS（Basic Input Output System，基本输入输出系统）：模拟器运行需要的程序（软件），可以直接控制硬件。大部分模拟器会模拟其系统的BIOS，不过有些游戏需要使用特定的BIOS，模拟器不支持，需要手动导入。由于版权保护，不在RetroPie中。</li>
</ul>
<blockquote>
<p>电脑的BIOS可以设置硬件、引导操作系统启动等</p>
<p>街机的BIOS还可以用来设置投币数、对局数等</p>
</blockquote>
<p>个人理解模拟器（虚拟机）就是在一台计算机上模拟另一台计算机的指令运行，并且会模拟CPU运行频率。例如将GBA模拟器的指令转成Windows的指令，进行渲染、绘制、控制等。</p>
<h2 id="RetroArch"><a href="#RetroArch" class="headerlink" title="RetroArch"></a>RetroArch</h2><p>Libretro是模拟器、游戏、媒体程序的开发库，RetroArch是其官方提供的一个参考前端实现。</p>
<p>RetroArch和libretro可以将现有的模拟器作为库或者核心加载进来，RetroArch处理输入（控制）和输出（图形和音频），核心模拟原始系统。</p>
<p>RetroArch为模拟器提供只配置一次手柄的功能，不需要单独配置每个模拟器。</p>
<p>RetroPie中，libretro的模拟器核心名称前标有<code>lr-</code>，例如<code>lr-mame2003</code>、<code>lr-fabneo</code>、<code>lr-mgba</code></p>
<p>RetroPie文档中会说明ROM、配置等文件放置的路径</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/lr-mame2003文件夹.png" style="zoom: 100%">

<h2 id="街机（arcade）说明"><a href="#街机（arcade）说明" class="headerlink" title="街机（arcade）说明"></a>街机（arcade）说明</h2><p>街机模拟器主要有两种：</p>
<ol>
<li>MAME（Multiple Arcade Machine Emulator）：最知名的开源街机模拟器，可以模拟多种街机，运行数千种游戏，推荐使用<code>lr-mame2003+</code></li>
<li>FinalBurn：旧版本是FinalBurn Alpha（fba），新版本是FinalBurn Neo（fbneo）</li>
</ol>
<blockquote>
<p>MESS（Multi Emulator Super System）：多街机模拟器，后合入MAME中</p>
</blockquote>
<p>RetroPie支持MAME和FinalBurn的多个版本</p>
<p>为避免不同街机有不同菜单，<strong>所有街机的ROM都可以放到arcade中，无需解压</strong>，但是需要在Runcommend菜单中指定每个Romset运行的模拟器。</p>
<blockquote>
<p>ROMSet：Rom集，可以指多个游戏ROM的集合，也可以指一个游戏需要多个ROM</p>
</blockquote>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p><strong>特定游戏ROM运行需要导入BIOS文件</strong>，RetroPie文档中会说明。</p>
<p>BIOS文件可以放在BIOS目录，也可以放在ROMS对应的模拟器目录。</p>
<p>以NeoGeo和NeoGeo Pocket为例</p>
<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/NeoGeo BIOS说明.png" style="zoom: 100%">

<img src="/2022/09/19/geek-2022-09-19-RetroPie%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA/NGP BIOS说明.png" style="zoom: 100%">

<p>ROM运行依赖BIOS，不同厂商ROM需要的BIOS不一样，放在同一个目录下，模拟器运行的时候会同时加载BIOS和ROM。</p>
<p>MAME模拟器必备36个BIOS：</p>
<ul>
<li>Acclaim PSX——&gt;acpsx.zip</li>
<li>American Laser Games BIOS——&gt;alg_bios.zip</li>
<li>Aleck64 PIF BIOS——&gt;aleck64.zip</li>
<li>Amiga CD32 Bios——&gt;cd32.zip</li>
<li>Arcadia System BIOS——&gt;ar_bios.zip</li>
<li>Atari PSX——&gt;atpsx.zip</li>
<li>Atlus PSX——&gt;atluspsx.zip</li>
<li>Crystal System BIOS——&gt;crysbios.zip</li>
<li>Atomiswave Bios——&gt;awbios.zip</li>
<li>CVS Bios——&gt;cvs.zip</li>
<li>Cassette System——&gt;decocass.zip </li>
<li>Galaxy Games BIOS——&gt;galgbios.zip</li>
<li>System GX——&gt;konamigx.zip</li>
<li>Baby Phoenix/GV System——&gt;konamigv.zip</li>
<li>Konami Viper BIOS——&gt;kviper.zip</li>
<li>Max-A-Flex——&gt;maxaflex.zip</li>
<li>MPU4 Video Firmware——&gt;bctvidbs.zip</li>
<li>Neo-Geo——&gt;neogeo.zip</li>
<li>Nintendo Super System BIOS——&gt;nss.zip</li>
<li>PlayChoice-10 BIOS——&gt;playch10.zip</li>
<li>Mega Play BIOS——&gt;megaplay.zip</li>
<li>Sega MegaTech——&gt;megatech.zip</li>
<li>Naomi Bios——&gt;naomi.zip</li>
<li>Naomi 2 Bios——&gt;naomi2.zip</li>
<li>ST-V Bios——&gt;stvbios.zip</li>
<li>Super Kaneko Nova System BIOS——&gt;skns.zip</li>
<li>System 573 BIOS——&gt;sys573.zip</li>
<li>Taito FX1——&gt;taitofx1.zip</li>
<li>PGM (Polygame Master) System BIOS——&gt;pgm.zip</li>
<li>TPS——&gt;tps.zip</li>
<li>PS Arcade 95——&gt;psarc95.zip</li>
<li>Multi Amenity Cassette System BIOS——&gt;macsbios.zip</li>
<li>Hyper NeoGeo 64 Bios——&gt;hng64.zip</li>
<li>ZN1——&gt;cpzn1.zip</li>
<li>ZN2——&gt;cpzn2.zip</li>
<li>Taito GNET——&gt;taitogn.zip</li>
</ul>
<h1 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h1><ul>
<li><a href="https://www.arcadepunks.com/">Arcade Punks</a>：街机朋克，包含大量游戏合集</li>
<li><a href="https://www.romsgames.net/roms/">ROMS Games</a>：需要VPN，根据游戏平台进行了分类</li>
<li><a href="http://www.gbarom.cn/">掌机迷</a>：提供了中文版的ROM，主要包含FC、NES、GBA、NDS等，没有街机</li>
<li><a href="https://www.mamecn.com/">街机中文网</a>：ROM、模拟器、BIOS下载</li>
<li><a href="https://n802.com/dir/11449240-27299530-05ba1e">FC中文ROMS</a></li>
</ul>
]]></content>
      <categories>
        <category>极客</category>
      </categories>
      <tags>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title>冒险岛私服搭建v176</title>
    <url>/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>私服不用玩太多版本，只要一个079的旧版本，一个高版本体验新职业新剧情。</p>
<p>高版本的端不太好找，都是付费的，还不一定能跑。而且都是打包混淆过的，没有源码，反编译查看也比较吃力。</p>
<ul>
<li><a href="https://www.fengyewuyu.com/thread-4801-1-1.html">搬运，2021冒险岛176至尊版 </a>：需要淘宝订单号，服务端验证</li>
<li><a href="http://www.rexuexia.com/forum.php?mod=viewthread&tid=35265&page=1&authorid=93572">某宝买的冒险岛单机版V175一键端，简单操作 </a>：基于上面的端改的，又加了一层验证码验证</li>
<li><a href="http://www.rexuexia.com/forum.php?mod=viewthread&tid=36921&page=3&authorid=107404">冒险岛176第二版来自冒险岛单机交流群 </a>：也是基于上面的端改的，不过跳过了授权校验的步骤，需要付30金币的下载费</li>
<li><a href="https://www.iopq.net/thread-17105612-1-1.html">【搬运】冒险岛【元旦大礼】怀旧岛V175至尊版 </a>：没试过，不过人家说了是免费的。上面的资源应该都是从群里搬运的，被无良商家拿来卖钱。</li>
</ul>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>用上面的第三个资源，帮我们绕过了服务端验证，使用比较简单</p>
<ol>
<li>使用phpStudy启动数据库，数据库名称默认为bms，用户名和密码为root</li>
<li>使用一键启动器来启动服务端和客户端</li>
</ol>
<p>也可以命令行启动服务端：<code>java -cp ;lib/*;jre8x64/lib/ext/log4j-core-2.14.0.jar;jre8x64/lib/ext/* org.bms.gui.BMS</code></p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E4%B8%80%E9%94%AE%E5%90%AF%E5%8A%A8%E5%99%A8.png"></p>
<h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><p>使用一键登录器，点击上图的”游戏启动”，或者直接打开客户端</p>
<blockquote>
<p>v94以上版本，需要使用虚拟网卡运行，<strong>IP地址为：221.231.130.70</strong></p>
</blockquote>
<p>有一点需要注意，在默认的登录界面输入账号密码会检查盛大账号。有三种方式解决</p>
<ol>
<li>使用自己的真正的盛大账号登录</li>
<li>单机登录方式</li>
</ol>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E5%8D%95%E6%9C%BA%E7%99%BB%E5%BD%95.png"></p>
<ol start="3">
<li>BMS个性账号登陆界面，随便输入账号密码，会自动注册</li>
</ol>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E4%B8%AA%E6%80%A7%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95.png"></p>
<p>运行成功截图</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F%E6%88%AA%E5%9B%BE.png"></p>
<h1 id="服务端破解"><a href="#服务端破解" class="headerlink" title="服务端破解"></a>服务端破解</h1><p>这里介绍下怎么绕过第一个资源的淘宝订单号验证。主要用于学习，第三个资源已经帮我们跳过了，可以直接使用</p>
<p>暂时能想到的一些破解思路：</p>
<ol>
<li>反编译修改Java源码，重新编译打包</li>
<li>修改字节码，再打包</li>
<li>拦截服务端验证请求，模拟返回成功结果</li>
</ol>
<p>使用jadx反编译工具查看jar包</p>
<h2 id="AuthCheckUtil请求服务端"><a href="#AuthCheckUtil请求服务端" class="headerlink" title="AuthCheckUtil请求服务端"></a>AuthCheckUtil请求服务端</h2><p>首先全局搜索”淘宝订单号”，定位到<code>AuthCheckUtil</code>类，代码逻辑比较简单，拼接淘宝订单号和<code>ProcessorId</code>，请求服务端验证。</p>
<img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/反编译AuthCheckUtil.png" style="zoom:100%;">

<p><code>org.bms.server.AuthCheckUtil</code>的main函数中输出了验证端url。因此可以运行AuthCheckUtil：<code>java -cp ;lib/*;jre8x64/lib/ext/log4j-core-2.14.0.jar;jre8x64/lib/ext/* org.bms.server.AuthCheckUtil</code>。</p>
<p>输出<code>http://47.99.96.61:8008/api/checkMapleAuthEn?ddhmid=</code>，即url地址</p>
<p><code>getProcessorId</code>方法使用wmic获取PC的<code>ProcessorId</code>，服务端加密之后返回</p>
<blockquote>
<p>wmic：Windows Management Instrumentation Command-line，Windows管理工具</p>
</blockquote>
<h2 id="校验返回值"><a href="#校验返回值" class="headerlink" title="校验返回值"></a>校验返回值</h2><p>查询<code>checkMapleAuth</code>使用的地方</p>
<p>下面的代码拿到服务端返回的加密字符串，调用<code>StringUtil.decode</code>方法进行解密，使用逗号分割。</p>
<ul>
<li><code>split[0]</code>就是个常量1，这里做了校验</li>
<li><code>split[1]</code>没什么意义，就是打印了一下字符串，因此可以随便填</li>
<li><code>split[2]</code>可以知道是一个Int值，这里我们填10</li>
<li><code>split[3]</code>是ProcessorId，这里做了校验</li>
</ul>
<p>因此解密后的字符串格式如：<code>1,无限制授权,10,ProcessorId</code></p>
<img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/反编译checkMapleAuth.png" style="zoom:100%;">

<h2 id="反编译查看加密方法"><a href="#反编译查看加密方法" class="headerlink" title="反编译查看加密方法"></a>反编译查看加密方法</h2><p>根据上面反编译的结果，可以知道服务端返回的字符串做了加密，反编译StringUtil查看加密和解密的方法，尝试逆推。</p>
<p>可以看到<code>JM</code>方法用于加密，decode方法用于解密。</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E5%8F%8D%E7%BC%96%E8%AF%91StringUtil.png"></p>
<h2 id="获取服务端返回的加密字符串"><a href="#获取服务端返回的加密字符串" class="headerlink" title="获取服务端返回的加密字符串"></a>获取服务端返回的加密字符串</h2><p>被加密的字符串如：<code>1,无限制授权,10,123</code></p>
<h3 id="修改main方法字节码"><a href="#修改main方法字节码" class="headerlink" title="修改main方法字节码"></a>修改main方法字节码</h3><p>上面知道<code>AuthCheckUtil</code>的main方法打印了服务端的url，这里简单修改下main方法，改为调用加密方法加密字符串</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E4%BF%AE%E6%94%B9main%E6%96%B9%E6%B3%95.png"></p>
<p>执行结果如下，<code>PcsI/8T435QUTypDM/e4HnXmNd/SYMWzz1IgsASJdWE=</code>即加密过的字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -cp  ;lib/*;jre8x64/lib/ext/log4j-core-2.14.0.jar;jre8x64/lib/ext/* org.bms.server.AuthCheckUtil</span></span><br><span class="line">PcsI/8T435QUTypDM/e4HnXmNd/SYMWzz1IgsASJdWE=</span><br></pre></td></tr></table></figure>

<h3 id="调用加密方法"><a href="#调用加密方法" class="headerlink" title="调用加密方法"></a>调用加密方法</h3><p>另一种方式，自己编写main文件，调用加密方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(org.bms.server.StringUtil.jM(<span class="string">&quot;1,无限制授权,10,123&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javac命令编译，由于使用了jar包中的方法，因此需要指定<code>classPath</code>，否则会找不到方法</p>
<p><code>javac -cp ;bms.server.jar Main.java -encoding utf8</code></p>
<p>使用java命令运行，由于<code>StringUtil</code>依赖了apache的codec库，因此也要包含到<code>classPath</code>中</p>
<p><code>java -cp ;bms.server.jar;commons-codec-1.7.jar Main</code></p>
<p>同样输出<code>PcsI/8T435QUTypDM/e4HnXmNd/SYMWzz1IgsASJdWE=</code></p>
<h1 id="方式一：修改字节码"><a href="#方式一：修改字节码" class="headerlink" title="方式一：修改字节码"></a>方式一：修改字节码</h1><p>根据上面的代码，可以尝试修改字节码，跳过服务端验证。</p>
<p>使用7-zip打开jar包，将<code>AuthCheckUtil.class</code>、<code>StringUtils.class</code>文件提取出来，使用jbe打开，修改完之后再拖进压缩包中。</p>
<blockquote>
<p><strong>找到合适的切入点，尽可能小的改动，防止引起其他异常。</strong></p>
</blockquote>
<h2 id="修改checkMapleAuth方法返回值"><a href="#修改checkMapleAuth方法返回值" class="headerlink" title="修改checkMapleAuth方法返回值"></a>修改checkMapleAuth方法返回值</h2><p>修改checkMapleAuth返回值为<code>1,无限制授权,10,123</code>，<code>ldc</code>表示加载常量到方法栈中。</p>
<blockquote>
<p>这里反编译参考上面的第二和第三个资源，也是修改了checkMapleAuth方法的返回值，返回字符串<code>1,无限制授权,10</code>，并且去掉了解密的过程。</p>
<p>也可以直接返回加密后的字符串，这样可以跳过第三步decode方法的修改</p>
</blockquote>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E4%BF%AE%E6%94%B9checkMapleAuth%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt="修改checkMapleAuth返回值"></p>
<h2 id="修改getProcessorId方法返回值"><a href="#修改getProcessorId方法返回值" class="headerlink" title="修改getProcessorId方法返回值"></a>修改getProcessorId方法返回值</h2><p>这里为了不修改校验的逻辑，我们再修改下<code>getProcessorId</code>的返回值为123</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E4%BF%AE%E6%94%B9getProcessorId%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt="修改getProcessorId返回值"></p>
<h2 id="修改decode方法返回值"><a href="#修改decode方法返回值" class="headerlink" title="修改decode方法返回值"></a>修改decode方法返回值</h2><p>修改decode方法的返回值，去掉解密逻辑，<code>aload0</code>表示将传入的参数原封不动的返回。</p>
<blockquote>
<p>全局搜了一下这个方法只用到了一次，因此不会影响到其他地方。如果有其他地方使用的话最好换个地方修改，避免影响其他逻辑。</p>
</blockquote>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E4%BF%AE%E6%94%B9decode%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt="修改decode方法返回值"></p>
<p>修改之后使用<code>java -cp ;lib/*;jre8x64/lib/ext/log4j-core-2.14.0.jar;jre8x64/lib/ext/* org.bms.gui.BMS</code>成功运行。</p>
<h1 id="方式二：拦截请求模拟服务端响应"><a href="#方式二：拦截请求模拟服务端响应" class="headerlink" title="方式二：拦截请求模拟服务端响应"></a>方式二：拦截请求模拟服务端响应</h1><p>由于URL是IP地址，想着有没有类似host配置（将域名映射成IP）一样的东西，将目标IP映射到自己的服务器IP和端口上，然后模拟服务端返回成功的结果。</p>
<p>这里要拦截的是从自己电脑出口的请求。查了一下可以通过<strong>IP地址重定向</strong>的方式拦截请求</p>
<p><strong>以Linux为例</strong>，Windows IP重定向较复杂。</p>
<h2 id="迁移资源到Linux上"><a href="#迁移资源到Linux上" class="headerlink" title="迁移资源到Linux上"></a>迁移资源到Linux上</h2><p>和079一样，将一些关键文件拷贝到Linux上，手动导入SQL文件。</p>
<blockquote>
<p>这里因为有一些jar库放到了jre8x64里面，因此需要把这个目录也拷贝进去</p>
</blockquote>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E8%BF%81%E7%A7%BB%E8%B5%84%E6%BA%90%E5%88%B0Linux.png"></p>
<h2 id="Linux模拟wmic结果"><a href="#Linux模拟wmic结果" class="headerlink" title="Linux模拟wmic结果"></a>Linux模拟wmic结果</h2><p>由于wmic是Windows上的程序，因此<code>getProcessorId</code>方法会出错，这里直接写一个脚本模拟。</p>
<p>创建一个wmic文件，把他放到<code>/usr/bin</code>目录（默认的环境变量）下即可执行。</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/Linux%E6%A8%A1%E6%8B%9Fwmic.png"></p>
<h2 id="IP地址重定向"><a href="#IP地址重定向" class="headerlink" title="IP地址重定向"></a>IP地址重定向</h2><p>Linux：使用iptables，可以成功转发出口请求，参考<a href="https://blog.csdn.net/weixin_45186298/article/details/122910466">iptables</a></p>
<p>将<code>http://47.99.96.61:8008/api/checkMapleAuthEn?ddhmid=</code>转发到本机的8008端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看规则</span></span><br><span class="line">sudo iptables  -t nat --list OUTPUT</span><br><span class="line"><span class="meta">#</span><span class="bash"> -A添加规则</span></span><br><span class="line">sudo iptables -t nat -A OUTPUT -d 47.99.96.61 -p tcp --dport 8008 -j DNAT --to-destination 127.0.0.1:8008</span><br><span class="line"><span class="meta">#</span><span class="bash"> -D删除规则</span></span><br><span class="line">sudo iptables -t nat -D OUTPUT -d 47.99.96.61 -p tcp --dport 8008 -j DNAT --to-destination 127.0.0.1:8008</span><br></pre></td></tr></table></figure>

<p>通过curl命令可以成功访问本地的8008端口的结果<code>curl http://47.99.96.61:8008</code></p>
<h2 id="启动Web服务"><a href="#启动Web服务" class="headerlink" title="启动Web服务"></a>启动Web服务</h2><p>将IP转发到自己的机器上后，需要开启Web服务，监听对应端口，模拟返回成功的结果</p>
<ol>
<li>使用Apache自带Web服务，监听80端口：将html网页放到这个目录下<code>/var/www/html/</code>，url带路径则新建文件夹</li>
<li>使用Java简易服务器：代码如下，使用<code>javac -encoding &quot;utf8&quot; MyHttpServer.java</code>编译，再使用java命令运行class文件。（这里监听的是8008端口，因此需要将上一步的IP转发到8008端口）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpServer server = HttpServer.create(<span class="keyword">new</span> InetSocketAddress(<span class="number">8008</span>), <span class="number">0</span>);</span><br><span class="line">            server.createContext(<span class="string">&quot;/api/checkMapleAuthEn&quot;</span>, httpExchange -&gt; &#123;</span><br><span class="line">                String response = <span class="string">&quot;PcsI/8T435QUTypDM/e4HnXmNd/SYMWzz1IgsASJdWE=&quot;</span>;</span><br><span class="line">                httpExchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">                <span class="keyword">try</span> (OutputStream os = httpExchange.getResponseBody()) &#123;</span><br><span class="line">                    os.write(response.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            server.setExecutor(Executors.newCachedThreadPool());</span><br><span class="line">            server.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行MyHttpServer，再使用curl请求地址，成功拦截了请求。（正常访问由于没有淘宝订单号，请求会超时或者错误）</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8F%91.png"></p>
<h2 id="运行服务端"><a href="#运行服务端" class="headerlink" title="运行服务端"></a>运行服务端</h2><p>由于是Linux环境，无法运行一键启动器的exe文件，因此使用java命令启动<code>java -cp :lib/*:jre8x64/lib/ext/log4j-core-2.14.0.jar:jre8x64/lib/ext/* org.bms.gui.BMS</code></p>
<blockquote>
<p>Linux使用冒号分割ClassPath</p>
</blockquote>
<p>可以看到<strong>成功跳过了服务端验证</strong>，不过会卡在加载怪怪卡的地方。</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/Linux%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8D%A1%E4%BD%8F.png"></p>
<p>这个主要是因为服务端没有针对Linux做过适配，使用开篇提到的第三个资源也有一样的问题。</p>
<p><del>暂时还未找到原因，后面可以尝试分析下。</del></p>
<h2 id="服务端启动卡住问题解决"><a href="#服务端启动卡住问题解决" class="headerlink" title="服务端启动卡住问题解决"></a>服务端启动卡住问题解决</h2><p><strong>先说结论：将<code>wz/String.wz</code>改为<code>wz/string.wz</code>，小写字母</strong></p>
<p>分析了一下服务端启动的过程，<strong>主要是对比启动日志</strong>，跟踪到<code>StartServer</code>类。</p>
<p>这里看到一堆中文乱码对应服务端启动的信息</p>
<blockquote>
<p>我们可以将解码方法拷贝出来，例如<code>MapleGuildSkill.ALLATORIxDEMO()</code>，通过main方法运行</p>
<p>例如<code>MapleGuildSkill.ALLATORIxDEMO(&quot;勚轓拺胓攊捀寶戾T&quot;)</code>打印出来实际上是”加载技能数据完成”</p>
</blockquote>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%8D%A1%E4%BD%8F%E5%88%86%E6%9E%901.png"></p>
<p>对比正常的日志，加载完怪怪卡之后就会打印”加载道具”的日志。</p>
<p>因此怪怪卡已经加载完成了，实际上是卡在加载道具的地方，因此查看<code>ItemInfoCache</code>逻辑。</p>
<p>这里比较难阅读，大概能够看出是启动了一个子线程去加载道具信息。</p>
<p>一开始有<code>ser/Item.ser</code>这个文件，运行服务端之后就没了。猜测是存放加载过的道具信息，由于出了问题所以文件自动被删除。</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%8D%A1%E4%BD%8F%E5%88%86%E6%9E%902.png"></p>
<p>幸运的是这里刚好有个main方法，可以直接运行”加载道具信息”，针对性的分析，避免每次都跑整个启动流程。</p>
<p><code>java -cp :lib/*:jre8x64/lib/ext/log4j-core-2.14.0.jar:jre8x64/lib/ext/* org.bms.common.cache.ItemInfoCache</code></p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%8D%A1%E4%BD%8F%E5%88%86%E6%9E%903.png"></p>
<p>看到这里答案就出来了，<strong>找不到<code>wz/string.wz</code>文件</strong>，由于是主线程崩溃，所以有日志打印。</p>
<p>wz目录实际上是有<code>String.wz</code>文件的，可能是大小写没有被正确解析，复制一个<code>string.wz</code>出来，再运行正常。</p>
<blockquote>
<p>Windows上可以正常解析，并且其他的wz也没问题，就只有<code>String.wz</code>有问题</p>
</blockquote>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%8D%A1%E4%BD%8F%E5%88%86%E6%9E%904.png"></p>
<h2 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h2><p>由于新版本客户端不支持v79的命令行指定服务器IP地址和端口，因此从网上找了个联机登录器，指定IP地址，运行成功。</p>
<blockquote>
<p>用登录器总感觉不太安全，不过暂时没找到高版本的登录方式。</p>
</blockquote>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%81%94%E6%9C%BA%E7%99%BB%E5%BD%95%E5%99%A8.png"></p>
<h2 id="修改数据库配置"><a href="#修改数据库配置" class="headerlink" title="修改数据库配置"></a>修改数据库配置</h2><p>该版本私服的数据库名称默认为bms，数据库用户名和密码默认为root。和服务器上数据库配置不同</p>
<p>找到<code>配置文件/ServerConfig.ini</code>，发现如下三个字段：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">数据库_库名</span>=<span class="string">bms</span></span><br><span class="line"><span class="attr">SQL_USER</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">SQL_PASSWORD</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>直接修改上述字段运行，发现连不上数据库</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5.png"></p>
<p>反编译分析源码，如下图</p>
<blockquote>
<p>吐槽一下一堆中文和乱码</p>
</blockquote>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/ServerConstantsType.png"></p>
<p>可以看到<code>getProps()</code>方法返回解析的Properties对象，通过枚举的名称查找配置，这里使用的名称和配置文件中定义的不同。</p>
<p>因此修改配置如下，再次运行正常</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">数据库_库名</span>=<span class="string">maplestory_176</span></span><br><span class="line"><span class="meta">数据库_用户名</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">数据库_密码</span>=<span class="string">afauria</span></span><br></pre></td></tr></table></figure>

<h2 id="数据库报错"><a href="#数据库报错" class="headerlink" title="数据库报错"></a>数据库报错</h2><p>如下图，Linux上运行服务端，客户端登录之后会提示表不存在。</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/Linux%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E6%8A%A5%E9%94%99.png"></p>
<p>原因：Linux上MariaDB默认区分大小写，如下图</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/MariaDB%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F.png"></p>
<p>解决：配置数据库大小写不敏感</p>
<p>修改<code>/etc/mysql/my.cnf</code>文件，添加如下配置。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment"># 0表示区分大小写</span></span><br><span class="line"><span class="comment"># 1表示存储时小写，比较时不区分大小写</span></span><br><span class="line"><span class="comment"># 2表示存储时区分大小写，比较时是小写</span></span><br><span class="line"><span class="comment"># Linux默认为0，Windows默认是1，MacOS默认是2</span></span><br><span class="line"><span class="attr">lower_case_table_name</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>

<p>修改之后重启数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mariadb </span><br></pre></td></tr></table></figure>

<p>查看大小写配置如下</p>
<p><img src="/2022/09/08/geek-2022-09-08-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv176/%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E5%B0%8F%E5%86%99%E9%85%8D%E7%BD%AE.png"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此可以在树莓派上运行冒险岛私服，079、176的教程都有了。</p>
<blockquote>
<p>建议使用修改字节码的方式运行服务端。不然每次启动都要配置下iptables、启动8008端口服务。</p>
</blockquote>
<p>自己玩的话最简单还是直接在Windows上一键运行服务端和客户端。如果是要部署和别人玩就要用云服务器了，怕麻烦的话也可以买Windows的服务器部署。这里只提供下迁移到Linux运行的一些思路，<strong>坑还很多</strong>。</p>
<p>老实说对冒险岛私服不太了解，平常也不太喜欢逛社区论坛、QQ群之类的。不过挺佩服那些大佬的。</p>
<p>这也是自己第一次尝试搭建私服，自己找资源去破解。中间踩了很多坑，没有加过群请教大佬，不然应该能少走很多弯路。</p>
<ul>
<li>netsh（Network Shell）是Windows的命令行工具。参考<a href="https://docs.microsoft.com/zh-cn/windows-server/networking/technologies/netsh/netsh-interface-portproxy">Windows netsh命令</a></li>
<li>Linux上常用的防火墙软件，很强大的功能，可以进行入口、出口请求的转发、拦截等。参考<a href="https://blog.csdn.net/weixin_45186298/article/details/122910466">iptables</a></li>
<li>Wireshark：网络抓包工具，使用比较简单，难点在于分析数据包</li>
<li>反编译工具：jadx、jbe、jd-gui。（有的时候会反编译不出来，可以尝试其他工具，或者阅读字节码）</li>
</ul>
<h2 id="修改jar包字节码"><a href="#修改jar包字节码" class="headerlink" title="修改jar包字节码"></a>修改jar包字节码</h2><p>注意：重编译的jdk版本要和jar的jdk版本一致，否则可能合不回去</p>
<p>方式一：修改Java源代码</p>
<ol>
<li>使用jd-gui或jadx将class反编译成java源代码</li>
<li>修改源代码</li>
<li>使用javac编译，由于会依赖到其他的类，因此编译时需要指定classpath依赖库</li>
<li>将编译出来的class文件拖入jar压缩包中</li>
</ol>
<p>缺点：当jar包被混淆时，可能会编译失败，或者jar包出错</p>
<p>方式二：修改字节码</p>
<ol>
<li>拷贝出要修改的class文件</li>
<li>使用jbe直接修改class字节码</li>
<li>将修改后的class文件拖入jar压缩保重</li>
</ol>
<p>缺点：需要学习理解字节码，也没法做大的改动，否则会导致编译失败，符号没对齐之类的。</p>
<h2 id="Windows请求转发"><a href="#Windows请求转发" class="headerlink" title="Windows请求转发"></a>Windows请求转发</h2><p>Windows：使用<code>netsh interface portproxy</code>代理IP地址和端口，貌似只能将外部进入本机的请求进行转发，无法对本机出口的请求进行转发（失败）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有监听的端口</span></span><br><span class="line">netsh interface portproxy show all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加规则</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=47.99.96.61 listenport=8008 connectaddress=192.168.1.104 connectport=80 protocol=tcp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除规则</span></span><br><span class="line">netsh interface portproxy delete v4tov4 listenaddress=47.99.96.61 listenport=8008</span><br></pre></td></tr></table></figure>

<p>另外的思路：使用虚拟网卡+netsh命令，参考<a href="https://blog.csdn.net/qq_34083079/article/details/110141360">Windows 下的 IP 重定向，非改 host</a></p>
<blockquote>
<p>没有实际尝试过，这种时候还是Linux方便</p>
</blockquote>
]]></content>
      <categories>
        <category>极客</category>
      </categories>
      <tags>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title>冒险岛私服搭建v079</title>
    <url>/2022/09/02/geek-2022-09-02-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv079/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>私服不用玩太多版本，只要一个079的旧版本，一个高版本体验新职业新剧情。</p>
<p>下面三个079版本都亲测可行，并且可以迁移到Linux上运行</p>
<ul>
<li><a href="https://www.fengyewuyu.com/thread-1573-1-1.html">架设自己的冒险岛服务端</a>：使用phpStudy集成环境，资源比较全，包含服务端源码、辅助工具、GM工具等。</li>
<li><a href="https://zhuanlan.zhihu.com/p/392762992">冒险岛079完整全套架设教程</a>：使用phpStudy集成环境，其实就是上面的教程精简过的。</li>
<li><a href="https://hostloc.com/thread-878810-1-1.html">Linux服务端搭建</a>：客户端和GM工具过期了，用上面的079客户端即可，服务端其实 是GitHub上的<a href="https://github.com/aoaostar/MapleStory">MapleStory</a>。自行安装Java和MySQL环境。</li>
</ul>
<p>先放一张运行成功的图，熟悉的侧分、新手剑</p>
<img src="/2022/09/02/geek-2022-09-02-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv079/冒险岛新手村.jpg" style="zoom:67%;">

<h1 id="教程1"><a href="#教程1" class="headerlink" title="教程1"></a>教程1</h1><p><a href="https://zhuanlan.zhihu.com/p/392762992">冒险岛079完整全套架设教程</a>：使用phpStudy集成环境，比较简单。</p>
<img src="/2022/09/02/geek-2022-09-02-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv079/教程1资源.png">

<ol>
<li>安装客户端、升级补丁、替换HShield</li>
<li>启动MySQL：打开<code>mSer/Mysql/phpStudy.exe</code>，启动</li>
<li>启动服务端，端口为9555，如下图</li>
</ol>
<img src="/2022/09/02/geek-2022-09-02-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv079/启动服务器截图.png" style="zoom:67%;">

<blockquote>
<p>GUI控制台有些GM命令，例如给金币、给物品等，可以自己实验下。</p>
<p>在这里<a href="https://mxd4.com/">mxd4</a>可以查到对应的物品ID</p>
</blockquote>
<p>也可以使用Java命令启动：<code>java -cp dist\* -Dnet.sf.odinms.wzpath=wz server.Start</code></p>
<h1 id="教程2"><a href="#教程2" class="headerlink" title="教程2"></a>教程2</h1><p><a href="https://hostloc.com/thread-878810-1-1.html">Linux服务端搭建</a>：客户端和GM工具过期了，直接用教程1里面的079客户端。服务端是GitHub上的<a href="https://github.com/aoaostar/MapleStory">MapleStory</a>。</p>
<p>本教程在树莓派4B Linux armv7上运行成功</p>
<ol>
<li>安装mysql，导入仓库中的sql文件</li>
<li>修改<code>config/db.propeties</code>配置，数据库名称、用户名和密码</li>
<li><code>./start.sh</code>运行服务端，端口为9595</li>
</ol>
<h1 id="迁移到Linux上运行"><a href="#迁移到Linux上运行" class="headerlink" title="迁移到Linux上运行"></a>迁移到Linux上运行</h1><p>phpStudy集成环境只能在Windows上运行，因此只能运行在自己电脑或者租个Windows的服务器，这里介绍下如何在Linux上部署该服务端。缺点就是不能用GM工具修改数据库了。</p>
<p>这里以教程1的资源为例（使用树莓派4B armv7作为服务器）</p>
<h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p>首先自行安装MySQL和JDK</p>
<p>将以下几个资源文件拷贝到Linux服务器上</p>
<img src="/2022/09/02/geek-2022-09-02-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BAv079/mSer迁移到Linux.png" style="zoom:80%;">

<h2 id="导出数据库文件"><a href="#导出数据库文件" class="headerlink" title="导出数据库文件"></a>导出数据库文件</h2><p>数据库文件包含在<code>MySQL/data</code>目录下，为了移植到Linux上，需要导出数据库。</p>
<p>先按照上面的教程在Windows上启动MySQL，然后使用<code>mysqldump</code>命令导出数据库sql文件。</p>
<p>由于树莓派使用MariaDB，底层引擎不是InnoDB，直接将sql文件导入会出现一些不兼容问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Can&#x27;t create table , (errno: 140 &quot;Wrong create options&quot;)</span><br></pre></td></tr></table></figure>

<p>将sql文件中的<code>ROW_FORMAT = DYNAMIC </code>和<code>ROW_FORMAT = FIXED</code>等批量删除掉即可。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改<code>Settings.ini</code>配置：</p>
<ol>
<li>数据库名称、用户名和密码</li>
<li>将<code>tmps.Port = 127.0.0.1</code>改成本机的IP地址，否则点击角色之后会退回登陆页面，提示无法连接服务器</li>
</ol>
<h2 id="运行服务端"><a href="#运行服务端" class="headerlink" title="运行服务端"></a>运行服务端</h2><p><code>java -cp :dist/* -Dnet.sf.odinms.wzpath=wz server.Start</code></p>
<blockquote>
<p>Linux上-cp前面需要加冒号，Windows上不用</p>
<p>反编译发现这个服务端使用的环境变量是<code>-Dnet.sf.odinms.wzpath</code></p>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>教程1和教程2没有测试过，不知道哪个更稳定。不过教程2有源码，出了问题可以自己尝试修改。</p>
<p>教程2服务端已上传GitHub：<a href="https://github.com/Afauria/MapleStory-Server-079">MapleStory-Server-079</a></p>
]]></content>
      <categories>
        <category>极客</category>
      </categories>
      <tags>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title>冒险岛私服搭建基础</title>
    <url>/2022/09/01/geek-2022-09-01-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前有几次想玩树莓派，但是由于芯片涨价，价格翻了几倍，买了感觉很亏。于是收藏了一些教程，想等降价了再买，后来瘾头就慢慢淡了。最近又看到一些树莓派的教程，想法又源源不断的冒出来，FC游戏机、私服等，不过查了一下价格又贵了。。。</p>
<p>想到游戏和私服就联想到自己最喜欢玩的冒险岛：从05年开始接触，那时候和老哥玩一台电脑，都是一人操作键盘控制，一人操作鼠标点NPC；那时候疯狂拣地上的金币道具，跟大佬讨装备；那时候大家还是组队过副本，废都、通天塔，新出的休.彼得曼嘉年华；那时候升级很慢，几个月都升不到3转，跳格子任务都要花好长时间，真惊讶当时为什么这么有耐心。后来就开始过图、飞天、稳如泰山、吸怪，外挂满天飞了。</p>
<p>大巨变之后没有一直玩，不过兴之所至就要上线体验下新职业，一般刷到4转就没什么动力了，辗转回归了10几次，差不多几十个职业都玩过。</p>
<p>老实说大巨变之后除了玩家少了，升级快、组队任务没人过之外，也没什么不好的，职业、技能变酷炫了、地图、音乐变多了、剧情铺开来了。就算纯粹逛逛风景、听听音乐、看看剧情也不错。</p>
<blockquote>
<p><a href="http://news.sohu.com/a/566460939_628730">为什么《冒险岛》玩家都想回到“大巨变”之前？</a></p>
</blockquote>
<p>想法起来后就挥之不去，也一直很好奇私服是怎么搭建的，外挂是怎么来的。迫不及待的查了下资料，确认了可行性，而且还可以学习源码，体验下改库的快乐。</p>
<p>收集了好几个教程亲测，看看哪个最好用，记录一下踩的坑。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>先普及一些命令，后面不再解释：</p>
<ol>
<li>卸载Windows服务：<code>sc delete &lt;服务名称&gt;</code>，例如<code>sc delete mysql</code>，需要管理员权限运行。卸载服务并不会删除数据库，可以放心。</li>
<li>安装MySQL服务：进入MySQL的bin目录，<code>.\mysqld.exe -install [服务名称]</code>，不指定的话默认服务名称为MySQL。为了服务不重名，可以指定一下。例如phpStudy安装的MySQL服务名称为<code>MySQLa</code></li>
<li>Windows启动MySQL服务：<code>net start mysql</code>，或者在【Windows服务】中手动启动</li>
<li>Linux启动MySQL服务：<code>service mysql start/stop/restart</code></li>
<li>查看端口号占用情况：<code>netstat -ano | grep 3306</code></li>
<li>登录mysql：<code>mysql -u root -p</code>，默认登录端口为3306，如果修改了端口号，可以使用<code>--port=&lt;端口号&gt;</code>或者<code>-P 端口号</code>指定。MySQL初始用户名和密码是root</li>
<li>进入数据库：登录之后输入<code>use databasename;</code></li>
</ol>
<h2 id="导出数据库文件"><a href="#导出数据库文件" class="headerlink" title="导出数据库文件"></a>导出数据库文件</h2><ol>
<li><code>mysqldump -u username -p database_name &gt; data-dump.sql</code></li>
<li>也可以使用phpStudy和Navicat的备份功能导出</li>
</ol>
<p>导出sql失败，提示表不存在时，直接把对应表删除，或者删除对应表的frm文件。</p>
<p>导出数据库报错，提示：<code>Incorrect file format &#39;combine_medal&#39; when using LOCK TABLES</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看报错信息</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> desc combine_medal;</span></span><br><span class="line">ERROR 130 (HY000): Incorrect file format &#x27;combine_medal&#x27;</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> check table combine_medal;</span></span><br><span class="line">+-------------------+-------+----------+---------------------------------------+</span><br><span class="line">| Table             | Op    | Msg_type | Msg_text                              |</span><br><span class="line">+-------------------+-------+----------+---------------------------------------+</span><br><span class="line">| bms.combine_medal | check | Error    | Incorrect file format &#x27;combine_medal&#x27; |</span><br><span class="line">| bms.combine_medal | check | error    | Corrupt                               |</span><br><span class="line">+-------------------+-------+----------+---------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> REPAIR table combine_medal use_frm;</span></span><br><span class="line">+-------------------+--------+----------+----------+</span><br><span class="line">| Table             | Op     | Msg_type | Msg_text |</span><br><span class="line">+-------------------+--------+----------+----------+</span><br><span class="line">| bms.combine_medal | repair | status   | OK       |</span><br><span class="line">+-------------------+--------+----------+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h2 id="导入sql数据库文件"><a href="#导入sql数据库文件" class="headerlink" title="导入sql数据库文件"></a>导入sql数据库文件</h2><p>进入数据库之后输入<code>source &lt;path&gt;/xxx.sql</code></p>
<p>由于树莓派使用MariaDB，底层引擎不是InnoDB，直接将sql文件导入会出现一些不兼容问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Can&#x27;t create table , (errno: 140 &quot;Wrong create options&quot;)</span><br></pre></td></tr></table></figure>

<p>将sql文件中的<code>ROW_FORMAT = DYNAMIC </code>和<code>ROW_FORMAT = FIXED</code>等批量删除掉即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>亲测了多个教程和不同版本，总的来说大同小异。后面会简单介绍每个教程的操作，记录下过程，遇到问题可以作为参考。</p>
<h2 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h2><p>搭建私服需要的文件：了解这些文件的作用，可以随意组合，不用完全按照教程来。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端比较简单，不同教程安装方式都一样，注意启动的时候指定服务器IP地址和端口号即可。</p>
<ol>
<li>冒险岛客户端</li>
<li>客户端补丁：将补丁复制到客户端安装目录，双击安装即可。</li>
<li>HShield：Hack Shield反外挂程序，需要覆盖掉安装目录中的HShield文件夹。并且修改ehsvc.ini文件中的<code>GamePath</code>为客户端安装路径。</li>
<li>客户端登录器：作用是指定服务器IP地址、端口号。<ol>
<li>可以使用豆豆冒险岛登录器，需要”以管理员方式运行”，否则会无响应</li>
<li>也可以使用命令启动：<code>maplestory.exe 127.0.0.1 9555</code></li>
</ol>
</li>
</ol>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>可能有不同版本的资源，但使用方式都大同小异，主要分为几种方式：</p>
<ol>
<li>傻瓜式集成环境：自带JRE和MySQL，有的还带Navicat、phpMyAdmin、phpStudy等（适用于Windows系统）</li>
<li>不带集成环境：需要自己装JDK和MySQL，导入数据库，改配置（适用于有一定基础的人，可以在Windows、Linux上运行）</li>
<li>虚拟机：将整个虚拟机系统打包，直接在虚拟机上运行服务端和客户端</li>
</ol>
<p>关键文件：</p>
<ol>
<li>服务端程序：一般是Jar，有的带源码，有的不带源码。<ol>
<li>有的教程提供启动程序或者脚本启动</li>
<li>也可以自己使用java命令启动，不同教程的服务端稍微有一些差异</li>
</ol>
</li>
<li>冒险岛MySQL数据库文件：<ol>
<li>集成环境是把整个MySQL拷过来了</li>
<li>也可以自行导入导出，一般是SQL文件或者PSC文件（psc是Navicat的备份文件，可以还原为SQL文件）。</li>
</ol>
</li>
<li>配置文件：数据库配置、服务端配置等</li>
<li>scripts脚本文件</li>
<li>WZ资源文件：<ol>
<li>从客户端提取的资源，一般下载服务端的时候已经包含</li>
<li>也可以自行提取，放到服务端目录下</li>
</ol>
</li>
</ol>
<p>WZ文件是Wizet公司用来压缩和加密游戏资源的文件，冒险岛所有游戏资源都打包在WZ文件中，例如角色、技能、地图、怪物、NPC等。</p>
<blockquote>
<p>客户端和服务端wz版本不对应可能会出问题，后台认为资源被修改，会进行拦截封号。</p>
</blockquote>
<p>可以通过一些工具提取和修改：例如HaRepacker，<a href="https://github.com/xsoameix/wz">wz</a>，<a href="https://github.com/Kagamia/WzComparerR2">WzComparerR2</a></p>
<blockquote>
<p>先插个眼，以后想自己开发一款冒险岛可以尝试逆向破解</p>
</blockquote>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><ul>
<li>MySQL数据库管理：非必须，可以使用Navicat、phpMyAdmin，也可以纯命令行</li>
<li>GM工具：便于修改指令，赠送物品</li>
<li>外挂：飞天、过图、吸怪</li>
</ul>
<blockquote>
<p>phpStudy集成了Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer等PHP开发环境</p>
<p>phpMyAdmin是一个基于Web的MySQL GUI管理程序，也可以使用Navicat管理</p>
</blockquote>
<h1 id="服务端使用方式"><a href="#服务端使用方式" class="headerlink" title="服务端使用方式"></a>服务端使用方式</h1><p>主要步骤：</p>
<ol>
<li><p>启动MySQL数据</p>
<ol>
<li><p>phpStudy方式：自带MySQL环境和数据库，不需要安装MySQL和导入数据库，适合新手。只适用于Windows环境</p>
<p>如果电脑中已经有MySQL的就要卸载、或者修改配置、或者导入数据库。</p>
</li>
<li><p>命令行方式：需要自行安装MySQL环境，获取冒险岛数据库文件，再导入。Windows和Linux均适用。</p>
</li>
</ol>
</li>
<li><p>修改配置：数据库配置、IP地址配置等，不同教程配置文件名字和属性不太一样，看着改就行。</p>
</li>
<li><p>安装JDK：</p>
<ol>
<li>使用集成环境的话已经自带了JRE。</li>
<li>自行安装JDK，最好是JDK1.7，JDK1.8会提示<code>importPackage</code>异常，不过暂时也没发现什么问题。</li>
</ol>
</li>
<li><p>运行服务端Java程序（一定要先成功启动数据库）</p>
<ol>
<li>有的教程提供启动程序或者脚本启动。</li>
<li>也可以自己使用java命令启动，不同教程的服务端稍微有一些差异。</li>
</ol>
</li>
</ol>
<p>启动命令例如：<code>java -cp dist\* -Dnet.sf.odinms.wzpath=wz server.Start</code>，</p>
<ol>
<li><code>-cp</code>等价于<code>-classpath</code>：多个路径Windows使用<code>;</code>分割，Linux使用<code>:</code>分割，也可以指定临时环境变量<code>SET CLASSPATH=xxx</code></li>
<li><code>-Dxxx</code>：环境变量，不同服务端不一样，一般是<code>-Dwzpath=wz</code></li>
<li><code>server.Start</code>是主类，函数入口</li>
</ol>
<blockquote>
<p>v94以上版本，需要使用虚拟网卡运行，IP地址为：221.231.130.70</p>
</blockquote>
<h2 id="启动MySQL"><a href="#启动MySQL" class="headerlink" title="启动MySQL"></a>启动MySQL</h2><h3 id="phpStudy方式"><a href="#phpStudy方式" class="headerlink" title="phpStudy方式"></a>phpStudy方式</h3><p>打开<code>MySQL</code>目录，启动phpStudy程序，点击启动Apache和MySQL服务。两个灯一直绿色表示成功（有可能起了之后过一会又挂了）。</p>
<p><img src="/2022/09/01/geek-2022-09-01-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/phpStudy.png"></p>
<p>MySQL管理器中可以打开phpMyAdmin，如下，后续可以在这里修改数据库。</p>
<img src="/2022/09/01/geek-2022-09-01-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/phpMyAdmin数据库管理.png" style="zoom:67%;">

<h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><p>自行安装MySQL</p>
<ol>
<li>Windows上下载zip包解压、配置环境变量、初始化数据库</li>
<li>Linux下适用apt即可</li>
</ol>
<p>获取sql备份文件：</p>
<ol>
<li>有的教程资源自带了</li>
<li>没有的话可以运行phpStudy集成环境，再导出数据库。</li>
</ol>
<h1 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h1><h2 id="数据库冲突问题"><a href="#数据库冲突问题" class="headerlink" title="数据库冲突问题"></a>数据库冲突问题</h2><p>电脑上已经装了一个MySQL 5.7.22了，再启动phpStudy中的MySQL 5.5.34失败（后面简称5.7、5.5）</p>
<p>或者手动启动MySQL服务报错误1067</p>
<img src="/2022/09/01/geek-2022-09-01-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/MySQL启动失败1067.png" style="zoom:80%;">

<p>试了网上好多种解决方法都不行，这里也记录一下，以后遇到了类似的问题可以尝试下</p>
<p>方法一：检查<code>my.ini</code>文件中的baseDir和dataDir</p>
<p>方法二：修改MySQL 5.7的端口为3307，避免冲突</p>
<p>方法三：将5.5的data目录中冒险岛的数据库文件复制到5.7中，再手动启动5.7的服务。</p>
<blockquote>
<p>phpStudy的灯倒是绿了，但是冒险岛的数据库有些问题，可能是不同版本数据库格式兼容的问题？</p>
</blockquote>
<p>方法四：修改环境变量Path中的MySQL为5.5的路径</p>
<p>方法五：<code>sc delete mysql</code>卸载MySQL 5.7服务，再使用phpStudy中的MySQL服务</p>
<p>解决方法：</p>
<p>Get到了Windows上查看日志的方式，如图：这里启动失败的MySQL是5.5的，但是报错提示读不到的却是MySQL 5.7的路径。</p>
<img src="/2022/09/01/geek-2022-09-01-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/MySQL启动错误信息.png" style="zoom:80%;">

<p>最后发现是环境变量的问题，只修改<code>Path</code>没用，<strong>要把<code>MYSQL_HOME</code>环境变量改成5.5的路径</strong>，应该是MySQL服务读取了该变量。</p>
<p>如下图，我把两个版本的MySQL路径都存了下来，需要用到哪个就改一下。</p>
<blockquote>
<p>两个服务可以都安装，只要指定不同的服务名，但是不能同时运行，因为<code>MYSQL_HOME</code>变量只有一个，即使改了端口号也不行。</p>
</blockquote>
<img src="/2022/09/01/geek-2022-09-01-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/MySQL环境变量.png" style="zoom:80%;">

<p><strong>运行成功后可以把数据库导出，再导入自己5.7的MySQL上，这样就不需要装多个MySQL了</strong></p>
<h2 id="JDK无法执行"><a href="#JDK无法执行" class="headerlink" title="JDK无法执行"></a>JDK无法执行</h2><p>教程资源中的jdk是Windows或者Linux amd64架构的，我用的树莓派4B是armv7的，<code>jdk/bin/java -version</code>无法执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MapleStory/jdk $ cat release </span><br><span class="line">JAVA_VERSION=&quot;1.7.0&quot;</span><br><span class="line">OS_NAME=&quot;Linux&quot;</span><br><span class="line">OS_VERSION=&quot;2.6&quot;</span><br><span class="line">OS_ARCH=&quot;amd64&quot;</span><br></pre></td></tr></table></figure>

<p>解决：自行安装JDK</p>
<h2 id="importPackage异常"><a href="#importPackage异常" class="headerlink" title="importPackage异常"></a>importPackage异常</h2><p>使用JDK1.8运行服务端提示<code>importPackage</code>异常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error executing script. Path: ./scripts/scripts/event/Subway.js</span><br><span class="line">Exception javax.script.ScriptException: ReferenceError: &quot;importPackage&quot; is not defined in &lt;eval&gt; at line number 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>importPackage</code>是JDK1.6的语法，JDK1.8不支持。<code>importPackage</code>可以在js中引入java的包</p>
</blockquote>
<p>使用JDK1.8运行暂时也没发现问题，为了避免异常也可以安装JDK1.7运行。<a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html">Java7 armv7下载</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jdk1.7.0_75 $ cat release </span><br><span class="line">JAVA_VERSION=&quot;1.7.0&quot;</span><br><span class="line">OS_NAME=&quot;Linux&quot;</span><br><span class="line">OS_VERSION=&quot;2.6&quot;</span><br><span class="line">OS_ARCH=&quot;arm&quot;</span><br></pre></td></tr></table></figure>

<h2 id="加密算法异常"><a href="#加密算法异常" class="headerlink" title="加密算法异常"></a>加密算法异常</h2><p>使用JDK 1.7运行提示加密算法异常，如下。</p>
<img src="/2022/09/01/geek-2022-09-01-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/加密套件异常.png">

<p>解决：解压<code>jce_policy-7.zip</code>，替换掉<code>jdk1.7.0_75/jre/lib/security</code>中的文件。</p>
<blockquote>
<p>集成环境自带的JRE可能已经替换完了，如果是自己装的JDK1.7就会出现这个问题</p>
</blockquote>
<h2 id="无法连接服务器"><a href="#无法连接服务器" class="headerlink" title="无法连接服务器"></a>无法连接服务器</h2><p>搭完之后能够登录，并且创建角色，但是点击角色无法进入游戏，返回登录页面，提示无法连接服务器。</p>
<p>解决：修改<code>server.properties</code>配置，将<code>RoyMS.IP = 172.0.0.1</code>改为局域网IP地址，例如<code>192.168.1.104</code></p>
<blockquote>
<p>客户端和服务器不在同一台机器上就会出现，不同服务端配置文件不太一样，不过原因是一样的。</p>
</blockquote>
<h2 id="数据库异常"><a href="#数据库异常" class="headerlink" title="数据库异常"></a>数据库异常</h2><p>登录成功之后服务端打印数据库异常，游戏键位清空，商城无法使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录之后提示数据库异常</span></span><br><span class="line">java.sql.SQLException: Cannot convert value &#x27;0000-00-00 00:00:00&#x27; from column 24 to TIMESTAMP.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 点击商城出现空指针</span></span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">	at handling.world.CharacterTransfer.&lt;init&gt;(CharacterTransfer.java:294)</span><br></pre></td></tr></table></figure>

<p>解决：修改<code>db.properties</code>，在url末尾添加<code>zeroDateTimeBehavior=convertToNull </code>，将0转化为null，如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">url</span> = <span class="string">jdbc:mysql://127.0.0.1:3306/maple_067?autoReconnect=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span></span><br></pre></td></tr></table></figure>

<h1 id="资源汇总存档"><a href="#资源汇总存档" class="headerlink" title="资源汇总存档"></a>资源汇总存档</h1><p><strong>这些资源都下载备份了，可以先在原地址中查找，找不到资源或者过期了可以私信我：评论、提issue、加联系方式均可</strong></p>
<blockquote>
<p>KMS（Korea Maple Story）：韩服</p>
<p>CMS：国服</p>
<p>GMS：国际服</p>
<p>NEO：新版的意思</p>
</blockquote>
<img src="/2022/09/01/geek-2022-09-01-%E5%86%92%E9%99%A9%E5%B2%9B%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/资源汇总存档.png">

<h2 id="V079"><a href="#V079" class="headerlink" title="V079"></a>V079</h2><ul>
<li><a href="https://www.fengyewuyu.com/thread-1573-1-1.html">架设自己的冒险岛服务端</a>：使用phpStudy集成环境，资源比较全，包含服务端源码、辅助工具、GM工具等。</li>
<li><a href="https://zhuanlan.zhihu.com/p/392762992">冒险岛079完整全套架设教程</a>：使用phpStudy集成环境，其实就是上面的教程精简过的。</li>
<li><a href="https://hostloc.com/thread-878810-1-1.html">Linux服务端搭建</a>：客户端和GM工具过期了，用上面的079客户端即可，服务端其实 是GitHub上的<a href="https://github.com/aoaostar/MapleStory">MapleStory</a>。自行安装Java和MySQL环境。</li>
<li><a href="http://www.xfdown.com/soft/131142.html">冒险岛079单机版</a>：将所有环境装了VMWare虚拟机中，由于我的系统里已经开了HyperV虚拟机，没法共存。</li>
</ul>
<h2 id="V176"><a href="#V176" class="headerlink" title="V176"></a>V176</h2><ul>
<li><a href="https://www.fengyewuyu.com/thread-4801-1-1.html">2021冒险岛176至尊版</a>：176整合版，需要淘宝订单号，服务端验证</li>
<li><a href="http://www.rexuexia.com/forum.php?mod=viewthread&tid=35265&page=1&authorid=93572">某宝买的冒险岛单机版V175一键端，简单操作 </a>：基于上面的端改的，又加了一层验证码验证</li>
<li><a href="http://www.rexuexia.com/forum.php?mod=viewthread&tid=36921&page=3&authorid=107404">冒险岛176第二版来自冒险岛单机交流群 </a>：跳过了授权校验的步骤，需要付30金币的下载费</li>
<li><a href="https://www.iopq.net/thread-17105612-1-1.html">【搬运】冒险岛【元旦大礼】怀旧岛V175至尊版 </a>：没试过，不过人家说了是免费的。应该是从群里搬运的原始的版本，上面的都是被无良商家拿来卖钱的。</li>
</ul>
<h2 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h2><ul>
<li><a href="https://forum.ragezone.com/f428/how-to-make-a-maplestory-741739/">冒险岛v83</a>：美国的客户端，无法安装客户端。服务端需要自行安装Java和MySQL环境。<ul>
<li>原资源：<code>how-to-make-a-maplestory（客户端无法安装）.zip</code></li>
</ul>
</li>
<li><a href="https://www.jiaosf.com/sf-51564-1.html">KMS362怀旧岛整合版</a>：韩服362版，约等于国服191版。服务端是phpStudy环境，使用方式同教程1。亲测可用，不能包含中文路径。不过都是韩语看不懂<ul>
<li>原资源：<code>KMS362怀旧岛整合版（韩服亲测可行）.zip</code>。</li>
</ul>
</li>
<li><a href="https://github.com/ronancpl/HeavenMS">HeavenMS</a>和<a href="https://github.com/HeavenClient/HeavenClient">HeavenClient</a>：从头实现的开源客户端和服务端代码，主要用来学习</li>
<li><a href="https://www.fengyewuyu.com/forum.php?mod=viewthread&tid=824&highlight=%E5%86%92%E9%99%A9%E5%B2%9B">彩虹冒险岛143商业端</a>：可以运行，但极其不稳定，技能点不了，怪物不动，传送口无法传送等。<ul>
<li>命令行运行：<code>java -cp ,;config\Server.jar;config\lib\* -Dwzpath=wz\ server.console.Start</code></li>
</ul>
</li>
<li><a href="https://www.maplestorycms456.com/download/">鲸鱼冒险岛</a></li>
<li><a href="https://www.jiaosf.com/ym-131.html">冒险岛私服教程</a>：论坛，很多东西要登录和付费，不能白嫖就不香了，以后再来这找</li>
<li><a href="http://w5cm.com/forum.php">冒险岛单机论坛</a></li>
</ul>
<h1 id="冒险岛v083测试失败"><a href="#冒险岛v083测试失败" class="headerlink" title="冒险岛v083测试失败"></a>冒险岛v083测试失败</h1><p><a href="https://forum.ragezone.com/f428/how-to-make-a-maplestory-741739/">冒险岛v83</a>：美国的客户端，不知道为什么安装不了，做个存档</p>
<ul>
<li>Java SE Development Kit (JDK) [<a href="http://www.mediafire.com/download.php?3ik2ax7srinpt23">32bit]</a> || [<a href="http://www.mediafire.com/download.php?3qrxipqpmxsnbrd">64bit]</a>：JDK，用不上</li>
<li>MySQL Query Browser [<a href="http://www.brothersoft.com/mysql-query-browser-for-windows-download-71868.html">Link]</a>：数据库管理器，用不上</li>
<li>WampServer [<a href="http://www.wampserver.com/en/download.php">Link]</a>：Apache服务器，用不上</li>
<li>JCE Unlimited Strength Files [<a href="http://www.mediafire.com/download.php?0g6t7xpcrbu4u8p">Link]</a>：Java Cryptography Extension，加密扩展包</li>
<li>LocalHost v83 [<a href="http://www.mediafire.com/?99ecxofh1436129">Link]</a>：客户端登录器</li>
<li>ZenthosDev v83 [<a href="http://www.mediafire.com/download.php?j43req4bj7l6nzk">Link]</a>：服务端</li>
<li>MapleStory v83 [<a href="https://mega.nz/#!098x2RII!m6aWPfTxcycUczGiaKxyuqHdKae391mwmNQfDWOCubY">Link]</a>：v83客户端</li>
<li>WZ Files [<a href="http://www.mediafire.com/?95sypygu1la3aeo">Link]</a>：冒险岛资源文件</li>
</ul>
<p>服务端倒是成功跑起来了：</p>
<ol>
<li>Java+MySQL环境已经装过了，就没有用到上面提供的</li>
<li>导入冒险岛数据库文件</li>
<li>解压WZ文件到服务端目录</li>
<li>修改<code>server.properties</code>配置：数据库用户名和密码</li>
<li>运行<code>[ZenthosDev] OneW.bat</code>程序</li>
</ol>
]]></content>
      <categories>
        <category>极客</category>
      </categories>
      <tags>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派使用记录</title>
    <url>/2022/08/27/geek-2022-08-27-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>闲鱼600淘了个树莓派4B 4G，带风扇、32G TF卡、7寸非触摸显示器、面包板等。可能还需要一套mini的键鼠、手柄、音响、一个读卡器。</p>
<blockquote>
<p>只做服务器的话，用远程桌面登录，可以不要键鼠</p>
<p>手柄主要是用于retropie玩游戏用的</p>
</blockquote>
<p>主要是想当服务器和FC游戏机使用。后面可能还会做NAS。</p>
<h1 id="Raspbian系统烧录"><a href="#Raspbian系统烧录" class="headerlink" title="Raspbian系统烧录"></a>Raspbian系统烧录</h1><p>由于手上没有读卡器，所以直接用卖家留下来的Raspbian系统。这里查了下网上的教程，没有亲自实践</p>
<ol>
<li>下载烧录工具：<a href="https://downloads.raspberrypi.org/imager/imager_latest.exe">Raspberry Pi Imager（Windows版）</a></li>
<li>下载OS镜像：<a href="https://downloads.raspberrypi.org/raspios_lite_armhf_latest">32 位 Lite 版（无桌面）</a> 、<a href="https://downloads.raspberrypi.org/raspios_armhf_latest">32 位桌面版（推荐使用）</a> 、 <a href="https://downloads.raspberrypi.org/raspios_full_armhf_latest">32 位桌面版（含常用软件）</a> </li>
<li>使用读卡器插入TF卡，打开烧录工具，选择操作系统、选择TF卡，烧录即可</li>
<li>将TF卡插入树莓派通电即可，听说首次启动还要设置下地区和时区</li>
</ol>
<img src="/2022/08/27/geek-2022-08-27-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/烧录工具.png" style="zoom: 80%">

<p><strong>注意操作系统是amrv7的，下载软件、JDK等需要注意，否则提示无法执行二进制文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ uname -a</span><br><span class="line">Linux raspberrypi 4.19.97-v7l+ #1294 SMP Thu Jan 30 13:21:14 GMT 2020 armv7l GNU/Linux</span><br></pre></td></tr></table></figure>

<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>HDMI需要先接线再开机，否则不会显示画面</p>
<p>打开终端：</p>
<ol>
<li>有鼠标：点击顶部任务栏的终端图标。</li>
<li>没有鼠标：用<code>ctrl+alt+T</code>打开终端</li>
</ol>
<p>其他快捷键和命令：</p>
<ol>
<li>终端翻页滚动：<code>shift+pageDown/pageUp</code></li>
<li>查看树莓派温度：<code>cat /sys/class/thermal/thermal_zone0/temp</code></li>
<li>关机：<code>sudo halt &amp;&amp; sudo shutdown &amp;&amp; sudo poweroff</code></li>
</ol>
<h2 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h2><p>由于装的是带常用软件的Raspbian版本，装了一堆乱七八糟的软件，需要卸载掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连上网线，更新apt</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除无用依赖</span></span><br><span class="line">sudo apt autoremove --purge</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除Java IDE：BlueJ、Greenfoot，轻量型IDE：Geany</span></span><br><span class="line">sudo apt remove --purge --auto-remove bluej greenfoot geany</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除IBM的编程套件：Node-RED、Mathematica、Scratch、Sonic Pi</span></span><br><span class="line">sudo apt remove --purge --auto-remove nodered wolfram-engine scratch scratch2 scratch3 sonic-pi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除Libre Office</span></span><br><span class="line">sudo apt remove --purge --auto-remove libreoffice*</span><br><span class="line"><span class="meta">#</span><span class="bash"> Sense HAT Emulator暂时保留，用来控制树莓派外设的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo apt remove --purge --auto-remove python-sense-emu python3-sense-emu python-sense-emu-doc sense-emu-tools</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自带的游戏，选择性移除</span></span><br><span class="line">sudo apt remove minecraft-pi</span><br></pre></td></tr></table></figure>

<p>自带的vi使用比较复杂，重新安装vim</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt remove vim-common</span><br><span class="line">sudo apt install vim</span><br><span class="line"><span class="meta">#</span><span class="bash"> 有了vim，也可以不用nano，看个人习惯</span></span><br><span class="line">sudo apt remove nano</span><br></pre></td></tr></table></figure>

<p>vim打开中文乱码：新建或者修改<code>~/.vimrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf8</span><br><span class="line">set fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030</span><br></pre></td></tr></table></figure>

<h2 id="更新密码"><a href="#更新密码" class="headerlink" title="更新密码"></a>更新密码</h2><p>方式1：<code>sudo raspi-config</code>打开配置，回车修改密码</p>
<img src="/2022/08/27/geek-2022-08-27-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/修改密码.png" style="zoom: 70%">

<p>方式2：<code>passwd</code>命令修改当前用户密码，<code>passwd root</code>修改root用户密码</p>
<h2 id="Windows远程桌面登录"><a href="#Windows远程桌面登录" class="headerlink" title="Windows远程桌面登录"></a>Windows远程桌面登录</h2><ol>
<li>树莓派安装xrdp：<code>sudo apt install xrdp</code></li>
<li>树莓派连接网线或者Wifi、查看IP地址：<code>ifconfig</code></li>
<li>Windows打开远程桌面：<code>alt+Q</code>或者<code>alt+R</code>，然后输入<code>mstsc</code></li>
<li>输入树莓派IP地址进入远程桌面，输入用户名和密码登录</li>
<li>如果不想远程桌面占满整个屏幕，可以修改显示配置，如图</li>
</ol>
<img src="/2022/08/27/geek-2022-08-27-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/远程桌面设置分辨率.png" style="zoom: 70%">

<p>没有显示器，如何查看IP地址？</p>
<p>连上网线，登录路由器，查看已连接设备。</p>
<img src="/2022/08/27/geek-2022-08-27-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/路由器查看IP地址.png" style="zoom: 70%">

<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><ol>
<li>下载<code>jdk-8u251-linux-arm32-vfp-hflt.tar.gz</code></li>
<li>解压：<code>tar -zvxf jdk-8u251-linux-arm32-vfp-hflt.tar.gz</code></li>
<li>设置环境变量：修改<code>~/.bashrc</code>文件，添加下面代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_251</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>source ~/.bashrc</code>使环境变量生效</li>
<li><code>java -version</code>测试</li>
</ol>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载默认版本的JDK，当前默认是jdk11</span></span><br><span class="line">sudo apt-get install default-jdk</span><br><span class="line">sudo apt-get install default-jre</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以下载jdk8</span></span><br><span class="line">apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<p><a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html">Java7 armv7下载</a></p>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止MySQL服务</span></span><br><span class="line">sudo service mysql stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载MySQL</span></span><br><span class="line">sudo apt remove --purge --auto-remove mysql-server mysql-client mysql-common</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理残余文件</span></span><br><span class="line">sudo apt autoremove</span><br><span class="line">sudo apt autoclean</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装MySQL，会提示找不到库，建议使用mariadb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo apt install mysql-client mysql-server</span></span><br><span class="line">sudo apt install mariadb-client mariadb-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动mysql服务</span></span><br><span class="line">service mysql start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录mysql</span></span><br><span class="line">sudo mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改root密码，并刷新</span></span><br><span class="line">update mysql.user set authentication_string=PASSWORD(&#x27;xxx&#x27;), plugin=&#x27;mysql_native_password&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">service mysql restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次登录mysql，输入密码</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置mysql远程连接</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27; WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置mysql监听所有IP地址，注释掉bind-address = 127.0.0.1</span></span><br><span class="line">sudo vi /etc/mysql/mariadb.conf.d/50-server.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<p>MariaDB是MySQL的一个分支，采用GPL开源协议。原因是MySQL被甲骨文收购后，存在闭源的风险，因此使用开源分支替代。</p>
<img src="/2022/08/27/geek-2022-08-27-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/mysql无法安装.png" style="zoom: 70%">

<h2 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h2><p>根据需要安装即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>

<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>有需要再装，主要还是为了搭建和移植环境方便。不过树莓派用SD卡也相当于保存了环境。</p>
<h1 id="树莓派介绍"><a href="#树莓派介绍" class="headerlink" title="树莓派介绍"></a>树莓派介绍</h1><h2 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h2><p>树莓派的操作系统Raspbian是基于Debian改造的，例如Debian8（Jessie）、Debian9（Streatch）、Debian10（Buster）、目前最新版是Debian11（Bullseye）。</p>
<blockquote>
<p>除了烧录Raspbian系统外，也可以烧录其他的操作系统，只要CPU支持即可</p>
</blockquote>
<p>此外树莓派还提供了Raspberry Pi Desktop操作系统，可以装在PC和Mac上</p>
<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>树莓派每一代分为三个系列</p>
<ol>
<li>B系列（标准版）</li>
<li>A系列（低配版）：砍掉了多余的接口，只有一个USB、无网口</li>
<li>Zero（低配版）：小尺寸、低功耗，保留无线和蓝牙连接功能</li>
</ol>
<p><img src="/2022/08/27/geek-2022-08-27-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%9E%8B%E5%8F%B7.jpg"></p>
<p><img src="/2022/08/27/geek-2022-08-27-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%89%88%E6%9C%AC%E5%AF%B9%E7%85%A7%E8%A1%A8.png"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料</p>
<ul>
<li><a href="https://shumeipai.nxez.com/raspberry-pi-os-collection">树莓派各类操作系统大全</a></li>
</ul>
]]></content>
      <categories>
        <category>极客</category>
      </categories>
      <tags>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title>电子游戏介绍</title>
    <url>/2022/08/22/geek-2022-08-22-%E7%94%B5%E5%AD%90%E6%B8%B8%E6%88%8F%E6%99%AE%E5%8F%8A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前玩游戏都没怎么关注游戏公司，最近抽空补了下游戏知识。</p>
<p>个人玩的比较多的是小时候的游戏机和网游，大型单机玩的比较少，不是资深玩家。</p>
<p>最喜欢的游戏是《冒险岛》，玩了很多年，不氪金，一般是剧情、任务向，刷职业、看地图、听音乐。《彩虹岛》类似</p>
<p>《宝可梦》喜欢但是玩的不深，没有集齐过全图鉴，以对战升级为主，到后期就没什么意思了，后面打算以剧情和收集为主。一般是隔一段时间回顾一下。</p>
<p>《三国群英传》寿命不长，很容易就无敌了。也是隔一段时间回顾一下。</p>
<h1 id="电子游戏（电玩）"><a href="#电子游戏（电玩）" class="headerlink" title="电子游戏（电玩）"></a>电子游戏（电玩）</h1><p>游戏机是一个统称：</p>
<ol>
<li>家用：主机、掌机</li>
<li>商用：街机，现代的加入体感的街机（游艺机），例如投篮机、抓娃娃机、跳舞机、赛车、VR游戏等。</li>
</ol>
<blockquote>
<p>掌机基本被手机替代了，家用主机被电脑替代了，游戏厅的街机被游艺机替代了。</p>
</blockquote>
<h2 id="任天堂游戏机"><a href="#任天堂游戏机" class="headerlink" title="任天堂游戏机"></a>任天堂游戏机</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
</tr>
</thead>
<tbody><tr>
<td>FC</td>
<td>Family Computer，Famicom</td>
<td>第一代红白机，1983年发售，1985年超级马里奥，1986年塞尔达传说</td>
</tr>
<tr>
<td>NES</td>
<td>Nintendo Entertainment System</td>
<td>欧美地区叫法，灰机</td>
</tr>
<tr>
<td>GB</td>
<td>Game Boy</td>
<td>1989年，俄罗斯方块</td>
</tr>
<tr>
<td>SFC</td>
<td>Super Famicom</td>
<td>1990年，第二代红白机，欧美地区叫SNES</td>
</tr>
<tr>
<td>N64</td>
<td>Nintendo 64</td>
<td>任天堂64位机，1996年发售，宝可梦系列，第三代红白机</td>
</tr>
<tr>
<td>NGC</td>
<td>Nintendo GameCube</td>
<td>2001年，第四代红白机</td>
</tr>
<tr>
<td>GBA</td>
<td>Game Boy Advance</td>
<td>2001年，第二代GameBoy</td>
</tr>
<tr>
<td>NDS</td>
<td>Nintendo Dual screen</td>
<td>2004年，折叠双屏掌机</td>
</tr>
<tr>
<td>GBM</td>
<td>Game Boy MICRO</td>
<td>2005年，Game Boy小型机</td>
</tr>
<tr>
<td>Wii</td>
<td></td>
<td>2006年，首次引入体感</td>
</tr>
<tr>
<td>3DS</td>
<td>Nintendo 3DS</td>
<td>2010年，折叠双屏掌机，3D裸眼技术</td>
</tr>
<tr>
<td>NS</td>
<td>Nintendo Switch</td>
<td>2017年发售的游戏机</td>
</tr>
<tr>
<td>FDS</td>
<td>Family Computer Disk System</td>
<td>FC磁碟机，FC游戏机的附件，为了降低卡带的高成本，使用磁碟读取游戏</td>
</tr>
</tbody></table>
<h2 id="其他游戏机"><a href="#其他游戏机" class="headerlink" title="其他游戏机"></a>其他游戏机</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
</tr>
</thead>
<tbody><tr>
<td>PSP</td>
<td>PlayStation Portable</td>
<td>索尼掌机</td>
</tr>
<tr>
<td>PS1、PS2、PS3</td>
<td>Play Station 3</td>
<td>索尼家用主机</td>
</tr>
<tr>
<td>Neo Geo</td>
<td></td>
<td>SNK家用主机</td>
</tr>
<tr>
<td>NGP</td>
<td>Neo Geo Pocket</td>
<td>1998年SNK生产的第一款掌机，由于只有黑白色，寿命较短，迅速被后续机种Neo Geo Pocket Color取代</td>
</tr>
<tr>
<td>Dreamcast</td>
<td></td>
<td>1998年世嘉第6带家用游戏机，是世嘉生产的最后一款游戏机</td>
</tr>
</tbody></table>
<h2 id="街机游戏英文名"><a href="#街机游戏英文名" class="headerlink" title="街机游戏英文名"></a>街机游戏英文名</h2><ul>
<li>拳皇：The King of fighters（KOF）</li>
<li>圆桌骑士：Knights of the round</li>
<li>三国志：Warriors of fate</li>
<li>双龙：Double Dragon</li>
<li>街霸：Street Fighter</li>
</ul>
<h1 id="游戏公司"><a href="#游戏公司" class="headerlink" title="游戏公司"></a>游戏公司</h1><p>需要区分的是开发游戏软件、和开发游戏机平台的区别。</p>
<p>任天堂的FC游戏机，有很多游戏都是其他游戏公司开发的。</p>
<p>同一个游戏可以运行在不同平台，例如街霸可以在街机、PS、Xbox等平台运行。</p>
<h2 id="电子游戏业三巨头"><a href="#电子游戏业三巨头" class="headerlink" title="电子游戏业三巨头"></a>电子游戏业三巨头</h2><ol>
<li>任天堂（Nintendo）：日本，主要从事电子游戏软硬件开发。FC、NES、GB、Switch等。知名游戏有马里奥、宝可梦、塞尔达传说等</li>
<li>微软（Microsoft）：美国，科技企业。主要是主机游戏，家用主机XBox。Windows操作系统、Office系列</li>
<li>索尼（Sony）：跨国集团，总部在日本，横跨生活用品、数码、娱乐各个行业。家用主机PSP、PS3等。</li>
</ol>
<blockquote>
<p>除了任天堂之外，另外两家的游戏都不太熟悉。</p>
</blockquote>
<h2 id="其他游戏公司"><a href="#其他游戏公司" class="headerlink" title="其他游戏公司"></a>其他游戏公司</h2><ol>
<li>Nexon：韩国第一大游戏公司，《冒险岛》、《跑跑卡丁车》、《泡泡堂》、《反恐精英Online》、《地下城与勇士DNF》等。</li>
<li>Valve：《半条命》、《反恐精英》、《求生之路》、《刀塔2》</li>
<li>暴雪：美国游戏开发商。《星际争霸》、《魔兽世界》、《炉石传说》、《守望先锋》、《暗黑破坏神》等。</li>
<li>EA（Electronic Arts，艺电）：美国互动娱乐软件公司，主要经营各种电子游戏的开发 。《极品飞车》、《NBA Live》等</li>
<li>卡普空（Capcom）：日本游戏公司，《鬼泣》、《洛克人》、《街头霸王》、《怪物猎人》等</li>
<li>SNK：《拳皇》、《饿狼传说》、《侍魂》、《合金弹头》等，NEO GEO家用游戏主机</li>
<li>Take-Two Interactive(Take 2)：美国。《侠盗猎车手》、《NBA 2K》</li>
<li>育碧(Ubisoft Entertainment) ：跨国游戏公司，总部在法国。《孤岛惊魂》、《刺客信条》、《看门狗》、《彩虹六号》等</li>
<li>南梦宫万代：日本综合性娱乐公司，《高达》系列。2005年万代（BANDAI）与南梦宫（Namco）合并。</li>
<li>世嘉公司 （SEGA）：日本电子游戏公司，2003年与SAMMY公司合并为SEGA-SAMMY。曾经并列四大家用游戏机制造商</li>
<li>科乐美（Konami）：《寂静岭》、《魂斗罗》、《合金装备》、《恶魔城》</li>
<li>哈德森（Hudson）：FC游戏《高桥名人的冒险岛》系列，后被Konami并购。旗下的产品还有Hudson CI服务器。</li>
</ol>
<blockquote>
<p>卡普空和SNK最早都是源于IREM，后来两任社长分家，分别成立了卡普空和SNK，前期势如水火。</p>
<p>后来SNK挖走“街霸之父”西山隆志，推出了《饿狼传说》和《拳皇》，其中暗讽了街霸的角色。</p>
<p>后期合作推出《Capcom VS SNK》（拳皇对街霸）</p>
</blockquote>
<h1 id="电子游戏里程碑"><a href="#电子游戏里程碑" class="headerlink" title="电子游戏里程碑"></a>电子游戏里程碑</h1><p>不同的粉丝喜欢不同类型游戏，不好排名，这里列一些个人认为的经典游戏</p>
<ul>
<li>马里奥：横板卷轴动作鼻祖</li>
<li>俄罗斯方块：休闲娱乐</li>
<li>星际争霸：电子竞技里程碑</li>
<li>街霸：格斗游戏原足</li>
<li>我的世界：沙盒游戏里程碑</li>
<li>魔兽世界：MMO（Massively Multiplayer Online Game，大型多人在线游戏）巨作</li>
<li>Pokemon Go：AR游戏里程碑</li>
<li>半条命：FPS游戏鼻祖，CS的前身</li>
</ul>
<blockquote>
<p>CS最初基于半条命Mod制作</p>
<ul>
<li>《半条命：反恐精英》v1.0-v1.5：2000年-2003年。仍为Mod，未独立</li>
<li>《反恐精英》：即1.6版本，2003年发售</li>
<li>《反恐精英：零点行动》</li>
<li>《反恐精英：起源》（CS：S，Counter-Strike： Source）：2004年，使用Source引擎重制版</li>
<li>《反恐精英：全球攻势》（CS GO，Counter-Strike: Global Offensive）：2017年</li>
</ul>
</blockquote>
<h1 id="任天堂"><a href="#任天堂" class="headerlink" title="任天堂"></a>任天堂</h1><p>电子游戏业三巨头之一，现代电子游戏产业的开创者。开发了FC、NES、GB等掌机、家用游戏机，以及马里奥、宝可梦、塞尔达传说等知名游戏系列。</p>
<p>任天堂创立于1889年9月23日，以生产花札起家，1970年代后期投入电子游戏产业，1983年推出了第一代家用游戏机FC。 </p>
<h2 id="历任社长"><a href="#历任社长" class="headerlink" title="历任社长"></a>历任社长</h2><ol>
<li>山内房治郎：1889年-1929年</li>
<li>山内积良：1929年-1949年</li>
<li>山内溥：1949年-2002年</li>
<li>岩田聪：2002年-2015年</li>
<li>君岛达己：2015年-2018年</li>
<li>古川俊太郎：2018年-至今</li>
</ol>
<h2 id="马里奥、塞尔达传说、宝可梦"><a href="#马里奥、塞尔达传说、宝可梦" class="headerlink" title="马里奥、塞尔达传说、宝可梦"></a>马里奥、塞尔达传说、宝可梦</h2><ul>
<li>马里奥：横版卷轴动作游戏。平台动作游戏鼻祖级作品 ，超级游戏IP。马里奥对于游戏的影响力，类比于哆啦A梦之于日本动画。</li>
<li>塞尔达：RPG冒险游戏，受限于游戏类型，无论是游戏设计上、难度上、风格上都无法像马力欧一样对男女老少通吃。在核心玩家心目中更高，口碑最好。</li>
<li>宝可梦：RPG游戏。成功的商业操作，衍生出大量动画、周边。可以说游戏角色里没有比皮卡丘更能演动画的，动画角色里没有比宝可梦更能卖游戏的。</li>
</ul>
<p>游戏年龄：马里奥&gt;塞尔达&gt;宝可梦</p>
<p>游戏史地位：马里奥=塞尔达&gt;宝可梦</p>
<p>知名度：宝可梦&gt;马里奥&gt;塞尔达传说</p>
<p>游戏销量：马里奥&gt;宝可梦&gt;塞尔达传说</p>
<p>总的来说宝可梦影响力在于广度，塞尔达影响力在于深度，马里奥兼而有之。在不同人心目中地位也不一样。</p>
<blockquote>
<p>PS：个人最喜欢宝可梦</p>
</blockquote>
<h1 id="塞尔达传说版本"><a href="#塞尔达传说版本" class="headerlink" title="塞尔达传说版本"></a>塞尔达传说版本</h1><table>
<thead>
<tr>
<th>平台</th>
<th>名称</th>
<th>发行时间</th>
</tr>
</thead>
<tbody><tr>
<td>FC/NES</td>
<td>塞尔达传说</td>
<td>1986年2月21日</td>
</tr>
<tr>
<td>FC/NES</td>
<td>塞尔达传说2：林克的冒险</td>
<td>1987年1月14日</td>
</tr>
<tr>
<td>SFC/SNES</td>
<td>塞尔达传说：众神的三角力量</td>
<td>1991年11月21日</td>
</tr>
<tr>
<td>GB</td>
<td>塞尔达传说：梦见岛</td>
<td>1993年6月6日</td>
</tr>
<tr>
<td>N64</td>
<td>塞尔达传说：时之笛</td>
<td>1998年11月21日</td>
</tr>
<tr>
<td>N64</td>
<td>塞尔达传说：梅祖拉的假面</td>
<td>2000年04月27日</td>
</tr>
<tr>
<td>GBC</td>
<td>塞尔达传说：不可思议的果实</td>
<td>2001年02月27日</td>
</tr>
<tr>
<td>NGC</td>
<td>塞尔达传说：风之杖</td>
<td>2002年12月13日</td>
</tr>
<tr>
<td>GBA</td>
<td>塞尔达传说：缩小帽</td>
<td>2004年11月4日</td>
</tr>
<tr>
<td>Wii/NGC</td>
<td>塞尔达传说：黄昏公主</td>
<td>2006年11月19日</td>
</tr>
<tr>
<td>NDS</td>
<td>塞尔达传说：幻影沙漏</td>
<td>2007年6月23日</td>
</tr>
<tr>
<td>NDS</td>
<td>塞尔达传说：大地的汽笛</td>
<td>2009年12月1日</td>
</tr>
<tr>
<td>Wii</td>
<td>塞尔达传说：天空之剑</td>
<td>2011年11月23日</td>
</tr>
<tr>
<td>3DS</td>
<td>塞尔达传说：众神的三角力量2</td>
<td>2013年11月22日</td>
</tr>
<tr>
<td>WiiU/3DS/NS</td>
<td>塞尔达无双</td>
<td>2014年8月14日</td>
</tr>
<tr>
<td>NS/Wii U</td>
<td>塞尔达传说：旷野之息</td>
<td>2017年3月3日</td>
</tr>
<tr>
<td>Switch</td>
<td>塞尔达传说：织梦岛</td>
<td>2019年9月20日</td>
</tr>
<tr>
<td>Switch</td>
<td>塞尔达传说：王国之泪</td>
<td>2023年5月12日</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>极客</category>
      </categories>
      <tags>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title>宝可梦手册</title>
    <url>/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为90后，宝可梦也是童年记忆，不是死忠粉，新作新动画片基本没怎么接触过，不过最近刚好在看网络小说《不科学御兽》，以及准备搭树莓派游戏机。因此想起了宝可梦，打算补一些知识。</p>
<p>本篇整理了宝可梦系列相关的一些知识，以后有时间还可以开发个宝可梦图鉴APP。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>《宝可梦（Pokemon）》Game Freaker（GF）开发的角色扮演游戏，由任天堂发行，原作者是田尻智（1965年）（动画主角小智以他命名），并由宫本茂（动画配角小茂以他命名）设计宝可梦图案。也叫《口袋妖怪》、《宠物小精灵》、《神奇宝贝》</p>
<blockquote>
<p>宫本茂（1952年）：马里奥之父，现代电子游戏之父</p>
<p>宝可梦公司（The Pokemon Company）由任天堂、Game Freaker、Creatures合资创立。</p>
<ul>
<li>Creatures负责宝可梦卡牌游戏和动漫画</li>
<li>Game Freaker（GF）负责游戏制作</li>
<li>The Pokemon Company（TPC）和任天堂负责商品销售和发行</li>
</ul>
</blockquote>
<p>除了主系列《宝可梦》系列之外，也有大量旁支系列游戏，以及衍生的动画及周边。</p>
<p>宝可梦日：1996年2月27日（和我的出生日期一模一样）《宝可梦红·绿》发售</p>
<p>幻之宝可梦：非常稀有的宝可梦，有时与传说宝可梦并称，有时被视为传说宝可梦的一种</p>
<p>传说宝可梦：各地流传的古老传说提到的关键宝可梦，拥有强大力量</p>
<p>闪光宝可梦（异色宝可梦）：最早出现在第二世代，与普通宝可梦颜色不同，能力没有区别，出现概率极低，基本看脸。</p>
<p>宝可梦博士：主系列重要角色，赠送初始宝可梦和图鉴给主角。除此之外还有许多剧情种出现的博士，以及旁支系列的博士。</p>
<p>宝可梦图鉴（PokeDex）：</p>
<ul>
<li>地区图鉴：存储了该地区的所有宝可梦数据的图鉴。一般情况前9种为御三家宝可梦及其进化体</li>
<li>全国图鉴：存储了全部地区所有宝可梦数据的图鉴。新世代出现的宝可梦从前作编号延续。</li>
</ul>
<p>御三家：初始的三只宝可梦。</p>
<blockquote>
<p>宝可梦系列初始可选择木、火、水三种属性的宝可梦。在《宝可梦皮卡丘》中，初始宝可梦是皮卡丘</p>
</blockquote>
<h1 id="世代"><a href="#世代" class="headerlink" title="世代"></a>世代</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>每一代都有双版本，各自有独占的宝可梦，鼓励玩家进行交换。封面、部分精灵、道馆、剧情不一样。</p>
<p>新世代只会包含部分旧世代宝可梦，没有任何一个版本可以单机集齐所有宝可梦，不同世代宝可梦可以互相传输，交换条件比较复杂。部分宝可梦（幻之宝可梦 ）需要通过现实活动获得，不算在全国图鉴中。</p>
<p>例如红宝石有固拉多，敌对组织是火岩队，蓝宝石有盖欧卡，敌对组织是水舰队。绿宝石则两队都有。</p>
<p>前几部都有总结的资料片，例如《皮卡丘》、《水晶版》、《绿宝石》、《白金》，从第五世代《黑·白》开始去掉了。</p>
<p>第一部是以御三家作为封面，之后都使用传说神奇宝贝作为封面。封面会标记游戏平台。</p>
<p>每一代都会来到一个新地区，伴随着旧作的复刻版，剧情、人物类似，游戏平台、画面更新。</p>
<blockquote>
<p>复刻版例如《火红·叶绿》、《心金·魂银》、《欧米伽红宝石·阿尔法蓝宝石》、《晶灿钻石·明亮珍珠》</p>
<p>同作可以只玩旧版或者复刻版</p>
</blockquote>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><table>
<thead>
<tr>
<th>年份</th>
<th>平台</th>
<th>作品</th>
<th>地区</th>
<th>初始地图</th>
<th>主角</th>
<th>宝可梦博士</th>
<th>御三家</th>
<th>种类</th>
<th>传说宝可梦</th>
</tr>
</thead>
<tbody><tr>
<td>1996年</td>
<td>Game Boy</td>
<td>《红·绿》<br>《蓝》<br>《红·蓝》<br>《皮卡丘（黄）》</td>
<td>关都地区<br>（关东）</td>
<td>真新镇</td>
<td>赤红<br>碧蓝</td>
<td>大木博士</td>
<td>小火龙<br>妙蛙种子<br>杰尼龟<br>皮卡丘</td>
<td>151种</td>
<td>急冻鸟<br>火焰鸟<br>闪电鸟<br>超梦</td>
</tr>
<tr>
<td>1999年</td>
<td>Game Boy Color</td>
<td>《金·银》<br>《水晶版》</td>
<td>城都地区<br>（关西）</td>
<td>若叶镇</td>
<td>小响<br>克丽斯</td>
<td>空木博士</td>
<td>火球鼠<br>菊草叶<br>小锯鳄</td>
<td>251种</td>
<td>凤王<br>洛奇亚<br>炎帝<br>水君<br>雷公</td>
</tr>
<tr>
<td>2002年</td>
<td>Game Boy Advance</td>
<td>《红宝石·蓝宝石》<br>《绿宝石》<br>《火红·叶绿》</td>
<td>丰缘地区<br>（九州岛）</td>
<td>未白镇</td>
<td>小悠<br>小瑶</td>
<td>小田卷博士</td>
<td>火稚鸡<br>木守宫<br>水跃鱼</td>
<td>386种</td>
<td>固拉多<br>盖欧卡<br>烈空坐</td>
</tr>
<tr>
<td>2006年</td>
<td>NDS</td>
<td>《钻石·珍珠》<br>《白金》<br>《心金·魂银》</td>
<td>神奥地区<br>（北海道）</td>
<td>双叶镇</td>
<td>明辉<br>小光</td>
<td>山梨博士</td>
<td>小火猴<br>草苗龟<br>波加曼</td>
<td>493种</td>
<td>帝牙卢卡<br>帕路奇亚<br>骑拉帝纳</td>
</tr>
<tr>
<td>2010年</td>
<td>NDS</td>
<td>《黑·白》<br>《黑2·白2》</td>
<td>合众地区<br>（纽约）</td>
<td>鹿子镇</td>
<td>斗也<br>斗子<br>共平<br>鸣伊</td>
<td>红豆杉博士</td>
<td>暖暖猪<br>藤藤蛇<br>水水獭</td>
<td>649种</td>
<td>莱希拉姆<br>捷克罗姆<br>酋雷姆</td>
</tr>
<tr>
<td>2013年</td>
<td>3DS</td>
<td>《X·Y》<br>《欧米伽红宝石·阿尔法蓝宝石》</td>
<td>卡洛斯地区<br>（法国北半部）</td>
<td>朝香镇</td>
<td>卡鲁穆<br>莎莉娜</td>
<td>布拉塔诺博士</td>
<td>哈力栗<br>火狐狸<br>呱呱泡娃</td>
<td>721种</td>
<td>哲尔尼亚斯<br>伊裴尔塔尔</td>
</tr>
<tr>
<td>2016年</td>
<td>3DS<br>Switch</td>
<td>《太阳·月亮》<br>《究极之日·究极之月》<br>《Let’s Go!皮卡丘·Let‘s Go伊布》</td>
<td>阿罗拉地区<br>（美国夏威夷）</td>
<td>好奥乐市郊</td>
<td>朗日<br>美月</td>
<td>库库伊博士</td>
<td>木木枭<br>火斑喵<br>球球海狮</td>
<td>809种</td>
<td>索尔迦雷欧<br>露奈雅拉<br>奈克洛兹玛</td>
</tr>
<tr>
<td>2019年</td>
<td>Switch</td>
<td>《剑·盾》<br>《晶灿钻石·明亮珍珠》<br>《宝可梦传说：阿尔宙斯》</td>
<td>伽勒尔地区<br>（英格兰和威尔士）</td>
<td>化朗镇</td>
<td>小胜<br>小优<br>明耀<br>小照</td>
<td>木兰博士<br>拉苯博士（洗翠地区）</td>
<td>炎兔儿<br>敲音猴<br>泪眼蜥</td>
<td>905种</td>
<td>苍响<br>藏玛然特</td>
</tr>
<tr>
<td>2022年</td>
<td>Switch</td>
<td>《朱·紫》</td>
<td>帕底压地区</td>
<td></td>
<td></td>
<td></td>
<td>新叶猫<br>呆火鳄<br>润水鸭</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="第一世代"><a href="#第一世代" class="headerlink" title="第一世代"></a>第一世代</h2><p>《红·绿》只在日本发售，《蓝》是修正版。海外发售的是《红·蓝》。《皮卡丘》是为了迎合动画重制发售的。</p>
<p>红绿蓝黄指喷火龙、妙蛙花、水箭龟，皮卡丘</p>
<p><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/红.png" style="zoom: 45%"><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/绿.png" style="zoom: 45%"><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/蓝.png" style="zoom: 45%"><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/皮卡丘.png" style="zoom: 45%"></p>
<h2 id="第二世代"><a href="#第二世代" class="headerlink" title="第二世代"></a>第二世代</h2><p>《水晶版》是《金·银》的资料片。城都地区探索完后可以回到最初的关都地区。</p>
<p>金银指凤王、洛奇亚，水晶指水君</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/金银.png" style="zoom: 45%">

<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/水晶.png" style="zoom: 45%">

<h2 id="第三世代"><a href="#第三世代" class="headerlink" title="第三世代"></a>第三世代</h2><p>《绿宝石》是《红宝石·蓝宝石》的资料片。</p>
<p>红宝石蓝宝石指固拉多和盖欧卡、绿宝石指烈空坐。</p>
<p><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/红宝石蓝宝石.png" style="zoom: 100%"><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/绿宝石.png" style="zoom: 45%"></p>
<p>《火红·叶绿》是《红·绿》在GBA的复刻版</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/火红叶绿.png" style="zoom: 60%">

<h2 id="第四世代"><a href="#第四世代" class="headerlink" title="第四世代"></a>第四世代</h2><p>《白金》是《钻石·珍珠》的资料片，钻石珍珠指帝牙卢卡和帕路奇亚，白金指骑拉帝纳</p>
<p><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/钻石珍珠.png" style="zoom: 60%"><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/白金.png" style="zoom: 35%"></p>
<p>《心金·魂银》是《金·银》在DS的复刻版</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/心金魂银.png" style="zoom: 60%">

<h2 id="第五世代"><a href="#第五世代" class="headerlink" title="第五世代"></a>第五世代</h2><p>《黑2·白2》（主角为共平、鸣伊）是《黑·白》（主角为斗也、斗子）的续作</p>
<p>黑白指莱希拉姆、捷克罗姆。黑2白2指暗黑酋雷姆 、焰白酋雷姆，是酋雷姆与黑白龙的合体</p>
<p>道之三龙：莱希拉姆、捷克罗姆、酋雷姆。源于道教中的阳极、阴极和无极。莱希拉姆和捷克罗姆代表两次工业革命，象征人类文明，酋雷姆代表冰河世纪，象征原始文明</p>
<p><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/黑白.png" style="zoom: 30%"><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/黑2白2.png" style="zoom: 30%"></p>
<h2 id="第六世代"><a href="#第六世代" class="headerlink" title="第六世代"></a>第六世代</h2><p>XY指哲尔尼亚斯、伊裴尔塔尔</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/XY.png" style="zoom: 20%">

<p>《欧米伽红宝石·阿尔法蓝宝石》 是《红宝石·蓝宝石》在3DS的复刻版</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/欧米伽红宝石阿尔法蓝宝石.png" style="zoom: 20%">

<h2 id="第七世代"><a href="#第七世代" class="headerlink" title="第七世代"></a>第七世代</h2><p>太阳月亮指索尔迦雷欧、露奈雅拉。</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/太阳月亮.png" style="zoom: 25%">

<p>《究极之日·究极之月》是《太阳·月亮》的加强版，新增究极调查队，核心为奈克洛兹玛（黄昏之鬃，吸收索尔迦雷欧）、奈克洛兹玛（拂晓之翼，吸收露奈雅拉）</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/究极之日究极之月.png" style="zoom: 60%">

<p>《Let’s Go!皮卡丘·Let‘s Go伊布》是Switch游戏，想把手游《宝可梦GO》玩家转化为主机玩家。</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/LetsGo.png" style="zoom: 60%">

<h2 id="第八世代"><a href="#第八世代" class="headerlink" title="第八世代"></a>第八世代</h2><p>《剑·盾》（主角为小胜、小优）首次新增了付费内容DLC扩展票：《剑/盾扩展票：铠之孤岛》、《剑/盾扩展票：冠之雪原》，可继承《剑·盾》进度，新增了铠之孤岛和冠之雪原两个区域。</p>
<p>剑盾指苍响、藏马然特</p>
<p><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/剑.png" style="zoom: 45%"><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/盾.png" style="zoom: 45%"></p>
<p>《晶灿钻石·明亮珍珠》是《钻石·珍珠》的重制版，为宝可梦主系列首个不由Game Freak开发的游戏，由ILCA制作。</p>
<p><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/晶灿钻石.png" style="zoom: 60%"><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/明亮珍珠.png" style="zoom: 60%"></p>
<p>《宝可梦传说：阿尔宙斯》（主角为明耀、小照）舞台为过去的神奥地区——洗翠地区。</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/阿尔宙斯.png" style="zoom: 45%">

<h2 id="第九世代"><a href="#第九世代" class="headerlink" title="第九世代"></a>第九世代</h2><p>朱紫指故勒顿、密勒顿</p>
<h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/角色1.jpg" style="zoom: 45%">

<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/角色2.jpg" style="zoom: 45%">

<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/角色3.jpg" style="zoom: 45%">

<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/角色4.jpg" style="zoom: 45%">

<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/角色5.jpg" style="zoom: 45%">

<h1 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h1><h2 id="关都地区"><a href="#关都地区" class="headerlink" title="关都地区"></a>关都地区</h2><p>原型是日本关东，白银大会所在地</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/关都地区2.png" style="zoom: 100%">

<h2 id="城都地区"><a href="#城都地区" class="headerlink" title="城都地区"></a>城都地区</h2><p>原型是日本关西和四国岛，位于关都地区西边，中间是石英高原</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/城都地区.png" style="zoom: 100%">

<h2 id="丰缘地区"><a href="#丰缘地区" class="headerlink" title="丰缘地区"></a>丰缘地区</h2><p>原型是日本九州岛，位于城都地区西南边</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/丰缘地区.png" style="zoom: 100%">

<h2 id="神奥地区"><a href="#神奥地区" class="headerlink" title="神奥地区"></a>神奥地区</h2><p>原型是日本北海道、国后岛、库页岛。位于宝可梦世界最北的地区，在关都和城都北部，被天冠山分为两半。</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/神奥地区.png" style="zoom: 100%">

<p>旧神奥地区称为洗翠地区。出现在《宝可梦传说：阿尔宙斯》中</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/洗翠地区.png" style="zoom: 100%">

<h2 id="合众地区"><a href="#合众地区" class="headerlink" title="合众地区"></a>合众地区</h2><p>原型是美国纽约，位于遥远的南方。</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/合众地区.png" style="zoom: 100%">

<h2 id="卡洛斯地区"><a href="#卡洛斯地区" class="headerlink" title="卡洛斯地区"></a>卡洛斯地区</h2><p>原型是法国北半部</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/卡洛斯地区.png" style="zoom: 100%">

<h2 id="阿罗拉地区"><a href="#阿罗拉地区" class="headerlink" title="阿罗拉地区"></a>阿罗拉地区</h2><p>原型是美国夏威夷，度假胜地，有连接其他世界的究极之洞</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/阿罗拉地区.png" style="zoom: 100%">

<h2 id="伽勒尔地区"><a href="#伽勒尔地区" class="headerlink" title="伽勒尔地区"></a>伽勒尔地区</h2><p>原型是英国大不列颠岛的英格兰、威尔士、马恩岛（铠岛）、苏格兰（冠之雪原）</p>
<img src="/2022/08/20/geek-2022-08-20-%E5%AE%9D%E5%8F%AF%E6%A2%A6%E6%89%8B%E5%86%8C/伽勒尔地区.png" style="zoom: 100%">

<h1 id="宝可梦动画"><a href="#宝可梦动画" class="headerlink" title="宝可梦动画"></a>宝可梦动画</h1><table>
<thead>
<tr>
<th></th>
<th>世代</th>
<th>地区</th>
<th>配角</th>
<th>集数</th>
<th>年份</th>
</tr>
</thead>
<tbody><tr>
<td>《宝可梦》（无印）</td>
<td>第一、第二世代</td>
<td>关都、城都地区</td>
<td>小霞、小刚</td>
<td>275</td>
<td>1997-2002</td>
</tr>
<tr>
<td>《宝可梦：超世代》</td>
<td>第三世代</td>
<td>丰缘地区</td>
<td>小遥、小胜、小刚</td>
<td>191</td>
<td>2002-2006</td>
</tr>
<tr>
<td>《宝可梦：钻石与珍珠》</td>
<td>第四世代</td>
<td>神奥地区</td>
<td>小光、小刚</td>
<td>189</td>
<td>2006-2010</td>
</tr>
<tr>
<td>《宝可梦：超级愿望》</td>
<td>第五世代</td>
<td>合众地区</td>
<td>艾莉丝、天桐</td>
<td>142</td>
<td>2010-2013</td>
</tr>
<tr>
<td>《宝可梦XY》</td>
<td>第六世代</td>
<td>卡洛斯地区</td>
<td>莎莉娜、希特隆、柚莉嘉</td>
<td>141</td>
<td>2013-2016</td>
</tr>
<tr>
<td>《宝可梦：太阳&amp;月亮》</td>
<td>第七世代</td>
<td>阿罗拉地区</td>
<td>莉莉艾、卡奇、水莲、玛奥、马玛内</td>
<td>146</td>
<td>2016-2019</td>
</tr>
<tr>
<td>《宝可梦旅途》</td>
<td></td>
<td>所有地区</td>
<td>小豪、小春</td>
<td></td>
<td>2019-至今</td>
</tr>
</tbody></table>
<h2 id="有趣的话题"><a href="#有趣的话题" class="headerlink" title="有趣的话题"></a>有趣的话题</h2><p>知乎上有趣的话题：摘了一些很有见地的回复。</p>
<p>宝可梦游戏每部主角不一样，动画主角为什么一直是小智？为什么小智的冠军一直被黑？</p>
<blockquote>
<p>总的来说是为了商业价值，小智就是赚钱的工具人。</p>
<p>皮卡丘商业价值太大，周边产品圈钱最多，超越了游戏系列。因此皮卡丘一定是主角，而小智已经被皮卡丘绑定了，不能让每一代的新主角用同一个皮卡丘，也不能让新主角开场各抓一个皮卡丘。另外换每部游戏主角观众容易出戏。</p>
<p>为什么小智的冠军一直被黑？因为东电认为拿了冠军就要换主角。</p>
</blockquote>
<p>为什么先玩宝可梦游戏再看动画会有种很不爽的感觉？</p>
<blockquote>
<p>神回复：</p>
<p>你玩游戏：对面来一只宝可梦，你选择了克制的招式或者1倍效果招式。</p>
<p>动画里小智：我就是逆属性大师！</p>
<p>你心里：md会不会玩宝可梦</p>
</blockquote>
<p>宝可梦八大师，小智数据面板垫底，打架全靠莽。二十几年经验值，每次开局都归零重连。除了皮卡丘，其他宝可梦没几个不放生的。</p>
<h1 id="宝可梦GO"><a href="#宝可梦GO" class="headerlink" title="宝可梦GO"></a>宝可梦GO</h1><p>2016年首发，AR手游</p>
<h1 id="Pokemmo"><a href="#Pokemmo" class="headerlink" title="Pokemmo"></a>Pokemmo</h1><p>Pokemmo是一款在线版宝可梦（非官方），集合了多个版本的地图。</p>
<p>不提供Rom，需要自行导入。画面、素材相比正作有一些优化。</p>
<p>没玩过，听说很肝，需要氪金。</p>
<blockquote>
<p>好奇实现原理。</p>
</blockquote>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul>
<li><a href="https://zukan.pokemon.co.jp/">宝可梦图鉴-日本</a></li>
<li><a href="https://hk.portal-pokemon.com/play/pokedex">宝可梦图鉴-香港</a></li>
<li><a href="https://www.pokemon.cn/play/pokedex">宝可梦图鉴-中国</a></li>
<li><a href="https://www.pokemon.com/us/pokedex/">宝可梦图鉴-美国</a></li>
<li><a href="https://wiki.52poke.com/zh-hans/%E5%AE%9D%E5%8F%AF%E6%A2%A6%E5%88%97%E8%A1%A8%EF%BC%88%E6%8C%89%E5%85%A8%E5%9B%BD%E5%9B%BE%E9%89%B4%E7%BC%96%E5%8F%B7%EF%BC%89">维基百科-全国图鉴</a></li>
<li><a href="https://www.portal-pokemon.com/">宝可梦官网-国家选择</a></li>
<li><a href="https://www.pokemon.co.jp/game/">宝可梦官网-游戏列表</a></li>
<li><a href="https://pokeapi.co/">PokeAPI</a>：免费宝可梦API接口，<a href="https://blog.ajiang.co/pokedex">NextJs示例</a></li>
<li><a href="https://github.com/PokeAPI/pokedex">PokeApi-爬虫</a></li>
<li><a href="https://github.com/brendn/PokemonAPIProject">Pokemon接口封装</a>：调用PokeAPI，JSP显示页面</li>
<li><a href="https://github.com/kiinlam/pokemonCollection">Pokemon爬虫</a>：从官网抓取数据存入mongoDB</li>
</ul>
<p>宝可梦图鉴参考App实现：</p>
<ul>
<li>ProDex</li>
<li>Gotcha</li>
</ul>
]]></content>
      <categories>
        <category>极客</category>
      </categories>
      <tags>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title>Google语音服务</title>
    <url>/2022/08/19/google-2022-08-19-Google%E8%AF%AD%E9%9F%B3%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Cloud-Speech-to-Text（STT）"><a href="#Cloud-Speech-to-Text（STT）" class="headerlink" title="Cloud Speech-to-Text（STT）"></a>Cloud Speech-to-Text（STT）</h1><table>
<thead>
<tr>
<th>识别方式</th>
<th>音频格式</th>
<th>请求方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>同步识别</td>
<td>短音频（不超过1分钟）</td>
<td>REST和gRPC</td>
<td>全部处理完之后返回结果</td>
</tr>
<tr>
<td>异步识别</td>
<td>长音频（不超过480分钟）</td>
<td>REST和gRPC</td>
<td>定期轮询，返回识别结果</td>
</tr>
<tr>
<td>流式识别</td>
<td>实时音频</td>
<td>gRPC</td>
<td>从麦克风采集实时音频，边讲话边返回识别结果</td>
</tr>
</tbody></table>
<ul>
<li><a href="https://cloud.google.com/speech-to-text/docs/quickstart?hl=zh-cn">Speech To Text API接入</a></li>
<li><a href="https://github.com/GoogleCloudPlatform/android-docs-samples">Speech To Text Android 示例</a>：Demo运行成功，按照文档配一下凭据即可<ul>
<li>SpeechRecognitionClient：使用Java客户端SDK方式调用，封装了grpc类。使用简单，但是未对Android进行优化，例如没有使用java-lite的protobuf库</li>
<li>Speech：使用轻量的protobuf，需要自己定义protobuf类</li>
</ul>
</li>
</ul>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>TvSpeechService采用的是speech api，使用服务账号json凭据生成AccessToken进行请求</p>
<ol>
<li>最早直接将json凭据放到raw中</li>
<li>然后将json凭据放到系统中，进行DES3加密，DES3密钥使用Java常量存储</li>
<li>再将DES3密钥放到so库中，增加破解难度</li>
<li>v2将AccessToken生成放到SDK中，SDK内部请求服务端，服务端生成AccessToken返回（Google推荐做法）</li>
</ol>
<h1 id="Google-Assistant-App"><a href="#Google-Assistant-App" class="headerlink" title="Google Assistant App"></a>Google Assistant App</h1><p>是Google开发的语音助手App，可以调起其他应用、显示其他应用的小部件或者Slice页面、百科搜索、通过Google Home控制智能家居等。</p>
<p>依赖gms运行。</p>
<h1 id="Google-Assistant功能"><a href="#Google-Assistant功能" class="headerlink" title="Google Assistant功能"></a>Google Assistant功能</h1><ul>
<li><a href="https://developer.android.com/guide/app-actions/overview">App Action</a>：应用定制Action，Google Assistant可以快捷跳转自己的应用或者执行动作，提高应用曝光率。可以结合Slice使用。</li>
<li><a href="https://developers.home.google.com/">智能家居</a>：传递智能家居Intent，定制特殊指令。文档从Assistant迁移到Google Home开发者中心。</li>
<li>Web Action：网页定制Action，Google Assistant可以发现并显示自己的网页内容。</li>
<li>Media Action：媒体资源定制Action，Google Assistant可以发现并播放内容。</li>
<li>Conversational Action：支持在控制台定制对话。2023年6月13日将被移除。</li>
</ul>
<blockquote>
<p>实现对话操作有两种方式</p>
<ul>
<li><a href="https://cloud.google.com/dialogflow/es/docs">Dialogflow对话流</a></li>
<li>Google Assistant（旧版）：旧版Google Assistant集成了Dialogflow，2023年将被移除，不再集成Dialogflow，改为使用内置的对话构建器。参考<ul>
<li><a href="https://cloud.google.com/dialogflow/es/docs/integrations/aog">Google助理（旧版）</a></li>
<li><a href="https://developers.google.com/assistant/ca-sunset">Conversational Actions sunset</a></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Google-Assistant-API和Speech-to-Text-API"><a href="#Google-Assistant-API和Speech-to-Text-API" class="headerlink" title="Google Assistant API和Speech-to-Text API"></a>Google Assistant API和Speech-to-Text API</h2><ul>
<li><p>Speech-to-Text API：服务接口为<code>speech.googleapis.com</code>，只提供了语音转文字功能。</p>
<ul>
<li>价格：$0.004/15 秒</li>
</ul>
</li>
<li><p>Google Assistant API：服务接口为<code>embeddedassistant.googleapis.com</code>，让设备具备类似Google Home的功能，智能音响设备集成SDK，发送语音到云端，云端识别成设备指令后返回。智能音响再去控制其他设备，或者控制自身。</p>
<ul>
<li>未标注价格，不过有配额限制，并且声明无法商用</li>
</ul>
</li>
</ul>
<blockquote>
<p>个人理解：GoogleAssistant服务内部应该是依赖了Speech-to-Text服务，并且还加入了一些自己的功能。</p>
<p>正常客户端直接请求speech服务，统计speech的配额和流量。assistant服务帮我们转发了请求，speech的配额和流量由assistant承担。</p>
</blockquote>
<h2 id="Google-Assistant接入"><a href="#Google-Assistant接入" class="headerlink" title="Google Assistant接入"></a>Google Assistant接入</h2><p>参考<a href="https://developers.google.com/assistant/sdk/guides/service/python">Google Assistant Service</a>和<a href="https://github.com/androidthings/sample-googleassistant">sample-googleassistant示例</a>，大致流程和接入Speech-to-Text类似</p>
<blockquote>
<p>语义识别暂未实验</p>
</blockquote>
<ol>
<li><a href="https://console.actions.google.com/">Action Console</a>中创建项目，<a href="https://console.cloud.google.com/">Google Cloud</a>中会同步创建项目</li>
<li>Google Cloud中启用Google Assistant API和OAuth授权功能。（根据需要创建结算账号，关联项目，定期结算）</li>
<li>下载<a href="https://github.com/androidthings/sample-googleassistant">sample-googleassistant</a>：该项目基于Android嵌入式树莓派平台，用到了嵌入式平台的类库和控件，在手机上无法直接运行。例如通过Gpio输出电信号，控制IoT设备。</li>
<li>修改为Android移动平台代码、去掉gradle依赖</li>
<li>控制台下载凭据：<ol>
<li>样例中使用<code>google-oauthlib-tool</code>工具生成OAuth凭据，试了一下没成功，不知道为什么提示400</li>
<li>这里使用服务账号生成凭据：【凭据-&gt;服务账号-&gt;密钥-&gt;添加密钥】，下载私钥的json文件</li>
</ol>
</li>
<li>根据私钥生成Access Token进行请求，或者将私钥传给SDK进行请求：<ol>
<li>保存json私钥到raw目录（考虑安全性，不应该放到工程中，而是放到服务器上，这里只是作为示例）</li>
<li>样例中使用<code>UserCredentials</code>读取私钥，需要改为<code>GoogleCredentials</code></li>
</ol>
</li>
<li>编译运行APP：能够识别语音转文字，但是由于没有注册嵌入式设备，无法进行具体的行为</li>
</ol>
<h1 id="智能家居相关"><a href="#智能家居相关" class="headerlink" title="智能家居相关"></a>智能家居相关</h1><p><a href="https://developers.google.com/assistant/smarthome/concepts/homegraph">Home Graph</a>：是一个存储家庭及其设备信息的数据库。本质是家庭的逻辑地图。智能家居的所有操作都依赖Home Graph</p>
<ul>
<li>结构Structure：每个房屋对应一个结构<ul>
<li>管理员Managers：每个结构至少包含一名管理员，可以与其他用户共享结构</li>
<li>标签Labels：标识结构，例如John‘s House</li>
<li>房间Rooms：结构包含房间</li>
<li>设备Devices：结构包含设备</li>
</ul>
</li>
<li>房间：一个结构包含多个房间<ul>
<li>标签：标识房间，例如Master Bedroom</li>
<li>设备：房间包含设备</li>
</ul>
</li>
<li><a href="https://developers.google.com/assistant/smarthome/concepts/devices-traits">设备</a>：一个设备必须属于一个结构，最多可以属于一个房间。<ul>
<li>标签：标识设备，例如Bedroom Lamp</li>
<li>类型Type：例如灯、摄像头、空调等</li>
<li>特性Traits：即功能，例如亮度、颜色、开关、模式等。<ul>
<li>属性Attributes：静态的设备属性，例如模式支持设置哪些选项，颜色支持设置多大范围等。</li>
<li>状态State：动态变化的设备状态</li>
<li>命令Command：下发控制指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>设备特性传输方式：</p>
<ul>
<li>查询：可读，queryOnlyXXX属性（默认为false）表示只支持被查询状态</li>
<li>控制：可写，commandOnlyXXX属性（默认为false）表示只支持被控制</li>
<li>可查询可控制：可读写</li>
</ul>
]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Google开发者平台介绍</title>
    <url>/2022/08/18/google-2022-08-18-Google%E5%BC%80%E5%8F%91%E8%80%85%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前接入过Firebase推送、YouTube API，对Google开发者平台做了简单的了解。后面逐渐将用到的Google功能和API整合到该分类下，例如FCM、YouTube等。</p>
<p>由于Google内部也有很多部门、业务、产品、软件架构的区分和调整，错综复杂。在这样的环境下，Google Cloud能够支撑大量的业务，并且保持架构稳定，是一件很了不起的事情，越了解就越觉得牛逼。不过也遇到了一些问题</p>
<ol>
<li>一些产品功能有交叉重合，不同业务之间有什么联系：例如Google Assistant API和Speech-to-Text API，GCM和FCM</li>
<li>有些文档、Sample很久没更新</li>
<li>不知道该去哪里找有用的资料</li>
</ol>
<p>因此粗浅地了解下Google开发者体系和架构。希望对Google开发者平台有个初步的、全面的认识。</p>
<h1 id="Google开发者"><a href="#Google开发者" class="headerlink" title="Google开发者"></a>Google开发者</h1><p>包含谷歌开发的框架、服务、应用等，以及对应的学习资料（教程、集成文档、Codelab、Google开发者认证等）。</p>
<p>热门产品：Android、Flutter、Chrome OS、YouTube、Google Cloud、Maps Platform、Google Play等，简单介绍几个</p>
<ul>
<li><a href="https://firebase.google.com/">Firebase</a>：提供应用开发解决方案，例如消息推送、云服务接口、测试、性能监控、数据分析等</li>
<li><a href="https://developers.google.com/web">Web</a>：包含UI设计、框架、性能、搜索、审核等学习资料</li>
<li><a href="https://www.tensorflow.org/">Tensor Flow</a>：机器学习框架</li>
<li><a href="https://workspace.google.com/">Google Workspace</a>：为企业提供的工作台，用于协同办公，包含企业邮箱、企业文档、会议等工具</li>
<li><a href="https://developers.google.com/google-ads">Google Ads</a>：广告服务</li>
<li><a href="https://cloud.google.com/">Google Cloud</a>：提供基础服务、基础设施等。除了Android、Flutter等非云产品，所有云服务都依赖Google Cloud Platform，准确来说Android和Flutter源码、依赖库等或多或少也会用到GCP。</li>
</ul>
<p>重要地址：</p>
<ul>
<li><a href="https://developers.google.com/products/develop">Google开发产品</a>：集合所有Google开发产品和资料，可以在这里搜索。</li>
</ul>
<h1 id="Google-Cloud-Platform（GCP）"><a href="#Google-Cloud-Platform（GCP）" class="headerlink" title="Google Cloud Platform（GCP）"></a>Google Cloud Platform（GCP）</h1><p><a href="https://cloud.google.com/">Google Cloud Platform</a>：提供计算、管理、数据分析、存储、运维、人工智能等一系列能力、基础服务和基础设施。</p>
<p><a href="https://console.cloud.google.com/">Google Cloud控制台</a>：管理Cloud项目，例如费用结算、配额和请求管理、生成凭据等。一个项目会用到各种各样的资源，例如API密钥、OAuth客户端、虚拟机、云存储等。</p>
<p>重要地址：</p>
<ul>
<li><a href="https://cloud.google.com/docs">Google Cloud产品</a>：Google Cloud自己开发的产品，对应的文档在Cloud中</li>
<li><a href="https://console.cloud.google.com/marketplace/browse">Google Cloud市场</a>：除了Google Cloud产品之外，还包含二方（例如Google、Google Enterprise、Firebase、YouTube）、三方合作伙伴（例如JFrog、Jenkins、CentOS）开发的产品，对应的文档在各自的网站中。</li>
<li><a href="https://cloud.google.com/pricing/list?hl=zh-cn">Google Cloud产品价格表</a></li>
<li><a href="https://github.com/googleapis/googleapis">Google Cloud APIs原始接口定义</a>：用于了解接口参数定义等，也可以直接使用客户端库</li>
<li><a href="https://github.com/googleapis/google-api-python-client/tree/main/docs">google api说明文档</a></li>
</ul>
<h2 id="Google-Cloud-APIs"><a href="#Google-Cloud-APIs" class="headerlink" title="Google Cloud APIs"></a>Google Cloud APIs</h2><ul>
<li><a href="https://cloud.google.com/apis/docs/overview">Google Cloud APIs</a>：Google Cloud服务的编程接口，用于管理Cloud服务资源，例如启用或停止某项服务。通常在<code>googleapis.com</code>子网域下运行，例如<code>cloudapis.googleapis.com</code>、<code>speech.googleapis.com</code>、<code>youtube.googleapis.com</code>。</li>
<li>Google Enterprise API：Google企业级API，更稳定的API，专门的团队支持。</li>
</ul>
<blockquote>
<p>Google Cloud APIs个人理解</p>
<ul>
<li>狭义：特指Cloud API基础服务，可以用编程方式管理Cloud资源。所有控制台项目默认启用Google Cloud APIs功能。</li>
<li>广义：指所有基于GCP开发的API，同样可以通过Google Cloud APIs管理接口。在GCP之上，Firebase、Assistant、Google Home这些产品有自己的控制台，每个控制台可以编辑特定的功能。在这些控制台创建项目之后会在Cloud控制台上创建同样的项目。</li>
</ul>
</blockquote>
<p>一般提供REST API、gRPC、客户端库等方式集成</p>
<h2 id="Google-Cloud-SDK"><a href="#Google-Cloud-SDK" class="headerlink" title="Google Cloud SDK"></a>Google Cloud SDK</h2><p><a href="https://cloud.google.com/sdk">Google Cloud SDK</a>主要包含两部分功能：</p>
<ul>
<li><a href="https://cloud.google.com/cli">gCloud CLI</a>命令行工具快速调用APIs</li>
<li>不同语言的Google Cloud客户端库：封装了<strong>所有Google Cloud APIs调用</strong>，持续更新优化。</li>
</ul>
<blockquote>
<p>使用的时候挑选特定的库即可，不需要全部依赖。</p>
</blockquote>
<p>重要地址：</p>
<ul>
<li>SDK文档地址：<a href="https://cloud.google.com/java/docs/reference">Java Cloud Client Libraries</a></li>
<li>SDK源码地址：<a href="https://github.com/googleapis/google-cloud-java">google-cloud-java</a>、<a href="https://github.com/googleapis/google-cloud-python">google-cloud-python</a>。</li>
</ul>
]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编译和运行命令</title>
    <url>/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java程序编译和运行主要分为以下过程</p>
<ol>
<li>使用<code>javac</code>编译，将java文件编译成class字节码文件</li>
<li>使用<code>jar</code>打包</li>
<li>使用<code>java</code>启动虚拟机执行，Windows下可以打包成exe运行</li>
</ol>
<p>本文用到的演示示例如下：<a href="https://github.com/Afauria/TestJavac">GitHub地址</a></p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/演示示例.png" style="zoom:50%;">

<h1 id="javac编译"><a href="#javac编译" class="headerlink" title="javac编译"></a>javac编译</h1><p>常用选项：</p>
<ul>
<li><code>-encoding UTF8</code>：指定UTF8编码，有中文字符时需要用到</li>
<li><code>-d build</code>：指定class输出路径，默认和源文件同一路径。不同IDE输出路径不同，例如eclipse输出到bin目录</li>
<li><code>-verbose</code>：输出详细的编译信息</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译少量文件，使用空格分割</span></span><br><span class="line">javac -d build First.java Second.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译多个文件，将java文件列在一个文件，使用@引用该文件</span></span><br><span class="line">javac -d build @sourcelist.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译同一目录下的java文件，使用通配符</span></span><br><span class="line">javac -d build src/*.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译多级子目录下的java文件，使用路径通配符</span></span><br><span class="line">javac -d build src/**/*.java</span><br></pre></td></tr></table></figure>

<p>其他选项：</p>
<ul>
<li><code>-source &lt;JDK版本&gt;</code>：指定编译版本，如果使用了高版本的特性，会编译失败</li>
<li><code>-target &lt;VM版本&gt;</code>：指定运行的目标版本，实际运行的JVM版本需要高于该版本</li>
<li><code>-processor &lt;class&gt;</code>：指定注解处理器的class文件</li>
</ul>
<h2 id="编译时搜索路径"><a href="#编译时搜索路径" class="headerlink" title="编译时搜索路径"></a>编译时搜索路径</h2><p>java编译源文件时，<strong>会按照下面的顺序搜索类文件</strong>：</p>
<ol>
<li>Bootstrap classes：JDK自带的类，主要是<code>jre/lib</code>下的jar文件，可以通过<code>-bootclasspath</code>设置</li>
<li>Extension classes：扩展类，主要是<code>jre/lib/ext</code>下的jar文件，可以通过<code>-extdirs</code>设置</li>
<li>User classes：用户类，可以通过<code>-cp</code>或者<code>-classpath</code>设置。搜索顺序为当前目录、CLASSPATH环境变量、<code>-classpath</code>下的类文件，</li>
<li>Source：源文件，通过<code>-sourcepath</code>设置</li>
</ol>
<blockquote>
<p>如果有多个路径，Linux上使用<code>:</code>分割，Windows使用<code>;</code>分隔（类似于环境变量）</p>
<p><code>-bootclasspath</code>和<code>-extdirs</code>几乎不会用到</p>
</blockquote>
<p><code>-sourcepath</code>和<code>-classpath</code>注意事项</p>
<ul>
<li><code>-sourcepath</code>：只会搜索源码（.java文件）</li>
<li><code>-classpath</code>：可以是java文件、class文件、jar包等<ul>
<li>如果不指定sourcepath，classpath会搜索java文件和class文件</li>
<li>如果指定了sourcepath，则classpath只搜索class文件</li>
</ul>
</li>
</ul>
<blockquote>
<p>javac既认识java文件也认识class文件，java（虚拟机）只认识class文件。</p>
</blockquote>
<h1 id="jar打包"><a href="#jar打包" class="headerlink" title="jar打包"></a>jar打包</h1><p>常用选项：</p>
<ul>
<li><code>-c</code>：创建新档案文件。</li>
<li><code>-f</code>：指定档案文件名</li>
<li><code>-m</code>：指定清单文件。</li>
<li><code>-e</code>：指定主类，程序入口。</li>
</ul>
<blockquote>
<p>档案文件名、清单文件、主类的顺序，与f、m、e选项顺序相同</p>
</blockquote>
<p><strong>需要进入class输出目录，否则打包的时候会把<code>build</code>文件夹也打包进去，导致主类路径不正确</strong></p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译src目录下的java文件</span></span><br><span class="line">javac -d build src/**/*.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入build目录</span></span><br><span class="line">cd build</span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动生成`MANIFEST.MF`清单文件，但是不会指定主类。使用`java -jar`执行的时候会提示“没有主清单属性”</span></span><br><span class="line">jar cvf out.jar **/*.class</span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动生成`MANIFEST.MF`清单文件，并指定主类。</span></span><br><span class="line">jar cvfe out.jar com.afauria.Main **/*.class</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用指定的清单文件。</span></span><br><span class="line">jar cvfm out.jar ../src/META-INF/MANIFEST.MF **/*.class</span><br></pre></td></tr></table></figure>

<p><strong>如果代码中使用了资源文件，也要打包到jar包中。</strong></p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> TestImage中引用了`images/icon.png`资源</span></span><br><span class="line">javac TestImage.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包资源到jar包中</span></span><br><span class="line">jar cvfe testImage.jar TestImage TestImage*.class images/icon.png</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行jar包</span></span><br><span class="line">java -jar testImage.jar</span><br></pre></td></tr></table></figure>

<h1 id="java运行"><a href="#java运行" class="headerlink" title="java运行"></a>java运行</h1><p>使用java命令启动虚拟机，执行class文件，分为两种方式：</p>
<ol>
<li>执行class文件：<code>java class</code>，class为主类名称</li>
<li>执行jar文件：<code>java -jar jarfile</code>，jar是归档文件，将多个class打包到一起，本质还是运行class。</li>
</ol>
<blockquote>
<p>主类不一定为Main，但是一定有main方法：<code>public static void main(String[] args)</code></p>
</blockquote>
<p><strong>如果定义了包名，需要输出到对应的路径下，否则执行class会找不到主类。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义包名</span></span><br><span class="line"><span class="keyword">package</span> com.afauria;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPackage</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译Java文件，输出class文件到当前目录</span></span><br><span class="line">javac TestPackage.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行提示<span class="string">&quot;找不到或无法加载主类&quot;</span></span></span><br><span class="line">java TestPackage</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动生成包名路径：com/afauria/TestPackage.class</span></span><br><span class="line">javac -d ./ TestPackage.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行正常</span></span><br><span class="line">java com.afauria.TestPackage</span><br><span class="line">java com/afauria/TestPackage</span><br></pre></td></tr></table></figure>

<p><strong>如果Java类依赖了其他class文件或者jar包，运行的时候需要指定<code>-classpath</code>或者<code>-cp</code>，否则会提示找不到类。</strong></p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> TestClassPath引用了out.jar中的类</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译TestClassPath文件，指定classpath搜索路径</span></span><br><span class="line">javac -cp build/out.jar TestClassPath.java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行TestClassPath类</span></span><br><span class="line">java -cp .:build/out.jar TestClassPath</span><br></pre></td></tr></table></figure>

<h1 id="找不到sun包"><a href="#找不到sun包" class="headerlink" title="找不到sun包"></a>找不到sun包</h1><p>如果代码中使用了<code>sun.*</code>或者<code>com.sun.*</code>的包，使用javac编译时会提示找不到类（JDK7及以上），并且IDE编译不报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.net.sdp.SdpSupport;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSun</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用-verbose查看编译过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -verbose TestSun.java</span></span><br><span class="line">[解析开始时间 RegularFileObject[TestSun.java]]</span><br><span class="line">[解析已完成, 用时 13 毫秒]</span><br><span class="line">[源文件的搜索路径: .]</span><br><span class="line">[类文件的搜索路径: $JAVA_HOME/jre/lib/resources.jar,$JAVA_HOME/jre/lib/rt.jar,$JAVA_HOME/jre/lib/sunrsasign.jar,$JAVA_HOME/jre/lib/jsse.jar,$JAVA_HOME/jre/lib/jce.jar,$JAVA_HOME/jre/lib/charsets.jar,$JAVA_HOME/jre/lib/jfr.jar,$JAVA_HOME/jre/classes,$JAVA_HOME/jre/lib/ext/sunec.jar,$JAVA_HOME/jre/lib/ext/nashorn.jar,$JAVA_HOME/jre/lib/ext/cldrdata.jar,$JAVA_HOME/jre/lib/ext/dnsns.jar,$JAVA_HOME/jre/lib/ext/localedata.jar,$JAVA_HOME/jre/lib/ext/sunjce_provider.jar,$JAVA_HOME/jre/lib/ext/sunpkcs11.jar,$JAVA_HOME/jre/lib/ext/jaccess.jar,$JAVA_HOME/jre/lib/ext/zipfs.jar,.]</span><br><span class="line">TestSun.java:1: 错误: 程序包sun.net.sdp不存在</span><br><span class="line">import sun.net.sdp.SdpSupport;</span><br><span class="line">                  ^</span><br><span class="line">[正在加载ZipFileIndexFileObject[$JAVA_HOME/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]]</span><br><span class="line">[正在检查TestSun]</span><br><span class="line">[正在加载ZipFileIndexFileObject[$JAVA_HOME/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[$JAVA_HOME/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class)]]</span><br><span class="line">[共 203 毫秒]</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure>

<p>原因：在Java6之后，JDK新增了一个链接文件<code>ct.sym</code>，使用javac命令进行编译代码时，默认使用该文件进行编译时class类的检查和链接，而不是使用rt.jar。</p>
<p>该文件约束了JDK的建议使用的类信息，包含了<code>rt.jar</code>中<strong>一部分类</strong>，其余的类是JDK内部私有的类，可能在之后的版本变动，因此没有开放出来。</p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/sym文件解压.png" style="zoom:50%;">

<p>解决方式：</p>
<ol>
<li>指定<code>-bootclasspath $JAVA_HOME/jre/lib/rt.jar</code></li>
<li>添加参数<code>-XDignore.symbol.file</code>忽略<code>ct.sym</code>文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -verbose -bootclasspath <span class="string">&quot;<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar&quot;</span> TestSun.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac -verbose -XDignore.symbol.file TestSun.java</span></span><br><span class="line">[解析开始时间 RegularFileObject[TestSun.java]]</span><br><span class="line">[解析已完成, 用时 14 毫秒]</span><br><span class="line">[源文件的搜索路径: .]</span><br><span class="line">[类文件的搜索路径: $JAVA_HOME/jre/lib/resources.jar,$JAVA_HOME/jre/lib/rt.jar,$JAVA_HOME/jre/lib/sunrsasign.jar,$JAVA_HOME/jre/lib/jsse.jar,$JAVA_HOME/jre/lib/jce.jar,$JAVA_HOME/jre/lib/charsets.jar,$JAVA_HOME/jre/lib/jfr.jar,$JAVA_HOME/jre/classes,$JAVA_HOME/jre/lib/ext/sunec.jar,$JAVA_HOME/jre/lib/ext/nashorn.jar,$JAVA_HOME/jre/lib/ext/cldrdata.jar,$JAVA_HOME/jre/lib/ext/dnsns.jar,$JAVA_HOME/jre/lib/ext/localedata.jar,$JAVA_HOME/jre/lib/ext/sunjce_provider.jar,$JAVA_HOME/jre/lib/ext/sunpkcs11.jar,$JAVA_HOME/jre/lib/ext/jaccess.jar,$JAVA_HOME/jre/lib/ext/zipfs.jar,.]</span><br><span class="line">[正在加载ZipFileIndexFileObject[$JAVA_HOME/jre/lib/rt.jar(sun/net/sdp/SdpSupport.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[$JAVA_HOME/jre/lib/rt.jar(java/lang/Object.class)]]</span><br><span class="line">[正在检查TestSun]</span><br><span class="line">[正在加载ZipFileIndexFileObject[$JAVA_HOME/jre/lib/rt.jar(java/io/Serializable.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[$JAVA_HOME/jre/lib/rt.jar(java/lang/AutoCloseable.class)]]</span><br><span class="line">[已写入RegularFileObject[TestSun.class]]</span><br><span class="line">[共 228 毫秒]</span><br></pre></td></tr></table></figure>

<h1 id="exe打包"><a href="#exe打包" class="headerlink" title="exe打包"></a>exe打包</h1><p><a href="https://www.ej-technologies.com/download/exe4j/files">exe4j</a>：将jar打包成exe可执行程序</p>
<p>简单介绍几个关键步骤，其余步骤按照提示配置即可。</p>
<p>首先输入License，否则执行exe文件会提示警告</p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/exe4j-1.png" style="zoom:70%;">

<p>选择jar模式</p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/exe4j-2.png" style="zoom:70%;">

<p>添加jar文件</p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/exe4j-5.png" style="zoom:70%;">

<h1 id="修改字节码"><a href="#修改字节码" class="headerlink" title="修改字节码"></a>修改字节码</h1><p>上述示例中，src目录中是一个简单的Java Swing程序。</p>
<p>编译src目录<code>javac -d build src/**/*.java</code></p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/GUI示例程序.png" style="zoom:90%;">

<p>运行<code>java com.afauria.Main</code>，效果如下</p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/运行GUI程序.png" style="zoom:70%;">

<p>现在我们需要想办法点击登录，让程序验证成功。首先分析代码，找到切入点，可以看到checkLogin中校验输入为123。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setBounds(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        JButton loginBtn = <span class="keyword">new</span> JButton(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">        JTextField codeField = <span class="keyword">new</span> JTextField();</span><br><span class="line">        codeField.setBounds(<span class="number">20</span>, <span class="number">20</span>, <span class="number">160</span>, <span class="number">40</span>);</span><br><span class="line">        loginBtn.setBounds(<span class="number">20</span>, <span class="number">60</span>, <span class="number">160</span>, <span class="number">40</span>);</span><br><span class="line">        JPanel pane = <span class="keyword">new</span> JPanel();</span><br><span class="line">        setContentPane(pane);</span><br><span class="line">        pane.setLayout(<span class="keyword">null</span>);</span><br><span class="line">        pane.add(codeField);</span><br><span class="line">        pane.add(loginBtn);</span><br><span class="line">        loginBtn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (checkLogin(codeField.getText())) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(MainFrame.<span class="keyword">this</span>, <span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(MainFrame.<span class="keyword">this</span>, <span class="string">&quot;登录失败！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkLogin</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>.equals(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用jbe工具，打开class文件，如下图，将字节码修改为<code>iconst_1</code>并保存方法。意思是加载常量1到操作数栈。</p>
<blockquote>
<p>boolean类型在单独使用时会转为int，占4个字节，在数组中占1个字节。</p>
</blockquote>
<p>重新运行之后不管输入什么都会提示“登录成功”。</p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/修改字节码.png" style="zoom:70%;">

<p>字节码指令集可以参考：<a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">字节码指令集：Wiki百科</a></p>
<p><strong>也可以自行编写Java源代码，编译成class文件之后，再使用javap工具查看字节码指令</strong>。</p>
<img src="/2022/04/14/note-2022-04-14-Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/javap查看字节码.png" style="zoom:70%;">

<h1 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h1><ul>
<li>javap：类文件解析器，<code>javap -c -v Test</code><ul>
<li><code>-c</code>：对代码进行反汇编，查看汇编格式的代码</li>
<li><code>-v</code>：可以查看附加信息，例如常量池等</li>
<li><code>-s</code>：输出方法内部类型签名</li>
<li><code>-p</code>或<code>-private</code>：查看私有方法</li>
</ul>
</li>
<li>javadoc：Java API文档生成器</li>
<li><a href="http://java-decompiler.github.io/">jd-gui</a>：反编译jar包或class文件查看源码</li>
<li><a href="http://set.ee/jbe/">jbe</a>：字节码编辑器，用于查看和修改class字节码文件</li>
<li><a href="https://github.com/skylot/jadx">jadx</a>：反编译jar、dex、aar、aab、apk、资源等，可视化操作界面。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Yocto嵌入式平台运行Flutter应用</title>
    <url>/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol>
<li><p>使用Yocto编译嵌入式Linux系统，原厂提供系统代码，内置支持Wayland协议</p>
</li>
<li><p>使用<a href="https://github.com/rdkcmf/westeros">westeros</a>作为Wayland Compositor，由<a href="https://rdkcentral.com/">RDK（Reference Design Kit）</a>提供</p>
</li>
<li><p>使用丰田开发的<a href="https://github.com/toyota-connected/ivi-homescreen">ivi-homescreen</a>作为Flutter嵌入层，基于Waylannd+EGL</p>
<blockquote>
<p>RDK（Reference Design Kit）是管理嵌入式应用参考设计套件的开源联盟</p>
</blockquote>
</li>
</ol>
<h1 id="Yocto介绍"><a href="#Yocto介绍" class="headerlink" title="Yocto介绍"></a>Yocto介绍</h1><p>Yocto是一个开源项目，用于构建嵌入式Linux系统。类似于<a href="https://buildroot.org/">BuildRoot</a>（基于Makefile和Kconfig配置）</p>
<p>关键概念：</p>
<ul>
<li>Poky：指整个构建系统，包括BitBake工具、编译工具链、BSP，以及诸多程序包和层</li>
<li>Metadata：元数据集<ul>
<li>Recipes：<code>.bb/.bbappend</code>配方文件，配置源码下载路径、如何编译等。一个配方（Recipe）可以包含多个软件包（Package）</li>
<li>Class：<code>.bbclass</code>文件，抽象的公共代码，给各个package使用</li>
<li>Configuration：<code>.conf</code>配置文件，构建配置</li>
</ul>
</li>
<li>Layers：即各种<code>meta-xxx</code>目录，包含Metadata的存储库，可以单独发布、下载，便于项目维护，例如<code>meta-flutter</code>、<code>meta-clang</code>等。<a href="https://layers.openembedded.org/layerindex/branch/krogoth/layers/">官方支持的层级包和配方文件</a></li>
<li>BitBake：任务执行引擎，解析Metadata，执行软件包的Task</li>
</ul>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/Poky架构.png" style="zoom:67%;">

<p>在Yocto环境中构建Flutter：依赖<a href="https://github.com/meta-flutter/meta-flutter">meta-flutter</a>项目，包含devtools工具项目、Flutter引擎项目、Flutter应用案例项目，以及各种定制嵌入层（sony、toyota、树莓派等）项目等，通过BitBake统一构建</p>
<p>对于Yocto，个人理解是类似于AOSP项目：</p>
<ul>
<li>Yocto使用Bitbake工具执行构建任务，AOSP使用make或者ninja构建</li>
<li>Yocto的<code>.bb/.bbappend</code>配方文件和<code>.conf</code>配置文件，类似于AOSP的<code>.mk/.bp</code>配置文件</li>
<li>Yocto项目只包含构建Metadata，代码从网上下载，AOSP需要下载所有代码进行编译。</li>
</ul>
<p>Yocto的发行版：zeus（3.0）、dunfell（3.1）、gatesgarth（3.2）、hardknott（3.3）、honister（3.4）</p>
<h2 id="Yocto目录结构说明"><a href="#Yocto目录结构说明" class="headerlink" title="Yocto目录结构说明"></a>Yocto目录结构说明</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── buildhistory</span><br><span class="line">│   ├── cache</span><br><span class="line">│   ├── conf</span><br><span class="line">│   │   ├── local.conf # 定制化配置文件，变量定义</span><br><span class="line">│   │   ├── bblayers.conf # bblayers决定哪些模块被编译</span><br><span class="line">│   └── tmp # 构建的输出目录</span><br><span class="line">├── downloads # build/downloads：构建过程中下载的所有源码，放到公共目录下，提高每次的编译效率</span><br><span class="line">├── sstate-cache # build/sstate-cache：构建状态缓存，放到公共目录下，提高每次的编译效率</span><br><span class="line">├── meta-clang</span><br><span class="line">├── meta-flutter # 自己添加的Metadata项目</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── recipes-devtools</span><br><span class="line">│   ├── recipes-graphics</span><br><span class="line">│   └── recipes-support</span><br><span class="line">├── meta-meson</span><br><span class="line">├── meta-openembedded</span><br><span class="line">├── meta-python2</span><br><span class="line">├── meta-thunder</span><br><span class="line">└── poky # Poky工程通用目录结构，顶级目录$&#123;TOPDIR&#125;</span><br><span class="line">    ├── bitbake # bitbake工具目录，解析Metadata、recipes、config，执行task</span><br><span class="line">    ├── contrib</span><br><span class="line">    ├── documentation</span><br><span class="line">    ├── meta # OE Core（Open Embedded）的Metadata，包括recipes、common、classes等</span><br><span class="line">    ├── meta-poky # poky发行版配置数据</span><br><span class="line">    ├── meta-selftest # OE自测的recipes和append文件</span><br><span class="line">    ├── meta-skeleton # BSP和Kernel开发用的临时recipes</span><br><span class="line">    ├── meta-yocto-bsp # 参考的BSP配置，厂商可以增加自己的bsp目录</span><br><span class="line">    ├── scripts # 脚本文件</span><br><span class="line">    └── oe-init-build-env  # 脚本文件，构建OE环境</span><br></pre></td></tr></table></figure>

<p><code>build/tmp</code>目录说明：构建的输出目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└── build</span><br><span class="line">    └── tmp # 构建的输出目录</span><br><span class="line">        ├── deploy # 最终部署需要的文件</span><br><span class="line">        │   ├── deb # deb类型的安装包</span><br><span class="line">        │   ├── ipk # ipk类型的安装包</span><br><span class="line">        │   ├── rpm # rpm类型的安装包</span><br><span class="line">        │   ├── licenses # 各种软件的许可信息</span><br><span class="line">        │   ├── images # image、rootfs（根文件系统）、boot等文件</span><br><span class="line">        │   ├── sdk # 工具链安装脚本</span><br><span class="line">        ├── work # 包含所有软件包的工作目录，根据CPU架构、厂商等分为多个子目录</span><br><span class="line">        ├── work-share # 工作信息缓存，提高效率</span><br><span class="line">        ├── sysroots-component # 制作sysroots前需要添加的组件</span><br><span class="line">        ├── sysroots # 构建出的sysroots</span><br><span class="line">        ├── log # 日志信息</span><br><span class="line">        ├── cache # Bitbake缓存解析结果，提高后续编译效率</span><br><span class="line">        ├── buildstats # 构建信息统计，每次构建都会生成一个日期目录</span><br><span class="line">        └── stamps # 记录Bitbake跟踪task执行时间信息</span><br></pre></td></tr></table></figure>

<p><code>poky/meta/</code>目录说明：OE Core构建配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└── poky # Poky工程通用目录结构</span><br><span class="line">    └── meta # OE Core（Open Embedded）的Metadata，包括recipes、common、classes等</span><br><span class="line">        ├── classes # 包含所有的.bbclass</span><br><span class="line">        ├── conf # 配置文件</span><br><span class="line">        ├── files # 包含license文件和系统构建的一些文件</span><br><span class="line">        ├── lib # 构建需要的python库文件</span><br><span class="line">        ├── recipes-bsp # uboot等硬件相关的配方</span><br><span class="line">        ├── recipes-connectivity # 和其他设备通信相关的库和应用，例如ssh</span><br><span class="line">        ├── recipes-core # 构建基本的Linux image所需的依赖</span><br><span class="line">        ├── recipes-devtools # 构建时需要的开发工具，在目标平台也能使用</span><br><span class="line">        ├── recipes-extended # 扩展的应用，例如wget、tar、zip、grep、which等</span><br><span class="line">        ├── recipes-gnome # GTK+框架相关的应用</span><br><span class="line">        ├── recipes-graphics # 绘图相关的库，例如vulkan、cairo、wayland、xorg、drm等</span><br><span class="line">        ├── recipes-kernel # Kernel以及内核依赖的库</span><br><span class="line">        ├── recipes-lsb # LSB（Linux Standard Base）需要的</span><br><span class="line">        ├── recipes-multimedia # 多媒体（图片、声音、视频）支持，例如ffmpeg、webp、libpng等</span><br><span class="line">        ├── recipes-support # 通用的recipes</span><br><span class="line">        ├── recipes-rt # PREEMPT_RT需要的包和recipes</span><br><span class="line">        ├── recipes-sato # Sato Demo</span><br><span class="line">        ├── recipes.txt # recpies目录说明文件</span><br><span class="line">        └── site  # 不同架构下的缓存结果</span><br></pre></td></tr></table></figure>

<h2 id="local-conf配置"><a href="#local-conf配置" class="headerlink" title="local.conf配置"></a>local.conf配置</h2><p>保存通用配置、全局变量等。</p>
<ul>
<li>配置downloads目录：<code>DL_DIR ?= &quot;$&#123;TOPDIR&#125;/../downloads&quot;</code></li>
<li>配置使用的包管理器：<code>PACKAGE_CLASSES ?= &quot;package_ipk/package_rpm/package_deb&quot;</code></li>
<li>镜像中安装软件：IMAGE_INSTALL_append = “ openjdk-8”</li>
<li>排除软件：PACKAGE_EXCLUDE = “ openjdk-8”</li>
</ul>
<h2 id="Bitbake笔记"><a href="#Bitbake笔记" class="headerlink" title="Bitbake笔记"></a>Bitbake笔记</h2><p><code>bitbake [options] [recipename/target recipe:do_task ...]</code></p>
<p><code>bitbake -s</code>：列出可用的recipes。</p>
<blockquote>
<p>原理：解析<code>bblayers.conf</code>中配置的Layer路径，从Layer中找到bb文件，解析出需要编译的recipe。</p>
<p>可以修改<code>bblayers.conf</code>文件，添加或移除模块。也可以使用以下命令</p>
<p><code>bitbake-layers show-layers/add-layer/remove-layer</code>：查看/添加/移除可用的Layers</p>
</blockquote>
<p><code>bitbake -g lib32-amlogic-yocto &amp;&amp; cat pn-buildlist | grep -ve &quot;native&quot; | sort | uniq</code>：查看镜像包依赖信息。</p>
<blockquote>
<p><code>-g</code>保存依赖信息到<code>pn-buildlist</code>文件中</p>
</blockquote>
<p><code>bitbake -e &lt;recipe&gt; | grep ^S=</code>：查看Package编译工作目录</p>
<p><code>bitbake -e lib32-flutter-sdk | grep ^SRC_URI=</code>：查看软件源码下载路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 32位工作目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bitbake -e lib32-flutter-sdk | grep ^S=</span></span><br><span class="line">S=&quot;/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-sdk/git-r0/git&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 64位工作目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bitbake -e flutter-sdk | grep ^S=</span></span><br><span class="line">S=&quot;/home/code/build/tmp/work/aarch64-poky-linux/flutter-sdk/git-r0/git&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 软件源码下载路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bitbake -e lib32-flutter-sdk |grep ^SRC_URI=</span></span><br><span class="line">SRC_URI=&quot;git://github.com/flutter/flutter.git;protocol=https;nobranch=1&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bitbake下载软件源码失败：可以手动下载到本地，切到期望的分支和commit，修改对应的<code>.bb</code>文件，将远程Git仓库改为本地路径。</p>
</blockquote>
<p>每个软件包都有自己的工作目录，包括源码、编译配置、编译输出、交叉编译需要的目标平台sysroot等。</p>
<p>其中temp临时目录中包含软件的Task脚本（例如<code>run.do_compile</code>、<code>run.do_fetch</code>等），Task执行log（例如<code>log.do_fetch</code>、<code>log.do_compile</code>）等。</p>
<blockquote>
<p><strong>注：可以在temp目录下查看和修改Task脚本，分析软件编译过程，手动执行编译命令。</strong></p>
</blockquote>
<p>不同的Package有不同的Task，Yocto有一些通用的Task，例如fetch、clean、build、listtasks等。</p>
<ul>
<li><code>bitbake &lt;recipe&gt; -c &lt;CMD&gt;</code>：执行特定Task。默认执行build任务。例如<code>bitbake lib32-flutter-engine-release -c clean</code></li>
<li><code>bitbake &lt;recipe&gt; -c listtasks</code>：查看软件包可执行的Task。</li>
</ul>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/Bitbake查看Task.png" style="zoom:100%;">

<h2 id="分析flutter-engine构建过程"><a href="#分析flutter-engine构建过程" class="headerlink" title="分析flutter-engine构建过程"></a>分析flutter-engine构建过程</h2><p>查看软件工作目录<code>temp</code>文件夹，分析Task脚本大致过程</p>
<ol>
<li><code>do_fetch</code>：根据<code>meta-flutter</code>中的配方文件下载Flutter引擎源代码</li>
<li><code>do_unpack</code>：将源码解包到工作目录</li>
<li><code>do_patch</code>：打补丁，修改Flutter引擎源代码，主要是修改引擎编译配置，<code>meta-flutter/recipes-graphics/flutter-engine/files</code></li>
<li><code>do_prepare_recipe_sysroot</code>：在workdir目录下创建两个sysroot(recipe-sysroot和recipe-sysroot-native)</li>
<li><code>do_configure</code>：执行gn命令生成构建配置</li>
<li><code>do_compile</code>：执行ninja编译</li>
<li><code>do_install</code>：将Flutter引擎产物拷贝到等候区，一般位于<code>$&#123;WORKDIR&#125;/image</code>目录下，使用<code>$&#123;D&#125;</code>表示</li>
<li><code>do_package</code>：根据需要打包生成package</li>
<li><code>do_package_write_ipk</code>：打包ipk</li>
<li>…</li>
</ol>
<blockquote>
<ul>
<li><code>$&#123;WORKDIR&#125;</code>：软件构建工作目录</li>
<li><code>$&#123;D&#125;</code>：<code>$&#123;WORKDIR&#125;/image</code></li>
<li><code>$&#123;PN&#125;</code>表示PackageName，例如<code>lib32-flutter-engine-release</code></li>
</ul>
</blockquote>
<p>do_package相关：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pkgdata只存放了包路径信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一般包括<span class="variable">$PN</span>-src、<span class="variable">$PN</span>-dbg、<span class="variable">$PN</span>-dev、<span class="variable">$PN</span>-staticdev、<span class="variable">$PN</span>-doc、<span class="variable">$PN</span>-locale、<span class="variable">$PN</span></span></span><br><span class="line"><span class="meta">lib32-flutter-engine-release/git-r0/$</span><span class="bash">cat pkgdata/lib32-flutter-engine-release</span></span><br><span class="line">PACKAGES: lib32-flutter-engine-release-src lib32-flutter-engine-release-dbg lib32-flutter-engine-release-sdk-dev lib32-flutter-engine-release-staticdev lib32-flutter-engine-release-dev lib32-flutter-engine-release-doc lib32-flutter-engine-release-locale lib32-flutter-engine-release</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 实际对应packages-split中的目录</span></span><br><span class="line"><span class="meta">lib32-flutter-engine-release/git-r0/$</span><span class="bash">ls -l packages-split</span></span><br><span class="line">drwxr-xr-x 3 builder builder 4096 Mar  9 19:47 lib32-flutter-engine-release</span><br><span class="line">drwxr-xr-x 3 builder builder 4096 Mar  9 19:47 lib32-flutter-engine-release-dbg</span><br><span class="line">drwxr-xr-x 3 builder builder 4096 Mar  9 19:47 lib32-flutter-engine-release-dev</span><br><span class="line">drwxr-xr-x 2 builder builder 4096 Mar  9 19:47 lib32-flutter-engine-release-doc</span><br><span class="line">drwxr-xr-x 2 builder builder 4096 Mar  9 19:47 lib32-flutter-engine-release-locale</span><br><span class="line">drwxr-xr-x 3 builder builder 4096 Mar  9 19:47 lib32-flutter-engine-release-sdk-dev</span><br><span class="line">-rw-r--r-- 1 builder builder   38 Mar  9 19:47 lib32-flutter-engine-release.shlibdeps</span><br><span class="line">drwxr-xr-x 3 builder builder 4096 Mar  9 19:47 lib32-flutter-engine-release-src</span><br><span class="line">drwxr-xr-x 2 builder builder 4096 Mar  9 19:47 lib32-flutter-engine-release-staticdev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后会合并到package中</span></span><br><span class="line"><span class="meta">lib32-flutter-engine-release/git-r0/$</span><span class="bash">ls -l package</span></span><br><span class="line">drwxr-xr-x 6 builder builder 4096 Mar  9 19:47 usr</span><br></pre></td></tr></table></figure>

<h1 id="Yocto编译Linux系统"><a href="#Yocto编译Linux系统" class="headerlink" title="Yocto编译Linux系统"></a>Yocto编译Linux系统</h1><h2 id="原始系统"><a href="#原始系统" class="headerlink" title="原始系统"></a>原始系统</h2><p>公司服务器已经搭建好了编译的Docker环境，并且提供了编译的脚本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ssh登录服务器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取系统源码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo init -u <span class="string">&quot;ssh://<span class="variable">$USER</span>@tvgit.gz.xxx.cn:29418/AMLT950D4_Linux/source/repo_manifest&quot;</span> -b dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;代码根目录&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入Docker容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker_aml_u16_build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> OPENLINUX_BUILD=1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量等，重复设置会导致local.conf增加很多重复的变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> meta-meson/aml-setenv.sh mesont5d-lib32-am301</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 整包编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bitbake lib32-amlogic-yocto</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成的镜像位置：code/build/tmp/deploy/images/mesont5d-lib32-am301/aml_upgrade_package.img</span></span><br></pre></td></tr></table></figure>

<h2 id="加入meta-flutter"><a href="#加入meta-flutter" class="headerlink" title="加入meta-flutter"></a>加入meta-flutter</h2><p><a href="https://github.com/meta-flutter/meta-flutter">meta-flutter</a>是Yocto Layer，用于Yocto编译。recipes包括：</p>
<ul>
<li><a href="https://github.com/flutter/flutter">flutter-sdk</a>：默认使用最新版，通过<code>FLUTTER_SDK_TAG</code>变量设置版本</li>
<li><a href="https://github.com/flutter/engine">flutter-engine</a>：默认使用和Flutter SDK对应的版本</li>
<li><a href="https://github.com/flutter/gallery">flutter-gallery</a>：Sample应用</li>
<li><a href="https://github.com/toyota-connected/ivi-homescreen">ivi-homescreen</a>：Toyota/AGL - Wayland嵌入层</li>
<li><a href="https://github.com/ardera/flutter-pi">flutter-pi</a>：树莓派DRM嵌入层</li>
<li><a href="https://github.com/sony/flutter-embedded-linux">sony</a>：Sony嵌入层flutter-eLinux</li>
<li><a href="https://github.com/jwinarske/flutter_wayland">flutter-wayland</a>、<a href="https://github.com/NilsBrause/waylandpp">waylandpp</a>：基于Wayland的嵌入层，类似ivi-homescreen。最新的meta-flutter已经去除</li>
</ul>
<p>步骤如下：</p>
<ol>
<li>下载<code>meta-flutter</code>到源码根目录：<code>git clone https://github.com/meta-flutter/meta-flutter.git</code></li>
<li>下载<code>meta-clang</code>到源码根目录：<code>git clone https://github.com/kraj/meta-clang.git</code></li>
<li><code>meta-clang</code>和<code>meta-flutter</code>切换到dunfell分支：<code>git checkout -b dunfell origin/dunfell</code></li>
<li><code>bblayers.conf</code>中配置Layer路径，或者执行<code>bitbake-layers add-layer /home/code/meta-clang</code>、<code>bitbake-layers add-layer /home/code/meta-flutter</code></li>
<li>设置Flutter SDK版本：<code>local.conf</code>中添加变量<code>FLUTTER_SDK_TAG = &quot;2.8.1&quot;</code></li>
</ol>
<h3 id="整包编译"><a href="#整包编译" class="headerlink" title="整包编译"></a>整包编译</h3><ol>
<li>整包编译时安装软件包：<code>local.conf</code>中添加变量<code>IMAGE_INSTALL_append = &quot; lib32-flutter-engine-release lib32-ivi-homescreen-release lib32-flutter-gallery-release&quot;</code>（注意开头有空格）</li>
<li>整包编译：<code>bitbake lib32-amlogic-yocto</code></li>
</ol>
<h3 id="局部编译"><a href="#局部编译" class="headerlink" title="局部编译"></a>局部编译</h3><p>局部编译<code>ivi-homescreen</code>和<code>flutter-engine</code>，再将生成的库手动push到系统中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitbake lib32-ivi-homescreen-release</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bitbake lib32-flutter-engine-release</span></span><br></pre></td></tr></table></figure>

<p><code>ivi-homescreen</code>运行只需要几个关键的库，这里收集起来放到一起，避免去构建目录中查找</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">aml_armv7at2hf_yocto$</span><span class="bash"> tree</span></span><br><span class="line">├── aml_upgrade_package.img # 系统软件包</span><br><span class="line">├── sdk # Flutter引擎编译生成，由engine_sdk.zip解压而来</span><br><span class="line">│   ├── clang_x64</span><br><span class="line">│   │   └── gen_snapshot # Flutter引擎编译生成的后端编译器</span><br><span class="line">│   ├── engine.version</span><br><span class="line">│   ├── platform_strong.dill</span><br><span class="line">│   ├── platform_strong.dill.d</span><br><span class="line">│   └── vm_outline_strong.dill</span><br><span class="line">└── usr</span><br><span class="line">    ├── bin</span><br><span class="line">    │   └── homescreen # ivi-homescreen嵌入层程序入口</span><br><span class="line">    ├── lib # ivi-homescreen需要的链接库</span><br><span class="line">    │   ├── libc++.so.1 # llvm编译生成</span><br><span class="line">    │   ├── libc++abi.so.1 # llvm编译生成</span><br><span class="line">    │   └── libflutter_engine.so # Flutter引擎编译生成</span><br><span class="line">    └── share</span><br><span class="line">        ├── flutter</span><br><span class="line">        │   ├── engine_sdk.zip</span><br><span class="line">        │   └── icudtl.dat # Flutter运行需要的国际化数据文件</span><br><span class="line">        └── homescreen # Flutter Samples编译产物，包括flutter_assets和libapp.so</span><br><span class="line">            ├── image_list</span><br><span class="line">            ├── particle_background</span><br><span class="line">            ├── platform_view</span><br><span class="line">            └── testing_app</span><br></pre></td></tr></table></figure>

<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="gn不支持-no-build-embedder-examples参数"><a href="#gn不支持-no-build-embedder-examples参数" class="headerlink" title="gn不支持--no-build-embedder-examples参数"></a>gn不支持<code>--no-build-embedder-examples</code>参数</h3><p><code>bitbake lib32-flutter-engine-release -v</code>构建失败，提示gn不支持<code>--no-build-embedder-examples</code>参数</p>
<blockquote>
<p>原因：Flutter引擎版本问题</p>
<p>分析：默认的PACKAGECONFIG包含<code>disable-embedder-examples</code>，导致gn命令会添加<code>--no-build-embedder-examples</code>选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> meta-flutter/recipes-graphics/flutter-engine/flutter-engine.inc</span></span><br><span class="line">PACKAGECONFIG ??= &quot;disable-desktop-embeddings \</span><br><span class="line">                   disable-embedder-examples \</span><br><span class="line">                   embedder-for-target \</span><br><span class="line">                   fontconfig \</span><br><span class="line">                   $&#123;FLUTTER_RUNTIME&#125; \</span><br><span class="line">                  &quot;</span><br><span class="line">PACKAGECONFIG[disable-desktop-embeddings] = &quot;--disable-desktop-embeddings&quot;</span><br><span class="line">PACKAGECONFIG[disable-embedder-examples] = &quot;--no-build-embedder-examples&quot;</span><br></pre></td></tr></table></figure>

<p>解决：<code>local.conf</code>中添加如下变量，去掉<code>disable-embedder-examples</code>，覆盖默认的PACKAGECONFIG</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PACKAGECONFIG_pn-flutter-engine-release = &quot;disable-desktop-embeddings embedder-for-target fontconfig release&quot;</span><br><span class="line">PACKAGECONFIG_pn-flutter-engine-debug = &quot;disable-desktop-embeddings embedder-for-target fontconfig debug&quot;</span><br><span class="line">PACKAGECONFIG_pn-flutter-engine-profile = &quot;disable-desktop-embeddings embedder-for-target fontconfig profile&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="无法编译Dart-SDK"><a href="#无法编译Dart-SDK" class="headerlink" title="无法编译Dart SDK"></a>无法编译Dart SDK</h3><p><code>bitbake lib32-flutter-engine-release -v</code>构建失败，报错如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Command failed: /home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/out/linux_release_arm/clang_x64/dart </span><br><span class="line">--disable-dart-dev --deterministic </span><br><span class="line">--packages=/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/flutter/flutter_frontend_server/.dart_tool/package_config.json </span><br><span class="line">--snapshot=/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/out/linux_release_arm/gen/frontend_server.dart.snapshot </span><br><span class="line">--snapshot-depfile=/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/out/linux_release_arm/gen/frontend_server.dart.snapshot.d </span><br><span class="line">--depfile-output-filename=gen/frontend_server.dart.snapshot </span><br><span class="line">--snapshot-kind=kernel /home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/flutter/flutter_frontend_server/bin/starter.dart </span><br><span class="line">--train </span><br><span class="line">--sdk-root=/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/out/linux_release_arm/flutter_patched_sdk </span><br><span class="line">/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/flutter/flutter_frontend_server/bin/starter.dart</span><br><span class="line">output:</span><br><span class="line">===== CRASH =====</span><br><span class="line">si_signo=Segmentation fault(11), si_code=1, si_addr=0x7f3b9f7dd1fc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：编译的ARM架构的<code>out/linux_release_arm/clang_x64/dart</code>程序无法执行。导致生成Kernel快照失败，例如<code>frontend_server.dart.snapshot</code>、<code>analysis_server.dart.snapshot</code>、<code>dartdoc.dart.snapshot</code>等</p>
<p><code>bitbake flutter-engine-release</code>编译正常：ARM64架构的dart程序可以正常执行。</p>
<p>分析：其实引擎编译的关键产物只有<code>gen_snapshot、libflutter_engine.so</code>。生成的Dart程序是平台无关的，直接用Flutter SDK中现成的即可，没必要编译Dart SDK。</p>
<p>解决：只要跳过Dart SDK编译即可，<strong>修改<code>src/flutter/BUILD.gn</code>文件，将<code>_build_engine_artifacts</code>改为false</strong></p>
<p>旧版本<code>meta-flutter</code>还需要修改<code>flutter-engine.bb</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> meta-flutter/recipes-graphics/flutter-engine/flutter-engine.bb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删掉full-dart-sdk</span></span><br><span class="line">PACKAGECONFIG ?= &quot;disable-desktop-embeddings \</span><br><span class="line">                   embedder-for-target \</span><br><span class="line">                   fontconfig \</span><br><span class="line">                   full-dart-sdk \</span><br><span class="line">                   mode-release \</span><br><span class="line">                  &quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删掉下面一行：将编译好的dart前端安装到image中。</span></span><br><span class="line">install -m 644 $&#123;S&#125;/$&#123;OUT_DIR_REL&#125;/dart-sdk/bin/snapshots/frontend_server.dart.snapshot  $&#123;D&#125;/$&#123;datadir&#125;/flutter/sdk/</span><br></pre></td></tr></table></figure>

<p>新版本<code>meta-flutter</code>配置改为了<code>flutter-engine.inc</code>文件：</p>
<ol>
<li>去除掉了上面的两个配置：高版本Dart虚拟机不再接收Dart源文件，只接收Kernel代码，将编译前后端分离。因此直接在主机编译Kernel即可，没必要安装编译前端。</li>
<li>gn命令默认加了<code>--no-stripped</code>选项，可以去掉</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> meta-flutter/recipes-graphics/flutter-engine/flutter-engine.inc</span></span><br><span class="line">GN_ARGS = &quot;$&#123;PACKAGECONFIG_CONFARGS&#125; --clang --lto --no-goma --no-stripped &quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="整包编译空间不足"><a href="#整包编译空间不足" class="headerlink" title="整包编译空间不足"></a>整包编译空间不足</h3><p>根据文档预装软件到系统中：<code>IMAGE_INSTALL_append = &quot; lib32-flutter-engine-release lib32-ivi-homescreen-release lib32-flutter-gallery-release&quot;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 整包编译报错</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bitbake lib32-amlogic-yocto</span></span><br><span class="line">The initramfs size xxx exceeds INITRAMFS_MAXSIZE: 131072</span><br><span class="line">You can set INITRAMFS_MAXSIZE a larger value. Usually, it should</span><br><span class="line">be less than 1/2 of ram size, or you may fail to boot it.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 全局搜索，默认值是128M</span></span><br><span class="line"><span class="meta">/home/code/poky$</span><span class="bash">grep -inR <span class="string">&quot;INITRAMFS_MAXSIZE&quot;</span> *</span></span><br><span class="line">meta/conf/bitbake.conf:789:INITRAMFS_MAXSIZE ??= &quot;131072&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决：只保留homescreen编译成功，<code>IMAGE_INSTALL_append = &quot; lib32-ivi-homescreen-release&quot;</code></p>
<p>homescreen依赖flutter-engine，因此引擎也会被打包进去。升级软件之后可以直接运行homescreen</p>
</blockquote>
<h1 id="10月12日补充问题"><a href="#10月12日补充问题" class="headerlink" title="10月12日补充问题"></a>10月12日补充问题</h1><p>上面配置的flutter引擎版本是2.8.1，时隔几个月之后，Google关掉了部分三方库的服务，迁移了地址，导致其他人用2.8.1版本，出现很多新问题，例如gclient同步依赖库失败。</p>
<p><strong>建议：更新Flutter引擎版本，重新调试环境</strong>。下面介绍下使用2.8.1版本遇到的问题</p>
<h2 id="Pseudo-Abort"><a href="#Pseudo-Abort" class="headerlink" title="Pseudo Abort"></a>Pseudo Abort</h2><p>编译过程中遇到Pseudo Abort问题。参考Wiki说明，是由于“路径不匹配”。</p>
<p>解决方法：<code>bitbake lib32-glib-2.0 -c clean</code>，清除然后重新构建对应的库</p>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/pseudoabort问题.png" style="zoom:100%;">

<h2 id="liberror库编译失败"><a href="#liberror库编译失败" class="headerlink" title="liberror库编译失败"></a>liberror库编译失败</h2><p>原因未知，<code>bitbake lliberrror-perl -c clean</code>之后再次编译即可</p>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/liberror.png" style="zoom:100%;">

<h2 id="libcxx-not-found"><a href="#libcxx-not-found" class="headerlink" title="libcxx not found"></a>libcxx not found</h2><p>编译flutter引擎<code>bitbake lib32-flutter-engine-release</code>出错，执行do_patch脚本的时候提示<code>libcxx not found</code></p>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/libcxxnotfound.png" style="zoom:100%;">

<p>分析：查看DEPS文件，libcxx在<code>https://fuchisa.googlesource.com</code>中，访问该地址，发现libcxx已经被移除</p>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/libcxx旧地址.png" style="zoom:100%;">

<p>查看新版本引擎代码，已经迁移到了llvm项目地址中</p>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/libcxx新地址.png" style="zoom:100%;">

<p>临时解决：直接将之前构建好的libcxx拷贝给其他人使用，在<code>src/thirdtparty</code>目录</p>
<h2 id="linter找不到远程引用"><a href="#linter找不到远程引用" class="headerlink" title="linter找不到远程引用"></a>linter找不到远程引用</h2><p>修复libcxx之后，do_patch脚本又出现linter找不到远程HEAD问题。原因未知，仓库地址还是可以访问的。</p>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/linterpatch失败.png" style="zoom:100%;">

<p>分析do_patch脚本，找到出问题的命令：<code>gclient sync --shallow --no-history -R -D --revision &quot;890a5fca2e34db413be624fc83aeea8e61d42ce6&quot; -j 48</code></p>
<blockquote>
<p>890a5fca2e34db413be624fc83aeea8e61d42ce6即我们指定的2.8.1的版本</p>
</blockquote>
<p>解决：</p>
<ol>
<li>先注释掉DEPS中linter的依赖库，版本是1.14.0，跳过下载</li>
</ol>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/跳过linter依赖.png" style="zoom:100%;">

<ol start="2">
<li>再手动执行<code>gclient sync</code>，下载其他的依赖库。注意不要指定<code>--revision</code>，否则会还原掉DEPS的修改。</li>
<li>这个时候patch的动作已经差不多被我们手动执行完了，所以可以跳过<code>do_patch</code>的过程</li>
<li>修改<code>meta-flutter/recipes-graphics/flutter-engine/flutter-engine.inc</code>配置文件，如下</li>
</ol>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/跳过do_patch脚本.png" style="zoom:100%;">

<ol start="5">
<li>顺便注释掉git apply，否则会出现打补丁失败</li>
</ol>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/patchapply失败.png" style="zoom:100%;">

<h2 id="找不到linter库"><a href="#找不到linter库" class="headerlink" title="找不到linter库"></a>找不到linter库</h2><p>再次编译flutter引擎<code>bitbake lib32-flutter-engine-release</code>，提示找不到linter库</p>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/linternotfound.png" style="zoom:100%;">

<p>分析：由于上面我们注释掉了linter的依赖库和patch脚本，所以找不到。依赖的linter库的tag是1.14.0</p>
<p>解决：手动克隆linter库，切到对应tag1.14.0对应的commit id</p>
<img src="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/手动克隆linter.png" style="zoom:100%;">

<h1 id="Flutter-Linux-ARM应用编译"><a href="#Flutter-Linux-ARM应用编译" class="headerlink" title="Flutter Linux ARM应用编译"></a>Flutter Linux ARM应用编译</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 前端编译生成app.dill</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dart frontend_server.dart.snapshot \</span></span><br><span class="line"><span class="bash">--target=flutter \</span></span><br><span class="line"><span class="bash">--aot --tfa \</span></span><br><span class="line"><span class="bash">-Ddart.vm.profile=<span class="literal">false</span> -Ddart.vm.product=<span class="literal">true</span> \</span></span><br><span class="line"><span class="bash">--sdk-root flutter_patched_sdk \</span></span><br><span class="line"><span class="bash">--output-dill app.dill \</span></span><br><span class="line"><span class="bash">demo/lib/main.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后端编译生成libapp.so</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sdk/clang_x64/gen_snapshot \</span></span><br><span class="line"><span class="bash">--snapshot_kind=app-aot-elf \</span></span><br><span class="line"><span class="bash">--elf=libapp.so \</span></span><br><span class="line"><span class="bash">app.dill</span></span><br></pre></td></tr></table></figure>

<p>文件和路径说明：</p>
<ul>
<li><code>dart</code>：使用Flutter SDK自带的Dart。<strong>Flutter SDK版本要和Flutter引擎版本对应</strong><ul>
<li><code>flutter/bin/dart</code></li>
</ul>
</li>
<li><code>frontend_server.dart.snapshot</code>：使用Flutter SDK缓存的前端编译器，或者引擎编译生成的前端编译器<ul>
<li><code>flutter/bin/cache/artifacts/engine/linux-x64/frontend_server.dart.snapshot</code></li>
<li><code>out/linux_release_arm/frontend_server.dart.snapshot</code></li>
</ul>
</li>
<li><code>flutter_patched_sdk</code>：使用Flutter SDK缓存的文件，或者引擎编译生成的文件<ul>
<li><code>flutter/bin/cache/artifacts/engine/common/flutter_patched_sdk</code></li>
<li><code>out/linux_release_arm/flutter_patched_sdk</code></li>
</ul>
</li>
<li><code>gen_snapshot</code>：引擎编译生成的后端编译器，用于在Linux x86_64平台上交叉编译出ARM平台目标代码。<ul>
<li><code>out/linux_release_arm/clang_x64/gen_snapshot</code></li>
</ul>
</li>
</ul>
<h1 id="Flutter应用启动"><a href="#Flutter应用启动" class="headerlink" title="Flutter应用启动"></a>Flutter应用启动</h1><ol>
<li>升级软件开机</li>
<li>杀掉WPExxx的进程（有两个进程）</li>
<li><code>su</code>进入root，或者<code>export XDG_RUNTIME_DIR=/run</code></li>
<li><code>westeros-init &amp;</code>：启动westeros服务端</li>
<li><code>westeros_test</code>：启动westeros示例客户端，运行成功显示UI</li>
<li>将<code>aml_armv7at2hf_yocto</code>下的文件夹push到板卡对应路径下（整包编译不需要再push引擎和homescreen，只需要装入应用即可）</li>
<li><code>homescreen --a=/usr/share/homescreen/image_list/flutter_assets</code>：运行Flutter程序，提前编了4个sample</li>
</ol>
<blockquote>
<p><code>--a</code>指定应用路径，不指定的话默认会找<code>/usr/share/homescreen/bundle</code>目录。可以将应用路径链接到bundle目录，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/share/homescreen</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将程序链接到bundle</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -sf particle_background/ bundle</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> homescreen查找默认目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> homescreen</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>默认系统环境：AML 950D4 Linux平台，版本如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh-5.0# uname -a</span><br><span class="line">Linux mesont5d-lib32-am301 5.4.125-amlogic #1 SMP PREEMPT Fri Mar 4 18:02:24 CST 2022 aarch64</span><br><span class="line">sh-5.0# cat /proc/version</span><br><span class="line">Linux version 5.4.125-amlogic (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 9.3.0, GNU ld (GNU Binutils) 2.34.0.20200220) #1 SMP PREEMPT Fri Mar 4 18:02:24 CST 2022</span><br></pre></td></tr></table></figure>

<p>系统默认使用WPEFramework运行应用。<a href="https://webkit.org/wpe/">WPEFramework</a>是嵌入式设备的WebKit引擎，能够运行Web应用。执行以下命令可以打开WPE Launcher应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动WPEFramework引擎，开启了一个网络端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wpeframework.sh &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过curl请求端口，传入参数启动Launcher应用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> launcher.sh &amp;</span></span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>编译环境搭建会遇到很多问题，需要缩小范围，不断调试。例如</p>
<ol>
<li>bitbake整编软件出问题，分析log找到报错的模块，局部编译</li>
<li>局部编译模块出问题，分析log找到对应的task脚本，手动执行单个脚本</li>
<li>单个脚本执行失败，分析log找到对应的命令，手动执行单条命令</li>
<li>分析命令执行原理和过程，尝试修改命令和脚本再运行。</li>
<li>由于temp目录的脚本是临时的，每次bitbake都会覆盖掉修改的脚本，所以需要想办法修改bb配置文件</li>
</ol>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter编译环境搭建探索</title>
    <url>/2022/02/14/flutter-2022-02-14-Flutter%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="探索过程总结"><a href="#探索过程总结" class="headerlink" title="探索过程总结"></a>探索过程总结</h1><p>环境配置较复杂，遇到的问题、涉及到的技术栈较多，导致文章内容比较零散。</p>
<blockquote>
<p>探索过程中最麻烦的是编译问题的实验和记录，不确定缺少了哪些库，遇到一个问题就去网上搜索解决，做了很多尝试，有时候误打误撞成功了，但是无法确定真正起作用的是哪一步操作。因此需要不断回退，重置环境。</p>
<p>有时候为了分析错误原因，验证自己的猜想，明知道有坑还得去踩上一遍。</p>
</blockquote>
<h2 id="背景和目标"><a href="#背景和目标" class="headerlink" title="背景和目标"></a>背景和目标</h2><p>目标：解决Flutter交叉编译Linux arm平台应用，在TV嵌入式设备上运行。</p>
<p>任务：使用Flutter开发Linux TV应用，研究Flutter应用和引擎编译，搭建编译环境，Flutter嵌入层定制和适配。</p>
<p>Flutter桌面应用编译只能在对应的平台上（Linux应用只能在Linux平台上编译），由于没有Linux电脑，无法编译和运行Linux程序（x86_64、arm、arm64）。参考<a href="https://flutter.cn/desktop">Flutter桌面支持</a></p>
<blockquote>
<p>解决思路：利用Docker Ubuntu容器环境。</p>
<ol>
<li>容器内本地编译Flutter Linux桌面应用，并尝试在容器内运行显示界面。</li>
<li>容器内交叉编译arm/arm64平台应用，并安装到嵌入式Linux设备运行。</li>
</ol>
<p>使用Docker有几个明显的好处：</p>
<ul>
<li>尝试过程中需要装各种乱七八糟的环境，很容易破坏主机环境，且不知道真正缺少的是哪些环境，使用Docker可以随时删除容器重新验证。</li>
<li>准备好环境之后可以方便的进行打包和移植</li>
</ul>
</blockquote>
<p><strong>注：Flutter官方的Linux桌面嵌入层使用GTK图形库，因此下面编译出的Linux应用只适用于Linux GTK环境。嵌入式平台如果使用其他图形系统（例如DRM、Wayland），需要定制嵌入层，修改编译工具链和sysroot</strong></p>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>环境：（下文不再赘述）</p>
<ul>
<li>主机（Host）：<ul>
<li>远程服务器：Linux CentOS，没有root权限（无法安装编译环境），但是可以使用Docker（容器中可以root）。</li>
<li>本地机器/主机：MacOS</li>
</ul>
</li>
<li>目标平台：Linux嵌入式平台（arm架构）、Android嵌入式平台（arm、armv8架构）、Linux桌面平台（x64、arm64架构）</li>
<li>实验镜像：<a href="https://hub.docker.com/_/ubuntu">ubuntu（x64架构）</a>：作为Flutter交叉编译主机，默认不带图形界面，无法运行Flutter GUI界面</li>
<li>容器：本地机器和远程服务器都可以运行Docker容器。<ul>
<li>本地Docker容器：通过QEMU可以运行Ubuntu arm镜像和arm64镜像</li>
<li>远程Docker容器：没有QEMU，只能运行x86_64 Ubuntu镜像</li>
</ul>
</li>
</ul>
<p>分别对比主机和容器系统版本差异，如下：</p>
<p><img src="/2022/02/14/flutter-2022-02-14-Flutter%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8E%A2%E7%B4%A2/%E4%B8%BB%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82.png"></p>
<p><img src="/2022/02/14/flutter-2022-02-14-Flutter%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8E%A2%E7%B4%A2/Docker%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82.png"></p>
<p>本地和远程Docker容器使用相同的Ubuntu官方镜像，但是查看版本有一定差异。本地Docker容器应该是QEMU模拟器运行Linux环境。</p>
<p><strong>注意这里有个坑，下文会提到</strong>：同一个gen_snapshot程序，在本地Linux容器可以运行，在远程Linux容器无法运行，都是x86_64架构</p>
<p>结论：<strong>不同系统的主机上即使使用相同的镜像，容器环境也存在差异</strong></p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ol>
<li>编译Linux x86_64桌面应用：问题不大，根据Flutter官方文档构建即可。</li>
<li>编译Linux arm64引擎：问题不大</li>
<li>编译Linux arm64应用：<ol>
<li>修改<code>flutter_tools</code>源码</li>
<li>指定<code>--target-sysroot</code>参数</li>
</ol>
</li>
<li>编译Linux arm引擎：<ol>
<li>修改<code>src/build/toolchain/custom/BUILD.gn</code>，<code>$&#123;custom_target_triple&#125;</code>改为<code>llvm</code></li>
<li>修改<code>srf/flutter/BUILD.gn</code>，将<code>_build_engine_artifacts</code>改为false，跳过Dart SDK编译</li>
<li><code>--target-sysroot=$PWD/build/linux/debian_sid_arm-sysroot/</code>：使用<code>install-sysroot.py</code>脚本下载</li>
<li><code>--target-toolchain=$PWD/buildtools/linux-x64/clang</code>：引擎自带路径</li>
<li><code>--target-triple=armv7-unknown-linux-gnueabihf</code></li>
</ol>
</li>
<li>编译Linux arm应用：需要修改<code>flutter_tools</code><ol>
<li>手动进行Dart前后端编译</li>
<li>手动编译Linux平台代码，链接引擎和应用so库，生成可执行程序</li>
</ol>
</li>
<li>运行应用：下载的Ubuntu镜像没有界面，无法运行GUI程序。</li>
</ol>
<blockquote>
<ul>
<li>x64和arm64应用使用VNC容器运行：<a href="/2022/02/13/tool-2022-02-13-DockerGUI/">Linux容器运行GUI程序</a></li>
<li>arm应用装入嵌入式平台运行：<a href="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/">Yocto嵌入式平台运行Flutter应用</a></li>
</ul>
</blockquote>
<p>引擎编译和应用编译有各自的sysroot和toolchain</p>
<ul>
<li>sysroot是编译需要的一些目标平台库和头文件等。</li>
<li>toolchain是交叉编译工具链。</li>
</ul>
<p>引擎获取方式：主要产物是<code>libflutter_engine.so</code>库和gen_snapshot编译后端程序</p>
<ol>
<li>手动下载<a href="https://storage.googleapis.com/flutter_infra_release">Flutter官方预构建引擎</a>：缺少arm平台</li>
<li>手动编译引擎</li>
</ol>
<p>sysroot和toolchain获取方式：</p>
<ol>
<li>手动下载<a href="https://commondatastorage.googleapis.com/chrome-linux-sysroot">Flutter官方预构建引擎sysroot</a>，使用引擎<code>src/buildtools</code></li>
<li>自行制作：参考<a href="/2022/01/20/tool-2022-01-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91">交叉编译</a></li>
</ol>
<p>应用编译方式：</p>
<ol>
<li>使用<code>flutter build</code>命令：需要修改flutter_tools源码</li>
<li>手动调用前后端编译</li>
</ol>
<h2 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h2><p>在arm64容器中直接本地编译arm64的Flutter应用。</p>
<h1 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h1><p>进入容器后首次使用<code>apt-get</code>安装软件报错：<code>&quot;E: Unable to locate package&quot;</code></p>
<blockquote>
<p>Linux的发行版维护了一个软件仓库，存储常用的软件，仓库地址存储在<code>/etc/apt/sources.list</code>文件中，使用<code>apt-get</code>工具会从该文件中读取仓库地址，下载并安装软件。</p>
<p>解决：执行下<code>apt update</code>，更新软件源地址列表</p>
<p><code>apt</code>命令是对<code>apt-get</code>、<code>apt-cache</code>等命令的封装，提供了统一的入口。</p>
</blockquote>
<p>使用apt安装的交叉编译工具链可能有多个版本，可以搜索，例如：<code>apt-cache search gcc | grep -E &quot;arm|aarch64&quot;</code></p>
<p>查看IP地址：<code>ifconfig en0 | grep inet | awk &#39;$1==&quot;inet&quot; &#123;print $2&#125;</code></p>
<p>Git clone仓库提示Permission denied：生成SSH Key，并在GitHub上配置Git SSH Key。或者将本地配置好的key拷贝到容器中使用。</p>
<h2 id="Docker操作"><a href="#Docker操作" class="headerlink" title="Docker操作"></a>Docker操作</h2><p>关于Docker介绍和使用可以参考我的其他文章，这里简单介绍下涉及到的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取Ubuntu镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull ubuntu</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台运行容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -itd --name ubuntu-env ubuntu /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器环境</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it ubuntu-env /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Flutter编译环境搭建好之后生成镜像，方便移植</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker commit ubuntu-env ubuntu-flutter-image</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包镜像，使用scp拷贝到其他服务器上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker save -o image.tar ubuntu-flutter-image:latest</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他服务器加载镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker load &lt; image.tar</span></span><br></pre></td></tr></table></figure>

<p>容器中下载Flutter引擎和SDK源码会导致生成镜像很大，可以让用户自己在主机下载好源码，运行的时候再挂载到容器中。</p>
<p>Docker容器中配置<code>.bash_profile</code>环境变量，退出容器再进入失效。</p>
<blockquote>
<p>可以通过DockerFile配置镜像环境变量，或者执行<code>docker run</code>和<code>docker exec</code>时使用-e参数。</p>
</blockquote>
<p>查看Docker镜像和容器大小：<code>docker system df -v</code></p>
<p>主机和Docker容器间文件拷贝：<code>docker cp 主机路径 容器名:容器内路径</code></p>
<h1 id="本地编译Linux桌面应用"><a href="#本地编译Linux桌面应用" class="headerlink" title="本地编译Linux桌面应用"></a>本地编译Linux桌面应用</h1><p>容器内安装Flutter SDK，根据<a href="https://flutter.cn/docs/get-started/install/linux">官方文档</a>配置环境即可，问题不大。国内网络下载不了的话参考<a href="https://docs.flutter.dev/community/china">Using Flutter in China</a></p>
<ol>
<li>下载Flutter SDK：<code>git clone https://github.com/flutter/flutter.git</code></li>
<li>配置环境变量</li>
<li>安装Linux编译环境：<code>apt install unzip git curl clang cmake ninja-build pkg-config libgtk-3-dev liblzma-dev</code></li>
<li>启用Linux编译：<code>flutter config --enable-linux-desktop</code></li>
<li>检查Flutter编译工具链：<code>flutter doctor</code></li>
</ol>
<p>编译Flutter应用：生成myapp可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Flutter模版工程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> flutter create myapp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myapp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是已有的项目，则需要创建Linux壳工程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> flutter create --platforms=linux</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译Flutter Linux桌面应用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> flutter build linux</span></span><br></pre></td></tr></table></figure>

<p>通过<a href="/2022/02/13/tool-2022-02-13-DockerGUI/">Linux容器运行GUI程序</a>，可以成功运行myapp应用。</p>
<h1 id="交叉编译Linux-arm64平台应用"><a href="#交叉编译Linux-arm64平台应用" class="headerlink" title="交叉编译Linux arm64平台应用"></a>交叉编译Linux arm64平台应用</h1><p>Linux x64主机交叉编译Linux arm64目标平台应用：参考<a href="https://github.com/flutter/flutter/issues/74929">issue</a>和<a href="https://docs.google.com/document/d/19tzWySgtgtTA99XQsjx5Pg0SFJeZKXyUlYavR0EXv8c/edit#">说明</a></p>
<h2 id="修改flutter-tools"><a href="#修改flutter-tools" class="headerlink" title="修改flutter_tools"></a>修改flutter_tools</h2><p>Flutter SDK命令默认不支持交叉编译arm64和arm应用，需要修改<code>flutter_tools</code>源码：</p>
<ol>
<li><p>修改<code>flutter_tools/lib/src/commands/build_linux.dart</code>代码，注释掉交叉编译报错：</p>
<p><img src="/2022/02/14/flutter-2022-02-14-Flutter%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8E%A2%E7%B4%A2/%E4%BF%AE%E6%94%B9flutter_tools%E4%BB%A3%E7%A0%811.png"></p>
</li>
<li><p>修改<code>flutter_tools/lib/src/artifacts.dart</code>代码：</p>
<p><img src="/2022/02/14/flutter-2022-02-14-Flutter%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8E%A2%E7%B4%A2/%E4%BF%AE%E6%94%B9flutter_tools%E4%BB%A3%E7%A0%812.png"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_tools/lib/src/artifacts.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedArtifacts</span> <span class="keyword">implements</span> <span class="title">Artifacts</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">String</span> _getDesktopArtifactPath(Artifact artifact, TargetPlatform? platform, BuildMode? mode) &#123;</span><br><span class="line">    <span class="comment">// When platform is null, a generic host platform artifact is being requested</span></span><br><span class="line">    <span class="comment">// and not the gen_snapshot for darwin as a target platform.</span></span><br><span class="line">    <span class="keyword">if</span> (platform != <span class="keyword">null</span> &amp;&amp; artifact == Artifact.genSnapshot) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">String</span> engineDir = _getEngineArtifactsPath(platform, mode)!;</span><br><span class="line"><span class="comment">// 添加代码块</span></span><br><span class="line">      <span class="keyword">if</span> (getNameForHostPlatformArch(getCurrentHostPlatform())</span><br><span class="line">         != getNameForTargetPlatformArch(platform)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">String</span> hostPlatform = getNameForHostPlatform(getCurrentHostPlatform());</span><br><span class="line">        <span class="keyword">return</span> _fileSystem.path.join(engineDir, hostPlatform, _artifactToFileName(artifact));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _fileSystem.path.join(engineDir, _artifactToFileName(artifact));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _getHostArtifactPath(artifact, platform ?? _currentHostPlatform(_platform, _operatingSystemUtils), mode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>flutter_tools/lib/src/flutter_cache.dart</code>代码（注意代码行数）：用于下载Flutter官方arm64引擎</p>
<p><img src="/2022/02/14/flutter-2022-02-14-Flutter%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8E%A2%E7%B4%A2/%E4%BF%AE%E6%94%B9flutter_tools%E4%BB%A3%E7%A0%813.png"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_tools/lib/src/flutter_cache.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterSdk</span> <span class="keyword">extends</span> <span class="title">EngineCachedArtifact</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; getBinaryDirs() &#123;</span><br><span class="line">    <span class="comment">// Currently only Linux supports both arm64 and x64.</span></span><br><span class="line">    <span class="keyword">return</span> &lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;[</span><br><span class="line">      &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;common&#x27;</span>, <span class="string">&#x27;flutter_patched_sdk.zip&#x27;</span>],</span><br><span class="line">      &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;common&#x27;</span>, <span class="string">&#x27;flutter_patched_sdk_product.zip&#x27;</span>],</span><br><span class="line">      <span class="keyword">if</span> (cache.includeAllPlatforms) ...&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;[</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;windows-x64&#x27;</span>, <span class="string">&#x27;windows-x64/artifacts.zip&#x27;</span>],</span><br><span class="line"><span class="comment">// 修改代码：Modified to download the artifacts of both linux-x64 and linux-arm64</span></span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-x64&#x27;</span>, <span class="string">&#x27;linux-x64/artifacts.zip&#x27;</span>],</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-arm64&#x27;</span>, <span class="string">&#x27;linux-arm64/artifacts.zip&#x27;</span>],</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;darwin-x64&#x27;</span>, <span class="string">&#x27;darwin-x64/artifacts.zip&#x27;</span>],</span><br><span class="line">      ]</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_platform.isWindows)</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;windows-x64&#x27;</span>, <span class="string">&#x27;windows-x64/artifacts.zip&#x27;</span>]</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_platform.isMacOS)</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;darwin-x64&#x27;</span>, <span class="string">&#x27;darwin-x64/artifacts.zip&#x27;</span>]</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_platform.isLinux) ...&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;[</span><br><span class="line"><span class="comment">// 修改代码：Modified to download the artifacts of both linux-x64 and linux-arm64</span></span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-x64&#x27;</span>, <span class="string">&#x27;linux-x64/artifacts.zip&#x27;</span>],</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-arm64&#x27;</span>, <span class="string">&#x27;linux-arm64/artifacts.zip&#x27;</span>],</span><br><span class="line">      ],</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinuxEngineArtifacts</span> <span class="keyword">extends</span> <span class="title">EngineCachedArtifact</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; getBinaryDirs() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_platform.isLinux || ignorePlatformFiltering) &#123;</span><br><span class="line">      <span class="comment">// 修改代码：Modified to download the artifacts of both linux-x64 and linux-arm64</span></span><br><span class="line">      <span class="keyword">return</span> &lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;[</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-x64&#x27;</span>, <span class="string">&#x27;linux-x64/linux-x64-flutter-gtk.zip&#x27;</span>],</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-x64-profile&#x27;</span>, <span class="string">&#x27;linux-x64-profile/linux-x64-flutter-gtk.zip&#x27;</span>],</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-x64-release&#x27;</span>, <span class="string">&#x27;linux-x64-release/linux-x64-flutter-gtk.zip&#x27;</span>],</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-arm64&#x27;</span>, <span class="string">&#x27;linux-arm64/linux-arm64-flutter-gtk.zip&#x27;</span>],</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-arm64-profile&#x27;</span>, <span class="string">&#x27;linux-arm64-profile/linux-arm64-flutter-gtk.zip&#x27;</span>],</span><br><span class="line">        &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;linux-arm64-release&#x27;</span>, <span class="string">&#x27;linux-arm64-release/linux-arm64-flutter-gtk.zip&#x27;</span>],</span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> &lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;[];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除<code>flutter_tools</code>重新构建：<code>rm flutter/bin/cache/flutter_tools*</code></p>
</li>
<li><p>执行编译命令：<code>flutter build linux --target-platform linux-arm64 -v</code></p>
</li>
</ol>
<blockquote>
<p>-v查看编译具体信息</p>
</blockquote>
<p>这里build失败是正常的，但是已经成功下载Flutter官方提供的Linux arm64引擎的构件，放到了SDK对应路径下，例如：<code>flutter/bin/cache/artifacts/engine/linux-arm64-release/</code>。</p>
<p>踩坑：下载的Flutter引擎gen_snapshot程序可以在本地Docker容器中执行，但是无法在远程Docker容器中执行。提示<code>cannot execute binary file: Exec format error</code>（二进制可执行程序格式不正确），导致编译失败。</p>
<blockquote>
<p>前面介绍环境的时候提到不同主机上即使使用相同镜像，容器环境也存在差异。</p>
<p>编译器本身也是一个可执行程序，只能在目标平台运行。</p>
</blockquote>
<p>既然官方提供的引擎构件无法使用，那只能自己下载引擎源码编译生成gen_snapshot了。</p>
<h2 id="交叉编译Flutter-arm64引擎"><a href="#交叉编译Flutter-arm64引擎" class="headerlink" title="交叉编译Flutter arm64引擎"></a>交叉编译Flutter arm64引擎</h2><p>源码下载和Host编译参考<a href="/2022/01/06/flutter-2022-01-06-Flutter%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/">Flutter源码下载和编译</a></p>
<p>注：Flutter SDK中内置了引擎的<code>artifact</code>，如果自己编译引擎，需要确保Engine源码和Framework源码版本对应。本文使用2.8.1版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flutter --version</span></span><br><span class="line">Flutter 2.8.1 • channel stable • https://github.com/flutter/flutter.git</span><br><span class="line">Framework • revision 77d935af4d (10 weeks ago) • 2021-12-16 08:37:33 -0800</span><br><span class="line">Engine • revision 890a5fca2e</span><br><span class="line">Tools • Dart 2.15.1</span><br></pre></td></tr></table></figure>

<p>在远程容器中下载好源码之后，开始交叉编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt install python3 git pkg-config vim curl unzip ninja-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./flutter/tools/gn --target-os linux --linux-cpu arm64 --runtime-mode release</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ninja -C out/linux_release_arm64</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码如果已经下载，可以不用安装depot_tools，使用apt安装ninja即可</p>
</blockquote>
<p>arm 64位引擎编译问题不大，比较顺利。</p>
<h2 id="交叉编译Linux-arm64应用"><a href="#交叉编译Linux-arm64应用" class="headerlink" title="交叉编译Linux arm64应用"></a>交叉编译Linux arm64应用</h2><p>按照上文修改<code>flutter_tools</code>，将引擎编译生成的关键产物拷贝到Flutter SDK路径下，替代官方Artifact。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拷贝gen_snapshot，目录不存在则创建</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp src/out/linux_release_arm64/clang_x64/gen_snapshot &lt;artifact_path&gt;/linux-arm64-release/linux-x64/gen_snapshot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝引擎so</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp src/out/linux_release_arm64/libflutter_linux_gtk.so &lt;artifact_path&gt;/linux-arm64-release/libflutter_linux_gtk.so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝头文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp src/flutter/shell/platform/linux/public/flutter_linux &lt;artifact_path&gt;/linux-arm64-release/flutter_linux</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最终路径如下</span></span><br><span class="line">~/flutter/flutter/bin/cache/artifacts/engine/linux-arm64-release $ tree</span><br><span class="line">├── flutter_linux # 位于src/flutter/engine/src/flutter/shell/platform/linux/public/flutter_linux </span><br><span class="line">├── libflutter_linux_gtk.so # 位于src/out/linux_release_arm64/libflutter_linux_gtk.so</span><br><span class="line">└── linux-x64</span><br><span class="line">    └── gen_snapshot # 位于src/out/linux_release_arm64/clang_x64/gen_snapshot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装gcc和g++交叉编译工具，注意这里安装的是gcc版本是9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝头文件，由于上一步安装的gcc版本是9，而Flutter官方的debian_sid_arm64-sysroot中的gcc为7。编译的时候从sysroot中找不到头文件，因此需要手动拷贝到头文件搜索路径。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -r /usr/aarch64-linux-gnu/include/c++/9/aarch64-linux-gnu/bits/ /lib/gcc-cross/aarch64-linux-gnu/9/../../../../include/c++/9/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译Linux arm64应用，指定target-sysroot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> flutter build linux --target-platform linux-arm64 --target-sysroot /root/flutter/engine/src/build/linux/debian_sid_arm64-sysroot -v</span> </span><br></pre></td></tr></table></figure>

<p><strong>注：最关键的步骤是指定<code>--target-sysroot</code>，否则会遇到很多错误。</strong></p>
<blockquote>
<p>这里使用Flutter引擎构建时用的sysroot，也可以自行制作sysroot</p>
</blockquote>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><p>一开始<code>flutter build</code>没有指定<code>--target-sysroot</code>一直报错。根据网上的办法解了一个又出现另一个，没完没了。都是弯路，其实问题原因就是缺少目标平台库sysroot，<strong>不应该聚焦单个问题，而是当作整体来看</strong>。</p>
<blockquote>
<p>此时Dart代码可以正常编译，<code>app.so</code>位于<code>.dart_tool</code>中。</p>
<p>主要是编译Linux壳工程（main.cc等）失败，依赖GTK、X11等目标平台库和头文件。</p>
<p>如果是定制嵌入层，需要自己创建<code>main.cc</code>入口文件，进行交叉编译。</p>
</blockquote>
<p><strong>这里记录下单个问题的踩坑过程，用来参考：无法真正解决，正确的做法参考上面的步骤（Don’t Do It！）</strong></p>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: unrecognised emulation mode: aarch64linux</span><br><span class="line">Supported emulations: elf_x86_64 elf32_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om i386pep i386pe</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：缺少GNU交叉编译工具链</p>
<p>解决：<code>apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</code></p>
</blockquote>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Target aot_elf_release failed: ProcessException: Failed to find &quot;/root/flutter/flutter/bin/cache/artifacts/engine/linux-arm64-release/linux-x64/gen_snapshot&quot; in the search path</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：官方下载的引擎Artifact解压文件夹不对</p>
<p>解决：手动将gen_snapshot放到<code>linux-x64</code>目录下</p>
</blockquote>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/root/flutter/flutter/bin/cache/artifacts/engine/linux-arm64-release/linux-x64/gen_snapshot: 1: Syntax error: &quot;(&quot; unexpected</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：官方下载的引擎Artifact的gen_snapshot可执行程序目标格式不正确，可以在</p>
<p>解决：将自己编译的引擎Artifact拷贝到对应目录下</p>
</blockquote>
<h3 id="问题4（X）"><a href="#问题4（X）" class="headerlink" title="问题4（X）"></a>问题4（X）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//usr/include/limits.h:26:10: fatal error: &#x27;bits/libc-header-start.h&#x27; file not found</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：缺少头文件</p>
<p>解决：<code>apt install gcc-multilib g++-multilib</code></p>
<p><strong>备注：无用的步骤，下面会拷贝整个头文件目录。</strong></p>
</blockquote>
<h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//lib/gcc-cross/aarch64-linux-gnu/9/../../../../include/c++/9/cstdlib:41:10: fatal error: &#x27;bits/c++config.h&#x27; file not found</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：系统安装的gcc工具链版本是9，Flutter引擎中的<code>debian_sid_arm64-sysroot</code>中gcc版本是7，导致在<code>--target-sysroot</code>路径中找不到头文件。</p>
<p>解决：拷贝整个文件夹到头文件搜索路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp -r /usr/aarch64-linux-gnu/include/c++/9/aarch64-linux-gnu/bits/ /lib/gcc-cross/aarch64-linux-gnu/9/../../../../include/c++/9/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[        ] FAILED: intermediates_do_not_run/myapp</span><br><span class="line">[        ] : &amp;&amp; /usr/bin/clang++ --target=aarch64-linux-gnu --sysroot=/ubuntu-arm64  -O3 -DNDEBUG   CMakeFiles/myapp.dir/main.cc.o CMakeFiles/myapp.dir/my_application.cc.o</span><br><span class="line">CMakeFiles/myapp.dir/flutter/generated_plugin_registrant.cc.o  -o intermediates_do_not_run/myapp -L/root/Desktop/myapp/linux/flutter/ephemeral</span><br><span class="line">-Wl,-rpath,/root/Desktop/myapp/linux/flutter/ephemeral:/usr/lib/aarch64-linux-gnu:  -lflutter_linux_gtk  -lgtk-3  -lgdk-3  -lpangocairo-1.0  -lpango-1.0  -lharfbuzz  -latk-1.0  -lcairo-gobject</span><br><span class="line">-lcairo  -lgdk_pixbuf-2.0  /ubuntu-arm64/usr/lib/aarch64-linux-gnu/libgio-2.0.so  /ubuntu-arm64/usr/lib/aarch64-linux-gnu/libgobject-2.0.so  /ubuntu-arm64/usr/lib/aarch64-linux-gnu/libglib-2.0.so &amp;&amp; :</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: cannot find -lgtk-3</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: cannot find -lgdk-3</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: cannot find -lpangocairo-1.0</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: cannot find -lpango-1.0</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: cannot find -lharfbuzz</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: cannot find -latk-1.0</span><br><span class="line">[   +4 ms] /usr/bin/aarch64-linux-gnu-ld: cannot find -lcairo-gobject</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: cannot find -lcairo</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: cannot find -lgdk_pixbuf-2.0</span><br><span class="line">[        ] clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：缺少GTK、Cairo等<strong>目标平台</strong>的链接库</p>
<p>解决思路：apt没有提供arm64的GTK平台库，需要自行下载，或者在arm64机器上使用apt下载，再拷贝出来。（sysroot其实就是这样制作的）</p>
</blockquote>
<p>备注：踩坑到这里解不动了。最后跳出单个问题看，其实就是缺了<code>--target-sysroot</code>。学习了下sysroot制作，验证成功，再后来发现其实用Flutter官方的sysroot也可以编译成功。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>下面的问题也是探索过程中遇到的，但是后面复现不到了，还是保留下踩坑过程。（看看就好，没有参考价值）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/aarch64-linux-gnu-ld: cannot find -lstdc++</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：找不到链接库</p>
<p>解决：<code>apt install libstdc++-9-dev-arm64-cross</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR: qemu-aarch64: Could not open &#x27;/lib/ld-linux-aarch64.so.1&#x27;: No such file or directory</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：找不到链接库</p>
<p>解决；<code>cp /usr/aarch64-linux-gnu/lib/ld-linux-aarch64.so.1 /lib/ld-linux-aarch64.so.1</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR: /root/flutter/bin/cache/artifacts/engine/linux-arm64-release/gen_snapshot: error while loading shared libraries: libdl.so.2: cannot open shared object file: No such file or directory</span><br><span class="line">ERROR: Dart snapshot generator failed with exit code 127</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：找不到链接库</p>
<p>解决：export LD_LIBRARY_PATH=/usr/aarch64-linux-gnu/lib`：添加程序加载运行时查找链接库的路径</p>
<p><code>LIBRARY_PATH</code>：添加gcc编译时查找链接库的路径。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Target unpack_linux failed: FileSystemException: Cannot open file, path = &#x27;/root/flutter/bin/cache/artifacts/engine/linux-arm64/icudtl.dat&#x27; (OS Error: No such file or directory,</span><br><span class="line">errno = 2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决：从Flutter官方仓库下载引擎Artifact，或者自行编译引擎，拷贝到对应目录</p>
</blockquote>
<h1 id="交叉编译Linux-arm应用"><a href="#交叉编译Linux-arm应用" class="headerlink" title="交叉编译Linux arm应用"></a>交叉编译Linux arm应用</h1><h2 id="交叉编译Flutter-arm引擎"><a href="#交叉编译Flutter-arm引擎" class="headerlink" title="交叉编译Flutter arm引擎"></a>交叉编译Flutter arm引擎</h2><ol>
<li><p>修改<code>src/flutter/BUILD.gn</code>文件，将<code>_build_engine_artifacts</code>改为false，跳过Dart SDK编译</p>
</li>
<li><p>修改<code>build/toolchain/custom/BUILD.gn</code>，将<code>$&#123;custom_target_triple&#125;</code>改为<code>llvm</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> build/toolchain/custom/BUILD.gn</span></span><br><span class="line">ar = &quot;$&#123;toolchain_bin&#125;/$&#123;custom_target_triple&#125;-ar&quot;</span><br><span class="line">readelf = &quot;$&#123;toolchain_bin&#125;/$&#123;custom_target_triple&#125;-readelf&quot;</span><br><span class="line">nm = &quot;$&#123;toolchain_bin&#125;/$&#123;custom_target_triple&#125;-nm&quot;</span><br><span class="line">strip = &quot;$&#123;toolchain_bin&#125;/$&#123;custom_target_triple&#125;-strip&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装基础环境</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt install python3 git pkg-config vim curl unzip ninja-build clang</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动下载arm平台的sysroot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> build/linux/sysroot_scripts/install-sysroot.py --arch=arm</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gn生成构建配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./flutter/tools/gn --target-os linux --linux-cpu arm --runtime-mode release \</span></span><br><span class="line"><span class="bash">--target-toolchain=<span class="variable">$PWD</span>/buildtools/linux-x64/clang \</span></span><br><span class="line"><span class="bash">--target-sysroot=<span class="variable">$PWD</span>/build/linux/debian_sid_arm-sysroot/ \</span></span><br><span class="line"><span class="bash">--target-triple=armv7-unknown-linux-gnueabihf \</span></span><br><span class="line"><span class="bash">--arm-float-abi=hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ninja编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ninja -C out/linux_release_arm</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="交叉编译Linux-arm应用-1"><a href="#交叉编译Linux-arm应用-1" class="headerlink" title="交叉编译Linux arm应用"></a>交叉编译Linux arm应用</h2><p>由于Flutter官方还不支持Linux arm应用的编译，因此需要修改<code>flutter_tools</code>源码：</p>
<ol>
<li>让<code>flutter build</code>命令支持<code>--target-platform=linux-arm</code>参数</li>
<li>编译时查找对应路径下的引擎产物，例如：<code>&#123;flutter_sdk&#125;/bin/cache/artifacts/engine/linux-arm-release/</code>）</li>
</ol>
<p>可以参考<a href="/2022/01/12/flutter-2022-01-12-Flutter%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Flutter应用构建流程分析</a>，能读懂源码自然就会修改了。</p>
<p>这里直接调用前后端编译，不使用<code>flutter build</code>命令（省略文件路径）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 前端编译生成app.dill</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dart frontend_server.dart.snapshot \</span></span><br><span class="line"><span class="bash">--target=flutter \</span></span><br><span class="line"><span class="bash">--aot --tfa \</span></span><br><span class="line"><span class="bash">-Ddart.vm.profile=<span class="literal">false</span> -Ddart.vm.product=<span class="literal">true</span> \</span></span><br><span class="line"><span class="bash">--sdk-root flutter_patched_sdk \</span></span><br><span class="line"><span class="bash">--output-dill app.dill \</span></span><br><span class="line"><span class="bash">demo/lib/main.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后端编译生成libapp.so</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./clang_x64/gen_snapshot \</span></span><br><span class="line"><span class="bash">--snapshot_kind=app-aot-elf \</span></span><br><span class="line"><span class="bash">--elf=libapp.so \</span></span><br><span class="line"><span class="bash">app.dill</span></span><br></pre></td></tr></table></figure>

<p>linux平台代码使用cmake和ninja编译，并链接<code>libapp.so</code>、<code>libflutter_engine.so</code>，需要修改<code>CMakeList.txt</code>，这里暂时不做介绍。</p>
<h2 id="踩坑记录-1"><a href="#踩坑记录-1" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="找不到交叉编译工具链"><a href="#找不到交叉编译工具链" class="headerlink" title="找不到交叉编译工具链"></a>找不到交叉编译工具链</h3><p><code>./flutter/tools/gn --target-os linux --linux-cpu arm --runtime-mode release --verbose</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Generating GN files in: out/linux_release_arm</span><br><span class="line">ERROR Unresolved dependencies.</span><br><span class="line">//:default(//build/toolchain/linux:clang_arm)</span><br><span class="line">  needs //build/toolchain/linux:clang_arm()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：找不到交叉编译工具链</p>
<p>分析：参考<a href="https://github.com/flutter/flutter/issues/55574">Flutter issue</a>，需要添加<code>--target-toolchain</code>参数</p>
<p>解决：添加<code>--target-toolchain</code>参数，同时需要添加<code>--target-sysroot</code>和<code>--target-triple</code>。否则断言会出错</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#build/config/BUILDCONFIG.gn</span></span><br><span class="line">if (custom_toolchain != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">  assert(custom_sysroot != <span class="string">&quot;&quot;</span>) <span class="comment"># 496</span></span><br><span class="line">  assert(custom_target_triple != <span class="string">&quot;&quot;</span>) <span class="comment"># 497</span></span><br><span class="line">  host_toolchain = <span class="string">&quot;//build/toolchain/linux:clang_$host_cpu&quot;</span></span><br><span class="line">  set_default_toolchain(<span class="string">&quot;//build/toolchain/custom&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>问题点在于这三个参数应该填什么？试验了很多次，ninja编译会出现各种各样的错。最终是参考<code>meta-flutter</code>项目的Yocto编译配方才解决的。</p>
<p>错误试验：</p>
<ul>
<li><code>--target-toolchain</code>使用<code>/</code>或者<code>/usr/lib/llvm-10/ </code></li>
<li>``–target-triple<code>使用</code>arm-linux-gnueabihf<code>或者</code>llvm`。</li>
</ul>
<h3 id="不带-arm-float-abi-hard选项"><a href="#不带-arm-float-abi-hard选项" class="headerlink" title="不带--arm-float-abi=hard选项"></a>不带<code>--arm-float-abi=hard</code>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ninja: Entering directory `out/linux_release_arm&#x27;</span><br><span class="line">/root/flutter/engine/src/build/linux/debian_sid_arm-sysroot//usr/include/arm-linux-gnueabihf/gnu/stubs.h:7:11: fatal error: &#x27;gnu/stubs-soft.h&#x27; file not found</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gn命令添加<code>--arm-float-abi=hard</code>。或者修改<code>build/config/compiler/BUILD.gn</code>文件，如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># build/config/compiler/BUILD.gn</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="string">&quot;-mfloat-abi=$arm_float_abi&quot;</span>,  <span class="comment"># 默认值为softfp，可以改为hard</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="target-triple使用arm-linux-gnueabihf"><a href="#target-triple使用arm-linux-gnueabihf" class="headerlink" title="--target-triple使用arm-linux-gnueabihf"></a><code>--target-triple</code>使用<code>arm-linux-gnueabihf</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ninja: Entering directory `out/linux_release_arm/&#x27;</span><br><span class="line">[552/6691] AR obj/third_party/dart/runtime/bin/libcrashpad.a</span><br><span class="line">FAILED: obj/third_party/dart/runtime/bin/libcrashpad.a</span><br><span class="line">rm -f obj/third_party/dart/runtime/bin/libcrashpad.a &amp;&amp; /usr/lib/llvm-10//bin/arm-linux-gnueabihf-ar rcs obj/third_party/dart/runtime/bin/libcrashpad.a @obj/third_party/dart/runtime/bin/libcrashpad.a.rsp</span><br><span class="line">/bin/sh: 1: /usr/lib/llvm-10//bin/arm-linux-gnueabihf-ar: not found</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：找不到<code>arm-linux-gnueabihf-ar</code>工具。</p>
<p>解决：修改<code>build/toolchain/custom/BUILD.gn</code>文件，将<code>$&#123;custom_target_triple&#125;</code>替换为<code>llvm</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FAILED: exe.unstripped/gen_snapshot gen_snapshot</span><br><span class="line"><span class="meta">#</span><span class="bash"> Clang生成./exe.unstripped/gen_snapshot，再通过llvm-strip生成./gen_snapshot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">ld.lld: error: unable to find library -lc++</span><br><span class="line">ld.lld: error: cannot open /root/flutter/engine/src/buildtools/linux-x64/clang/lib/clang/14.0.0/lib/linux/libclang_rt.builtins-armhf.a: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索该文件</span></span><br><span class="line"><span class="meta">~/flutter/engine/src#</span><span class="bash"> find buildtools/ -name <span class="string">&quot;libclang_rt.builtins*&quot;</span></span></span><br><span class="line">buildtools/linux-x64/clang/lib/clang/14.0.0/lib/aarch64-unknown-fuchsia/libclang_rt.builtins.a</span><br><span class="line">buildtools/linux-x64/clang/lib/clang/14.0.0/lib/aarch64-unknown-linux-gnu/libclang_rt.builtins.a</span><br><span class="line">buildtools/linux-x64/clang/lib/clang/14.0.0/lib/armv7-unknown-linux-gnueabihf/libclang_rt.builtins.a</span><br><span class="line">buildtools/linux-x64/clang/lib/clang/14.0.0/lib/i386-unknown-fuchsia/libclang_rt.builtins.a</span><br><span class="line">buildtools/linux-x64/clang/lib/clang/14.0.0/lib/i386-unknown-linux-gnu/libclang_rt.builtins.a</span><br><span class="line">buildtools/linux-x64/clang/lib/clang/14.0.0/lib/riscv64-unknown-fuchsia/libclang_rt.builtins.a</span><br><span class="line">buildtools/linux-x64/clang/lib/clang/14.0.0/lib/x86_64-unknown-fuchsia/libclang_rt.builtins.a</span><br><span class="line">buildtools/linux-x64/clang/lib/clang/14.0.0/lib/x86_64-unknown-linux-gnu/libclang_rt.builtins.a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决：修改<code>--target-triple</code>为<code>armv7-unknown-linux-gnueabihf</code></p>
</blockquote>
<h3 id="Dart-SDK编译报错"><a href="#Dart-SDK编译报错" class="headerlink" title="Dart SDK编译报错"></a>Dart SDK编译报错</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Command failed: /home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/out/linux_release_arm/clang_x64/dart </span><br><span class="line">--disable-dart-dev --deterministic </span><br><span class="line">--packages=/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/flutter/flutter_frontend_server/.dart_tool/package_config.json </span><br><span class="line">--snapshot=/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/out/linux_release_arm/gen/frontend_server.dart.snapshot </span><br><span class="line">--snapshot-depfile=/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/out/linux_release_arm/gen/frontend_server.dart.snapshot.d </span><br><span class="line">--depfile-output-filename=gen/frontend_server.dart.snapshot </span><br><span class="line">--snapshot-kind=kernel /home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/flutter/flutter_frontend_server/bin/starter.dart </span><br><span class="line">--train </span><br><span class="line">--sdk-root=/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/out/linux_release_arm/flutter_patched_sdk </span><br><span class="line">/home/code/build/tmp/work/armv7at2hf-neon-pokymllib32-linux-gnueabi/lib32-flutter-engine-release/git-r0/src/flutter/flutter_frontend_server/bin/starter.dart</span><br><span class="line">output:</span><br><span class="line">===== CRASH =====</span><br><span class="line">si_signo=Segmentation fault(11), si_code=1, si_addr=0x7f3b9f7dd1fc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：编译的arm架构的<code>out/linux_release_arm/clang_x64/dart</code>程序无法执行。导致生成Kernel快照失败，例如<code>frontend_server.dart.snapshot</code>、<code>analysis_server.dart.snapshot</code>、<code>dartdoc.dart.snapshot</code>等</p>
<p>分析：这个时候<code>gen_snapshot</code>和<code>libflutter_engine.so</code>已经编译完了，不需要编译Dart SDK，所以也可以不处理该问题。</p>
<p>解决：只要跳过Dart SDK编译即可，修改<code>src/flutter/BUILD.gn</code>文件，将<code>_build_engine_artifacts</code>改为false</p>
</blockquote>
<h2 id="其他问题-1"><a href="#其他问题-1" class="headerlink" title="其他问题"></a>其他问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[   +1 ms] /usr/bin/aarch64-linux-gnu-ld: CMakeFiles/myapp.dir/my_application.cc.o: in function `my_application_activate(_GApplication*)&#x27;:</span><br><span class="line">[        ] my_application.cc:(.text+0x36c): undefined reference to `fl_dart_project_new&#x27;</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: my_application.cc:(.text+0x378): undefined reference to `fl_dart_project_set_dart_entrypoint_arguments&#x27;</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: my_application.cc:(.text+0x380): undefined reference to `fl_view_new&#x27;</span><br><span class="line">[        ] /usr/bin/aarch64-linux-gnu-ld: my_application.cc:(.text+0x3c0): undefined reference to `fl_plugin_registry_get_type&#x27;</span><br><span class="line">[        ] clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>

<p>ninja编译arm报错：缺少glibc库，需要编译libcxx和libcxxabi</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Using &#x27;dlopen&#x27; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>相关文章链接：</p>
<ul>
<li><a href="/2022/01/06/flutter-2022-01-06-Flutter%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/">Flutter源码下载和编译</a></li>
<li><a href="/2022/02/13/tool-2022-02-13-DockerGUI/">Linux容器运行GUI程序</a></li>
<li><a href="/2022/03/04/flutter-2022-03-04-Yocto%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CFlutter%E5%BA%94%E7%94%A8/">Yocto嵌入式平台运行Flutter应用</a></li>
<li><a href="/2022/01/20/tool-2022-01-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91">交叉编译</a></li>
<li><a href="/2022/03/01/flutter-2022-03-01-Flutter%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81/">Flutter引擎源码</a></li>
</ul>
<p>资源下载链接：</p>
<ul>
<li><a href="https://storage.googleapis.com/flutter_infra_release">Flutter官方预构建引擎</a>：缺少arm平台</li>
<li><a href="https://github.com/ardera/flutter-engine-binaries-for-arm">预构建ARM引擎</a>：开发者预构建的arm引擎，需要注意版本对应，否则可能无法使用</li>
<li><a href="https://commondatastorage.googleapis.com/chrome-linux-sysroot">Flutter官方预构建引擎sysroot</a></li>
<li><a href="https://storage.googleapis.com/dart-archive">Flutter官方预构建Dart SDK</a></li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://wiki.loliot.net/docs/lang/flutter/engine/flutter-engine-for-linux-arm64/">Build Flutter engine for linux-arm/arm64</a>、<a href="https://medium.com/flutter/flutter-on-raspberry-pi-mostly-from-scratch-2824c5e7dcb1">Flutter on Raspberry Pi (mostly) from scratch</a>：自行制作toolchain，编译引擎</li>
<li><a href="https://github.com/flutter/flutter/issues/55574">Flutter Issue</a>：编译arm引擎</li>
</ul>
<h2 id="Linux发行版说明"><a href="#Linux发行版说明" class="headerlink" title="Linux发行版说明"></a>Linux发行版说明</h2><p>搭建环境过程中见到很多库的名词不认识，因此查了一下</p>
<ul>
<li>RHEL（Red Hat Enterprise Linux）：Red Hat企业版，更稳定，需要付费，能获得相应的服务和技术支持</li>
<li>CentOS（Community ENTerprise Operating System）：源于RHEL，不需要付费</li>
<li>Fedora：相当于RHEL的实验版本，迭代速度快，实验稳定之后可能会应用到RHEL中。<ul>
<li>Red Hat早期分为普通版（Red Hat Linux）和企业版（RHEL），2003年普通版不再发布，改为Fedora项目，</li>
</ul>
</li>
<li>Ubuntu源于Debian：<a href="https://linux.cn/article-13746-1.html">Debian 和 Ubuntu：有什么不同？应该选择哪一个？</a></li>
<li>Ubuntu和Debian版本对应关系如下：5是debian、6是squeeze、7是wheezy、8是jessie、9是stretch、10是buster。sid代表开发版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Ubuntu      |       Debian  </span><br><span class="line">18.04  bionic     buster  &#x2F; sid   - 10</span><br><span class="line">17.10  artful     stretch &#x2F; sid   - 9</span><br><span class="line">17.04  zesty      stretch &#x2F; sid</span><br><span class="line">16.10  yakkety    stretch &#x2F; sid</span><br><span class="line">16.04  xenial     stretch &#x2F; sid</span><br><span class="line">15.10  wily       jessie  &#x2F; sid   - 8</span><br><span class="line">15.04  vivid      jessie  &#x2F; sid</span><br><span class="line">14.10  utopic     jessie  &#x2F; sid</span><br><span class="line">14.04  trusty     jessie  &#x2F; sid</span><br><span class="line">13.10  saucy      wheezy  &#x2F; sid   - 7</span><br><span class="line">13.04  raring     wheezy  &#x2F; sid</span><br><span class="line">12.10  quantal    wheezy  &#x2F; sid</span><br><span class="line">12.04  precise    wheezy  &#x2F; sid</span><br><span class="line">11.10  oneiric    wheezy  &#x2F; sid</span><br><span class="line">11.04  natty      squeeze &#x2F; sid   - 6</span><br><span class="line">10.10  maverick   squeeze &#x2F; sid</span><br><span class="line">10.04  lucid      squeeze &#x2F; sid</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux容器运行GUI程序</title>
    <url>/2022/02/13/tool-2022-02-13-DockerGUI/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>研究Flutter跨平台应用在Linux上运行。由于没有Linux电脑，因此尝试使用Docker容器代替Linux主机环境，将编译好的Flutter应用放到Linux容器中运行。</p>
<p>本文只介绍如何在Linux容器中运行GUI程序，不介绍Flutter编译相关。只演示x86_64架构Linux容器，arm和arm64步骤相同。</p>
<h1 id="Mac上运行Docker-Linux-GUI程序"><a href="#Mac上运行Docker-Linux-GUI程序" class="headerlink" title="Mac上运行Docker Linux GUI程序"></a>Mac上运行Docker Linux GUI程序</h1><p>Linux本身不带图形界面，需要安装桌面环境。有两种方式X Window和VNC：</p>
<ul>
<li>X Window System本身支持网络传输，本地开启X Server服务，远程X Client应用通过ssh连接到本地。</li>
<li>VNC（Virtual Network Console）用于远程控制桌面，远程开启VNC服务，本地通过VNC Viewer或浏览器连接到远程。类似于Windows下的RDP（Remote Desktop Protocol）。</li>
</ul>
<p>X Window以X Client应用为单位。VNC以桌面为单位。</p>
<blockquote>
<p>x11vnc：是一个VNC Server，通过X协议要求X Server将画面显示和控制权交给VNC Server，并且将X界面通过VNC共享给远程，默认端口为5900</p>
</blockquote>
<h2 id="使用X-Window"><a href="#使用X-Window" class="headerlink" title="使用X Window"></a>使用X Window</h2><p>原理：<strong>Mac提供了XQuartz工具，支持在Mac上运行X11</strong>。在主机端启动X Server，容器中启动X Client应用，建立连接，XServer将画面输出到显示器。</p>
<p>步骤：</p>
<ol>
<li><p>Mac主机安装XQuartz：<code>brew install XQuartz</code></p>
</li>
<li><p>打开XQuartz：在偏好设置-安全性中，勾选”允许从网络客户端连接”，重启XQuartz</p>
</li>
<li><p>运行xhost：<code>xhost +</code></p>
<blockquote>
<ul>
<li><code>xhost +</code>：允许所有客户端连接，不需要认证</li>
<li><code>xhost -</code>：开启访问控制，只有认证的机器能够连接</li>
<li><code>xhost + IP地址</code>：允许某台机器连接</li>
</ul>
</blockquote>
</li>
<li><p>下载Ubuntu镜像：<code>docker pull ubuntu</code></p>
</li>
<li><p>运行容器：<code>docker run -itd --name ubuntu-env ubuntu /bin/bash</code></p>
</li>
<li><p>进入Ubuntu容器，并设置DISPLAY环境变量：<code>docker exec -it -e DISPLAY=主机IP地址:0 ubuntu-env /bin/bash</code>。（或者进入容器中使用export命令设置）</p>
</li>
<li><p>更新apt包管理器下载路径：<code>apt update</code></p>
</li>
<li><p>安装gnome桌面环境：<code>apt install gnome-core</code></p>
</li>
<li><p>打开GUI程序：<code>gnome-help</code>、<code>gnome-calculator</code>、<code>firefox</code>，Mac电脑上成功显示Linux GUI程序界面</p>
</li>
</ol>
<p>无法运行<code>mutter</code>、<code>gnome-shell</code>、<code>gnome-session</code>、<code>gnome-control-center</code>等，报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@88f72f82f080:/# mutter</span><br><span class="line">Window manager warning: Unsupported session type</span><br><span class="line">root@88f72f82f080:/# gnome-shell</span><br><span class="line">Window manager warning: Unsupported session type</span><br><span class="line">root@88f72f82f080:/# gnome-session</span><br><span class="line">libGL error: No matching fbConfigs or visuals found</span><br><span class="line">libGL error: failed to load driver: swrast</span><br><span class="line">libGL error: No matching fbConfigs or visuals found</span><br><span class="line">libGL error: failed to load driver: swrast</span><br><span class="line">gnome-session-binary[3604]: WARNING: software acceleration check failed: Child process exited with code 1</span><br><span class="line">gnome-session-binary[3604]: CRITICAL: We failed, but the fail whale is dead. Sorry....</span><br><span class="line">root@88f72f82f080:/# gnome-control-center</span><br><span class="line">libGL error: No matching fbConfigs or visuals found</span><br><span class="line">libGL error: failed to load driver: swrast</span><br><span class="line"></span><br><span class="line">(gnome-control-center:3626): Gdk-ERROR **: 19:25:07.958: The program &#x27;gnome-control-center&#x27; received an X Window System error.</span><br><span class="line">This probably reflects a bug in the program.</span><br><span class="line">The error was &#x27;BadValue (integer parameter out of range for operation)&#x27;.</span><br><span class="line">  (Details: serial 173 error_code 2 request_code 149 (GLX) minor_code 24)</span><br><span class="line">  (Note to programmers: normally, X errors are reported asynchronously;</span><br><span class="line">   that is, you will receive the error a while after causing it.</span><br><span class="line">   To debug your program, run it with the GDK_SYNCHRONIZE environment</span><br><span class="line">   variable to change this behavior. You can then get a meaningful</span><br><span class="line">   backtrace from your debugger if you break on the gdk_x_error() function.)</span><br><span class="line">Trace/breakpoint trap</span><br></pre></td></tr></table></figure>

<p>Flutter应用运行同样报错，尝试了很多方法还是无法解决。</p>
<h2 id="使用VNC"><a href="#使用VNC" class="headerlink" title="使用VNC"></a>使用VNC</h2><p>直接使用<code>dorowu/ubuntu-desktop-lxde-vnc</code>镜像，不需要自己安装图形环境。</p>
<p>步骤：</p>
<ol>
<li>下载Ubuntu桌面镜像（大约500M）：<code>docker pull dorowu/ubuntu-desktop-lxde-vnc</code></li>
<li>创建并运行容器：<code>docker run -d --name ubuntu-desktop-lxde-vnc -p 6080:80 -p 5900:5900 -e VNC_PASSWORD=passwd -v /dev/shm:/dev/shm dorowu/ubuntu-desktop-lxde-vnc</code></li>
<li>浏览器访问：<code>&#123;服务器ip地址&#125;:6080/</code></li>
<li>输入密码passwd，成功连接Linux容器桌面。</li>
<li>在VNC桌面上点击图标可以运行Flutter应用</li>
</ol>
<blockquote>
<p>用命令行执行，需要先<code>export DISPLAY=:1.0</code></p>
</blockquote>
<p><img src="/2022/02/13/tool-2022-02-13-DockerGUI/Linux%E4%BD%BF%E7%94%A8VNC%E8%BF%90%E8%A1%8CFlutter.png"></p>
<h1 id="其他Docker操作"><a href="#其他Docker操作" class="headerlink" title="其他Docker操作"></a>其他Docker操作</h1><p>本节内容和要实现的目标没有关系，算是走了一些弯路和尝试，不过也是一些比较有用的知识点。</p>
<h2 id="使用ssh登录Docker-Linux容器环境"><a href="#使用ssh登录Docker-Linux容器环境" class="headerlink" title="使用ssh登录Docker Linux容器环境"></a>使用ssh登录Docker Linux容器环境</h2><p>目标：使用ssh方式直接登录到本地或远程Docker容器。</p>
<ul>
<li>本地Docker容器：也可以直接<code>docker exec</code>进入容器</li>
<li>远程Docker容器：也可以先使用ssh连接到服务器，再使用<code>docker exec</code>进入容器。</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>下载Docker官方ubuntu镜像：<code>docker pull ubuntu</code></p>
</li>
<li><p>创建并运行容器，将主机8022端口映射到容器的22端口：<code>docker run -it --name ubuntu-env -p 8022:22 ubuntu /bin/bash</code></p>
</li>
<li><p>此时进入了容器终端。使用<code>-d</code>参数可以后台运行，不进入终端。之后可以通过<code>docker exec -it ubuntu-env /bin/bash</code>命令进入</p>
</li>
<li><p>容器中安装ssh服务：<code>apt install openssh-server openssh-client vim</code></p>
</li>
<li><p>修改root登录权限：<code>vim /etc/ssh/sshd_config</code>，将PermitRootLogin值改为yes，取消注释</p>
</li>
<li><p>修改root密码：<code>passwd root</code></p>
</li>
<li><p>生成ssh密钥，如果已有文件则可跳过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动ssh服务：<code>service ssh start</code></p>
</li>
<li><p>输入exit或者<code>control+D</code>退出容器</p>
</li>
<li><p>主机通过ssh登陆容器Linux环境：<code>ssh -p 8022 root@localhost</code>（也可以输入IP连接远程机器的Docker容器）</p>
</li>
</ol>
<p>如果连不上的话可以重启下容器<code>docker restart ubuntu-env</code>再进入容器启动ssh服务</p>
<p>容器创建的时候没有指定端口映射，如何修改？（挂载同理）</p>
<blockquote>
<p>方法一：制作新镜像，重新创建容器。（推荐）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker stop ubuntu-env</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将容器制作为镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker commit ubuntu-env ubuntu-env</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rm ubuntu-env</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用新镜像重新创建容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --name ubuntu-env -p 8022:22 ubuntu-env /bin/bashs</span></span><br></pre></td></tr></table></figure>

<p>方法二：修改容器配置，重启Docker服务。（不推荐，会导致其他容器重启）</p>
<p>方法三：容器运行时修改端口映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A DOCKER -p tcp --dport 宿主机端口 -j DNAT --to-destination 容器ip:容器端口</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="打包服务器的Docker镜像到本地机器使用"><a href="#打包服务器的Docker镜像到本地机器使用" class="headerlink" title="打包服务器的Docker镜像到本地机器使用"></a>打包服务器的Docker镜像到本地机器使用</h2><p>目标：将远程Linux服务器的Docker容器打包成镜像，拷贝到本地机器（MacOS）加载，避免重新安装一遍环境（gnome、ssh、git、vim等）。</p>
<p>步骤：</p>
<ol>
<li>将容器制作为镜像：<code>docker commit [container] [image]</code></li>
<li>服务器打包镜像：<code>docker save -o image.tar ubuntu-env:latest</code></li>
<li>本地机器开启远程登录：系统偏好设置-共享-远程登录</li>
<li>拷贝镜像到本地机器：<code>scp image.tar Afauria@ip地址:/Users/Afauria/Desktop/</code></li>
<li>本地机器下载Docker，加载镜像：<code>docker load &lt; image.tar</code></li>
<li>使用<code>docker image ls</code>可以看到已经成功加载镜像</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><a href="https://hub.docker.com/_/ubuntu">Ubuntu镜像</a>有不同架构的版本，例如x86_64、ARM64、ARM：</p>
<ul>
<li><code>docker pull ubuntu</code></li>
<li><code>docker pull arm64v8/ubuntu</code></li>
<li><code>docker pull arm32v7/ubuntu</code></li>
</ul>
<p><a href="(https://hub.docker.com/r/dorowu/ubuntu-desktop-lxde-vnc)">Ubuntu桌面VNC镜像</a>只有x86_64、ARM64的版本：</p>
<ul>
<li><code>docker pull dorowu/ubuntu-desktop-lxde-vnc</code></li>
<li><code>docker pull dorowu/ubuntu-desktop-lxde-vnc:focal-arm64</code></li>
</ul>
<blockquote>
<p>运行其他架构的容器需要利用QEMU虚拟化技术：</p>
<ul>
<li>Mac电脑默认支持</li>
<li>Linux电脑需要手动安装：<code>apt install qemu-user-static</code></li>
</ul>
</blockquote>
<p>Docker中运行GUI参考资料：</p>
<ul>
<li><a href="http://fabiorehm.com/blog/2014/09/11/running-gui-apps-with-docker/">running-gui-apps-with-docker</a></li>
<li><a href="https://blog.jessfraz.com/post/docker-containers-on-the-desktop/">Docker Containers on the Desktop</a>：Docker中运行GUI程序</li>
<li><a href="https://stackoverflow.com/questions/16296753/can-you-run-gui-applications-in-a-linux-docker-container/25280523#25280523">StackOverflow：Can-you-run-gui-applications-in-a-linux-docker-container</a>：解决方案较全</li>
<li><a href="https://gitlab.gnome.org/GNOME/gnome-shell/-/issues/1545">issue：Allow running GNOME desktop/shell within docker</a></li>
<li><a href="https://github.com/mviereck/x11docker">x11docker</a>：在Linux容器中运行GUI程序（不支持MacOS）</li>
<li><a href="https://wiki.archlinux.org/title/X11vnc_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">X11vnc (简体中文)</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Flutter</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>图形系统概念扫盲</title>
    <url>/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p>OpenGL（Open Grapics Library） 是一套图形操作与渲染规范，它定义了一套 API；一般由显卡商进行实现。OpenGL只负责图形绘制，不包含窗口。</p>
<ul>
<li>OpenGL ES（OpenGL for Embedded Systems）</li>
<li>GLEW（OpenGL Extension Wrangler Library）：对底层OpenGL接口的封装，实现了跨平台。</li>
<li><a href="https://www.glfw.org/">GLFW</a>（Graphics Library Framework，图形库框架） 是配合 OpenGL 使用的轻量级工具程序库。GLFW 的主要功能是创建并管理窗口和 OpenGL 上下文，同时还提供了处理手柄、键盘、鼠标输入的功能。有类似功能的库还有 <a href="https://www.opengl.org/resources/libraries/glut/">GLUT</a>（OpenGL Utility Toolkit）和 <a href="https://www.libsdl.org/">SDL</a>（Simple DirectMedia Layer）。</li>
</ul>
<p>各种相关的库介绍如下</p>
<p><img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/OpenGL%E5%BA%93%E6%A6%82%E8%A7%88.png"></p>
<p>窗口库：OpenGL和本地窗口系统之间的通信接口，实现了OpenGL的平台无关性。</p>
<p>例如EGL提供本地窗口相关的API，创建渲染表面EGLSurface（和Buffer绑定），管理渲染上下文EGLContext、渲染同步等。OpenGL ES可以在这个Surface上进行绘制。</p>
<ul>
<li>Display（EGLDisplay）：对实际显示设备的抽象</li>
<li>Surface（EGLSurface）：对存储图形的内存区域FrameBuffer的抽象，包括Color Buffer（颜色缓冲区）、Stencil Buffer（模版缓冲区）、Depth Buffer（深度缓冲区）</li>
<li>Context（EGLContext）：存储OpenGL ES绘图的状态信息</li>
</ul>
<blockquote>
<p>Android中的GLSurfaceView内部实现了对EGL的封装，不需要直接调用EGL库</p>
</blockquote>
<p>Mesa是OpenGL的一种开源实现，由两部分组成：</p>
<ul>
<li>LibGL：实现了OpenGL的编程接口，提供给用户进行开发</li>
<li>DRI（Direct Rendering Infrastructure）驱动：直接访问和操作硬件（显卡、显存、GPU），利用硬件加速，实现绘图操作</li>
</ul>
<h2 id="绘图引擎"><a href="#绘图引擎" class="headerlink" title="绘图引擎"></a>绘图引擎</h2><p>3D绘图引擎，图形API接口，可以直接操作GPU，主要为GPU硬件加速设计，由显卡厂商实现：</p>
<ul>
<li>OpenGL：传统的图形API接口，支持跨平台，主要用于3D绘制</li>
<li>DirectX：用于Windows系统，是一个多媒体处理框架，不是单纯的图形API，分为显示、声音、输入、网络四部分。显示部分分为Direct2D和Direct3D</li>
<li>Vulkan：跨平台的2D和3D绘图API，15年发布，为取代OpenGL</li>
<li>Metal：14年推出，为Apple游戏开发设计</li>
</ul>
<p>2D绘图引擎，一般是软件实现：</p>
<ul>
<li>Cairo：FireFox和GTK+底层使用Cairo绘图引擎</li>
<li>Skia（SGL）：Google的Android绘图引擎</li>
<li>GDI、GDI+：微软推出的二维绘图引擎</li>
<li>Direct2D：微软推出的二维绘图引擎，取代GDI、GDI+</li>
</ul>
<blockquote>
<p>图形API可以通过软件（CPU）实现，也可以使用硬件加速（GPU）</p>
</blockquote>
<h2 id="GTK和QT"><a href="#GTK和QT" class="headerlink" title="GTK和QT"></a>GTK和QT</h2><p>GTK+（GIMP ToolKit）和QT是图形开发套件（GUI Toolkits），提供了很多控件，有不同的backend，例如在X11上是对XLib的封装，QT支持OpenGL的backend。</p>
<p>GTK2+不直接使用XLib，而是使用GDK和GLib函数库，通过GDK调用XLib，提高了可移植性。</p>
<p>GTK3+使用Cairo作为绘图引擎，Cairo支持不同的backend</p>
<blockquote>
<p>GTK+最初是为GIMP（GNU Image Manipulation Program，GNU图像处理程序）设计的，用于GNU/Linux下图形界面应用程序的开发，也有Winodws版和Mac版</p>
</blockquote>
<p><strong>前端向上层提供统一的编程接口，屏蔽底层绘图细节，后端（Backend）指底层的绘图引擎</strong>，例如</p>
<ul>
<li>XLib后端：使用XLib接口，向X Server发送绘图请求，由X Server完成图形绘制</li>
<li>OpenGL后端：通过OpenGL接口（LibGL），操作GPU完成绘制</li>
<li>DRM后端：直接调用DRM接口（LibDRM）或者通过DRI或DDX调用</li>
</ul>
<blockquote>
<p>后端是相对的概念，例如X Server内部也能调用OpenGL后端，DRM后端</p>
</blockquote>
<h1 id="窗口系统"><a href="#窗口系统" class="headerlink" title="窗口系统"></a>窗口系统</h1><p>Linux是一个基于命令行的操作系统，不包含图形界面，很多Linux服务器不装X服务器，只有命令行界面。而Windows在内核中就实现了图形界面。</p>
<p>GUI界面要呈现给用户，主要分为两个步骤：</p>
<ol>
<li>渲染（绘制）：通过图形API接口绘制图形（包括软件/硬件加速，2D/3D，直接/间接，客户端渲染/服务端渲染），保存到Buffer中（操作内存MMIO、DMA）</li>
<li>送显：将Buffer中的UI数据，呈现到显示设备上。</li>
</ol>
<blockquote>
<p>渲染管线分为几个步骤：应用阶段-几何阶段（顶点处理）-光栅化阶段-像素处理-合并阶段</p>
</blockquote>
<p><strong>由于每个应用都有自己的界面，这些应用共用一个显示设备，或是并列显示，或是层叠显示。因此需要一个程序来管理这些应用界面：负责将各个界面排列、合并最终显示到显示设备，即显示服务器。</strong></p>
<blockquote>
<p>如X Window中的X Server、Wayland中的Wayland Server，Android中的Surface Flinger。</p>
</blockquote>
<p>显示服务器（Display Server）：直接和硬件交互（输入设备管理，输出画面到显示器等），需要将事件传递给应用处理，并获取每个应用的绘制信息，因此需要一套通信协议，即窗口系统协议。</p>
<h2 id="XWindow"><a href="#XWindow" class="headerlink" title="XWindow"></a>XWindow</h2><p>X Window是窗口系统协议，用来显示图形界面，<strong>定义了服务端（X Server）和客户端（X Client）通信以及内核通信的机制，是一种协议，不是软件</strong>。</p>
<p><img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/XWindow%E6%9E%B6%E6%9E%84.png"></p>
<ul>
<li>X Server：负责屏幕绘制，并将图像输出到屏幕；并且接收设备输入，分给对应的窗口处理。直接与硬件交互。</li>
<li>X Client：指不同的应用程序，负责处理事件，处理绘图数据，并将绘制结果传给X Server。不和硬件交互。</li>
<li>X Window Manager（窗口管理器）：特殊的X Client，负责管理所有Client窗口大小、位置等，合成所有窗口内容传给X Server。</li>
</ul>
<p>优点：</p>
<ol>
<li>X Client不需要知道X Server的硬件配备和操作系统，只负责处理绘图数据。</li>
<li>客户端和服务端可以是同一台主机的两个进程，也可以不在一台机器上，使用网络通信。</li>
<li>可以有多个X Server，Linux服务器被多个用户使用，每个用户都有一个显示器需要显示画面。</li>
</ol>
<p><strong>注：这里的Server/Client不同于计算机概念上的Server/Client。</strong></p>
<ul>
<li>在计算机本身的意义上：Server指远程的机器，Client指用户端本地机器，性能和功能较弱。</li>
<li>在显示的意义上：Server指显示服务器，一般在用户端，将画面显示到用户端的设备上，而Client运行在远程服务器上。</li>
</ul>
<p>常用的X Server服务器软件有XFree86、Xorg、Xnest等。</p>
<blockquote>
<p>X11R6（XProtocol Version 11 Release 6）是X协议的版本，XFree86 3.3.6是软件的版本</p>
</blockquote>
<p><strong>Xlib由Xorg提供，封装了X通信协议内容</strong>，供客户端使用。</p>
<h3 id="X-Window由来"><a href="#X-Window由来" class="headerlink" title="X Window由来"></a>X Window由来</h3><p>终端概念的提出：一台计算机可以被多个用户共享，通过终端连接到同一台计算机，而不需要在计算机旁边，多用户、多任务的概念也是诞生于此。</p>
<blockquote>
<p>终端只是显示和操作接口，并不包含逻辑处理。</p>
<ul>
<li>例如字符终端（也叫CLI）输入<code>ls</code>，传给计算机，应用程序处理之后将结果传回来，终端显示字符。</li>
<li>例如图形界面终端（也叫GUI）点击一个按钮，告诉计算机，应用程序处理之后将绘图数据传回，终端显示画面。</li>
</ul>
</blockquote>
<p>由于<strong>每个GUI应用都要显示界面，而显示设备只有一个</strong>，因此需要为每个应用分配一个窗口，再对画面进行合成，最终输出到显示设备。</p>
<p>但由于早期RAM内存不足，如果为每个窗口分配一块Buffer，打开几个窗口内存就满了。X Window的做法是只使用一块屏幕大小的Buffer，每个窗口可以减去自己被盖住部分的Buffer，当窗口位置发生变化时，发一个重绘信号给窗口，窗口将绘制数据传给X Server的Buffer。</p>
<p>要实现半透明的窗口，需要对上层窗口和下层窗口做alpha混合，但是由于X Server中的Buffer只有一层，无法进行alpha混合。因此X Window扩展了协议，由Compositor合成之后再将整个屏幕的结果传给X Server渲染（内存够了，但X Window不想变更原来的机制）。</p>
<p>随着时间发展，越来越多的Client和Server程序运行在同一台机器，<strong>Client和Server频繁通信导致性能较低</strong>，特别是针对3D渲染。因此出现了DRI框架，客户端可以直接利用显卡处理图形（<strong>直接渲染</strong>）。</p>
<p>随着客户端做的事越来越多，X Server做的事越来越少。并且有很多问题不好修改原有机制，而是在X协议基础上打洞和扩展，<strong>导致X协议越来越复杂</strong>。</p>
<ul>
<li>直接渲染（Direct Rendering）：客户端直接渲染本地窗口内容。显示步骤还是交给显示服务器统一管理</li>
<li>间接渲染（Indirect Rendeing）：将绘制指令打包发给Server，通过Server进行窗口的渲染和合成。</li>
</ul>
<blockquote>
<p>GLX实现了直接渲染和间接渲染，可以通过OpenGL直接访问GPU绘制，也可以将OpenGL绘制指令发给X Server，由X Server执行OpenGL指令。</p>
</blockquote>
<h3 id="XWindow工作机制"><a href="#XWindow工作机制" class="headerlink" title="XWindow工作机制"></a>XWindow工作机制</h3><p>XWindow工作机制如下：</p>
<img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/XWindow工作流程.png" style="zoom:60%;">

<ol>
<li>鼠标点击按钮，内核收到事件，通过evdev输入驱动发送到XServer</li>
<li>XServer将事件发给对应的XClient（实际上XServer不知道窗口信息是否正确，无法将屏幕坐标转为窗口坐标，因为所有的窗口都由Compositor进行管理，例如Compositor可能将窗口缩放或最小化了）</li>
<li>客户端处理事件，决定绘制的效果，比如按压效果，将绘制指令发给请求服务端</li>
<li>服务端告诉显卡驱动进行绘制，并且计算变更区域，告诉窗口管理器</li>
<li>窗口管理器重新合成图像，请求服务端进行渲染</li>
<li>服务端告诉显卡驱动进行绘制</li>
</ol>
<p>缺点：</p>
<ol>
<li>窗口管理器也是一个X Client，这个过程中包含多次Client/Server通信。</li>
<li>尽管Compositor已经掌管了最终桌面呈现效果，但是Compositor请求X Server渲染时，X Server还会进行一些<strong>重复工作</strong>，例如窗口计算等。</li>
</ol>
<h2 id="Wayland"><a href="#Wayland" class="headerlink" title="Wayland"></a>Wayland</h2><p>Wayland的出现就是为了去掉X中不必要的设计，减少Client和Server频繁交互和数据传递，提高效率。</p>
<p>Wayland工作机制如下：去掉了X Server中间层，直接将渲染工作交给了Compositor（相当于X Server+WindowManager），减少了Client/Server通信和X Server的重复工作。</p>
<img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/Wayland工作流程.png" style="zoom:60%;">



<p>Wayland和XWindow的主要区别在于</p>
<ul>
<li>X Window在服务端绘制：XClient调用XLib绘制指令，传给X Server，X Server进行绘制计算存入Buffer，通知合成器（Compositor）合成图像，再将合成的图像渲染到屏幕。当然现代的X Client也可以做渲染（通过Cairo、GTK+、QT等）</li>
<li>Wayland在客户端绘制：客户端自行计算绘制的图形，放到Buffer中（可以是共享内存，也可以是显存），请求服务端Wayland Compositor合成图像，渲染到屏幕上。</li>
</ul>
<p>其他区别：</p>
<ul>
<li>X提供了网络协议，Wayland本身不提供网络传输，但是合成器可以实现不同的后端（X11、RDP等）</li>
</ul>
<h2 id="Wayland-Weston"><a href="#Wayland-Weston" class="headerlink" title="Wayland/Weston"></a>Wayland/Weston</h2><p>Wayland和X Window System一样，是一种协议。Weston是Wayland的参考实现，类似X Window中的Xorg。</p>
<h3 id="Weston架构"><a href="#Weston架构" class="headerlink" title="Weston架构"></a>Weston架构</h3><p>Weston模块和工作流程如下</p>
<img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/Weston工作流程.png" style="zoom:80%;">

<p>Weston Server内部分为输入管理（InputManager）、窗口管理（Shell）、合成器（Compositor）几个部分。类似于Android的InputManagerService、WindowManagerService和SurfaceFlinger。</p>
<p>Server主循环通过epoll机制等待文件fd（文件描述符），例如监听设备fd输入，listener fd监听Client连接等。</p>
<p>Client和Server之间通过Domain Socket连接通信。</p>
<blockquote>
<p>Domain Socket是UNIX的一种IPC机制，通过绑定socket文件接收和发送数据</p>
</blockquote>
<p>Weston自带了一些核心Client和简单用例，如下：</p>
<ol>
<li>weston-desktop-shell：负责一些系统全局界面，如桌面图标、状态栏等</li>
<li>weston-keyboard：软键盘面板</li>
<li>weston-screenshooter：截屏</li>
<li>weston-screensaver：屏保</li>
</ol>
<p>Weston Server启动过程中会加载几个backend，<strong>backend可以有不同的实现，可以以动态链接库的形式被加载</strong>，如下：</p>
<ol>
<li>shell backend（桌面后端）：实现窗口管理功能，如desktop-shell、fullscreen-shell、ivi-shell（车载桌面）</li>
<li>renderer backend（渲染后端）：处理Client渲染后的内容，负责合成所有窗口，如pixman（软件渲染）、gl（GPU硬件渲染）、noop</li>
<li>compositor backend（合成后端）：处理合成之后的内容<ol>
<li>DRM（Direct Rendering Module），一般用于Linux桌面系统</li>
<li>fbdev（FrameBuffer设备驱动）：直接输出到Linux的FrameBuffer</li>
<li>RPI（Raspberry PI）：用于树莓派平台</li>
<li>RDP（Remote Desktop Protocal，远程桌面协议）：合成后通过RDP传输到远程桌面</li>
<li>x11：Wayland Compositor作为X Server的Client，运行在X11上</li>
<li>Wayland：Wayland Compositor作为Server的同时，也作为另一个Wayland Compositor的Client</li>
<li>…</li>
</ol>
</li>
</ol>
<img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/Weston架构.png" style="zoom:70%;">

<h3 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h3><img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/Wayland渲染流水线.png" style="zoom:80%;">

<ol>
<li>Client申请一块Graphic Buffer（可以是共享内存、DRM中的GEM、gralloc分配的显存）</li>
<li>客户端自行绘制，存入BufferQueue</li>
<li>通过Wayland协议（Domain Socket连接）将Buffer的handle（fd）传给Server</li>
<li>Server生成z-order序的窗口栈</li>
<li>Server使用renderer backend将Buffer转为纹理，并与其他窗口内容合成最终图像</li>
<li>通过compositor backend输出到屏幕</li>
</ol>
<blockquote>
<p>移动平台上一般没有专门的显存，实际是系统内存，区别在于图形加速硬件一般要求物理连续且符合要求的内存，普通共享内存一般是物理不连续的</p>
</blockquote>
<p>Android SurfaceFlinger由服务端分配Buffer。而Wayland中buffer默认是由Client端分配，理论上可以始终只用一块Buffer，但是由于Client和Server同时访问会产生竞争，所以一般Client端都会实现BufferQueue。</p>
<p><strong>Client和Server都会发生绘制：Client绘制本地窗口内容，Server用于合成时渲染。两边都可以选择软件或者硬件渲染</strong>。软件渲染如Direct Painting，Cairo，硬件渲染如OpenGL等</p>
<h2 id="窗口管理器"><a href="#窗口管理器" class="headerlink" title="窗口管理器"></a>窗口管理器</h2><p>在现代的合成桌面系统中，X服务器只提供了生成窗口的方法，真正负责窗口控制（标题栏、边框、移动、缩放等功能）和多窗口合成的是窗口管理器（Window Manager），一般由桌面环境提供。</p>
<p>KDE（K Desktop Enviorment）和GNOME（The GNU Network Object Model Environment）是桌面环境（类似于Window桌面、手机桌面等）。除了窗口管理器的功能外，还包括任务栏，开始菜单、桌面图标，以及一系列自带的GUI程序（如gnome-help、gnome-calculator等）等。<strong>本质是一个X Client应用程序，与其他应用同级</strong>。</p>
<blockquote>
<p>KDE基于QT开发，GNOME基于GTK+开发。</p>
<p>XFree86中自带了一个窗口管理器twm（Tab Window Manager）。</p>
<ul>
<li>GNOME桌面使用GDM（The GNOME Display Manager）作为窗口管理器。</li>
<li>GNOME3桌面使用Mutter作为窗口管理器，Mutter基于Clutter库开发</li>
<li>Ubuntu Unity桌面在10.10时使用Mutter，后来使用Compiz作为窗口管理器，Compiz基于OpenGL开发</li>
<li>KDE桌面使用KWin作为窗口管理器</li>
</ul>
<p>其他桌面环境如：LXDE（Lightweight X11 Desktop Environment）、Xfce等</p>
</blockquote>
<p>开机启动X服务器，X服务器启动桌面应用，进入图形界面，桌面显示任务栏，开始菜单、桌面图标等。可以打开关闭其他应用，控制窗口大小、移动、关闭等。</p>
<blockquote>
<p>如果不使用窗口管理器，直接打开X应用程序（如浏览器），此时浏览器不能移动、不能最小化、最大化，没有边框。</p>
<p>演示：</p>
<ol>
<li>开机进入图形界面</li>
<li>打开XTerm，输入<code>init 3</code>，回到字符界面</li>
<li>输入<code>startx</code>，启动X服务器，同时启动了一个窗口管理器。进入桌面，和正常开机一样，可以操作窗口</li>
<li>按<code>ctrl+alt+backspace</code>退出</li>
<li>输入<code>xinit</code>，启动X服务器，此时可以看到一个XTerm应用，但是不能移动</li>
<li>在这个XTerm中输入<code>mozilla</code>，打开浏览器，由于没有窗口浏览器，无法移动，不能最小化、最大化，没有边框</li>
</ol>
</blockquote>
<h1 id="图形系统架构"><a href="#图形系统架构" class="headerlink" title="图形系统架构"></a>图形系统架构</h1><p>X Window窗口管理器和X Server分开，通信繁琐，且存在重复工作。</p>
<p>Wayland更简单一些，窗口管理器内置在Wayland Compositor中，基于EGL接口。</p>
<img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/图形系统架构.png" style="zoom:100%;">

<p>X Server使用OpenGL的扩展GLX也可以渲染3D，但是3D绘制信息多，通过X协议传输绘制性能较低。因此出现了使用DRI框架，由客户端直接渲染到Buffer中，再交给Compositor进行合成。</p>
<p>Client可以支持不同的协议，使用不同的后端，选择直接渲染或者间接渲染，开发套件已经封装好了，例如QT支持OpenGL、XLib等后端，Cairo支持Skia、DRM、GL、XLib等后端。</p>
<p>X Server和Wayland Server本质也是应用程序，可以使用不同的渲染引擎。</p>
<p>借用一下网上的图片：</p>
<img src="/2022/02/12/tech-2022-02-12-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/图形系统架构层级.png" style="zoom:100%;">

<p>其他概念解释：</p>
<ul>
<li>DIX（Device Independent X，设备无关层）：为X Server提供统一的接口，与底层设备无关</li>
<li>DDX（Device Dependent X，设备相关层）：X Server的2D硬件驱动，用于访问显卡硬件，实现2D加速，由显卡厂商实现。</li>
<li>DRI（Direct Rendering Infrastructure，直接渲染框架）：是一套软件架构，不是单个软件或库。用于为用户态程序提供直接渲染功能，涉及Kernel层、XServer层、应用层。</li>
<li>DRM（Direct Rendering Moudle，直接渲染模块）：Linux内核模块，是DRI框架的一个组件。分为两层：通用DRM接口和显卡驱动实现<ul>
<li>libDRM：DRM接口封装，用于用户态程序管理显存（例如分配显存、DMA操作、访问FrameBuffer等），由显卡厂商实现接口。例如libDRM-intel（Intel显卡）、libDRM-radeon（AMD镭龙显卡）、libDRM-nouveau（Nvidia显卡）、libDRM-freedreno（高通Adreno显卡）</li>
</ul>
</li>
<li>KMS（Kernel Mode Setting）：负责分辨率、刷新率等相关参数设置和显示画面切换</li>
<li>GEM（Graphic Execution Manager）：负责Buffer管理，通过DMA机制</li>
<li>DMA（Direct Memory Access，直接存储器访问）：外部设备直接与系统内存交换数据，不经过CPU。解决批量数据传输的问题。</li>
<li>MMIO（Memory-mapped I/O，内存映射I/O）：将I/O设备空间映射到内存空间中，可以像访问内存一样访问外部设备资源</li>
<li>OpenVG（Open Vector Graphics）：2D矢量图形库</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>查看Flutter嵌入层相关的项目介绍时，出现很多陌生的名词Wayland、X11、DRM等，越搜越懵，涉及到GLX、GLFW、KDE、GNOME等概念、工具。结合多篇文章，反复看，终于简单理解了这些名词之间的关系，在此做个总结。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://happyseeker.github.io/graphic/2016/01/25/Graphic-stack.html">图形栈&amp;架构</a></li>
<li><a href="https://learnopengl-cn.github.io/">Learn OpenGL CN</a></li>
<li><a href="https://sh.alynx.one/posts/Difference-between-X-and-Wayland/">X和Wayland的主要区别</a></li>
<li><a href="https://magcius.github.io/xplain/article/">xplain</a>：XWindow介绍，包含大量演示案例</li>
<li><a href="https://blog.csdn.net/jinzhuojun/article/details/47290707">Wayland与Weston简介</a></li>
<li><a href="http://cn.linux.vbird.org/linux_basic/0590xwindow_1.php">X Window配置介绍</a>：鸟哥的Linux私房菜</li>
<li><a href="https://www.it610.com/article/1290551243260895232.htm">OpenGL/Vulkan/Cairo/Skia/angle/VTK/OpenVG/GIMP/Krita等开源绘图库或软件收集</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Linux</tag>
        <tag>图形</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter启动流程</title>
    <url>/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Flutter启动流程-Java层"><a href="#Flutter启动流程-Java层" class="headerlink" title="Flutter启动流程-Java层"></a>Flutter启动流程-Java层</h1><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><h3 id="FlutterActivity-onCreate"><a href="#FlutterActivity-onCreate" class="headerlink" title="FlutterActivity#onCreate"></a>FlutterActivity#onCreate</h3><ol>
<li>创建代理类，并传入this。Host接口提供子类Hook，代理类中会在特定时机回调接口通知宿主，例如配置<code>FlutterEngine</code></li>
<li><code>delegate.onAttach</code>：创建<code>FlutterEngine</code></li>
<li><code>delegate.onCreateView</code>：创建<code>FlutterView</code>，设置为ContentView</li>
<li><code>getFlutterShellArgs()</code>：从Intent中获取Flutter参数</li>
</ol>
<blockquote>
<p>通过代理的方式，使<code>FlutterActivity</code>和<code>FlutterFragment</code>共用代理类逻辑，避免重复编码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//./shell/platform/android/io/flutter/embedding/android/FlutterActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">FlutterActivityAndFragmentDelegate</span>.<span class="title">Host</span>, <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Activity和Fragment继承Host接口，可以实现不同Hook方法逻辑</span></span><br><span class="line">    delegate = <span class="keyword">new</span> FlutterActivityAndFragmentDelegate(<span class="keyword">this</span>);</span><br><span class="line">    delegate.onAttach(<span class="keyword">this</span>);</span><br><span class="line">    delegate.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">    <span class="comment">// 通过代理类创建FlutterView，添加到界面上</span></span><br><span class="line">    setContentView(createFlutterView());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> View <span class="title">createFlutterView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.onCreateView(...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从Intent中解析Flutter参数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FlutterShellArgs <span class="title">getFlutterShellArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FlutterShellArgs.fromIntent(getIntent());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FlutterActivityAndFragmentDelegate"><a href="#FlutterActivityAndFragmentDelegate" class="headerlink" title="FlutterActivityAndFragmentDelegate"></a>FlutterActivityAndFragmentDelegate</h3><ol>
<li><code>setupFlutterEngine</code>：<strong>创建<code>FlutterEngine</code></strong></li>
<li>配置PlatformPlugin（平台插件）：用于接收Flutter消息，调用系统方法，例如播放声音，状态栏、导航栏、剪贴板等</li>
<li>配置引擎：例如注册FlutterPlugin（Flutter插件）</li>
<li>**创建<code>FlutterSurfaceView</code>或者<code>FlutterTextureView</code>**：默认使用SurfaceView，无法像普通View一样使用动画和z-index</li>
<li><strong>实例化FlutterView</strong>：addView添加<code>FlutterSurfaceView</code>，并添加首帧渲染监听（最终会注册到FlutterJNI中，由Native层回调通知）</li>
<li><code>flutterView.attachToFlutterEngine</code>：<strong>FlutterView绑定引擎</strong></li>
<li>如果配置了闪屏页，还会启动闪屏页，在Flutter引擎初始化、到首帧渲染完成之间显示。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./shell/platform/android/io/flutter/embedding/android/FlutterActivityAndFragmentDelegate.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterActivityAndFragmentDelegate</span> </span>&#123;</span><br><span class="line">  FlutterActivityAndFragmentDelegate(<span class="meta">@NonNull</span> Host host) &#123;</span><br><span class="line">    <span class="keyword">this</span>.host = host; <span class="comment">// 保存FlutterActivity对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Flutter引擎</span></span><br><span class="line">    setupFlutterEngine();</span><br><span class="line">    <span class="comment">// 创建PlatformPlugin，和Activity绑定</span></span><br><span class="line">    <span class="comment">// Fragment每次绑定Activity的时候都会重新创建</span></span><br><span class="line">    platformPlugin = host.providePlatformPlugin(host.getActivity(), flutterEngine);</span><br><span class="line">    <span class="comment">// 配置Flutter引擎</span></span><br><span class="line">    host.configureFlutterEngine(flutterEngine);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function">View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建FlutterSurfaceView，用于提供绘制Flutter UI的Surface。也可以是FlutterTextureView</span></span><br><span class="line">    FlutterSurfaceView flutterSurfaceView = <span class="keyword">new</span> FlutterSurfaceView(host.getContext(), host.getTransparencyMode() == TransparencyMode.transparent);</span><br><span class="line">    <span class="comment">// 通知子类Hook</span></span><br><span class="line">    host.onFlutterSurfaceViewCreated(flutterSurfaceView);</span><br><span class="line">    <span class="comment">// 创建FlutterView</span></span><br><span class="line">    flutterView = <span class="keyword">new</span> FlutterView(host.getContext(), flutterSurfaceView);</span><br><span class="line">    <span class="comment">// 添加首帧渲染监听，通知子类Hook，最终会注册到FlutterJNI中，由Native层调用</span></span><br><span class="line">    flutterView.addOnFirstFrameRenderedListener(flutterUiDisplayListener);</span><br><span class="line">    <span class="comment">// 绑定Flutter引擎</span></span><br><span class="line">    flutterView.attachToFlutterEngine(flutterEngine);</span><br><span class="line">    <span class="comment">// 显示闪屏页，从Manifest中读取</span></span><br><span class="line">    SplashScreen splashScreen = host.provideSplashScreen();</span><br><span class="line">    <span class="keyword">if</span> (splashScreen != <span class="keyword">null</span>) &#123;</span><br><span class="line">      FlutterSplashView flutterSplashView = <span class="keyword">new</span> FlutterSplashView(host.getContext());</span><br><span class="line">      flutterSplashView.setId(ViewUtils.generateViewId(FLUTTER_SPLASH_VIEW_FALLBACK_ID));</span><br><span class="line">      flutterSplashView.displayFlutterViewWithSplash(flutterView, splashScreen);</span><br><span class="line">      <span class="keyword">return</span> flutterSplashView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flutterView;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> flutterSplashView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这里包含两个关键步骤：由于流程比较长，拆开来介绍</p>
<ol>
<li><p>创建<code>FlutterEngine</code>：</p>
<ol>
<li>加载Flutter资源</li>
<li>解析Intent参数</li>
<li>绑定<code>FlutterJNI</code>实例</li>
</ol>
</li>
<li><p><code>FlutterView</code>绑定Flutter引擎</p>
<ol>
<li>创建<code>FlutterView</code>和<code>FlutterSurfaceView</code></li>
<li>创建<code>FlutterRenderer</code></li>
<li>将Surface和<code>FlutterRenderer</code>关联，并传给Flutter引擎</li>
<li>创建触摸、按键等监听器，将Android View事件发给Flutter引擎</li>
</ol>
</li>
</ol>
<p><img src="/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/FlutterActivity#onCreate.png"></p>
<h2 id="创建FlutterEngine"><a href="#创建FlutterEngine" class="headerlink" title="创建FlutterEngine"></a>创建FlutterEngine</h2><h3 id="setupFlutterEngine"><a href="#setupFlutterEngine" class="headerlink" title="setupFlutterEngine"></a>setupFlutterEngine</h3><p>首先看下<code>setupFlutterEngine()</code>方法如何获取FlutterEngine：</p>
<ol>
<li>从<code>FlutterEngineCache</code>缓存中获取预热的引擎，重写<code>getCachedEngineId()</code></li>
<li>子类自行创建引擎，重写<code>provideFlutterEngine</code>方法</li>
<li>创建默认引擎</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterActivityAndFragmentDelegate</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setupFlutterEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First, check if the host wants to use a cached FlutterEngine.</span></span><br><span class="line">    String cachedEngineId = host.getCachedEngineId();</span><br><span class="line">    <span class="keyword">if</span> (cachedEngineId != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flutterEngine = FlutterEngineCache.getInstance().get(cachedEngineId);</span><br><span class="line">      isFlutterEngineFromHost = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Second, defer to subclasses for a custom FlutterEngine.</span></span><br><span class="line">    flutterEngine = host.provideFlutterEngine(host.getContext());</span><br><span class="line">    <span class="keyword">if</span> (flutterEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      isFlutterEngineFromHost = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收Activity解析Intent的参数</span></span><br><span class="line">    flutterEngine = <span class="keyword">new</span> FlutterEngine(host.getContext(), host.getFlutterShellArgs().toArray(),</span><br><span class="line">            <span class="comment">/*automaticallyRegisterPlugins=*/</span> <span class="keyword">false</span>,</span><br><span class="line">            <span class="comment">/*willProvideRestorationData=*/</span> host.shouldRestoreAndSaveState());</span><br><span class="line">    isFlutterEngineFromHost = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看FlutterEngine实例化：</p>
<ol>
<li><code>FlutterJNI</code>：沟通Android和Flutter引擎Native代码</li>
<li><code>FlutterLoader</code>：加载Flutter资源、Kernel或者AOT Library路径。通过FlutterJNI初始化Native引擎</li>
<li><code>DartExecutor</code>：用于配置、启动、执行Dart代码。<strong>原生通过JNI和Dart通信</strong>。<ol>
<li>Java层调用<code>FlutterJNI.dispatchPlatformMessage</code>将消息发到Native层</li>
<li>Native层调用<code>FlutterJNI.handlePlatformMessage</code>通知Java层</li>
</ol>
</li>
<li><code>XXXChannel</code>：创建不同的消息通道，监听和处理固定的事件，需要通过<code>DartMessenger</code>来传递消息<ol>
<li><code>PlatformChannel</code>：内部使用<code>MethodChannel</code>，通知Dart层SystemUI变化，接收Dart层消息修改SystemUI、设置剪贴板等</li>
<li><code>LifecycleChannel</code>：内部使用<code>BasicMessageChannel</code>，生命周期变化时通知Dart层</li>
<li>…</li>
</ol>
</li>
</ol>
<blockquote>
<p>Channel只是封装了不同类型的消息，以及响应和处理特定消息。最终都是通过<code>DartExecutor</code>调用JNI方法将消息发给Native层。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterEngine</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FlutterEngine</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    FlutterInjector injector = FlutterInjector.instance();</span><br><span class="line">    <span class="keyword">if</span> (flutterJNI == <span class="keyword">null</span>) &#123;</span><br><span class="line">      flutterJNI = injector.getFlutterJNIFactory().provideFlutterJNI();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.flutterJNI = flutterJNI;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过AssetManager获取Assets资源</span></span><br><span class="line">    <span class="keyword">this</span>.dartExecutor = <span class="keyword">new</span> DartExecutor(flutterJNI, assetManager);</span><br><span class="line">    <span class="comment">//注册PlatformMessageHandler，FlutterJNI收到Dart调用后转发给DartExecutor，再分发给特定的处理者</span></span><br><span class="line">    <span class="keyword">this</span>.dartExecutor.onAttachedToJNI();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建各个消息通道（例如触摸、按键、生命周期、导航跳转等），将消息发送给Dart，并且接收Dart的onMethodCall</span></span><br><span class="line">    xxxChannel = <span class="keyword">new</span> XXXChannel(dartExecutor, flutterJNI);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flutterLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      flutterLoader = injector.flutterLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载Flutter资源、Kernel或者AOT Library路径</span></span><br><span class="line">    <span class="keyword">if</span> (!flutterJNI.isAttached()) &#123;</span><br><span class="line">      <span class="comment">//异步加载Flutter资源</span></span><br><span class="line">      flutterLoader.startInitialization(context.getApplicationContext());</span><br><span class="line">      <span class="comment">//获取Activity中的Intent参数，通过FlutterJNI传给Flutter引擎</span></span><br><span class="line">      flutterLoader.ensureInitializationComplete(context, dartVmArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于spawn生成的引擎，Native已经绑定过JNI实例，因此FlutterJNI由Native Shell创建，不需要再attach</span></span><br><span class="line">    <span class="comment">// It should typically be a fresh, unattached JNI. But on a spawned engine, the JNI instance</span></span><br><span class="line">    <span class="comment">// is already attached to a native shell. In that case, the Java FlutterEngine is created around</span></span><br><span class="line">    <span class="comment">// an existing shell.</span></span><br><span class="line">    <span class="keyword">if</span> (!flutterJNI.isAttached()) &#123;</span><br><span class="line">      attachToJni();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.renderer = <span class="keyword">new</span> FlutterRenderer(flutterJNI);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spawn方法用于创建多个Flutter引擎，通过<code>FlutterEngineGroup</code>类进行管理，spawn引擎都由第一个引擎生成，避免重复绑定JNI对象</p>
</blockquote>
<h3 id="加载Flutter资源，解析Intent参数"><a href="#加载Flutter资源，解析Intent参数" class="headerlink" title="加载Flutter资源，解析Intent参数"></a>加载Flutter资源，解析Intent参数</h3><ol>
<li><p><code>ApplicationInfoLoader.load</code>从<code>meta-data</code>配置中读取Flutter资源名称，不配置的话默认值如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterApplicationInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AOT_SHARED_LIBRARY_NAME = <span class="string">&quot;libapp.so&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_VM_SNAPSHOT_DATA = <span class="string">&quot;vm_snapshot_data&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ISOLATE_SNAPSHOT_DATA = <span class="string">&quot;isolate_snapshot_data&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_FLUTTER_ASSETS_DIR = <span class="string">&quot;flutter_assets&quot;</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>异步从Apk中提取Flutter资源，加载Flutter引擎so库</p>
</li>
<li><p><code>ensureInitializationComplete</code>：获取Activity中的Intent参数，通过<code>FlutterJNI</code>传给Flutter引擎：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FlutterLoader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterLoader</span> </span>&#123;</span><br><span class="line">  <span class="comment">//异步加载Flutter资源</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInitialization</span><span class="params">(<span class="meta">@NonNull</span> Context applicationContext, <span class="meta">@NonNull</span> Settings settings)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只会初始化一次</span></span><br><span class="line">    <span class="comment">// Do not run startInitialization more than once.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.settings != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.settings = settings;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//检查是否在主线程调用</span></span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;startInitialization must be called on the main thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从配置的meta-data中读取so库、snapshot、assets目录等名称</span></span><br><span class="line">    flutterApplicationInfo = ApplicationInfoLoader.load(appContext);</span><br><span class="line">    Callable&lt;InitResult&gt; initTask = <span class="keyword">new</span> Callable&lt;InitResult&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> InitResult <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//从Apk中提取资源：snapshot、kernel中间代码等</span></span><br><span class="line">            ResourceExtractor resourceExtractor = initResources(appContext);</span><br><span class="line">            <span class="comment">//加载Native库</span></span><br><span class="line">            flutterJNI.loadLibrary();</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (resourceExtractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">              resourceExtractor.waitForCompletion();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InitResult(</span><br><span class="line">                PathUtils.getFilesDir(appContext),</span><br><span class="line">                PathUtils.getCacheDirectory(appContext),</span><br><span class="line">                PathUtils.getDataDirectory(appContext));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">//子线程执行</span></span><br><span class="line">    initResultFuture = Executors.newSingleThreadExecutor().submit(initTask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取Activity中的Intent参数，通过`FlutterJNI`传给Flutter引擎</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureInitializationComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Context applicationContext, <span class="meta">@Nullable</span> String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//等待资源初始化完毕</span></span><br><span class="line">      InitResult result = initResultFuture.get();</span><br><span class="line">      List&lt;String&gt; shellArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//初始化FlutterJNI，以shell参数的形式传给Native</span></span><br><span class="line">      flutterJNI.init(</span><br><span class="line">          applicationContext,</span><br><span class="line">          shellArgs.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]),</span><br><span class="line">          kernelPath,</span><br><span class="line">          result.appStoragePath,</span><br><span class="line">          result.engineCachesPath,</span><br><span class="line">          initTimeMillis);</span><br><span class="line">      initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Flutter initialization failed.&quot;</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FlutterJNI实例和引擎绑定"><a href="#FlutterJNI实例和引擎绑定" class="headerlink" title="FlutterJNI实例和引擎绑定"></a>FlutterJNI实例和引擎绑定</h3><p><code>FlutterEngine.attachToJni();</code>中调用<code>FlutterJNI.attachToNative</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FlutterJNI.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterJNI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachToNative</span><span class="params">(<span class="keyword">boolean</span> isBackgroundView)</span> </span>&#123;</span><br><span class="line">    ensureRunningOnMainThread();</span><br><span class="line">    ensureNotAttachedToNative();</span><br><span class="line">    nativeShellHolderId = performNativeAttach(<span class="keyword">this</span>, isBackgroundView);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">performNativeAttach</span><span class="params">(<span class="meta">@NonNull</span> FlutterJNI flutterJNI, <span class="keyword">boolean</span> isBackgroundView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeAttach(flutterJNI, isBackgroundView);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeAttach</span><span class="params">(<span class="meta">@NonNull</span> FlutterJNI flutterJNI, <span class="keyword">boolean</span> isBackgroundView)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>创建和绑定Flutter引擎</p>
<ol>
<li><code>DartExecutor</code>：注册平台通信通道，直接和<code>FlutterJNI</code>通信</li>
<li><code>XXXChannel</code>：注册监听和响应特定的Dart消息，通过<code>DartExecutor</code>分发消息，不直接和<code>FlutterJNI</code>交互</li>
<li><code>FlutterLoader</code>：<ol>
<li><code>startInitialization()</code>：异步从APK中提取资源</li>
<li><code>ensureInitializationComplete()</code>：调用<code>FlutterJNI.nativeInit()</code>方法法，解析和保存Intent参数</li>
</ol>
</li>
<li><code>FlutterJNI.nativeAttach()</code>：创建和绑定Flutter引擎</li>
</ol>
<blockquote>
<p>这里涉及到两个JNI方法<code>nativeInit和nativeAttach</code>，后面会分析到</p>
</blockquote>
<p><img src="/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/FlutterEngine%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="FlutterView关联引擎"><a href="#FlutterView关联引擎" class="headerlink" title="FlutterView关联引擎"></a>FlutterView关联引擎</h2><p>查看<code>FlutterView.attachToFlutterEngine</code>源码</p>
<ol>
<li><code>FlutterRenderer</code>：Flutter渲染在Java层的代言人，封装渲染相关的操作，通过<code>FlutterJNI</code>和Native交互</li>
<li><code>FlutterSurfaceView</code>：创建Android Surface，通过<code>FlutterRenderer</code>传给Native操作</li>
<li>通过<code>KeyBoardManager</code>和<code>AndroidTouchProcessor</code>等将Android事件传递给引擎</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">MouseCursorPlugin</span>.<span class="title">MouseCursorViewDelegate</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachToFlutterEngine</span><span class="params">(<span class="meta">@NonNull</span> FlutterEngine flutterEngine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flutterEngine = flutterEngine;</span><br><span class="line">    FlutterRenderer flutterRenderer = <span class="keyword">this</span>.flutterEngine.getRenderer();</span><br><span class="line">    <span class="comment">//FlutterSurfaceView的Surface提供给引擎的Renderer，将Flutter UI绘制到FlutterSurfaceView</span></span><br><span class="line">    renderSurface.attachToRenderer(flutterRenderer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建KeyBoardManager和AndroidTouchProcessor等，将Android事件传给Dart和Native层</span></span><br><span class="line">    keyboardManager = <span class="keyword">new</span> KeyboardManager(<span class="keyword">this</span>, textInputPlugin, <span class="keyword">new</span> KeyChannelResponder[] &#123;</span><br><span class="line">      <span class="keyword">new</span> KeyChannelResponder(flutterEngine.getKeyEventChannel())</span><br><span class="line">    &#125;);</span><br><span class="line">    androidTouchProcessor =</span><br><span class="line">        <span class="keyword">new</span> AndroidTouchProcessor(<span class="keyword">this</span>.flutterEngine.getRenderer(), <span class="comment">/*trackMotionEvents=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将安卓系统配置发给Flutter，例如字体缩放、日期格式、夜间模式、Locale等</span></span><br><span class="line">    sendUserSettingsToFlutter();</span><br><span class="line">    localizationPlugin.sendLocalesToFlutter(getResources().getConfiguration());</span><br><span class="line">    sendViewportMetricsToFlutter();</span><br><span class="line">    </span><br><span class="line">    flutterEngine.getPlatformViewsController().attachToView(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置ViewPort</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendViewportMetricsToFlutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    flutterEngine.getRenderer().setViewportMetrics(viewportMetrics);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attachToRenderer</code>：调用<code>nativeSurfaceCreated()</code>将<code>Surface</code>传到Native层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterRenderer</span> <span class="keyword">implements</span> <span class="title">TextureRegistry</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachToRenderer</span><span class="params">(<span class="meta">@NonNull</span> FlutterRenderer flutterRenderer)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果已经连接一个Renderer，则移除，重新连接新的Renderer </span></span><br><span class="line">    <span class="comment">//onSurfaceCreated之后可以连接Renderer</span></span><br><span class="line">    <span class="keyword">if</span> (isSurfaceAvailableForRendering) &#123;</span><br><span class="line">      connectSurfaceToRenderer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSurfaceToRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Renderer、getHolder不为空</span></span><br><span class="line">    flutterRenderer.startRenderingToSurface(getHolder().getSurface());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startRenderingToSurface</span><span class="params">(<span class="meta">@NonNull</span> Surface surface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.surface != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stopRenderingToSurface();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.surface = surface;</span><br><span class="line">    <span class="comment">//将surface传给Native层</span></span><br><span class="line">    flutterJNI.onSurfaceCreated(surface);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/FlutterView%E5%85%B3%E8%81%94%E5%BC%95%E6%93%8E.png"></p>
<h2 id="Flutter代码执行入口"><a href="#Flutter代码执行入口" class="headerlink" title="Flutter代码执行入口"></a>Flutter代码执行入口</h2><p>上面几步完成了Flutter引擎、FlutterView、FlutterJNI等创建和绑定。但是还没执行开发者写的Flutter代码。</p>
<h3 id="FlutterActivity-onStart"><a href="#FlutterActivity-onStart" class="headerlink" title="FlutterActivity#onStart"></a>FlutterActivity#onStart</h3><p>还是从<code>FlutterActivity</code>开始分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">FlutterActivityAndFragmentDelegate</span>.<span class="title">Host</span>, <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">    <span class="keyword">if</span> (stillAttachedForEvent(<span class="string">&quot;onStart&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">//调用代理类的onStart方法</span></span><br><span class="line">      delegate.onStart();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FlutterActivityAndFragmentDelegate-1"><a href="#FlutterActivityAndFragmentDelegate-1" class="headerlink" title="FlutterActivityAndFragmentDelegate"></a>FlutterActivityAndFragmentDelegate</h3><ol>
<li>检查Dart代码是否已经执行</li>
<li>从Intent中获取Flutter初始页面路由</li>
<li>找到Dart程序入口，执行Dart代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterActivityAndFragmentDelegate</span> <span class="keyword">implements</span> <span class="title">ExclusiveAppComponent</span>&lt;<span class="title">Activity</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.v(TAG, <span class="string">&quot;onStart()&quot;</span>);</span><br><span class="line">    ensureAlive();</span><br><span class="line">    doInitialFlutterViewRun();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInitialFlutterViewRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t attempt to start a FlutterEngine if we&#x27;re using a cached FlutterEngine.</span></span><br><span class="line">    <span class="keyword">if</span> (host.getCachedEngineId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//onStart每次页面切换都会调用，只需要执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (flutterEngine.getDartExecutor().isExecutingDart()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从Activity或者Intent中获取Flutter初始页面路由</span></span><br><span class="line">    String initialRoute = host.getInitialRoute();</span><br><span class="line">    <span class="keyword">if</span> (initialRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">      initialRoute = maybeGetInitialRouteFromIntent(host.getActivity().getIntent());</span><br><span class="line">      <span class="keyword">if</span> (initialRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">        initialRoute = DEFAULT_INITIAL_ROUTE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置初始路由</span></span><br><span class="line">    flutterEngine.getNavigationChannel().setInitialRoute(initialRoute);</span><br><span class="line">    String appBundlePathOverride = host.getAppBundlePath();</span><br><span class="line">    <span class="keyword">if</span> (appBundlePathOverride == <span class="keyword">null</span> || appBundlePathOverride.isEmpty()) &#123;</span><br><span class="line">      appBundlePathOverride = FlutterInjector.instance().flutterLoader().findAppBundlePath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置Dart代码执行入口，一般是main函数</span></span><br><span class="line">    DartExecutor.DartEntrypoint entrypoint =</span><br><span class="line">        <span class="keyword">new</span> DartExecutor.DartEntrypoint(appBundlePathOverride, host.getDartEntrypointFunctionName());</span><br><span class="line">    <span class="comment">//执行Dart代码</span></span><br><span class="line">    flutterEngine.getDartExecutor().executeDartEntrypoint(entrypoint);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会调用<code>FlutterJNI</code>的<code>nativeRunBundleAndSnapshotFromLibrary</code></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/FlutterActivity#onStart.png"></p>
<h1 id="FlutterJNI动态注册Native方法"><a href="#FlutterJNI动态注册Native方法" class="headerlink" title="FlutterJNI动态注册Native方法"></a>FlutterJNI动态注册Native方法</h1><p>Flutter引擎和Flutter代码最终会被打包成Native动态库<code>libengine.so</code>、<code>libapp.so</code>。</p>
<p>而JNI是Java和Native通信的桥梁，因此这里先介绍下Flutter注册的方法，后面分析源码时可以直接找到对应的Native方法。</p>
<p>Flutter在Java层提供了唯一的入口<code>FlutterJNI</code>，在Native层对应多个类，核心接口是<code>PlatformViewAndroid</code></p>
<ol>
<li><code>FlutterMain</code>：主要负责解析Java层参数</li>
<li><code>PlatformViewAndroid</code>：实现<code>PlatformView</code><strong>平台通用接口</strong>，负责Surface创建，事件分发，PlatformMessage通知等</li>
<li><code>VsyncWaiterAndroid</code>：实现<code>VsyncWaiter</code><strong>平台通用接口</strong>，监听Vsync信号，通知引擎进行绘制。</li>
<li><code>AndroidImageGenerator</code>：备用的图片解码方法，引擎根据需要调用Android方法进行解码，解码完成之后通知Native层</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//library_loader.cc</span></span><br><span class="line"><span class="comment">// 首次加载so库时，由虚拟机调用</span></span><br><span class="line"><span class="comment">// This is called by the VM when the shared library is first loaded.</span></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize the Java VM.</span></span><br><span class="line">  fml::jni::<span class="built_in">InitJavaVM</span>(vm);</span><br><span class="line">  JNIEnv* env = fml::jni::<span class="built_in">AttachCurrentThread</span>();</span><br><span class="line">  <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 初始化Native代码，解析参数</span></span><br><span class="line">  <span class="comment">// Register FlutterMain.</span></span><br><span class="line">  result = flutter::FlutterMain::<span class="built_in">Register</span>(env);</span><br><span class="line">  <span class="built_in">FML_CHECK</span>(result);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Register PlatformView</span></span><br><span class="line">  result = flutter::PlatformViewAndroid::<span class="built_in">Register</span>(env);</span><br><span class="line">  <span class="built_in">FML_CHECK</span>(result);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register VSyncWaiter.</span></span><br><span class="line">  result = flutter::VsyncWaiterAndroid::<span class="built_in">Register</span>(env);</span><br><span class="line">  <span class="built_in">FML_CHECK</span>(result);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register AndroidImageDecoder.</span></span><br><span class="line">  result = flutter::AndroidImageGenerator::<span class="built_in">Register</span>(env);</span><br><span class="line">  <span class="built_in">FML_CHECK</span>(result);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>FlutterMain</code>为例，JNI方法<code>FlutterJNI.nativeInit</code>对应<code>FlutterMain.Init</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_main.cc</span></span><br><span class="line"><span class="comment">//动态注册FlutterJNI方法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FlutterMain::Register</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">      &#123;</span><br><span class="line">          .name = <span class="string">&quot;nativeInit&quot;</span>,</span><br><span class="line">          .signature = <span class="string">&quot;(Landroid/content/Context;[Ljava/lang/String;Ljava/&quot;</span></span><br><span class="line">                       <span class="string">&quot;lang/String;Ljava/lang/String;Ljava/lang/String;J)V&quot;</span>,</span><br><span class="line">          .fnPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;Init),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          .name = <span class="string">&quot;nativePrefetchDefaultFontManager&quot;</span>,</span><br><span class="line">          .signature = <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">          .fnPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;PrefetchDefaultFontManager),</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  jclass clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;io/flutter/embedding/engine/FlutterJNI&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (clazz == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> env-&gt;<span class="built_in">RegisterNatives</span>(clazz, methods, fml::<span class="built_in">size</span>(methods)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Flutter启动流程-Native层"><a href="#Flutter启动流程-Native层" class="headerlink" title="Flutter启动流程-Native层"></a>Flutter启动流程-Native层</h1><p>上文分析过Java层的调用流程，涉及几个JNI方法，下面分析下Native层做了哪些事情</p>
<ol>
<li><code>nativeInit</code>：对应<code>flutter_main.cc</code>的<code>Init()</code>方法，解析Intent参数，保存到Settings结构体中</li>
<li><code>nativeAttach</code>：对应<code>platform_view_android_jni_impl.cc</code>的<code>AttachJNI()</code>方法<ol>
<li>创建<code>AndroidShellHolder</code></li>
<li>创建4个<code>TaskRunner</code>并指定线程，保存到<code>TaskRunners</code>中</li>
<li>在指定线程创建Shell、DartVM、Engine、PlatformView、Rasterizer、ShellIOManager等实例</li>
</ol>
</li>
<li><code>nativeSurfaceCreated</code>：<code>FlutterView</code>将Surface传给引擎</li>
<li><code>nativeRunBundleAndSnapshotFromLibrary</code>：执行Flutter代码</li>
</ol>
<blockquote>
<p>主要分析nativeAttach方法，其他方法分析流程类似</p>
</blockquote>
<h2 id="nativeInit"><a href="#nativeInit" class="headerlink" title="nativeInit"></a>nativeInit</h2><ol>
<li>调用<code>shell/common/switches.cc</code>的<code>SettingsFromCommandLine</code>解析参数，保存到<code>Settings</code>结构体中。</li>
<li>注意这里<code>switches</code>和<code>settings</code>都属于common包，所有平台通用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;flutter/shell/platform/android/flutter_main.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> flutter &#123;</span><br><span class="line">FlutterMain::<span class="built_in">FlutterMain</span>(flutter::Settings settings)</span><br><span class="line">    <span class="comment">//这种写法是给成员变量settings_赋值，引用settings变量</span></span><br><span class="line">    : <span class="built_in">settings_</span>(std::<span class="built_in">move</span>(settings)), <span class="built_in">observatory_uri_callback_</span>() &#123;&#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="function"><span class="keyword">const</span> flutter::Settings&amp; <span class="title">FlutterMain::GetSettings</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> settings_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FlutterJNI.nativeInit</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FlutterMain::Init</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jobject context,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jobjectArray jargs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jstring kernelPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jstring appStoragePath,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jstring engineCachesPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jlong initTimeMillis)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; args;</span><br><span class="line">  args.<span class="built_in">push_back</span>(<span class="string">&quot;flutter&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; arg : fml::jni::<span class="built_in">StringArrayToVector</span>(env, jargs)) &#123;</span><br><span class="line">    args.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(arg));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> command_line = fml::<span class="built_in">CommandLineFromIterators</span>(args.<span class="built_in">begin</span>(), args.<span class="built_in">end</span>());</span><br><span class="line">  <span class="comment">//shell/common/switches.cc</span></span><br><span class="line">  <span class="comment">//解析参数，保存到Settings架构体中</span></span><br><span class="line">  <span class="keyword">auto</span> settings = <span class="built_in">SettingsFromCommandLine</span>(command_line);</span><br><span class="line">  ...</span><br><span class="line">  g_flutter_main.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">FlutterMain</span>(std::<span class="built_in">move</span>(settings)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace flutter</span></span><br></pre></td></tr></table></figure>

<h2 id="nativeAttach"><a href="#nativeAttach" class="headerlink" title="nativeAttach"></a>nativeAttach</h2><h3 id="AttachJNI"><a href="#AttachJNI" class="headerlink" title="AttachJNI"></a>AttachJNI</h3><p>实例化<code>AndroidShellHolder</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platform_view_android_jni_impl.cc</span></span><br><span class="line"><span class="comment">// Called By Java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">AttachJNI</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jobject flutterJNI,</span></span></span><br><span class="line"><span class="function"><span class="params">                       jboolean is_background_view)</span> </span>&#123;</span><br><span class="line">  fml::<span class="function">jni::JavaObjectWeakGlobalRef <span class="title">java_object</span><span class="params">(env, flutterJNI)</span></span>;</span><br><span class="line">  std::shared_ptr&lt;PlatformViewAndroidJNI&gt; jni_facade =</span><br><span class="line">      std::make_shared&lt;PlatformViewAndroidJNIImpl&gt;(java_object);</span><br><span class="line">  <span class="comment">//实例化AndroidShellHolder</span></span><br><span class="line">  <span class="comment">//Settings在前面`FlutterLoader`初始化的时候调用`nativeInit`解析过了</span></span><br><span class="line">  <span class="keyword">auto</span> shell_holder = std::make_unique&lt;AndroidShellHolder&gt;(</span><br><span class="line">      FlutterMain::<span class="built_in">Get</span>().<span class="built_in">GetSettings</span>(), jni_facade, is_background_view);</span><br><span class="line">  <span class="keyword">if</span> (shell_holder-&gt;<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(shell_holder.<span class="built_in">release</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AndroidShellHolder"><a href="#AndroidShellHolder" class="headerlink" title="AndroidShellHolder"></a>AndroidShellHolder</h3><p><code>AndroidShellHolder</code>是<code>FlutterEngine</code>在C++端的顶级类，将<code>Shell</code>和<code>PlatformViewAndroid</code>等组合在一起。每个FlutterEngine对应一个<code>AndroidShellHolder</code>和一个<code>PlatformViewAndroid</code>。</p>
<ol>
<li>创建4个<code>TaskRunner</code>，通过<code>ThreadHost</code>指定线程，设置优先级，放到<code>TaskRunners</code>中统一管理</li>
<li>通过<code>Shell::Create</code>创建Shell对象，创建成功后回调将shell设置为<code>PlatformViewAndroid</code>的委托</li>
<li><code>GetPlatformView</code>函数返回<code>PlatformViewAndroid</code>对象，JNI几乎所有的调用都是通过<code>AndroidShellHolder</code>转发给<code>PlatformViewAndroid</code>处理</li>
<li>Launch函数用于启动引擎执行Dart代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android_shell_holder.cc</span></span><br><span class="line">AndroidShellHolder::<span class="built_in">AndroidShellHolder</span>(</span><br><span class="line">    flutter::Settings settings,</span><br><span class="line">    std::shared_ptr&lt;PlatformViewAndroidJNI&gt; jni_facade,</span><br><span class="line">    <span class="keyword">bool</span> is_background_view)</span><br><span class="line">    : <span class="built_in">settings_</span>(std::<span class="built_in">move</span>(settings)), <span class="built_in">jni_facade_</span>(jni_facade) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> thread_host_count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">auto</span> thread_label = std::<span class="built_in">to_string</span>(thread_host_count++);</span><br><span class="line">  <span class="comment">//4个Runner：Platform、UI、IO、GPU，可以运行在不同线程，也可以运行在相同线程</span></span><br><span class="line">  thread_host_ = std::make_shared&lt;ThreadHost&gt;();</span><br><span class="line">  <span class="keyword">if</span> (is_background_view) &#123;</span><br><span class="line">    <span class="comment">//Runner共用一个线程</span></span><br><span class="line">    *thread_host_ = &#123;thread_label, ThreadHost::Type::UI&#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//每个Runner独立线程</span></span><br><span class="line">    *thread_host_ = &#123;thread_label, ThreadHost::Type::UI |</span><br><span class="line">                                       ThreadHost::Type::RASTER |</span><br><span class="line">                                       ThreadHost::Type::IO&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  fml::WeakPtr&lt;PlatformViewAndroid&gt; weak_platform_view;</span><br><span class="line">  <span class="comment">//Shell创建时回调</span></span><br><span class="line">  Shell::CreateCallback&lt;PlatformView&gt; on_create_platform_view =</span><br><span class="line">      [is_background_view, &amp;jni_facade, &amp;weak_platform_view](Shell&amp; shell) &#123;</span><br><span class="line">        std::unique_ptr&lt;PlatformViewAndroid&gt; platform_view_android;</span><br><span class="line">        <span class="comment">//创建PlatformViewAndroid，委托类是shell对象</span></span><br><span class="line">        platform_view_android = std::make_unique&lt;PlatformViewAndroid&gt;(</span><br><span class="line">            shell,                   <span class="comment">// delegate</span></span><br><span class="line">            shell.<span class="built_in">GetTaskRunners</span>(),  <span class="comment">// task runners</span></span><br><span class="line">            jni_facade,              <span class="comment">// JNI interop</span></span><br><span class="line">            shell.<span class="built_in">GetSettings</span>().enable_software_rendering,  <span class="comment">// use software rendering</span></span><br><span class="line">            !is_background_view              <span class="comment">// create onscreen surface</span></span><br><span class="line">        );</span><br><span class="line">        weak_platform_view = platform_view_android-&gt;<span class="built_in">GetWeakPtr</span>();</span><br><span class="line">        <span class="keyword">auto</span> display = <span class="built_in">Display</span>(jni_facade-&gt;<span class="built_in">GetDisplayRefreshRate</span>());</span><br><span class="line">        shell.<span class="built_in">OnDisplayUpdates</span>(DisplayUpdateType::kStartup, &#123;display&#125;);</span><br><span class="line">        <span class="keyword">return</span> platform_view_android;</span><br><span class="line">      &#125;;</span><br><span class="line">  <span class="comment">//Shell创建时回调</span></span><br><span class="line">  Shell::CreateCallback&lt;Rasterizer&gt; on_create_rasterizer = [](Shell&amp; shell) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::make_unique&lt;Rasterizer&gt;(shell);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The current thread will be used as the platform thread. Ensure that the</span></span><br><span class="line">  <span class="comment">// message loop is initialized.</span></span><br><span class="line">  fml::MessageLoop::<span class="built_in">EnsureInitializedForCurrentThread</span>();</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; raster_runner;</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; ui_runner;</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; io_runner;</span><br><span class="line">  <span class="comment">//PlatformRunner引擎共享，其他三个Runner引擎独立</span></span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; platform_runner = fml::MessageLoop::<span class="built_in">GetCurrent</span>().<span class="built_in">GetTaskRunner</span>();</span><br><span class="line">  <span class="keyword">if</span> (is_background_view) &#123;</span><br><span class="line">    <span class="comment">//Runner运行在同一线程</span></span><br><span class="line">    <span class="keyword">auto</span> single_task_runner = thread_host_-&gt;ui_thread-&gt;<span class="built_in">GetTaskRunner</span>();</span><br><span class="line">    raster_runner = single_task_runner;</span><br><span class="line">    ui_runner = single_task_runner;</span><br><span class="line">    io_runner = single_task_runner;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Runner运行在不同线程</span></span><br><span class="line">    raster_runner = thread_host_-&gt;raster_thread-&gt;<span class="built_in">GetTaskRunner</span>();</span><br><span class="line">    ui_runner = thread_host_-&gt;ui_thread-&gt;<span class="built_in">GetTaskRunner</span>();</span><br><span class="line">    io_runner = thread_host_-&gt;io_thread-&gt;<span class="built_in">GetTaskRunner</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将四个Runner放到TaskRunners中统一管理</span></span><br><span class="line">  <span class="function">flutter::TaskRunners <span class="title">task_runners</span><span class="params">(thread_label,     <span class="comment">// label</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                    platform_runner,  <span class="comment">// platform</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                    raster_runner,    <span class="comment">// raster</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                    ui_runner,        <span class="comment">// ui</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                    io_runner         <span class="comment">// io</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>;</span><br><span class="line">  <span class="comment">//设置线程优先级，越小优先级越高</span></span><br><span class="line">  <span class="comment">//Raster优先级为-5</span></span><br><span class="line">  <span class="comment">//UI优先级为-1</span></span><br><span class="line">  <span class="comment">//IO优先级为1</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//创建Shell对象，回调创建PlatformView和Rasterizer</span></span><br><span class="line">  shell_ = Shell::<span class="built_in">Create</span>(<span class="built_in">GetDefaultPlatformData</span>(),  <span class="comment">// window data</span></span><br><span class="line">                         task_runners,              <span class="comment">// task runners</span></span><br><span class="line">                         settings_,                 <span class="comment">// settings</span></span><br><span class="line">                         on_create_platform_view,   <span class="comment">// platform view create callback</span></span><br><span class="line">                         on_create_rasterizer       <span class="comment">// rasterizer create callback</span></span><br><span class="line">                        );</span><br><span class="line">  ...</span><br><span class="line">  platform_view_ = weak_platform_view;</span><br><span class="line">  <span class="built_in">FML_DCHECK</span>(platform_view_);</span><br><span class="line">  is_valid_ = shell_ != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidShellHolder::Launch</span><span class="params">(std::shared_ptr&lt;AssetManager&gt; asset_manager,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> std::string&amp; entrypoint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> std::string&amp; libraryUrl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  asset_manager_ = asset_manager;</span><br><span class="line">  <span class="keyword">auto</span> config = <span class="built_in">BuildRunConfiguration</span>(asset_manager, entrypoint, libraryUrl);</span><br><span class="line">  <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//启动引擎</span></span><br><span class="line">  shell_-&gt;<span class="built_in">RunEngine</span>(std::<span class="built_in">move</span>(config.<span class="built_in">value</span>()));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">fml::WeakPtr&lt;PlatformViewAndroid&gt; <span class="title">AndroidShellHolder::GetPlatformView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">FML_DCHECK</span>(platform_view_);</span><br><span class="line">  <span class="keyword">return</span> platform_view_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PlatformViewAndroid"><a href="#PlatformViewAndroid" class="headerlink" title="PlatformViewAndroid"></a>PlatformViewAndroid</h3><ol>
<li><code>Register</code>静态方法，用于动态注册JNI方法</li>
<li>继承自<code>PlatformView</code>，并且构造函数包含<code>PlatformView::Delegate</code>委托对象和<code>PlatformViewAndroidJNI</code>对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shell/android/platform_view_android.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformViewAndroid</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> PlatformView &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//动态注册JNI方法</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Register</span><span class="params">(JNIEnv* env)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">PlatformViewAndroid</span>(PlatformView::Delegate&amp; delegate,</span><br><span class="line">                      flutter::TaskRunners task_runners,</span><br><span class="line">                      std::shared_ptr&lt;PlatformViewAndroidJNI&gt; jni_facade,</span><br><span class="line">                      <span class="keyword">bool</span> use_software_rendering,</span><br><span class="line">                      <span class="keyword">bool</span> create_onscreen_surface);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//摘取两个方法分析</span></span><br><span class="line">  <span class="comment">//将平台消息分发给Flutter代码处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DispatchPlatformMessage</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                               std::string name,</span></span></span><br><span class="line"><span class="function"><span class="params">                               jobject message_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                               jint message_position,</span></span></span><br><span class="line"><span class="function"><span class="params">                               jint response_id)</span></span>;</span><br><span class="line">  <span class="comment">//将Flutter代码发出的消息交给Android层处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">HandlePlatformMessage</span><span class="params">(std::unique_ptr&lt;flutter::PlatformMessage&gt; message)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下具体的实现：</p>
<ol>
<li><code>DispatchPlatformMessage</code>：将JNI传过来的数据转换成<code>PlatformMessage</code>并<strong>转发给父类</strong>的<code>DispatchPlatformMessage</code>方法</li>
<li><code>HandlePlatformMessage</code>：通过JNI由Native调用Java方法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shell/android/platform_view_android.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformViewAndroid::DispatchPlatformMessage</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  std::string name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  jobject java_message_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  jint java_message_position,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  jint response_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//封装PlatformMessage</span></span><br><span class="line">  <span class="keyword">uint8_t</span>* message_data = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(env-&gt;<span class="built_in">GetDirectBufferAddress</span>(java_message_data));</span><br><span class="line">  fml::MallocMapping message = fml::MallocMapping::<span class="built_in">Copy</span>(message_data, java_message_position);</span><br><span class="line"></span><br><span class="line">  fml::RefPtr&lt;flutter::PlatformMessageResponse&gt; response;</span><br><span class="line">  <span class="keyword">if</span> (response_id) &#123;</span><br><span class="line">    response = fml::MakeRefCounted&lt;PlatformMessageResponseAndroid&gt;(</span><br><span class="line">        response_id, jni_facade_, task_runners_.<span class="built_in">GetPlatformTaskRunner</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//交给PlatformVIew处理</span></span><br><span class="line">  PlatformView::<span class="built_in">DispatchPlatformMessage</span>(std::make_unique&lt;flutter::PlatformMessage&gt;(</span><br><span class="line">          std::<span class="built_in">move</span>(name), std::<span class="built_in">move</span>(message), std::<span class="built_in">move</span>(response)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformViewAndroid::HandlePlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    std::unique_ptr&lt;flutter::PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> response_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> response = message-&gt;<span class="built_in">response</span>()) &#123;</span><br><span class="line">    response_id = next_response_id_++;</span><br><span class="line">    pending_responses_[response_id] = response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Native调用Java方法</span></span><br><span class="line">  <span class="comment">// This call can re-enter in InvokePlatformMessageXxxResponseCallback.</span></span><br><span class="line">  jni_facade_-&gt;<span class="built_in">FlutterViewHandlePlatformMessage</span>(std::<span class="built_in">move</span>(message),</span><br><span class="line">                                                response_id);</span><br><span class="line">  message = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PlatformView"><a href="#PlatformView" class="headerlink" title="PlatformView"></a>PlatformView</h3><p><code>PlatformView</code>是平台通用实现，不同平台的Embedder可以继承该类，定制一些自己的方法（一般是将数据格式转换为通用结构），再通过<code>PlatformView</code>交给引擎处理。</p>
<p>摘取PlatformView部分声明函数</p>
<ol>
<li>构造时传入委托对象，上文已经分析过，<code>PlatformViewAndroid</code>创建用的委托对象就是<code>shell/common/shell.cc</code>类</li>
<li><code>PlatformView</code>声明函数：创建<code>RenderingSurface</code>，将输入事件、平台消息等发给Flutter处理等</li>
<li><strong>委托类</strong>的函数：基本和<code>PlatformView</code>的函数对应</li>
<li>比较特殊的是<code>HandlePlatformMessage</code>，这个函数是由<code>Flutter引擎-&gt;委托Shell调用-&gt;PlatformView</code>，交给Android层处理的，因此没有委托方法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter/shell/common/platform_view.h</span></span><br><span class="line"><span class="keyword">namespace</span> flutter &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformView</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//代理类，相当于Callback，PlatformView将行为转发给外部，外部实现监听器</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//基本和PlatformView类的方法对应</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPlatformViewCreated</span><span class="params">(std::unique_ptr&lt;Surface&gt; surface)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPlatformViewDestroyed</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPlatformViewSetViewportMetrics</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> ViewportMetrics&amp; metrics)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPlatformViewDispatchPlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        std::unique_ptr&lt;PlatformMessage&gt; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPlatformViewDispatchPointerDataPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        std::unique_ptr&lt;PointerDataPacket&gt; packet)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPlatformViewDispatchKeyDataPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        std::unique_ptr&lt;KeyDataPacket&gt; packet,</span></span></span><br><span class="line"><span class="function"><span class="params">        std::function&lt;<span class="keyword">void</span>(<span class="keyword">bool</span> <span class="comment">/* handled */</span>)&gt; callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//构造的时候传入Delegate</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PlatformView</span><span class="params">(Delegate&amp; delegate, TaskRunners task_runners)</span></span>;</span><br><span class="line">  <span class="comment">//通知引擎PlatformView创建和销毁，可以开始创建Rendering Surface</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NotifyCreated</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NotifyDestroyed</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//设置视图区域</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetViewportMetrics</span><span class="params">(<span class="keyword">const</span> ViewportMetrics&amp; metrics)</span></span>;</span><br><span class="line">  <span class="comment">//Embedder往Flutter发消息，发到root isolate中处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DispatchPlatformMessage</span><span class="params">(std::unique_ptr&lt;PlatformMessage&gt; message)</span></span>;</span><br><span class="line">  <span class="comment">//Embedder处理Flutter发过来的消息</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HandlePlatformMessage</span><span class="params">(std::unique_ptr&lt;PlatformMessage&gt; message)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Embedder分发点击事件和按键事件给Flutter Framework</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DispatchPointerDataPacket</span><span class="params">(std::unique_ptr&lt;PointerDataPacket&gt; packet)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DispatchKeyDataPacket</span><span class="params">(std::unique_ptr&lt;KeyDataPacket&gt; packet, Delegate::KeyDataResponse callback)</span></span>;</span><br><span class="line">  <span class="comment">//指定Texture，用于光栅合成Flutter视图</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RegisterTexture</span><span class="params">(std::shared_ptr&lt;flutter::Texture&gt; texture)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">UnregisterTexture</span><span class="params">(<span class="keyword">int64_t</span> texture_id)</span></span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  PlatformView::Delegate&amp; delegate_;</span><br><span class="line">  <span class="keyword">const</span> TaskRunners task_runners_;</span><br><span class="line"></span><br><span class="line">  PointerDataPacketConverter pointer_data_packet_converter_;</span><br><span class="line">  SkISize size_;</span><br><span class="line">  fml::WeakPtrFactory&lt;PlatformView&gt; weak_factory_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在GPU Runner中创建RenderingSurface</span></span><br><span class="line">  <span class="comment">// This is the only method called on the raster task runner.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Surface&gt; <span class="title">CreateRenderingSurface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">FML_DISALLOW_COPY_AND_ASSIGN</span>(PlatformView);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace flutter</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// COMMON_PLATFORM_VIEW_H_</span></span></span><br></pre></td></tr></table></figure>

<p><code>PlatformView</code>自身也不干活，而是交给委托对象处理，这个委托对象实际上就是Shell</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shell/common/platform_view.cc</span></span><br><span class="line">PlatformView::<span class="built_in">PlatformView</span>(Delegate&amp; delegate, TaskRunners task_runners)</span><br><span class="line">    : <span class="built_in">delegate_</span>(delegate),</span><br><span class="line">      <span class="built_in">task_runners_</span>(std::<span class="built_in">move</span>(task_runners)),</span><br><span class="line">      <span class="built_in">size_</span>(SkISize::<span class="built_in">Make</span>(<span class="number">0</span>, <span class="number">0</span>)),</span><br><span class="line">      <span class="built_in">weak_factory_</span>(<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformView::DispatchPlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    std::unique_ptr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//交给委托对象处理</span></span><br><span class="line">  delegate_.<span class="built_in">OnPlatformViewDispatchPlatformMessage</span>(std::<span class="built_in">move</span>(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Shell是嵌入层的壳，超出shell基本就到了引擎层，实现了多个组件<code>Delegate</code>类，通过委托的方式将嵌入层的请求转发到引擎层，并且将引擎层的事件发到嵌入层。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shell/common/shell.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> PlatformView::Delegate,</span><br><span class="line">                    <span class="keyword">public</span> Animator::Delegate,</span><br><span class="line">                    <span class="keyword">public</span> Engine::Delegate,</span><br><span class="line">                    <span class="keyword">public</span> Rasterizer::Delegate,</span><br><span class="line">                    <span class="keyword">public</span> ServiceProtocol::Handler &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//创建Shell</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> std::unique_ptr&lt;Shell&gt; <span class="title">Create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> PlatformData&amp; platform_data,</span></span></span><br><span class="line"><span class="function"><span class="params">      TaskRunners task_runners,</span></span></span><br><span class="line"><span class="function"><span class="params">      Settings settings,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> CreateCallback&lt;PlatformView&gt;&amp; on_create_platform_view,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> CreateCallback&lt;Rasterizer&gt;&amp; on_create_rasterizer,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">bool</span> is_gpu_disabled = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 启动isolate</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RunEngine</span><span class="params">(RunConfiguration run_configuration)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Setup</span><span class="params">(std::unique_ptr&lt;PlatformView&gt; platform_view,</span></span></span><br><span class="line"><span class="function"><span class="params">             std::unique_ptr&lt;Engine&gt; engine,</span></span></span><br><span class="line"><span class="function"><span class="params">             std::unique_ptr&lt;Rasterizer&gt; rasterizer,</span></span></span><br><span class="line"><span class="function"><span class="params">             std::unique_ptr&lt;ShellIOManager&gt; io_manager)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 持有对象</span></span><br><span class="line">  std::unique_ptr&lt;PlatformView&gt; platform_view_;  <span class="comment">// on platform task runner</span></span><br><span class="line">  std::unique_ptr&lt;Engine&gt; engine_;               <span class="comment">// on UI task runner</span></span><br><span class="line">  std::unique_ptr&lt;Rasterizer&gt; rasterizer_;       <span class="comment">// on raster task runner</span></span><br><span class="line">  std::unique_ptr&lt;ShellIOManager&gt; io_manager_;   <span class="comment">// on IO task runner</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shell对象创建：<code>Create--&gt;CreateWithSnapshot--&gt;CreateShellOnPlatformThread</code></p>
<ol>
<li>创建DartVM</li>
<li>创建Shell对象</li>
<li>在GPU Runner中创建<code>Rasterizer</code>：回调<code>on_create_rasterizer</code>，传入shell委托对象<ol>
<li>负责绘制Engine提交的LayerTree到Surface上</li>
<li>持有Surface和合成器上下文</li>
</ol>
</li>
<li>在Platform Runner中创建<code>PlatformView</code>：回调<code>on_create_platform_view</code>，传入shell委托对象</li>
<li>在IO Runner中创建<code>ShellIOManager</code></li>
<li>在UI Runner中创建<code>Engine</code>：回调<code>on_create_engine</code>，传入shell委托对象</li>
<li>调用<code>Shell::Setup</code>将上面创建的几个对象保存到Shell中</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Shell&gt; <span class="title">Shell::Create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Always use the `vm_snapshot` and `isolate_snapshot` provided by the</span></span><br><span class="line">  <span class="comment">// settings to launch the VM.  If the VM is already running, the snapshot</span></span><br><span class="line">  <span class="comment">// arguments are ignored.</span></span><br><span class="line">  <span class="comment">//从Settings中读取快照文件</span></span><br><span class="line">  <span class="keyword">auto</span> vm_snapshot = DartSnapshot::<span class="built_in">VMSnapshotFromSettings</span>(settings);</span><br><span class="line">  <span class="keyword">auto</span> isolate_snapshot = DartSnapshot::<span class="built_in">IsolateSnapshotFromSettings</span>(settings);</span><br><span class="line">  <span class="comment">//创建虚拟机</span></span><br><span class="line">  <span class="keyword">auto</span> vm = DartVMRef::<span class="built_in">Create</span>(settings, vm_snapshot, isolate_snapshot);</span><br><span class="line">  <span class="built_in">FML_CHECK</span>(vm) &lt;&lt; <span class="string">&quot;Must be able to initialize the VM.&quot;</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CreateWithSnapshot</span>(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Shell&gt; <span class="title">Shell::CreateWithSnapshot</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  fml::AutoResetWaitableEvent latch;</span><br><span class="line">  std::unique_ptr&lt;Shell&gt; shell;</span><br><span class="line">  <span class="comment">//在PlatformRunner中创建Shell，并Wait直到创建完成</span></span><br><span class="line">  fml::TaskRunner::<span class="built_in">RunNowOrPostTask</span>(</span><br><span class="line">      task_runners.<span class="built_in">GetPlatformTaskRunner</span>(),</span><br><span class="line">      fml::<span class="built_in">MakeCopyable</span>(</span><br><span class="line">            ...</span><br><span class="line">            shell = <span class="built_in">CreateShellOnPlatformThread</span>(...);</span><br><span class="line">            latch.<span class="built_in">Signal</span>();</span><br><span class="line">          &#125;));</span><br><span class="line">  latch.<span class="built_in">Wait</span>();</span><br><span class="line">  <span class="keyword">return</span> shell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Shell&gt; <span class="title">Shell::CreateShellOnPlatformThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DartVMRef vm,</span></span></span><br><span class="line"><span class="function"><span class="params">    TaskRunners task_runners,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> PlatformData&amp; platform_data,</span></span></span><br><span class="line"><span class="function"><span class="params">    Settings settings,</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;<span class="keyword">const</span> DartSnapshot&gt; isolate_snapshot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Shell::CreateCallback&lt;PlatformView&gt;&amp; on_create_platform_view, <span class="comment">//回调创建PlatformView</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Shell::CreateCallback&lt;Rasterizer&gt;&amp; on_create_rasterizer, <span class="comment">//回调创建Rrasterizer</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Shell::EngineCreateCallback&amp; on_create_engine, <span class="comment">//回调创建Engine</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> is_gpu_disabled)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!task_runners.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">    <span class="built_in">FML_LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Task runners to run the shell were invalid.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建Shell对象</span></span><br><span class="line">  <span class="keyword">auto</span> shell = std::unique_ptr&lt;Shell&gt;(<span class="keyword">new</span> <span class="built_in">Shell</span>(std::<span class="built_in">move</span>(vm), task_runners, settings, std::make_shared&lt;VolatilePathTracker&gt;(task_runners.<span class="built_in">GetUITaskRunner</span>(), !settings.skia_deterministic_rendering_on_cpu), is_gpu_disabled));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the rasterizer on the raster thread.</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the platform view on the platform thread (this thread).</span></span><br><span class="line">  <span class="keyword">auto</span> platform_view = <span class="built_in">on_create_platform_view</span>(*shell.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">if</span> (!platform_view || !platform_view-&gt;<span class="built_in">GetWeakPtr</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Ask the platform view for the vsync waiter. This will be used by the engine</span></span><br><span class="line">  <span class="comment">// to create the animator.</span></span><br><span class="line">  <span class="keyword">auto</span> vsync_waiter = platform_view-&gt;<span class="built_in">CreateVSyncWaiter</span>();</span><br><span class="line">  <span class="keyword">if</span> (!vsync_waiter) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create the IO manager on the IO thread.</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Create the engine on the UI thread.</span></span><br><span class="line">  std::promise&lt;std::unique_ptr&lt;Engine&gt;&gt; engine_promise;</span><br><span class="line">  <span class="keyword">auto</span> engine_future = engine_promise.<span class="built_in">get_future</span>();</span><br><span class="line">  fml::TaskRunner::<span class="built_in">RunNowOrPostTask</span>(</span><br><span class="line">      shell-&gt;<span class="built_in">GetTaskRunners</span>().<span class="built_in">GetUITaskRunner</span>(),</span><br><span class="line">      fml::<span class="built_in">MakeCopyable</span>([...]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">TRACE_EVENT0</span>(<span class="string">&quot;flutter&quot;</span>, <span class="string">&quot;ShellSetupUISubsystem&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; task_runners = shell-&gt;<span class="built_in">GetTaskRunners</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The animator is owned by the UI thread but it gets its vsync pulses</span></span><br><span class="line">        <span class="comment">// from the platform.</span></span><br><span class="line">        <span class="keyword">auto</span> animator = std::make_unique&lt;Animator&gt;(*shell, task_runners,</span><br><span class="line">                                                   std::<span class="built_in">move</span>(vsync_waiter));</span><br><span class="line"></span><br><span class="line">        engine_promise.<span class="built_in">set_value</span>(<span class="built_in">on_create_engine</span>(*shell,...));</span><br><span class="line">      &#125;));</span><br><span class="line">  <span class="comment">// 等待四个Runner创建好对应的对象，调用Setup保存这四个对象</span></span><br><span class="line">  <span class="keyword">if</span> (!shell-&gt;<span class="built_in">Setup</span>(std::<span class="built_in">move</span>(platform_view),  <span class="comment">//</span></span><br><span class="line">                    engine_future.<span class="built_in">get</span>(),       <span class="comment">//</span></span><br><span class="line">                    rasterizer_future.<span class="built_in">get</span>(),   <span class="comment">//</span></span><br><span class="line">                    io_manager_future.<span class="built_in">get</span>())   <span class="comment">//</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> shell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><img src="/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/nativeAttach调用流程.png" style="zoom:100%;">

<h2 id="nativeRunBundleAndSnapshotFromLibrary"><a href="#nativeRunBundleAndSnapshotFromLibrary" class="headerlink" title="nativeRunBundleAndSnapshotFromLibrary"></a>nativeRunBundleAndSnapshotFromLibrary</h2><p>和上文一样查看Native调用流程，这里顺着搜索代码即可，就不贴源码了</p>
<p><img src="/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/nativeRunBundleAndSnapshotFromLibrary%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="关系梳理"><a href="#关系梳理" class="headerlink" title="关系梳理"></a>关系梳理</h2><p>嵌入层涉及到很多类，这里梳理一下它们之间引用和调用的关系，如下：</p>
<ol>
<li><code>FlutterJNI</code>：Java和Native通信的统一入口</li>
<li><code>PlatformViewAndroidJNIImpl</code>：Native方法的核心实现</li>
<li><code>AndroidShellHolder</code>：作为C++层的主要入口，并且负责创建4个Runner线程</li>
<li><code>PlatformViewAndroid</code>：继承自PlatformView，加一些原生平台的特殊处理和转换后，交给父类执行，对父类功能进行扩充</li>
<li><code>PlatformView</code>：平台通用接口，负责沟通平台和Shell，没有具体的行为，基本都是委托给Shell处理</li>
<li><code>Shell</code>：平台通用实现，负责与引擎层交互</li>
<li><code>Engine</code>：引擎层主要入口，管理<code>RootIsolate</code>，接收Layer渲染请求等</li>
<li><code>TaskRunners</code>：保存4个<code>TaskRunner</code></li>
<li><code>ThreadHost</code>：创建线程</li>
</ol>
<p>思考：Shell为什么不和PlatformView合并，而要通过<code>PlatformView</code>委托调用Shell？</p>
<blockquote>
<ol>
<li>PlatformView接口是用来约束原生平台的实现</li>
<li>Shell是嵌入层和引擎层之间的门户，同时作为平台嵌入层和引擎层等的委托对象</li>
<li>组合优于继承：Shell是平台通用的，如果要添加平台特殊处理，<code>PlatformViewAndroid</code>需要继承Shell，而Shell除了平台接口之外，还实现了引擎的委托接口，这一部分是不应该被继承的。</li>
</ol>
</blockquote>
<img src="/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Flutter嵌入层调用关系.png" style="zoom:80%;">

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="FlutterInjector"><a href="#FlutterInjector" class="headerlink" title="FlutterInjector"></a>FlutterInjector</h2><p><code>FlutterInjector</code>使用Builder创建<code>FlutterLoader</code>和<code>FlutterJNI</code>工厂对象，方便单元测试注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FlutterInjector.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterInjector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (flutterJniFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建FlutterJNI工厂</span></span><br><span class="line">        flutterJniFactory = <span class="keyword">new</span> FlutterJNI.Factory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flutterLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建FlutterLoader实例</span></span><br><span class="line">        flutterLoader = <span class="keyword">new</span> FlutterLoader(flutterJniFactory.provideFlutterJNI());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FlutterApplication"><a href="#FlutterApplication" class="headerlink" title="FlutterApplication"></a>FlutterApplication</h2><p>这里单独把<code>FlutterApplication</code>拎出来介绍是因为这一步可有可无，在Application中加载是为了<strong>加快<code>FlutterEngine</code>启动速度</strong>。</p>
<p><strong>注：由于应用可能不使用<code>FlutterApplication</code>，因此<code>FlutterEngine</code>初始化的时候还会再尝试加载资源</strong></p>
<p>调用<code>FlutterLoader</code>的<code>startInitialization</code>方法进行初始化，异步加载Flutter资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FlutterApplication.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    FlutterInjector.instance().flutterLoader().startInitialization(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Flutter多线程"><a href="#Flutter多线程" class="headerlink" title="Flutter多线程"></a>Flutter多线程</h1><p>Flutter嵌入层中包含4个Runner：</p>
<ol>
<li>Platform Runner：处理平台消息，调用Flutter Engine接口</li>
<li>UI Runner：执行Flutter Engine的Root Isolate代码，处理Widgets生成Layer Tree</li>
<li>GPU Runner（Raster Runner）：负责GPU相关的管理和调度，UI Runner将构建的Layer Tree交给GPU Runner，GPU Runner中调用Skia引擎进行渲染</li>
<li>IO Runner：处理耗时操作，例如图片读取、压缩、渲染，可以向GPU Runner提交渲染请求</li>
</ol>
<blockquote>
<p>Platform Runner多个FlutterEngine共享，其他3个Runner引擎独立。</p>
<p>Runner不等同于线程，可以运行在同一线程，也可以运行在不同线程</p>
</blockquote>
<h1 id="Dart单线程"><a href="#Dart单线程" class="headerlink" title="Dart单线程"></a>Dart单线程</h1><p>Dart默认是单线程处理任务，主线程有一个事件循环，包含两个事件队列：</p>
<ol>
<li>microtask queue：自定义Task，优先执行，不应该执行耗时操作，否则会阻塞event队列事件，导致延迟</li>
<li>event queue：负责处理I/O、UI绘制、触摸事件等</li>
</ol>
<p><img src="/2022/01/22/flutter-2022-01-22-Flutter%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Isolate%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png"></p>
<h2 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h2><p>协程语法糖，标记await方法，保存async方法上下文环境，事件循环的时候进行检查，如果执行完，则沿着离开的指针继续执行下面的代码。</p>
<p>async没有真正切换线程，因此无法执行耗时操作，会造成UI延迟</p>
<h2 id="Isolate"><a href="#Isolate" class="headerlink" title="Isolate"></a>Isolate</h2><p>切换线程需要创建Isolate，和Java线程区别在于线程间内存独立，需要通过Port和其他Isolate通信和交换数据（sendPort、receivePort）</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以Flutter工程方式为例，模块集成方式类似。源码分析比较枯燥，可以关注每个部分的小结和图片。</p>
<p>改了很多次，发现源码很深、结构比较乱，最终决定将Java层和Native层分开介绍，可能更利于阅读。</p>
<p>第一次分析C++的代码，style不是很习惯，很难像Java一样梳理类图关系。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://xiaozhuanlan.com/gityuan_flutter?sort_by=asc">深入理解Flutter引擎架构</a></li>
<li><a href="https://my.oschina.net/u/3698453/blog/4810854">Flutter-Android-Embedder启动流程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/394560540">Flutter源码阅读分析：引擎初始化与启动</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/340729824">Flutter Engine层核心逻辑梳理</a></li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译</title>
    <url>/2022/01/20/tool-2022-01-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="交叉编译概念"><a href="#交叉编译概念" class="headerlink" title="交叉编译概念"></a>交叉编译概念</h1><p>一支编译程序只生成一种机器代码。不同架构使用的编译器不同，并且生成不同的目标代码，例如x86，x64架构上的GCC是不一样的。要在一种CPU架构上生成另一个平台的目标代码，需要使用<strong>交叉编译</strong>。</p>
<ul>
<li>本地编译（native compile）：本机编译出来的程序在本机上运行</li>
<li>交叉编译（cross compile）：在一个平台上生成另一个平台的可执行代码，即编译环境和运行环境不一样。常用于嵌入式开发</li>
</ul>
<p>编译用的机器叫宿主机（Host），软件运行的机器叫目标机（Target）。宿主机和目标机通过串口或网络通讯。</p>
<p>为何需要交叉编译？</p>
<blockquote>
<p>单片机或嵌入式设备功能较少，硬件资源和性能有限，只能供嵌入式系统运行，难以再提供编译资源。</p>
</blockquote>
<p>嵌入式系统一般也比PC系统要轻量，CPU种类更多（如x86、arm、armv7、arm64、mips等），各家的指令集也存在差异，因此嵌入式操作系统一般要针对芯片分别进行编译。应用软件也需要分别编译。</p>
<blockquote>
<ul>
<li>Android使用Java，运行在虚拟机上，因此不需要分别编译，但是如果使用了so库，则需要分别编译</li>
<li>iPhone不同版本使用不同CPU架构，编译的时候可以选择目标版本系统和目标架构。</li>
</ul>
</blockquote>
<h1 id="交叉编译工具链"><a href="#交叉编译工具链" class="headerlink" title="交叉编译工具链"></a>交叉编译工具链</h1><p>交叉编译工具链（交叉编译器）：交叉编译用到的<strong>一系列工具、库和头文件</strong>等。一般命名为<code>arch-[-vendor][-os][-(gnu)eabi][-tool]</code>，如<code>arm-none-linux-gnueabi-gcc</code>、<code>arm-linux-ld</code>等。</p>
<blockquote>
<p>常用的交叉编译工具链有两种：GCC/GNU和Clang/LLVM</p>
</blockquote>
<p>注：交叉编译工具本身也是应用程序，需要针对主机编译才能运行。因此可能会出现命名如下</p>
<ul>
<li><code>x86_64-aarch64-none-linux-gnueabihf</code>：在Linux x86_64主机上运行，目标平台是aarch64架构的Linux系统</li>
<li><code>aarch64-arm-none-linux-gnueabihf</code>：在Linux aarch64主机运行，目标平台是arm架构的Linux系统</li>
<li><code>aarch64-aarch64-none-elf</code>：在Linux aarch64主机运行，目标平台是aarch64架构的裸机系统</li>
</ul>
<blockquote>
<ul>
<li>aarch32=arm</li>
<li>aarch64=arm64</li>
</ul>
</blockquote>
<p>交叉编译示意图如下：</p>
<p><img src="/2022/01/20/tool-2022-01-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91.png"></p>
<p>Android和Java代码编译只需要编译成dex或class，不需要编译成目标代码，因此不需要交叉编译。但是Android中的Native开发还是需要使用交叉编译工具链，只不过NDK中做了封装。</p>
<p>ABI（Application Binary Interface）和EABI（Embedded ABI）区别</p>
<blockquote>
<p>前者是计算机上的，后者是嵌入式平台上（arm、mips等）</p>
</blockquote>
<p><code>arm-none-eabi</code>和<code>arm-none-linux-eabi</code>区别</p>
<blockquote>
<p>前者指目标平台为aarch32架构的裸机系统（ELF bare-metal，没有操作系统），后者指目标平台为aarch32架构的Linux系统（GNU/Linux）</p>
</blockquote>
<p><code>arm-linux-gnueabi</code>和<code>arm-linux-gnueabihf</code>区别</p>
<blockquote>
<p>前者适用于armel架构，后者适用于armhf架构。二者的<code>--mfloat-abi</code>编译选项不同。</p>
</blockquote>
<p>gcc编译选项<code>-mfloat-abi</code>有三种值：</p>
<ul>
<li>soft：不用fpu进行浮点运算，使用软件模式。</li>
<li>softfp：armel架构采用的默认值，用fpu计算，传参数用普通寄存器传。</li>
<li>hard：armhf架构采用的默认值，用fpu计算，传参数也用fpu的浮点寄存器传。</li>
</ul>
<blockquote>
<p>el表示little-endian</p>
<p>hf表示hard float，需要fpu浮点运算单元支持</p>
<p>arm64默认是hf，因此不需要hf后缀</p>
<p>be表示big-endian</p>
</blockquote>
<p>交叉编译工具链获取方式：</p>
<ol>
<li>获取源码，自行编译制作：<a href="https://github.com/llvm/llvm-project">LLVM-Project</a>、<a href="https://clang.llvm.org/get_started.html">Clang构建</a>、<a href="https://www.cnblogs.com/Charles-Zhang-Blog/archive/2013/02/21/2920999.html">Linux ARM交叉编译工具链制作过程</a></li>
<li>使用现成的编译好的工具链：<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/">ARM</a>、<a href="https://www.linaro.org/downloads/">Linaro</a>、<a href="https://www.plm.automation.siemens.com/global/en/products/embedded-software/sourcery-codebench-lite-downloads.html">Codesourcery</a>。</li>
<li>使用包管理器直接下载，如apt、rpm、yum等</li>
</ol>
<h2 id="制作LLVM交叉编译工具链"><a href="#制作LLVM交叉编译工具链" class="headerlink" title="制作LLVM交叉编译工具链"></a>制作LLVM交叉编译工具链</h2><p>本地编译器构建比较简单（一般可以直接使用包管理器安装），交叉编译器则需要获取LLVM源码自行构建。</p>
<p>Flutter引擎使用Clang/LLVM工具链编译，这里简单介绍下步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载源码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> --branch=llvmorg-11.1.0 --depth=1 https://github.com/llvm/llvm-project.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> llvm-project</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建并安装Clang</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -G Ninja \</span></span><br><span class="line"><span class="bash">    -S llvm \</span></span><br><span class="line"><span class="bash">    -B build_llvm \</span></span><br><span class="line"><span class="bash">    -DCMAKE_BUILD_TYPE=Release \</span></span><br><span class="line"><span class="bash">    -DCMAKE_CROSSCOMPILING=True \</span></span><br><span class="line"><span class="bash">    -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/sdk/toolchain \</span></span><br><span class="line"><span class="bash">    -DLLVM_ENABLE_PROJECTS=clang \</span></span><br><span class="line"><span class="bash">    -DLLVM_DEFAULT_TARGET_TRIPLE=arm-linux-gnueabihf \</span></span><br><span class="line"><span class="bash">    -DLLVM_TARGET_ARCH=ARM \</span></span><br><span class="line"><span class="bash">    -DLLVM_TARGETS_TO_BUILD=ARM</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build build_llvm &amp;&amp; sudo cmake --install build_llvm</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>-S：源码目录</li>
<li>-G：使用Ninja构建</li>
<li>-B：构建目录</li>
<li>-DCMAKE_INSTALL_PREFIX：LLVM工具和库安装的路径。默认安装在/usr/local，可能会覆盖系统本身的工具</li>
<li>-DLLVM_ENABLE_PROJECTS：LLVM子项目构建，分号分隔</li>
<li>-DLLVM_ENABLE_RUNTIMES：运行时库构建，分号分隔</li>
</ul>
</blockquote>
<h3 id="Binutils构建"><a href="#Binutils构建" class="headerlink" title="Binutils构建"></a>Binutils构建</h3><p>GNU Binutils：二进制工具集合：</p>
<ul>
<li>ld、gold：GNU链接器</li>
<li>as：GNU汇编器</li>
<li>addr2line：地址转代码行数</li>
<li>ar：归档工具</li>
<li>objdump：输出目标文件信息</li>
<li>objcopy：拷贝目标文件</li>
<li>….</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载源码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> --depth=1 git://sourceware.org/git/binutils-gdb.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-gdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建并安装Binutils</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/sdk/toolchain&quot;</span> \</span></span><br><span class="line"><span class="bash">    --enable-gold \</span></span><br><span class="line"><span class="bash">    --enable-ld \</span></span><br><span class="line"><span class="bash">    --target=arm-linux-gnueabihf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j$(expr $(expr $(nproc) \* 6) \/ 5) &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>./configure</code>也是用于生成Makefile文件</p>
</blockquote>
<h3 id="libcxx和libcxx构建"><a href="#libcxx和libcxx构建" class="headerlink" title="libcxx和libcxx构建"></a>libcxx和libcxx构建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> llvm-project</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> arm目标平台libcxxabi构建</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -d build_libcxxabi ] &amp;&amp; sudo rm -r build_libcxxabi ;\</span></span><br><span class="line"><span class="bash">cmake -G Ninja \</span></span><br><span class="line"><span class="bash">    -S libcxxabi \</span></span><br><span class="line"><span class="bash">    -B build_libcxxabi \</span></span><br><span class="line"><span class="bash">    -DCMAKE_MAKE_PROGRAM=$(<span class="built_in">which</span> ninja) \</span></span><br><span class="line"><span class="bash">    -DCMAKE_BUILD_TYPE=Release \</span></span><br><span class="line"><span class="bash">    -DCMAKE_SYSROOT=<span class="variable">$HOME</span>/flutter-engine/sdk/sysroot \</span></span><br><span class="line"><span class="bash">    -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/sdk/toolchain \</span></span><br><span class="line"><span class="bash">    -DCMAKE_SYSTEM_NAME=Linux \</span></span><br><span class="line"><span class="bash">    -DCMAKE_SYSTEM_PROCESSOR=ARM \</span></span><br><span class="line"><span class="bash">    -DCMAKE_C_COMPILER=<span class="variable">$HOME</span>/sdk/toolchain/bin/clang \</span></span><br><span class="line"><span class="bash">    -DCMAKE_CXX_COMPILER=<span class="variable">$HOME</span>/sdk/toolchain/bin/clang++ \</span></span><br><span class="line"><span class="bash">    -DCMAKE_AR=<span class="variable">$HOME</span>/sdk/toolchain/bin/arm-linux-gnueabihf-ar \</span></span><br><span class="line"><span class="bash">    -DCMAKE_RANLIB=<span class="variable">$HOME</span>/sdk/toolchain/bin/arm-linux-gnueabihf-ranlib \</span></span><br><span class="line"><span class="bash">    -DLLVM_TARGETS_TO_BUILD=ARM \</span></span><br><span class="line"><span class="bash">    -DLIBCXX_ENABLE_SHARED=False \</span></span><br><span class="line"><span class="bash">    -DLIBCXXABI_ENABLE_EXCEPTIONS=False</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build build_libcxxabi &amp;&amp; sudo cmake --install build_libcxxabi</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> arm目标平台libcxx构建</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -d build_libcxx ] &amp;&amp; sudo rm -r build_libcxx ;\</span></span><br><span class="line"><span class="bash">cmake -G Ninja \</span></span><br><span class="line"><span class="bash">    -S libcxx \</span></span><br><span class="line"><span class="bash">    -B build_libcxx \</span></span><br><span class="line"><span class="bash">    -DCMAKE_MAKE_PROGRAM=$(<span class="built_in">which</span> ninja) \</span></span><br><span class="line"><span class="bash">    -DCMAKE_BUILD_TYPE=Release \</span></span><br><span class="line"><span class="bash">    -DCMAKE_SYSROOT=<span class="variable">$HOME</span>/sdk/sysroot \</span></span><br><span class="line"><span class="bash">    -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/sdk/toolchain \</span></span><br><span class="line"><span class="bash">    -DCMAKE_SYSTEM_NAME=Linux \</span></span><br><span class="line"><span class="bash">    -DCMAKE_SYSTEM_PROCESSOR=ARM \</span></span><br><span class="line"><span class="bash">    -DCMAKE_C_COMPILER=<span class="variable">$HOME</span>/sdk/toolchain/bin/clang \</span></span><br><span class="line"><span class="bash">    -DCMAKE_CXX_COMPILER=<span class="variable">$HOME</span>/sdk/toolchain/bin/clang++ \</span></span><br><span class="line"><span class="bash">    -DCMAKE_AR=<span class="variable">$HOME</span>/sdk/toolchain/bin/arm-linux-gnueabihf-ar \</span></span><br><span class="line"><span class="bash">    -DCMAKE_RANLIB=<span class="variable">$HOME</span>/sdk/toolchain/bin/arm-linux-gnueabihf-ranlib \</span></span><br><span class="line"><span class="bash">    -DLLVM_TARGETS_TO_BUILD=ARM \</span></span><br><span class="line"><span class="bash">    -DLIBCXX_ENABLE_EXCEPTIONS=False \</span></span><br><span class="line"><span class="bash">    -DLIBCXX_ENABLE_SHARED=False \</span></span><br><span class="line"><span class="bash">    -DLIBCXX_ENABLE_RTTI=False \</span></span><br><span class="line"><span class="bash">    -DLIBCXX_CXX_ABI=libcxxabi \</span></span><br><span class="line"><span class="bash">    -DLIBCXX_CXX_ABI_INCLUDE_PATHS=<span class="variable">$HOME</span>/llvm-project/libcxxabi/include \</span></span><br><span class="line"><span class="bash">    -DLIBCXX_CXX_ABI_LIBRARY_PATH=<span class="variable">$HOME</span>/sdk/toolchain/lib \</span></span><br><span class="line"><span class="bash">    -DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=True</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build build_libcxx &amp;&amp; sudo cmake --install build_libcxx</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>[-d path]</code>：判断目录是否存在，存在则条件成立</p>
<p><code>[-n 变量]</code>：判断变量是否为空，为空则条件成立</p>
</blockquote>
<p>踩坑：<code>libcxx</code>和<code>libcxxabi</code>构建报错，网上说是Glibc版本太高，折腾了一下没搞定。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/root/flutter-engine/sdk/toolchain/bin/arm-linux-gnueabihf-ld: /root/flutter-engine/sdk/sysroot/lib/gcc/arm-linux-gnueabihf/9/libstdc++.so: undefined reference to `acos@GLIBC_2.4&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="sysroot"><a href="#sysroot" class="headerlink" title="sysroot"></a>sysroot</h1><p>指定编译时的逻辑根目录，<strong>只在链接过程中起作用</strong>，作为交叉编译工具链搜索目标平台库和头文件的根路径。</p>
<blockquote>
<p>编译过程中默认会在<code>/usr/include</code>、<code>/usr/lib</code>下查找引用的库和头文件，指定sysroot为dir之后会在<code>dir/usr/include</code>、<code>dir/usr/lib</code>下查找。</p>
</blockquote>
<p><strong>sysroot本质是目标平台的依赖库，不特指某个库，而是编译时需要的所有的库，不同软件编译依赖不同的库。</strong></p>
<p><strong>软件交叉编译时需要链接对应架构的平台库，在sysroot路径下查找目标平台的库和头文件。</strong></p>
<p>直接在主机用apt安装只会安装当前平台的库，所以需要利用容器环境的包管理工具（apt）下载目标架构的平台库。</p>
<p>例如在arm64容器中和x86_64容器中分别使用apt安装依赖库，二者的目标平台不同（如下图对比）。</p>
<p><img src="/2022/01/20/tool-2022-01-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/%E4%B8%8D%E5%90%8C%E6%9E%B6%E6%9E%84Ubuntu%E9%95%9C%E5%83%8F%E5%B7%AE%E5%BC%82.png"></p>
<h2 id="制作sysroot"><a href="#制作sysroot" class="headerlink" title="制作sysroot"></a>制作sysroot</h2><p>sysroot本质是目标平台的依赖库，只要能下载到编译需要的依赖库即可。</p>
<ol>
<li>网上下载</li>
<li>使用Docker+QEMU+包管理器下载已经编好的库</li>
<li>使用BuildRoot构建系统，交叉编译依赖库的源码，生成可链接的目标平台库</li>
<li>使用Yocto构建系统，交叉编译依赖库的源码，生成可链接的目标平台库</li>
</ol>
<p>以Docker+QEMU为例，创建<code>flutter_elinux</code>需要的arm64 sysroot</p>
<ol>
<li><p>在Linux主机上安装Docker</p>
</li>
<li><p>安装QEMU，用于运行arm架构容器：<code>apt install qemu-user-static</code></p>
</li>
<li><p>运行Docker官方<code>arm64v8/ubuntu</code>容器：<code>docker run -it --name ubuntu-arm64 arm64v8/ubuntu:18.04</code></p>
<ol>
<li>arm Ubuntu镜像：<code>docker pull arm32v7/ubuntu</code></li>
<li>arm64 Ubuntu镜像：<code>docker pull arm64v8/ubuntu</code></li>
</ol>
</li>
<li><p>在容器中安装依赖库：根据需要安装，这里以Flutter eLinux为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt install clang cmake build-essential pkg-config libegl1-mesa-dev libxkbcommon-dev libgles2-mesa-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt install libwayland-dev wayland-protocols</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt install libdrm-dev libgbm-dev libinput-dev libudev-dev libsystemd-dev</span></span><br></pre></td></tr></table></figure></li>
<li><p>将arm64平台的依赖库拷贝到Linux主机：根据需要拷贝sysroot，常用的有<code>/lib /usr /etc /opt</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker cp ubuntu-arm64:/ ubuntu-arm64-sysroot</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>由于公司的远程Linux主机没有权限使用apt，无法安装QEMU，因此在本地Mac主机上运行ARM64容器，下载平台库制作sysroot，再上传到Linux X86_64的容器中进行编译。</p>
</blockquote>
<h1 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h1><p>通过<code>.pc</code>文件查找软件的头文件和库文件位置，用于C/C++程序链接。</p>
<p>例如<code>/usr/lib/arm-linux-gnueabihf/pkgconfig/x11.pc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /usr/lib/arm-linux-gnueabihf/pkgconfig/x11.pc</span></span><br><span class="line">prefix=/usr</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">libdir=$&#123;prefix&#125;/lib/arm-linux-gnueabihf</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line"></span><br><span class="line">xthreadlib=-lpthread</span><br><span class="line"><span class="meta">#</span><span class="bash"> 软件简介</span></span><br><span class="line">Name: X11</span><br><span class="line">Description: X Library</span><br><span class="line">Version: 1.6.9</span><br><span class="line">Requires: xproto kbproto</span><br><span class="line">Requires.private: xcb &gt;= 1.11.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 头文件路径</span></span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 库目录</span></span><br><span class="line">Libs: -L$&#123;libdir&#125; -lX11</span><br><span class="line">Libs.private: -lpthread</span><br></pre></td></tr></table></figure>

<ul>
<li>查看已知的软件包：<code>pkg-config --list-all</code></li>
<li>查看软件头文件路径：<code>pkg-config --cflags &lt;software&gt;</code></li>
<li>查看软件库路径：<code>pkg-config --libs &lt;software&gt;</code></li>
</ul>
<p>输出的格式可以直接用于gcc链接选项，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pkg-config --cflags --libs cairo</span></span><br><span class="line">-I/usr/include/cairo -I/usr/include/glib-2.0 -I/usr/lib/arm-linux-gnueabihf/glib-2.0/include -I/usr/include/pixman-1 -I/usr/include/uuid -I/usr/include/freetype2 -I/usr/include/libpng16 -lcairo</span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ -o main.out $(pkg-config --cflags --libs cairo) main.cc</span></span><br></pre></td></tr></table></figure>

<h1 id="CMake配置"><a href="#CMake配置" class="headerlink" title="CMake配置"></a>CMake配置</h1><p>CMake编译过程中遇到一些问题，做个记录。</p>
<p>CMakeList.txt中添加打印：<code>message(WARNING $&#123;变量名&#125;)</code></p>
<p>查看CMake变量</p>
<ul>
<li><code>cmake --help-variable-list</code></li>
<li><code>cmake --help-variable CMAKE_SYSROOT_COMPILE</code></li>
</ul>
<h2 id="保存临时文件夹"><a href="#保存临时文件夹" class="headerlink" title="保存临时文件夹"></a>保存临时文件夹</h2><p>cmake执行时会使用测试项目进行检查。执行完之后会自动删除。</p>
<p>添加<code>--debug-trycompile</code>选项可以保留临时目录。</p>
<blockquote>
<p>cmake会调用多个命令，有时候cmake执行失败，我们想调试具体的报错命令，需要用到临时目录。</p>
</blockquote>
<h2 id="编译工具链指定"><a href="#编译工具链指定" class="headerlink" title="编译工具链指定"></a>编译工具链指定</h2><p>交叉编译时主机可能会包含本地编译工具链，以及多个目标平台的交叉编译工具链，因此需要指定编译工具链。</p>
<p>方式一：执行命令的时候添加参数选项。</p>
<p>例如：<code>-DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++</code></p>
<p>方式二：通过文件配置变量</p>
<p>例如创建<code>gcc_arm_toolchain.cmake</code>文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定目标系统</span></span><br><span class="line">SET(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译器</span></span><br><span class="line">SET(CMAKE_C_COMPILER aarch64-none-linux-gnu-gcc)</span><br><span class="line">SET(CMAKE_CXX_COMPILER aarch64-none-linux-gnu-g++)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定搜索的根路径</span></span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH /opt/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/)</span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) <span class="comment"># 使用本机程序</span></span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)  <span class="comment"># 仅使用 FIND_ROOT 下的库</span></span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)  <span class="comment"># 仅使用 FIND_ROOT 下的头文件</span></span><br></pre></td></tr></table></figure>

<p>执行命令的时候使用<code>-DCMAKE_TOOLCHAIN_FILE=gcc_arm_toolchain.cmake</code>选项指定配置文件，或者在CMakeList.txt中使用<code>include(gcc_arm_toolchain.cmake)</code>引入文件</p>
<h2 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories"></a>include_directories</h2><p>编译过程中如果提示找不到头文件，需要添加头文件查找路径：</p>
<ul>
<li>方式一：编译命令添加<code>-I dir</code>参数</li>
<li>方式二：配置<code>CMakeList.txt</code>文件，添加命令<code>include_directories([AFTER|BEFORE][SYSTEM] dir1 [dir2...])</code></li>
</ul>
<p>BEFORE和AFTER表示将路径添加到列表前面还是后面。SYSTEM表示当成系统搜索目录。</p>
<p>举例：<code>test.h</code>头文件放到sub目录下，<code>main.cpp</code>引用头文件如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sub/test.h&quot;</span></span></span><br><span class="line"><span class="comment">//不指定sub路径</span></span><br><span class="line"><span class="comment">//#include &quot;test.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMakeList.txt</span></span><br><span class="line">cmake_minimum_required(VERSION 3.18.2)</span><br><span class="line">project(cmake_test)</span><br><span class="line"><span class="comment"># 引入头文件路径</span></span><br><span class="line"><span class="comment"># include_directories(sub) </span></span><br><span class="line">add_executable(test main.cpp)</span><br></pre></td></tr></table></figure>

<p>执行<code>cmake --build .</code>，生成test程序，执行输出Hello World!</p>
<p>如果直接<code>#include &quot;test.h&quot;</code>，构建的时候会提示找不到头文件：<code>fatal error: &#39;test.h&#39; file not found </code></p>
<p>此时可以在CMakeList.txt中添加<code>include_directories(sub) </code>，引入头文件路径，编译成功。</p>
<h2 id="target-include-directories"><a href="#target-include-directories" class="headerlink" title="target_include_directories"></a>target_include_directories</h2><p><code>target_include_directories(target PRIVATE|INTERFACE|PUBLIC dir)</code>：指定目标包含的头文件路径。<code>include_directories()</code>会对其子目录起作用，导致整个工程编译时都会增加<code>-I dir</code></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/82244559">cmake：target_**</a></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于GCC链接可以参考<a href="/2022/01/03/tool-2022-01-03-GNU%E5%92%8C%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">构建工具</a></p>
<p>glibc和glib：</p>
<ul>
<li>glib：GTK+库</li>
<li>glibc：GNU C函数库，<a href="http://blog.fpliu.com/it/software/GNU/glibc">glibc介绍和安装</a></li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/sony/flutter-elinux/wiki/Building-flutter-apps#case-1-use-docker--qemu">Flutter eLinux：Cross-building from x64 to arm64</a>：制作sysroot</li>
<li><a href="https://wiki.loliot.net/docs/lang/flutter/engine/flutter-engine-for-linux-arm64/">Build Flutter engine for linux-arm/arm64</a>、<a href="https://medium.com/flutter/flutter-on-raspberry-pi-mostly-from-scratch-2824c5e7dcb1">Flutter on Raspberry Pi (mostly) from scratch</a>：自行制作toolchain，编译Flutter引擎</li>
<li><a href="https://www.cnblogs.com/oloroso/p/13995309.html">Linux 下交叉编译 ARM64-linux 版本 GDAL-3.2.0</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter应用构建产物分析</title>
    <url>/2022/01/14/flutter-2022-01-14-Flutter%E4%BA%A7%E7%89%A9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Flutter支持平台"><a href="#Flutter支持平台" class="headerlink" title="Flutter支持平台"></a>Flutter支持平台</h1><p>Flutter支持不同平台应用构建：</p>
<ul>
<li>Android：aar、apk、appbundle</li>
<li>iOS：iOS应用、iOSFramework库、ipa归档文件</li>
<li>Fuchsia应用</li>
<li>桌面应用：MacOS、Linux、Windows</li>
<li>Web应用</li>
<li>自定义嵌入式平台，需要定制引擎构建</li>
</ul>
<p><code>flutter build -h</code>查看帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Available subcommands:</span><br><span class="line">  aar             Build a repository containing an AAR and a POM file.</span><br><span class="line">  apk             Build an Android APK file from your app.</span><br><span class="line">  appbundle       Build an Android App Bundle file from your app.</span><br><span class="line">  bundle          Build the Flutter assets directory from your app.</span><br><span class="line">  ios             Build an iOS application bundle (Mac OS X host only).</span><br><span class="line">  ios-framework   Produces .xcframeworks for a Flutter project and its plugins for integration into existing, plain Xcode projects.</span><br><span class="line">  ipa             Build an iOS archive bundle (Mac OS X host only).</span><br><span class="line">  macos           Build a macOS desktop application.</span><br><span class="line">  web             Build a web application bundle.</span><br></pre></td></tr></table></figure>

<p>只可以看到移动应用、web应用macOS桌面应用构建，其他桌面应用被隐藏。</p>
<p>查看<code>flutter_tools</code>源码如下，需要使用<code>flutter config --enable-linux/windows/macos-desktop</code>启用，并且在对应的主机平台上才能进行构建。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildMacosCommand</span> <span class="keyword">extends</span> <span class="title">BuildSubCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hidden =&gt; !featureFlags.isMacOSEnabled || !globals.platform.isMacOS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildLinuxCommand</span> <span class="keyword">extends</span> <span class="title">BuildSubCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hidden =&gt; !featureFlags.isLinuxEnabled || !globals.platform.isLinux;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildWindowsCommand</span> <span class="keyword">extends</span> <span class="title">BuildSubCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hidden =&gt; !featureFlags.isWindowsEnabled || !globals.platform.isWindows;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildFuchsiaCommand</span> <span class="keyword">extends</span> <span class="title">BuildSubCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> hidden = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Flutter构建模式"><a href="#Flutter构建模式" class="headerlink" title="Flutter构建模式"></a>Flutter构建模式</h1><ul>
<li>Debug模式下，Flutter应用在VM上运行，能够保存应用状态，提供热重载能力。支持断点，调试信息等。</li>
<li>Release模式下，Flutter会使用<code>gen_snapshot</code>将应用代码预编译成目标平台的机器代码，针对web平台，会编译成JavaScript代码。进行了编译优化、压缩等。</li>
<li>Profile模式下，与Release类似，会进行预编译，进行了一些优化，使性能更接近Release模式，同时也支持调试和跟踪。模拟器上无法使用该模式</li>
</ul>
<blockquote>
<p><code>flutter run</code>命令默认为debug模式，<code>flutter build</code>命令默认为release模式。构建时可以指定<code>--debug</code>、<code>--release</code>、<code>--profile</code>选项</p>
</blockquote>
<h1 id="产物分析"><a href="#产物分析" class="headerlink" title="产物分析"></a>产物分析</h1><p>不指定<code>--target-platform</code>的话，编译出来的目标代码默认包含多个cpu架构。这里控制变量，只对比arm架构的产物。</p>
<p>Flutter支持多个平台，并且Debug和Release产物可能不一样，这里我们以Android和iOS为例，使用默认的Demo项目。这里不关心产物大小的具体数值。</p>
<p>添加<code>--analyze-size</code>选项，构建时会记录和输出包信息，生成<code>*-code-size-analysis_*.json</code>文件，可以使用DevTools工具进行分析。参考<a href="https://flutter.cn/docs/perf/app-size">Flutter官方文档</a></p>
<h2 id="Android-Debug和Release产物对比"><a href="#Android-Debug和Release产物对比" class="headerlink" title="Android Debug和Release产物对比"></a>Android Debug和Release产物对比</h2><p>分别编译arm架构的Debug和Release包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter build apk --debug --target-platform android-arm</span><br><span class="line">flutter build apk --release --target-platform android-arm</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/14/flutter-2022-01-14-Flutter%E4%BA%A7%E7%89%A9%E5%88%86%E6%9E%90/Android%E4%BA%A7%E7%89%A9.png"></p>
<p>使用AS的apkanalyzer工具分析对比apk，如下</p>
<img src="/2022/01/14/flutter-2022-01-14-Flutter%E4%BA%A7%E7%89%A9%E5%88%86%E6%9E%90/安卓Debug和Release对比.png" style="zoom:80%;">

<ul>
<li>libflutter.so：Flutter引擎编译出的目标代码</li>
<li>嵌入层Java代码编译产物：Flutter引擎中嵌入层的Java部分编译出的字节码，最终编译为dex字节码包含在apk中</li>
<li>libapp.so：Release模式下Dart业务代码编译成的目标代码。由四部分组成：Dart VM Snapshot、Isolate Snapshot、Dart VM Instructions、Isolate Instructions</li>
<li>flutter_assets：Flutter静态资源文件<ul>
<li>kernel_blob：Debug模式下Dart业务代码编译成的Kernel代码，是一种中间代码，和平台无关。由<code>app.dill</code>拷贝而成。存放在flutter_assets中</li>
<li>vm_snapshot_data和isolate_snaphost_data：Debug模式下生成的是<strong>Flutter引擎编译出来</strong>的虚拟机和isolate快照，用于快速启动虚拟机。一般情况下拷贝自<code>&#123;flutter_sdk&#125;/bin/cache/artifacts/engine/darwin-x64/</code>下的<code>vm_isolate_snapshot.bin</code>和<code>isolate_snapshot.bin</code>。存放在flutter_assets中</li>
</ul>
</li>
</ul>
<h2 id="iOS-Debug和Release产物对比"><a href="#iOS-Debug和Release产物对比" class="headerlink" title="iOS Debug和Release产物对比"></a>iOS Debug和Release产物对比</h2><p>分别编译iOS Debug和Release包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter build ios</span><br><span class="line">flutter build ios --debug</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/14/flutter-2022-01-14-Flutter%E4%BA%A7%E7%89%A9%E5%88%86%E6%9E%90/iOS%E4%BA%A7%E7%89%A9.png"></p>
<img src="/2022/01/14/flutter-2022-01-14-Flutter%E4%BA%A7%E7%89%A9%E5%88%86%E6%9E%90/iOS Debug和Release对比.png" style="zoom: 45%;">

<ul>
<li>Flutter.framework：包含引擎编译的目标代码</li>
<li>App.framework：包含Dart业务代码编译的目标代码</li>
<li>flutter_assets：Flutter静态资源文件，同Android</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Flutter产物主要包含几个部分：</p>
<ul>
<li>Flutter引擎：包括引擎相关代码、嵌入层Java代码、国际化数据文件，一般是SDK下载和缓存官方构建的引擎，位于<code>&#123;flutter_sdk&#125;/bin/cache/artifacts/engine</code>中。也可以下载引擎源码到本地自行编译，使用<code>--local-engine</code>选项指定本地引擎路径<ul>
<li>安卓中作为<code>flutter.jar</code>被项目依赖，打包到apk中之后分为<code>lib/&lt;abi&gt;/libflutter.so</code>和java字节码</li>
<li>iOS中打包为<code>Flutter.Framework</code></li>
</ul>
</li>
<li>Dart代码：开发者编写的Dart代码，Debug模式编译成Kernel快照（平台无关）运行，存放在<code>flutter_assets</code>中，Release模式编译成目标平台代码。<ul>
<li>Android打包为目标代码：<code>lib/&lt;abi&gt;/libapp.so</code>，主要包括四个部分：Dart VM Snapshot、Isolate Snapshot、Dart VM Instructions、Isolate Instructions</li>
<li>iOS中打包为<code>App.Framework</code></li>
<li>Debug模式打包为平台无关的中间代码：<code>flutter_assets/kernel_blob.bin</code>，存放在flutter_assets中</li>
</ul>
</li>
<li>Flutter资源文件：如字体、图片、动画文件等，以及<code>pubspec.yaml</code>中对应的assets、fonts配置。Debug模式下还会包括Kernel代码文件和快照文件。<ul>
<li>安卓存放在<code>assets/flutter_assets</code>中</li>
<li>iOS存放在<code>App.Framework/flutter_assets</code>中</li>
</ul>
</li>
</ul>
<ol>
<li>Android和iOS的flutter_assets一致</li>
<li>Debug模式下Dart代码会被编译成中间代码<code>kernel_blob.bin</code>，存放在flutter_assets中，Release模式下编译成目标代码<code>libapp.so</code>和<code>App.framework</code></li>
<li>Debug模式包含调试和热重载功能，不能用于衡量应用体积大小。Release模式经过压缩优化，整体更小</li>
<li>初始引入Flutter会显著增加应用大小，随着Flutter业务越多，收益会越来越高</li>
</ol>
<h1 id="减包方案"><a href="#减包方案" class="headerlink" title="减包方案"></a>减包方案</h1><h2 id="–split-debug-info"><a href="#–split-debug-info" class="headerlink" title="–split-debug-info"></a>–split-debug-info</h2><p>编译时使用<code>--split-debug-info</code>选项，可以减少代码量</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>图片资源压缩：根据业务场景降低分辨率，使用网络图片等</p>
<h2 id="引擎产物删减"><a href="#引擎产物删减" class="headerlink" title="引擎产物删减"></a>引擎产物删减</h2><p>Flutter引擎中用到了多个模块，对于不需要的模块可以定制和删减，自行编译引擎。</p>
<p>难度较高，收益较低</p>
<h2 id="ABI分包"><a href="#ABI分包" class="headerlink" title="ABI分包"></a>ABI分包</h2><p><code>--target-platform</code>指定目标平台，只编译目标平台代码。也可以使用<code>--split-per-abi</code>分别对每个abi编译。</p>
<blockquote>
<p>部分应用商店支持根据设备类型，自动分包下发，例如Google Play。因此也可以多个abi打包到一起。</p>
</blockquote>
<table>
<thead>
<tr>
<th>ABI</th>
<th>适用设备</th>
<th>市场占有率</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>arm64-v8a</td>
<td>第8代、64位ARM处理器</td>
<td>目前主流版本</td>
<td>2014年起</td>
</tr>
<tr>
<td>armeabi-v7a</td>
<td>第7代及以上的 ARM 处理器，使用硬件浮点运算</td>
<td>一些老旧的手机</td>
<td>2010年起</td>
</tr>
<tr>
<td>armeabi</td>
<td>第5代、第6代的ARM处理器，通用性强，速度慢</td>
<td>较少</td>
<td>最早</td>
</tr>
<tr>
<td>x86</td>
<td>Intel 32位，一般用于平板、模拟器</td>
<td>很少</td>
<td>2011年起</td>
</tr>
<tr>
<td>x86_64</td>
<td>Intel 64位，一般用于平板、模拟器</td>
<td>很少</td>
<td>2014年起</td>
</tr>
<tr>
<td>MIPS</td>
<td></td>
<td>较少</td>
<td></td>
</tr>
<tr>
<td>MIPS64</td>
<td></td>
<td>较少</td>
<td>2014年起</td>
</tr>
</tbody></table>
<p>高版本的CPU架构会兼容低版本的ABI，但是可能会损失性能或者出错，为了减少apk包大小，同时兼顾性能，一般使用armeabi-v7a或者arm64-v8a。</p>
<p>具体支持类型如下：</p>
<ul>
<li>ARMv5(CPU)：armeabi(ABI)</li>
<li>ARMv7：armeabi、armeabi-v7a</li>
<li>ARMv8：armeabi、armeabi-v7a、arm64-v8a</li>
<li>MIPS：mips</li>
<li>MIPS64：mips、mips64</li>
<li>x86：x86、armeabi-v7a、armeabi</li>
<li>x86_64：armeabi、armeabi-v7a、x86、x86_64</li>
</ul>
<blockquote>
<p>设备优先选择合适的ABI，性能更好，更加稳定。如果不存在对应的ABI，才选择兼容的库</p>
<p>64位设备可以运行32位ABI，但是以32位模式运行。</p>
</blockquote>
<h2 id="动态下发和加载"><a href="#动态下发和加载" class="headerlink" title="动态下发和加载"></a>动态下发和加载</h2><p>动态下发是减包的主要手段。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ol>
<li>定制gradle脚本在打包阶段移除Flutter产物（so库和Flutter资源等）</li>
<li>上传Flutter产物到动态发布系统托管</li>
<li>运行阶段对Flutter产物全部进行动态下发，添加loading，确保进入Flutter页面之前，产物下发完成</li>
<li>自定义引擎加载：初始化Flutter引擎，需要修改so库路径，包括<code>libflutter.so</code>和<code>libapp.so</code>，结合Flutter加载流程源码修改<ol>
<li>修改引擎源码，自行编译引擎</li>
<li>通过继承+反射修改加载流程</li>
</ol>
</li>
<li>自定义资源加载：原来是通过MethodChannel调用AssetManager，从APK的assets中加载，需要修改assets路径。可以自定义并替换AssetBundle</li>
</ol>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>iOS限制较多，较复杂。没有实际操作过，这里暂时不做介绍。</p>
<p>思路是将flutter_assets、icudtl.dat静态资源、以及kDartIsolateSnapshotData、kDartVmSnapshotData数据段文件动态下发和加载。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>了解Flutte构建产物有助于我们理解Flutter运行原理，并且可以对产物进行裁剪，动态下发产物。</p>
<p>关于Dart前端编译（生成Dart Kernel文件，即<code>.dill</code>）和AOT编译（生成目标代码）可以参考<a href="/2022/01/03/flutter-2022-01-05-Dart%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C/">Dart的编译和执行</a></p>
<p>关于Flutter构建流程，可以参考<a href="/2022/01/12/flutter-2022-01-12-Flutter%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Flutter应用构建流程分析</a></p>
<p>此外，Android还支持延迟组件加载（<code>DeferredComponent</code>），通过Google Play商店的动态模块功能进行下发，可以参考<a href="https://flutter.cn/docs/perf/deferred-components">延迟加载组件</a></p>
<p>参考资料：</p>
<ul>
<li><a href="https://tech.meituan.com/2020/09/18/flutter-in-meituan.html">美团-Flutter包大小治理上的探索与实践</a></li>
<li><a href="https://me.ursb.me/archives/flutter-reduce.html">Flutter 产物分析与减包方案</a></li>
<li><a href="https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode">Flutter Wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter应用构建流程分析</title>
    <url>/2022/01/12/flutter-2022-01-12-Flutter%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Flutter命令执行原理"><a href="#Flutter命令执行原理" class="headerlink" title="Flutter命令执行原理"></a>Flutter命令执行原理</h1><h2 id="Flutter命令脚本"><a href="#Flutter命令脚本" class="headerlink" title="Flutter命令脚本"></a>Flutter命令脚本</h2><p>查看<code>&#123;flutter_sdk&#125;/bin/flutter</code>脚本，内部会调用<code>shared.sh</code>脚本的execute方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source &quot;$BIN_DIR/internal/shared.sh&quot;</span><br><span class="line">shared::execute &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<p>查看<code>shared.sh</code>脚本，最终会执行dart命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;$DART&quot; --disable-dart-dev --packages=&quot;$FLUTTER_TOOLS_DIR/.packages&quot; $FLUTTER_TOOL_ARGS &quot;$SNAPSHOT_PATH&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>$DART：Dart可执行文件，用于启动Dart虚拟机。对应<code>&#123;flutter_sdk&#125;/bin/cache/dart-sdk/bin/dart</code></li>
<li>$FLUTTER_TOOLS_DIR：<code>flutter_tools</code>项目路径，对应<code>&#123;flutter_sdk&#125;/packages/flutter_tools</code></li>
<li>$SNAPSHOT_PATH：<code>flutter_tools</code>项目的snapshot文件，包含编译过的kernel中间代码，可以被Dart虚拟机执行，对应<code>&#123;flutter_sdk&#125;/bin/cache/flutter_tools.snapshot</code></li>
<li>$FLUTTER_TOOL_ARGS：用于调试Flutter SDK，一般情况为空。可以开启断言和调试端口。</li>
<li>$@：输入的参数</li>
</ul>
<p>因此实际的命令即：<code>flutter/bin/cache/dart-sdk/bin/dart flutter/bin/cache/flutter_tools.snapshot build apk</code></p>
<blockquote>
<p>类似java执行jar文件：<code>java -jar main.jar</code>，jar运行在java环境，snapshot运行在dart环境。</p>
</blockquote>
<h2 id="flutter-tools流程"><a href="#flutter-tools流程" class="headerlink" title="flutter_tools流程"></a>flutter_tools流程</h2><p>在AS中打开<code>flutter/packages/flutter_tools/</code>源码，配置Dart SDK，支持代码跳转。</p>
<p><code>flutter_tools.snapshot</code>类似jar文件，也有对应的main函数入口，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_tools/bin/flutter_tools.dart</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_tools/executable.dart&#x27;</span> <span class="keyword">as</span> executable;</span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  executable.main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>executable.dart</code>源码如下：创建了多个Command子类</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_tools/lib/executable.dart</span></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">await</span> runner.run(</span><br><span class="line">    args,</span><br><span class="line">    () =&gt; generateCommands(</span><br><span class="line">      verboseHelp: verboseHelp,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;FlutterCommand&gt; generateCommands(&#123;</span><br><span class="line">  <span class="meta">@required</span> <span class="built_in">bool</span> verboseHelp,</span><br><span class="line">  <span class="meta">@required</span> <span class="built_in">bool</span> verbose,</span><br><span class="line">&#125;) =&gt; &lt;FlutterCommand&gt;[</span><br><span class="line">  <span class="comment">//省略其他命令...</span></span><br><span class="line">  CreateCommand(verboseHelp: verboseHelp),</span><br><span class="line">  BuildCommand(verboseHelp: verboseHelp),</span><br><span class="line">  RunCommand(verboseHelp: verboseHelp),</span><br><span class="line">  AssembleCommand(verboseHelp: verboseHelp, buildSystem: globals.buildSystem),</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看<code>runner.run</code>源码：根据参数找到对应的Command类</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_tools/lib/runner.dart</span></span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; run(</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args,</span><br><span class="line">  <span class="built_in">List</span>&lt;FlutterCommand&gt; <span class="built_in">Function</span>() commands) <span class="keyword">async</span> &#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">  <span class="keyword">return</span> runInContext&lt;<span class="built_in">int</span>&gt;(() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> FlutterCommandRunner runner = FlutterCommandRunner(verboseHelp: verboseHelp);</span><br><span class="line">    commands().forEach(runner.addCommand); <span class="comment">//将所有Flutter命令存入map中</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> runZoned&lt;Future&lt;<span class="built_in">int</span>&gt;&gt;(() <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> runner.run(args); <span class="comment">//FlutterCommandRunner根据参数找到对应的Command执行</span></span><br><span class="line">  &#125;, overrides: overrides);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FlutterCommandRunner</code>会调用父类<code>CommandRunner</code>的run方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package:args/command_runner.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandRunner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  Future&lt;T?&gt; run(<span class="built_in">Iterable</span>&lt;<span class="built_in">String</span>&gt; args) =&gt; Future.<span class="keyword">sync</span>(() =&gt; runCommand(parse(args)));</span><br><span class="line">  </span><br><span class="line">  Future&lt;T?&gt; runCommand(ArgResults topLevelResults) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> argResults = topLevelResults;</span><br><span class="line">    <span class="keyword">var</span> commands = _commands; <span class="comment">//执行的Flutter命令，参数转换为列表</span></span><br><span class="line">    Command? command;</span><br><span class="line">    <span class="keyword">var</span> commandString = executableName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (commands.isNotEmpty) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">// Step into the command.</span></span><br><span class="line">      argResults = argResults.command!;</span><br><span class="line">      command = commands[argResults.name]!; <span class="comment">//遍历参数找到对应的命令类和子命令类，先找到BuildCommand类</span></span><br><span class="line">      command._globalResults = topLevelResults;</span><br><span class="line">      command._argResults = argResults;</span><br><span class="line">      commands = command._subcommands <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Command&lt;T&gt;&gt;; <span class="comment">//找到BuildCommand支持的子命令，下一次循环根据参数匹配子命令</span></span><br><span class="line">      commandString += <span class="string">&#x27; <span class="subst">$&#123;argResults.name&#125;</span>&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">await</span> command.run()) <span class="keyword">as</span> T?; <span class="comment">//执行最终匹配到的Command类的run方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：<code>flutter build apk</code>先找到<code>BuildCommand</code>类，Build后面包含多个子命令（如下）。</p>
<p>最终会匹配到<code>BuildApkCommand</code>类，然后调用<code>BuildApkCommand</code>的run方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildCommand</span> <span class="keyword">extends</span> <span class="title">FlutterCommand</span> </span>&#123;</span><br><span class="line">  BuildCommand(&#123; <span class="built_in">bool</span> verboseHelp = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    _addSubcommand(BuildAarCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildApkCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildAppBundleCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildIOSCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildIOSFrameworkCommand(</span><br><span class="line">      buildSystem: globals.buildSystem,</span><br><span class="line">      verboseHelp: verboseHelp,</span><br><span class="line">    ));</span><br><span class="line">    _addSubcommand(BuildIOSArchiveCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildBundleCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildWebCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildMacosCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildLinuxCommand(</span><br><span class="line">      operatingSystemUtils: globals.os,</span><br><span class="line">      verboseHelp: verboseHelp</span><br><span class="line">    ));</span><br><span class="line">    _addSubcommand(BuildWindowsCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildWindowsUwpCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildFuchsiaCommand(verboseHelp: verboseHelp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XXCommand继承自FlutterCommand类，调用FlutterCommand父类的run方法，如下：<code>verifyThenRunCommand</code>验证命令并调用runCommand方法。注释中说明了让子类重写<code>runCommand</code>来执行命令。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterCommand</span> <span class="keyword">extends</span> <span class="title">Command</span>&lt;<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Rather than overriding this method, subclasses should override</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[verifyThenRunCommand] to perform any verification</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">and [runCommand] to execute the command</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">so that this method can record and report the overall time to analytics.</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; run() &#123;</span><br><span class="line">    <span class="keyword">return</span> context.run&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">      name: <span class="string">&#x27;command&#x27;</span>,</span><br><span class="line">      overrides: &lt;<span class="built_in">Type</span>, Generator&gt;&#123;FlutterCommand: () =&gt; <span class="keyword">this</span>&#125;,</span><br><span class="line">      body: () <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//验证命令并调用runCommand方法</span></span><br><span class="line">          commandResult = <span class="keyword">await</span> verifyThenRunCommand(commandPath); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换flutter-tools原理"><a href="#替换flutter-tools原理" class="headerlink" title="替换flutter_tools原理"></a>替换flutter_tools原理</h2><p><code>flutter_tools.snapshot</code>对应的源码位于<code>&#123;flutter_framework&#125;/packages/flutter_tools/</code>中，可以直接修改。</p>
<p>修改了<code>flutter_tools</code>源码之后如何编译并替换呢？</p>
<p>查看<code>bin/internal/shared.sh</code>脚本的<code>upgrade_flutter</code>方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function upgrade_flutter () (</span><br><span class="line">  mkdir -p &quot;$FLUTTER_ROOT/bin/cache&quot;</span><br><span class="line"></span><br><span class="line">  local revision=&quot;$(cd &quot;$FLUTTER_ROOT&quot;; git rev-parse HEAD)&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Invalidate cache <span class="keyword">if</span>:</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  * SNAPSHOT_PATH is not a file, or</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  * STAMP_PATH is not a file with nonzero size, or</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  * Contents of STAMP_PATH is not our <span class="built_in">local</span> git HEAD revision, or</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  * pubspec.yaml last modified after pubspec.lock</span></span><br><span class="line">  if [[ ! -f &quot;$SNAPSHOT_PATH&quot; || ! -s &quot;$STAMP_PATH&quot; || &quot;$(cat &quot;$STAMP_PATH&quot;)&quot; != &quot;$revision&quot; || &quot;$FLUTTER_TOOLS_DIR/pubspec.yaml&quot; -nt &quot;$FLUTTER_TOOLS_DIR/pubspec.lock&quot; ]]; then</span><br><span class="line">    # 等待锁</span><br><span class="line">    _wait_for_lock</span><br><span class="line">    # 获取锁之后再次判断，防止并发</span><br><span class="line">    # A different shell process might have updated the tool/SDK.</span><br><span class="line">    if [[ -f &quot;$SNAPSHOT_PATH&quot; &amp;&amp; -s &quot;$STAMP_PATH&quot; &amp;&amp; &quot;$(cat &quot;$STAMP_PATH&quot;)&quot; == &quot;$revision&quot; &amp;&amp; &quot;$FLUTTER_TOOLS_DIR/pubspec.yaml&quot; -ot &quot;$FLUTTER_TOOLS_DIR/pubspec.lock&quot; ]]; then</span><br><span class="line">      exit $?</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    #...</span><br><span class="line">    </span><br><span class="line">    # 重新编译生成快照文件snapshot</span><br><span class="line">    &quot;$DART&quot; --verbosity=error --disable-dart-dev $FLUTTER_TOOL_ARGS --snapshot=&quot;$SNAPSHOT_PATH&quot; --packages=&quot;$FLUTTER_TOOLS_DIR/.packages&quot; --no-enable-mirrors &quot;$SCRIPT_PATH&quot;</span><br><span class="line">    echo &quot;$revision&quot; &gt; &quot;$STAMP_PATH&quot;</span><br><span class="line">  fi</span><br><span class="line">  exit $?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>  什么时候会重新编译<code>flutter_tools</code>？</p>
<blockquote>
<p>注释已经写的很清楚了：</p>
<ol>
<li>snapshot或者stamp文件不存在</li>
<li>stamp的commit id不是当前的HEAD id</li>
<li>pubspec.yaml文件被修改</li>
</ol>
</blockquote>
<h2 id="替换本地引擎原理"><a href="#替换本地引擎原理" class="headerlink" title="替换本地引擎原理"></a>替换本地引擎原理</h2><p>根据<a href="https://github.com/flutter/flutter/wiki/The-flutter-tool#using-a-locally-built-engine-with-the-flutter-tool">官方文档</a>，Flutter可以指定<code>local-engine</code>和<code>local-engine-src-path</code>选项来替换为本地编译引擎，这是如何生效的呢？</p>
<p>直接找到解析<code>local-engine-src-path</code>参数的地方：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lib/src/runner/flutter_command_runner</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterCommandRunner</span> <span class="keyword">extends</span> <span class="title">CommandRunner</span>&lt;<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; runCommand(ArgResults topLevelResults) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//传入参数，执行命令，根据local-engine参数获取本地构建的引擎</span></span><br><span class="line">    <span class="comment">// Set up the tooling configuration.</span></span><br><span class="line">    <span class="keyword">final</span> EngineBuildPaths engineBuildPaths = <span class="keyword">await</span> globals.localEngineLocator.findEnginePath(</span><br><span class="line">      topLevelResults[<span class="string">&#x27;local-engine-src-path&#x27;</span>] <span class="keyword">as</span> <span class="built_in">String</span>,</span><br><span class="line">      topLevelResults[<span class="string">&#x27;local-engine&#x27;</span>] <span class="keyword">as</span> <span class="built_in">String</span>,</span><br><span class="line">      topLevelResults[<span class="string">&#x27;packages&#x27;</span>] <span class="keyword">as</span> <span class="built_in">String</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>findEnginePath</code>方法，如何获取引擎路径</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lib/src/runner/local_engine.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalEngineLocator</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Returns the engine build path of a local engine if one is located, otherwise <span class="code">`null`</span>.</span></span></span><br><span class="line">  Future&lt;EngineBuildPaths?&gt; findEnginePath(<span class="built_in">String?</span> engineSourcePath, <span class="built_in">String?</span> localEngine, <span class="built_in">String?</span> packagePath) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//如果没有指定参数，从系统环境变量$FLUTTER_ENGINE读取</span></span><br><span class="line">    engineSourcePath ??= _platform.environment[kFlutterEngineEnvironmentVariableName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (engineSourcePath == <span class="keyword">null</span> &amp;&amp; localEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果local-engine参数是绝对路径，且父文件夹为src/out/，则使用src目录</span></span><br><span class="line">        engineSourcePath = _findEngineSourceByLocalEngine(localEngine);</span><br><span class="line">        <span class="comment">//从配置中读取</span></span><br><span class="line">        engineSourcePath ??= <span class="keyword">await</span> _findEngineSourceByPackageConfig(packagePath);</span><br><span class="line">      &#125; <span class="keyword">on</span> FileSystemException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        _logger.printTrace(<span class="string">&#x27;Local engine auto-detection file exception: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">        engineSourcePath = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//判断如果engine源码和flutter sdk目录同级，则不需要该参数</span></span><br><span class="line">      engineSourcePath ??= _tryEnginePath(</span><br><span class="line">        _fileSystem.path.join(_fileSystem.directory(_flutterRoot).parent.path, <span class="string">&#x27;engine&#x27;</span>, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">String?</span> _findEngineSourceByLocalEngine(<span class="built_in">String</span> localEngine) &#123;</span><br><span class="line">    <span class="comment">// When the local engine is an absolute path to a variant inside the</span></span><br><span class="line">    <span class="comment">// out directory, parse the engine source.</span></span><br><span class="line">    <span class="comment">// --local-engine /path/to/cache/builder/src/out/host_debug_unopt</span></span><br><span class="line">    <span class="keyword">if</span> (_fileSystem.path.isAbsolute(localEngine)) &#123;</span><br><span class="line">      <span class="keyword">final</span> Directory localEngineDirectory = _fileSystem.directory(localEngine);</span><br><span class="line">      <span class="keyword">final</span> Directory outDirectory = localEngineDirectory.parent;</span><br><span class="line">      <span class="keyword">final</span> Directory srcDirectory = outDirectory.parent;</span><br><span class="line">      <span class="keyword">if</span> (localEngineDirectory.existsSync() &amp;&amp; outDirectory.basename == <span class="string">&#x27;out&#x27;</span> &amp;&amp; srcDirectory.basename == <span class="string">&#x27;src&#x27;</span>) &#123;</span><br><span class="line">        _logger.printTrace(<span class="string">&#x27;Parsed engine source from local engine as <span class="subst">$&#123;srcDirectory.path&#125;</span>.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> srcDirectory.path;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Future&lt;<span class="built_in">String?</span>&gt; _findEngineSourceByPackageConfig(<span class="built_in">String?</span> packagePath) <span class="keyword">async</span> &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断out文件夹是否存在</span></span><br><span class="line">  <span class="built_in">String?</span> _tryEnginePath(<span class="built_in">String</span> enginePath) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_fileSystem.isDirectorySync(_fileSystem.path.join(enginePath, <span class="string">&#x27;out&#x27;</span>))) &#123;</span><br><span class="line">      <span class="keyword">return</span> enginePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取Flutter编译引擎源码路径？<code>--local-engine-src-path</code>什么时候可以省略？</p>
<blockquote>
<p>流程如下</p>
<ol>
<li>如果没有指定该参数，从系统环境变量<code>$FLUTTER_ENGINE</code>读取源码路径</li>
<li>如果<code>--local-engine</code>参数是绝对路径，且父文件夹为src/out/，则使用src目录</li>
<li>根据<code>--packages</code>参数加载<code>package_config.json</code>文件，读取<code>sky_engine</code>配置路径，例如<code>&#123;flutter-engine-local-path&#125;/src/out/host_debug_unopt/gen/dart-pkg/sky_engine/lib/</code></li>
<li>如果engine源码和flutter sdk目录同级，且存在<code>src/out</code>文件夹，则使用src目录</li>
</ol>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Flutter命令脚本会启动一个dart虚拟机，执行<code>flutter_tools</code>的dart程序。</li>
<li><code>flutter_tools</code>封装了不同的命令类，通过解析参数，执行对应的Command类，并调用run方法，例如<code>BuildApkCommand.runCommand()</code></li>
<li>替换<code>flutter_tools</code>：删除<code>&#123;flutter_framework&#125;/bin/cache/</code>下的<code>flutter_tools.snapshot</code>和<code>flutter_tools.stamp</code>文件，执行flutter命令的时候会重新构建`</li>
<li>替换本地引擎：通过<code>local-engine</code>和<code>local-engine-src-path</code>选项指定本地引擎路径</li>
</ol>
<h1 id="Flutter-Android应用构建源码分析"><a href="#Flutter-Android应用构建源码分析" class="headerlink" title="Flutter Android应用构建源码分析"></a>Flutter Android应用构建源码分析</h1><p>以<code>flutter build apk</code>为例，分析apk构建执行过程（其他构建可以自行分析）。</p>
<blockquote>
<p>上文已经介绍了flutter命令查找过程，这里直接找到<code>BuildApkCommand</code>命令</p>
</blockquote>
<p>查看<code>BuildApkCommand</code>的<code>runCommand</code>方法：通过<code>androidBuilder.buildApk</code>执行构建，<code>AndroidBuilder</code>从<code>context.get&lt;AndroidBuilder&gt;()</code>中获取，使用箭头函数，在调用的时候才会创建对象，实现了懒加载。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_tools/lib/src/commands/build_apk.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildApkCommand</span> <span class="keyword">extends</span> <span class="title">BuildSubCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;FlutterCommandResult&gt; runCommand() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (globals.androidSdk == <span class="keyword">null</span>) &#123;</span><br><span class="line">      exitWithNoSdkMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> BuildInfo buildInfo = <span class="keyword">await</span> getBuildInfo();</span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">final</span> AndroidBuildInfo androidBuildInfo = AndroidBuildInfo(</span><br><span class="line">      buildInfo,</span><br><span class="line">      splitPerAbi: boolArg(<span class="string">&#x27;split-per-abi&#x27;</span>),</span><br><span class="line">      targetArchs: stringsArg(<span class="string">&#x27;target-platform&#x27;</span>).map&lt;AndroidArch&gt;(getAndroidArchForName),</span><br><span class="line">    );</span><br><span class="line">    validateBuild(androidBuildInfo);</span><br><span class="line">    displayNullSafetyMode(androidBuildInfo.buildInfo);</span><br><span class="line">    <span class="keyword">await</span> androidBuilder.buildApk(</span><br><span class="line">      project: FlutterProject.current(),</span><br><span class="line">      target: targetFile,</span><br><span class="line">      androidBuildInfo: androidBuildInfo,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> FlutterCommandResult.success();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会调用<code>AndroidGradleBuilder</code>的<code>buildGradleApp</code>方法，内部就是拼接<code>gradle</code>命令，指定不同的参数，然后执行。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;project_path&#125;/gradlew -q -Ptarget=lib/main.dart -Ptrack-widget-creation=<span class="literal">false</span> -Ptarget-platform=android-arm  -Psplit-per-abi=<span class="literal">true</span> assembleRelease</span><br></pre></td></tr></table></figure>

<h2 id="flutter-gradle"><a href="#flutter-gradle" class="headerlink" title="flutter.gradle"></a>flutter.gradle</h2><p>Android本身的代码构建基本没什么疑问，这里主要关心Flutter项目中的dart代码如何构建打包成so的。</p>
<p>查看<code>build.gradle</code>文件，主要是引入了<code>flutter.gradle</code>，源码位于<code>flutter_tools</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply from: &quot;$flutterRoot&#x2F;packages&#x2F;flutter_tools&#x2F;gradle&#x2F;flutter.gradle&quot;</span><br></pre></td></tr></table></figure>

<p><code>flutter.gradle</code>自定义了gradle插件，解析gradle命令参数，并添加自定义task完成flutter项目的构建和打包。</p>
<p>下面分析几段关键代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_tools/gradle/flutter.gradle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">    <span class="comment">//添加自定义task</span></span><br><span class="line">    <span class="built_in">this</span>.addFlutterTasks(project)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//so分包构建，否则会将多个架构的so打包到一个apk中</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSplitPerAbi()) &#123;</span><br><span class="line">      project.android &#123;</span><br><span class="line">        splits &#123;</span><br><span class="line">          abi &#123;</span><br><span class="line">            <span class="comment">// Enables building multiple APKs per ABI.</span></span><br><span class="line">            enable <span class="literal">true</span></span><br><span class="line">            <span class="comment">// Resets the list of ABIs that Gradle should create APKs for to none.</span></span><br><span class="line">            reset()</span><br><span class="line">            <span class="comment">// Specifies that we do not want to also generate a universal APK that includes all ABIs.</span></span><br><span class="line">            universalApk <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析target-platform参数，指定编译目标平台的so</span></span><br><span class="line">    getTargetPlatforms().each &#123; targetArch -&gt;</span><br><span class="line">      String abiValue = PLATFORM_ARCH_MAP[targetArch]</span><br><span class="line">      project.android &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldSplitPerAbi()) &#123;</span><br><span class="line">          splits &#123;</span><br><span class="line">            abi &#123;</span><br><span class="line">              include abiValue</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加引擎库：io.flutter:xxx，即libflutter.so</span></span><br><span class="line">    <span class="comment">//添加嵌入层库：io.flutter:flutter_embedding_xxx，即FlutterActivity、FlutterView等</span></span><br><span class="line">    project.android.buildTypes.all <span class="built_in">this</span>.&amp;addFlutterDependencies</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>addFlutterTask</code>方法：主要是添加compileTask用于编译Flutter，生成so库。再通过其他Task对产物进行重命名、移动、合并，最终打包出apk</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> addFlutterTasks(Project project) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">def</span> targetPlatforms = getTargetPlatforms()</span><br><span class="line">    <span class="keyword">def</span> addFlutterDeps = &#123; variant -&gt;</span><br><span class="line">      String taskName = toCammelCase([<span class="string">&quot;compile&quot;</span>, FLUTTER_BUILD_PREFIX, variant.name])</span><br><span class="line">      FlutterTask compileTask = project.tasks.create(<span class="attr">name:</span> taskName, <span class="attr">type:</span> FlutterTask) &#123;</span><br><span class="line">        <span class="comment">//创建Flutter编译Task：如compileFlutterRelease，编译Flutter代码</span></span><br><span class="line">      &#125;</span><br><span class="line">      File libJar = project.file(<span class="string">&quot;$&#123;project.buildDir&#125;/$&#123;AndroidProject.FD_INTERMEDIATES&#125;/flutter/$&#123;variant.name&#125;/libs.jar&quot;</span>)</span><br><span class="line">      <span class="comment">//创建Flutter打包Task，并dependsOn等待编译Task执行完成</span></span><br><span class="line">      Task packFlutterAppAotTask = project.tasks.create(<span class="attr">name:</span> <span class="string">&quot;packLibs$&#123;FLUTTER_BUILD_PREFIX&#125;$&#123;variant.name.capitalize()&#125;&quot;</span>, <span class="attr">type:</span> Jar) &#123;</span><br><span class="line">        destinationDir libJar.parentFile</span><br><span class="line">        archiveName libJar.name <span class="comment">//打包到/build/intermediates/flutter/debug/libs.jar中</span></span><br><span class="line">        dependsOn compileTask</span><br><span class="line">        targetPlatforms.each &#123; targetPlatform -&gt;</span><br><span class="line">          String abi = PLATFORM_ARCH_MAP[targetPlatform]</span><br><span class="line">          from(<span class="string">&quot;$&#123;compileTask.intermediateDir&#125;/$&#123;abi&#125;&quot;</span>) &#123;</span><br><span class="line">            include <span class="string">&quot;*.so&quot;</span></span><br><span class="line">            <span class="comment">// Move `app.so` to `lib/&lt;abi&gt;/libapp.so`</span></span><br><span class="line">            <span class="comment">//Flutter项目代码最终会转换成目标平台的libapp.so文件，将so文件打包到libs.jar中</span></span><br><span class="line">            rename &#123; String filename -&gt;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;lib/$&#123;abi&#125;/lib$&#123;filename&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将Flutter项目编译打包好的libs.jar包添加到项目依赖中</span></span><br><span class="line">      addApiDependencies(project, variant.name, project.files &#123;</span><br><span class="line">        packFlutterAppAotTask</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//这里定义了三个Task：packageAssets、cleanPackageAssets、copyFlutterAssets，将Flutter产物移到/build/app/intermediates/merged_assets/release/out目录下</span></span><br><span class="line">      Task packageAssets = project.tasks.findByPath(<span class="string">&quot;:flutter:package$&#123;variant.name.capitalize()&#125;Assets&quot;</span>)</span><br><span class="line">      Task cleanPackageAssets = project.tasks.findByPath(<span class="string">&quot;:flutter:cleanPackage$&#123;variant.name.capitalize()&#125;Assets&quot;</span>)</span><br><span class="line">      Task copyFlutterAssetsTask = project.tasks.create(</span><br><span class="line">        <span class="symbol">name:</span> <span class="string">&quot;copyFlutterAssets$&#123;variant.name.capitalize()&#125;&quot;</span>,</span><br><span class="line">        <span class="symbol">type:</span> Copy,</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> copyFlutterAssetsTask</span><br><span class="line">    &#125; <span class="comment">// end def addFlutterDeps</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFlutterAppProject()) &#123;</span><br><span class="line">      project.android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        Task assembleTask = getAssembleTask(variant)</span><br><span class="line">        <span class="keyword">if</span> (!shouldConfigureFlutterTask(assembleTask)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        Task copyFlutterAssetsTask = addFlutterDeps(variant)</span><br><span class="line">        <span class="keyword">def</span> variantOutput = variant.outputs.first()</span><br><span class="line">        <span class="keyword">def</span> processResources = variantOutput.hasProperty(<span class="string">&quot;processResourcesProvider&quot;</span>) ?</span><br><span class="line">          variantOutput.processResourcesProvider.get() : variantOutput.processResources</span><br><span class="line">        <span class="comment">//先编译生成Flutter产物，将Flutter任务加到Android构建流程中</span></span><br><span class="line">        processResources.dependsOn(copyFlutterAssetsTask)</span><br><span class="line"></span><br><span class="line">        variant.outputs.all &#123; output -&gt;</span><br><span class="line">          assembleTask.doLast &#123; <span class="comment">//将生成的apk拷贝到对应路径，并重命名：app&lt;-abi&gt;?&lt;-flavor-name&gt;?-&lt;build-mode&gt;.apk</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      configurePlugins()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...其他模块编译类似</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>FlutterTask</code>源码如何编译Flutter代码生成<code>libapp.so</code>：调用<code>flutter assemble</code>命令编译flutter产物</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterTask</span> <span class="keyword">extends</span> <span class="title">BaseFlutterTask</span> &#123;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="meta">@TaskAction</span></span><br><span class="line">  <span class="keyword">void</span> build() &#123;</span><br><span class="line">    <span class="comment">//调用父类方法</span></span><br><span class="line">    buildBundle()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFlutterTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> buildBundle() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sourceDir.isDirectory()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;Invalid Flutter source directory: $&#123;sourceDir&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intermediateDir.mkdirs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the rule name for flutter assemble. To speed up builds that contain</span></span><br><span class="line">    <span class="comment">// multiple ABIs, the target name is used to communicate which ones are required</span></span><br><span class="line">    <span class="comment">// rather than the TargetPlatform. This allows multiple builds to share the same</span></span><br><span class="line">    <span class="comment">// cache.</span></span><br><span class="line">    <span class="comment">//根据ruleNames找到对应的编译目标</span></span><br><span class="line">    String[] ruleNames;</span><br><span class="line">    <span class="keyword">if</span> (buildMode == <span class="string">&quot;debug&quot;</span>) &#123;</span><br><span class="line">      ruleNames = [<span class="string">&quot;debug_android_application&quot;</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deferredComponents) &#123;</span><br><span class="line">      ruleNames = targetPlatformValues.collect &#123; <span class="string">&quot;android_aot_deferred_components_bundle_$&#123;buildMode&#125;_$it&quot;</span> &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ruleNames = targetPlatformValues.collect &#123; <span class="string">&quot;android_aot_bundle_$&#123;buildMode&#125;_$it&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    project.exec &#123; <span class="comment">//执行命令flutter assemble命令，加上各种参数，旧版本使用的可能是flutter build aot/bundle命令</span></span><br><span class="line">      logging.captureStandardError LogLevel.ERROR</span><br><span class="line">      executable flutterExecutable.absolutePath</span><br><span class="line">      workingDir sourceDir</span><br><span class="line">      <span class="keyword">if</span> (localEngine != <span class="literal">null</span>) &#123;</span><br><span class="line">        args <span class="string">&quot;--local-engine&quot;</span>, localEngine</span><br><span class="line">        args <span class="string">&quot;--local-engine-src-path&quot;</span>, localEngineSrcPath</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        args <span class="string">&quot;--verbose&quot;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        args <span class="string">&quot;--quiet&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      args <span class="string">&quot;assemble&quot;</span></span><br><span class="line">      args <span class="string">&quot;--no-version-check&quot;</span></span><br><span class="line">      args <span class="string">&quot;--depfile&quot;</span>, <span class="string">&quot;$&#123;intermediateDir&#125;/flutter_build.d&quot;</span></span><br><span class="line">      args <span class="string">&quot;--output&quot;</span>, <span class="string">&quot;$&#123;intermediateDir&#125;&quot;</span></span><br><span class="line">      <span class="comment">//省略其他参数...</span></span><br><span class="line">      args ruleNames</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Deferred Component延迟组件：可以在运行时下载Dart代码编译，减少包大小。目前只在Android上可用，利用Android和Google Play商店的动态功能模块实现延迟加载。</p>
<p>参考<a href="https://flutter.cn/docs/perf/deferred-components">Flutter延迟加载组件</a></p>
</blockquote>
<h2 id="flutter-assemble编译"><a href="#flutter-assemble编译" class="headerlink" title="flutter assemble编译"></a>flutter assemble编译</h2><p>直接找到<code>AssembleCommand</code>类的<code>runCommand</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssembleCommand</span> <span class="keyword">extends</span> <span class="title">FlutterCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;FlutterCommandResult&gt; runCommand() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Target&gt; targets = createTargets(); <span class="comment">//根据ruleNames创建编译目标</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Target&gt; nonDeferredTargets = &lt;Target&gt;[];</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Target&gt; deferredTargets = &lt;AndroidAotDeferredComponentsBundle&gt;[]; <span class="comment">//延迟组件</span></span><br><span class="line">    Target target;</span><br><span class="line">    <span class="comment">//省略deferredComponents目标判断...</span></span><br><span class="line">    <span class="comment">//调用buildSystem.build方法对target进行编译</span></span><br><span class="line">    <span class="keyword">final</span> BuildResult result = <span class="keyword">await</span> _buildSystem.build(</span><br><span class="line">      target,</span><br><span class="line">      environment,</span><br><span class="line">      buildSystemConfig: BuildSystemConfig(</span><br><span class="line">        resourcePoolSize: argResults.wasParsed(<span class="string">&#x27;resource-pool-size&#x27;</span>)</span><br><span class="line">          ? <span class="built_in">int</span>.tryParse(stringArg(<span class="string">&#x27;resource-pool-size&#x27;</span>))</span><br><span class="line">          : <span class="keyword">null</span>,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> FlutterCommandResult.success();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建编译目标</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Target&gt; createTargets() &#123;</span><br><span class="line">    <span class="keyword">if</span> (argResults.rest.isEmpty) &#123;</span><br><span class="line">      throwToolExit(<span class="string">&#x27;missing target name for flutter assemble.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> name = argResults.rest.first;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Target&gt; targetMap = &lt;<span class="built_in">String</span>, Target&gt;&#123; </span><br><span class="line">      <span class="comment">//_kDefaultTargets预定义了一堆默认编译目标，存到map中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> Target target <span class="keyword">in</span> _kDefaultTargets)</span><br><span class="line">        target.name: target <span class="comment">//目标名作为key</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Target&gt; results = &lt;Target&gt;[</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="built_in">String</span> targetName <span class="keyword">in</span> argResults.rest)</span><br><span class="line">        <span class="comment">//根据rest参数（除了options和flags之外的参数），从map中获取编译目标对象</span></span><br><span class="line">        <span class="comment">//此处的rest即上文中的ruleNames，可以是一个数组，如：[android_aot_bundle_$&#123;buildMode&#125;_$it]，$it指目标平台</span></span><br><span class="line">        <span class="keyword">if</span> (targetMap.containsKey(targetName))</span><br><span class="line">          targetMap[targetName]</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">if</span> (results.isEmpty) &#123;</span><br><span class="line">      throwToolExit(<span class="string">&#x27;No target named &quot;<span class="subst">$name</span>&quot; defined.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FlutterBuildSystem</code>继承自<code>BuildSystem</code>，源码较长，简单来说就是将编译目标Target和其依赖的编译目标，组成一个个编译节点，依次调用Target的build方法。默认的编译目标如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译目标之间可以有依赖关系</span></span><br><span class="line"><span class="built_in">List</span>&lt;Target&gt; _kDefaultTargets = &lt;Target&gt;[</span><br><span class="line">  <span class="comment">// Shared targets</span></span><br><span class="line">  <span class="keyword">const</span> CopyAssets(),</span><br><span class="line">  <span class="keyword">const</span> KernelSnapshot(), <span class="comment">//生成kernel文件，即app.dill</span></span><br><span class="line">  <span class="keyword">const</span> AotElfProfile(TargetPlatform.android_arm),</span><br><span class="line">  <span class="keyword">const</span> AotElfRelease(TargetPlatform.android_arm), <span class="comment">//将dart kernel生成elf文件</span></span><br><span class="line">  <span class="keyword">const</span> AotAssemblyProfile(), <span class="comment">//将dart kernel生成汇编文件</span></span><br><span class="line">  <span class="keyword">const</span> AotAssemblyRelease(),</span><br><span class="line">  <span class="comment">// macOS targets</span></span><br><span class="line">  <span class="keyword">const</span> DebugMacOSFramework(),</span><br><span class="line">  <span class="keyword">const</span> DebugMacOSBundleFlutterAssets(),</span><br><span class="line">  <span class="keyword">const</span> ProfileMacOSBundleFlutterAssets(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseMacOSBundleFlutterAssets(),</span><br><span class="line">  <span class="comment">// Linux targets</span></span><br><span class="line">  <span class="keyword">const</span> DebugBundleLinuxAssets(TargetPlatform.linux_x64),</span><br><span class="line">  <span class="keyword">const</span> DebugBundleLinuxAssets(TargetPlatform.linux_arm64),</span><br><span class="line">  <span class="keyword">const</span> ProfileBundleLinuxAssets(TargetPlatform.linux_x64),</span><br><span class="line">  <span class="keyword">const</span> ProfileBundleLinuxAssets(TargetPlatform.linux_arm64),</span><br><span class="line">  <span class="keyword">const</span> ReleaseBundleLinuxAssets(TargetPlatform.linux_x64),</span><br><span class="line">  <span class="keyword">const</span> ReleaseBundleLinuxAssets(TargetPlatform.linux_arm64),</span><br><span class="line">  <span class="comment">// Web targets</span></span><br><span class="line">  <span class="keyword">const</span> WebServiceWorker(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseAndroidApplication(),</span><br><span class="line">  <span class="comment">// This is a one-off rule for bundle and aot compat.</span></span><br><span class="line">  <span class="keyword">const</span> CopyFlutterBundle(),</span><br><span class="line">  <span class="comment">// Android targets,</span></span><br><span class="line">  <span class="keyword">const</span> DebugAndroidApplication(),</span><br><span class="line">  <span class="keyword">const</span> ProfileAndroidApplication(),</span><br><span class="line">  <span class="comment">// Android ABI specific AOT rules.</span></span><br><span class="line">  androidArmProfileBundle,</span><br><span class="line">  androidArm64ProfileBundle,</span><br><span class="line">  androidx64ProfileBundle,</span><br><span class="line">  androidArmReleaseBundle,</span><br><span class="line">  androidArm64ReleaseBundle,</span><br><span class="line">  androidx64ReleaseBundle,</span><br><span class="line">  <span class="comment">// Deferred component enabled AOT rules</span></span><br><span class="line">  androidArmProfileDeferredComponentsBundle,</span><br><span class="line">  androidArm64ProfileDeferredComponentsBundle,</span><br><span class="line">  androidx64ProfileDeferredComponentsBundle,</span><br><span class="line">  androidArmReleaseDeferredComponentsBundle,</span><br><span class="line">  androidArm64ReleaseDeferredComponentsBundle,</span><br><span class="line">  androidx64ReleaseDeferredComponentsBundle,</span><br><span class="line">  <span class="comment">// iOS targets</span></span><br><span class="line">  <span class="keyword">const</span> DebugIosApplicationBundle(),</span><br><span class="line">  <span class="keyword">const</span> ProfileIosApplicationBundle(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseIosApplicationBundle(),</span><br><span class="line">  <span class="comment">// Windows targets</span></span><br><span class="line">  <span class="keyword">const</span> UnpackWindows(),</span><br><span class="line">  <span class="keyword">const</span> DebugBundleWindowsAssets(),</span><br><span class="line">  <span class="keyword">const</span> ProfileBundleWindowsAssets(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseBundleWindowsAssets(),</span><br><span class="line">  <span class="comment">// Windows UWP targets</span></span><br><span class="line">  <span class="keyword">const</span> DebugBundleWindowsAssetsUwp(),</span><br><span class="line">  <span class="keyword">const</span> ProfileBundleWindowsAssetsUwp(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseBundleWindowsAssetsUwp(),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>挑一个<code>androidArmReleaseBundle</code>编译目标的源码查看，如下：</p>
<ol>
<li><code>androidArmReleaseBundle</code>编译目标对应<code>AndroidAotBundle</code>类</li>
<li>依赖<code>androidArmRelease</code>编译目标生成<code>app.so</code>文件，对应<code>AndroidAot</code>类</li>
<li>依赖<code>AotAndroidAssetBundle</code>生成<code>flutter_assets</code>文件，继承自<code>AndroidAssetBundle</code></li>
<li><code>AndroidAot</code>和<code>AndroidAssetBundle</code>编译目标都依赖<code>KernelSnapshot</code>编译目标</li>
<li>此外，Debug模式的编译目标<code>DebugAndroidApplication</code>也继承自<code>AndroidAssetBundle</code>，并且拷贝生成<code>kernel_blob.bin</code>、<code>vm_snapshot_data</code>、<code>isolate_snapshot_data</code>到<code>flutter_assets</code>下</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依赖androidArmRelease</span></span><br><span class="line"><span class="keyword">const</span> AndroidAotBundle androidArmReleaseBundle = AndroidAotBundle(androidArmRelease); </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidAotBundle</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Create an [AndroidAotBundle] implementation for a given [targetPlatform] and [buildMode].</span></span></span><br><span class="line">  <span class="keyword">const</span> AndroidAotBundle(<span class="keyword">this</span>.dependency);</span><br><span class="line">  <span class="comment">//ruleNames匹配的名称</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; <span class="string">&#x27;android_aot_bundle_<span class="subst">$&#123;getNameForBuildMode(dependency.buildMode)&#125;</span>_&#x27;</span></span><br><span class="line">    <span class="string">&#x27;<span class="subst">$&#123;getNameForTargetPlatform(dependency.targetPlatform)&#125;</span>&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Source&gt; <span class="keyword">get</span> inputs =&gt; &lt;Source&gt;[</span><br><span class="line">    Source.pattern(<span class="string">&#x27;&#123;BUILD_DIR&#125;/<span class="subst">$_androidAbiName</span>/app.so&#x27;</span>),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可以看出AndroidAotBundle只是将app.so移动打包而已</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Source&gt; <span class="keyword">get</span> outputs =&gt; &lt;Source&gt;[</span><br><span class="line">    Source.pattern(<span class="string">&#x27;&#123;OUTPUT_DIR&#125;/<span class="subst">$_androidAbiName</span>/app.so&#x27;</span>),</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//依赖androidArmRelease和AotAndroidAssetBundle编译目标</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Target&gt; <span class="keyword">get</span> dependencies =&gt; &lt;Target&gt;[</span><br><span class="line">    dependency,</span><br><span class="line">    <span class="keyword">const</span> AotAndroidAssetBundle(),</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先<code>KernelSnapshot</code>目标调用<code>KernelCompiler.compile</code>方法，将Flutter代码编译为<code>app.dill</code>文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KernelSnapshot</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; <span class="string">&#x27;kernel_snapshot&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; build(Environment environment) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> KernelCompiler compiler = KernelCompiler(</span><br><span class="line">      fileSystem: environment.fileSystem,</span><br><span class="line">      logger: environment.logger,</span><br><span class="line">      processManager: environment.processManager,</span><br><span class="line">      artifacts: environment.artifacts,</span><br><span class="line">      fileSystemRoots: &lt;<span class="built_in">String</span>&gt;[],</span><br><span class="line">      fileSystemScheme: <span class="keyword">null</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//执行frontend_server.dart.snapshot程序</span></span><br><span class="line">    <span class="keyword">final</span> CompilerOutput output = <span class="keyword">await</span> compiler.compile(</span><br><span class="line">      sdkRoot: environment.artifacts.getArtifactPath(</span><br><span class="line">        Artifact.flutterPatchedSdkPath,</span><br><span class="line">        platform: targetPlatform,</span><br><span class="line">        mode: buildMode,</span><br><span class="line">      ),</span><br><span class="line">      outputFilePath: environment.buildDir.childFile(<span class="string">&#x27;app.dill&#x27;</span>).path,</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compile内部实际是执行<code>frontend_server.dart.snapshot</code>程序，命令如下，省略部分参数（亲测：修改路径之后可以直接执行，生成app.dill文件）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dart &#123;flutter_sdk&#125;/bin/cache/artifacts/engine/darwin-x64/frontend_server.dart.snapshot </span><br><span class="line">--sdk-root &#123;flutter_sdk&#125;/bin/cache/artifacts/engine/common/flutter_patched_sdk/ </span><br><span class="line">--target=flutter </span><br><span class="line">--aot --tfa </span><br><span class="line">-Ddart.vm.profile=false </span><br><span class="line">-Ddart.vm.product=true </span><br><span class="line">--packages .packages </span><br><span class="line">--output-dill &#123;build_dir&#125;/app.dill </span><br><span class="line">--depfile &#123;build_dir&#125;/kernel_snapshot.d </span><br><span class="line">&#123;project&#125;/main.dart</span><br></pre></td></tr></table></figure>

<p>再查看<code>AndroidAot</code>编译目标：可以将<code>app.dill</code>文件编译成<code>app.so</code>文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AndroidAot androidArmRelease = AndroidAot(TargetPlatform.android_arm,  BuildMode.release);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidAot</span> <span class="keyword">extends</span> <span class="title">AotElfBase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; <span class="string">&#x27;android_aot_<span class="subst">$&#123;getNameForBuildMode(buildMode)&#125;</span>_&#x27;</span></span><br><span class="line">    <span class="string">&#x27;<span class="subst">$&#123;getNameForTargetPlatform(targetPlatform)&#125;</span>&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//依赖KernelSnapshot编译目标</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Target&gt; <span class="keyword">get</span> dependencies =&gt; <span class="keyword">const</span> &lt;Target&gt;[</span><br><span class="line">    KernelSnapshot(),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; build(Environment environment) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AOTSnapshotter snapshotter = AOTSnapshotter(</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> snapshotExitCode = <span class="keyword">await</span> snapshotter.build(</span><br><span class="line">      platform: targetPlatform,</span><br><span class="line">      buildMode: buildMode,</span><br><span class="line">      mainPath: environment.buildDir.childFile(<span class="string">&#x27;app.dill&#x27;</span>).path,</span><br><span class="line">      outputPath: output.path,</span><br><span class="line">      bitcode: <span class="keyword">false</span>,</span><br><span class="line">      extraGenSnapshotOptions: extraGenSnapshotOptions,</span><br><span class="line">      splitDebugInfo: splitDebugInfo,</span><br><span class="line">      dartObfuscation: dartObfuscation,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AOTSnapshotter</code>内部调用<code>_genSnapshot.run</code>方法，针对不同目标平台编译不同目标代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AOTSnapshotter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Builds an architecture-specific ahead-of-time compiled snapshot of the specified script.</span></span></span><br><span class="line">  Future&lt;<span class="built_in">int</span>&gt; build(</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  ) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//添加genSnapshot参数...</span></span><br><span class="line">    <span class="comment">//iOS编译出.S文件</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> assembly = _fileSystem.path.join(outputDir.path, <span class="string">&#x27;snapshot_assembly.S&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (platform == TargetPlatform.ios || platform == TargetPlatform.darwin) &#123;</span><br><span class="line">      genSnapshotArgs.addAll(&lt;<span class="built_in">String</span>&gt;[</span><br><span class="line">        <span class="string">&#x27;--snapshot_kind=app-aot-assembly&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;--assembly=<span class="subst">$assembly</span>&#x27;</span>,</span><br><span class="line">      ]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//Android编译出elf文件，.so文件</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">String</span> aotSharedLibrary = _fileSystem.path.join(outputDir.path, <span class="string">&#x27;app.so&#x27;</span>);</span><br><span class="line">      genSnapshotArgs.addAll(&lt;<span class="built_in">String</span>&gt;[</span><br><span class="line">        <span class="string">&#x27;--snapshot_kind=app-aot-elf&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;--elf=<span class="subst">$aotSharedLibrary</span>&#x27;</span>,</span><br><span class="line">      ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> SnapshotType snapshotType = SnapshotType(platform, buildMode);</span><br><span class="line">    <span class="comment">//执行gen_snapshot程序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> genSnapshotExitCode = <span class="keyword">await</span> _genSnapshot.run(</span><br><span class="line">      snapshotType: snapshotType,</span><br><span class="line">      additionalArgs: genSnapshotArgs,</span><br><span class="line">      darwinArch: darwinArch,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//iOS上将.S文件再通过XCode编译出.O文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_genSnapshot.run</code>内部实际是调用对应CPU架构引擎的<code>gen_snapshot</code>程序，命令如下，省略部分参数（亲测：修改路径之后可以直接执行，将上步生成的<code>app.dill</code>文件生成<code>app.so</code>文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;flutter_sdk&#125;/bin/cache/artifacts/engine/android-arm-release/darwin-x64/gen_snapshot </span><br><span class="line">--deterministic </span><br><span class="line">--snapshot_kind=app-aot-elf</span><br><span class="line">--elf=&#123;output_path&#125;/app.so</span><br><span class="line">app.dill</span><br></pre></td></tr></table></figure>

<p>查看<code>AotAndroidAssetBundle</code>目标：调用<code>copyAssets</code>生成Flutter静态资源文件（如图片、字体文件，配置文件等）并拷贝，如果是Debug模式，还会拷贝快照文件到<code>flutter_assets</code>中，而不是打包成<code>libapp.so</code>。Debug模式下产物如下：</p>
<ul>
<li><code>kernel_blob.bin</code>：Dart编译前端Debug模式（不带<code>--aot --tfa</code>参数）生成的Kernel快照文件，即<code>app.dill</code>（aot编译的Kernel文件无法直接运行）</li>
<li><code>vm_snapshot_data</code>和<code>isolate_snapshot_data</code>：包含Flutter引擎的虚拟机和特定isolate的Dart堆的初始状态，用于快速启动Dart虚拟机。分别对应引擎产物<code>vm_isolate_snapshot.bin</code>、<code>isolate_snapshot.bin</code>。<ul>
<li>位于缓存引擎路径<code>&#123;flutter_sdk&#125;/bin/cache/artifacts/engine/darwin-x64</code>下</li>
<li>或者本地编译引擎路径下<code>&#123;flutter_engine&#125;/src/out/host_debug_unopt/gen/flutter/lib/snapshot/</code>下</li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidAssetBundle</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; build(Environment environment) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> Directory outputDirectory = environment.outputDir</span><br><span class="line">      .childDirectory(<span class="string">&#x27;flutter_assets&#x27;</span>)</span><br><span class="line">      ..createSync(recursive: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only copy the prebuilt runtimes and kernel blob in debug mode.</span></span><br><span class="line">    <span class="keyword">if</span> (buildMode == BuildMode.debug) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">String</span> vmSnapshotData = environment.artifacts.getArtifactPath(Artifact.vmSnapshotData, mode: BuildMode.debug);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">String</span> isolateSnapshotData = environment.artifacts.getArtifactPath(Artifact.isolateSnapshotData, mode: BuildMode.debug);</span><br><span class="line">      <span class="comment">//Debug模式下app.dill复制为kernel_blob.bin，打包到flutter_assets中</span></span><br><span class="line">      environment.buildDir.childFile(<span class="string">&#x27;app.dill&#x27;</span>)</span><br><span class="line">          .copySync(outputDirectory.childFile(<span class="string">&#x27;kernel_blob.bin&#x27;</span>).path);</span><br><span class="line">      <span class="comment">//这两个文件不需要编译，直接拷贝engine中的产物，例如&#123;flutter_sdk&#125;/bin/cache/artifacts/engine/darwin-x64</span></span><br><span class="line">      environment.fileSystem.file(vmSnapshotData)</span><br><span class="line">          .copySync(outputDirectory.childFile(<span class="string">&#x27;vm_snapshot_data&#x27;</span>).path);</span><br><span class="line">      environment.fileSystem.file(isolateSnapshotData)</span><br><span class="line">          .copySync(outputDirectory.childFile(<span class="string">&#x27;isolate_snapshot_data&#x27;</span>).path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用copyAssets</span></span><br><span class="line">    <span class="keyword">final</span> Depfile assetDepfile = <span class="keyword">await</span> copyAssets(</span><br><span class="line">      environment,</span><br><span class="line">      outputDirectory,</span><br><span class="line">      targetPlatform: TargetPlatform.android,</span><br><span class="line">      buildMode: buildMode,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlutterTask用于编译Flutter资源，实际是执行<code>flutter assemble</code>命令。编译流程如下：</p>
<p><img src="/2022/01/12/flutter-2022-01-12-Flutter%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/FlutterTask%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png"></p>
<blockquote>
<ul>
<li><code>frontend_server.dart.snapshot</code>是一个dart程序，作为Dart编译前端，可以将dart源码编译成<code>.dill</code>中间代码文件。源码入口为<code>&#123;flutter_engine&#125;/flutter_frontend_server/bin/starter.dart</code>，内部会调用Dart SDK中的<code>frontend_server</code>，源码位于<code>&#123;dart_sdk&#125;/pkg/frontend_server</code>中</li>
<li><code>gen_snapshot</code>是一个可执行程序，作为Dart编译后端，可以将<code>.dill</code>文件编译成目标代码，生成<code>.so</code>或者<code>App.framework</code>，源码入口为<code>&#123;dart_sdk&#125;/runtime/bin/gen_snapshot.cc</code></li>
</ul>
</blockquote>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>BuildApkCommand</code>类中解析参数，调用gradle命令进行构建，例如<code>gradlew assembleRelease</code></li>
<li><code>flutter_tools</code>中自定义了一个gradle脚本<code>flutter.gradle</code>，将FlutterTask编译任务加到Android构建中，生成so库，合并打包生成最终的apk。</li>
<li>FlutterTask通过执行<code>flutter assemble</code>命令来编译Flutter代码和资源。依次构建多个编译目标，例如：<ol>
<li><code>KernelSnapshot</code>目标：调用<code>KernelCompiler.compile()</code>方法，执行<code>dart frontend_server.dart.snapshot</code>命令，生成<code>.dill</code>文件</li>
<li><code>AndroidAot</code>目标：调用<code>AOTSnapshotter.build()</code>方法，执行<code>gen_snapshot</code>命令，生成<code>app.so</code>文件</li>
<li><code>AotAndroidAssetBundle</code>目标：调用<code>AssetBundle.build()</code>，生成<code>flutter_assets</code>资源</li>
</ol>
</li>
</ol>
<blockquote>
<p>可以自行调用编译器前端和后端进行编译生成so库，不通过<code>flutter build</code></p>
</blockquote>
<p>Flutter构建源码分析整体流程如下：</p>
<p><img src="/2022/01/12/flutter-2022-01-12-Flutter%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/Flutter%E6%9E%84%E5%BB%BA%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%B5%81%E7%A8%8B.png"></p>
<p>Android中的Flutter Release产物编译总体流程如下：</p>
<p>![](2022-01-12-Flutter应用构建流程分析/Flutter Android应用编译流程.png)</p>
<h1 id="Flutter-Linux应用构建源码分析"><a href="#Flutter-Linux应用构建源码分析" class="headerlink" title="Flutter Linux应用构建源码分析"></a>Flutter Linux应用构建源码分析</h1><p>Linux桌面应用构建方式如下：</p>
<ul>
<li>创建Linux工程：<code>flutter create --platforms=linux .</code></li>
<li>开启Linux支持：<code>flutter config --enable-linux-desktop</code></li>
<li>开始构建：<code>flutter build linux --release</code></li>
</ul>
<p>分析<code>flutter_tools</code>源码，<code>BuildLinuxCommand</code>会调用cmake和ninja命令，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行cmake生成build.ninja文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DFLUTTER_TARGET_PLATFORM=linux-x64 /Users/Afauria/AndroidStudioProjects/flutter_app/linux</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ninja编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ninja -C build/linux/x64/release install</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>flutter_tools</code>内部通过<code>flutter_tools/lib/src/base/process.dart</code>的<code>ProcessUtil.stream()</code>方法执行命令行，可以在该方法中添加打印，查看执行的具体命令</p>
</blockquote>
<p>查看<code>build.ninja</code>文件，ninja会调用<code>tool_backend.sh</code>脚本，内部会执行<code>flutter assmeble</code>命令，找到对应的<code>BuildTargets</code>，和Android类似，经过前后端编译生成<code>app.so</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">linux/x64/release/build.ninja:240:  COMMAND = cd /Users/Afauria/AndroidStudioProjects/flutter_app/build/linux/x64/release/flutter &amp;&amp; /usr/local/Cellar/cmake/3.19.5/bin/cmake -E env FLUTTER_ROOT=/Users/Afauria/Flutter/flutter PROJECT_DIR=/Users/Afauria/AndroidStudioProjects/flutter_app DART_OBFUSCATION=false TRACK_WIDGET_CREATION=true TREE_SHAKE_ICONS=true PACKAGE_CONFIG=/Users/Afauria/AndroidStudioProjects/flutter_app/.dart_tool/package_config.json FLUTTER_TARGET=lib/main.dart /Users/Afauria/Flutter/flutter/packages/flutter_tools/bin/tool_backend.sh linux-x64 Release</span><br></pre></td></tr></table></figure>

<p>同时<code>build.ninja</code>中使用clang编译linux平台代码（<code>main.cc、my_application.cc</code>等）。</p>
<p>最终链接动态库生成可执行文件。</p>
<p>![](2022-01-12-Flutter应用构建流程分析/Flutter Linux应用编译流程.png)</p>
<h2 id="mac上交叉编译Linux（尝试）"><a href="#mac上交叉编译Linux（尝试）" class="headerlink" title="mac上交叉编译Linux（尝试）"></a>mac上交叉编译Linux（尝试）</h2><p>Linux应用只能在Linux主机上进行编译，使用mac主机编译Linux会报各种错误。</p>
<ol>
<li>首先<code>flutter_tools</code>限制如下：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flutter_tools/lib/src/commands/build_linux.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildLinuxCommand</span> <span class="keyword">extends</span> <span class="title">BuildSubCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;FlutterCommandResult&gt; runCommand() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (!featureFlags.isLinuxEnabled) &#123;</span><br><span class="line">      throwToolExit(<span class="string">&#x27;&quot;build linux&quot; is not currently supported. To enable, run &quot;flutter config --enable-linux-desktop&quot;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!globals.platform.isLinux) &#123;</span><br><span class="line">      throwToolExit(<span class="string">&#x27;&quot;build linux&quot; only supported on Linux hosts.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Cross-building for x64 targets on arm64 hosts is not supported.</span></span><br><span class="line">    <span class="keyword">if</span> (_operatingSystemUtils.hostPlatform != HostPlatform.linux_x64 &amp;&amp;</span><br><span class="line">        targetPlatform != TargetPlatform.linux_arm64) &#123;</span><br><span class="line">      throwToolExit(<span class="string">&#x27;&quot;cross-building&quot; only supported on Linux x64 hosts.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(fujino): https://github.com/flutter/flutter/issues/74929</span></span><br><span class="line">    <span class="keyword">if</span> (_operatingSystemUtils.hostPlatform == HostPlatform.linux_x64 &amp;&amp;</span><br><span class="line">        targetPlatform == TargetPlatform.linux_arm64) &#123;</span><br><span class="line">      throwToolExit(</span><br><span class="line">          <span class="string">&#x27;Cross-build from Linux x64 host to Linux arm64 target is not currently supported.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释掉上面的限制，替换sdk中的<code>flutter_tools</code>：删除<code>&#123;flutter_sdk&#125;/bin/cache/</code>下的<code>flutter_tools.snapshot</code>和<code>flutter_tools.stamp</code>文件，重新执行<code>build</code>命令</p>
<ol start="2">
<li>执行cmake命令时会报错找不到GTK3+库，使用brew进行安装，再次执行<code>build</code>命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mac安装GTK+</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install pkg-config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install gtk+3</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ninja执行前端编译成功，可以生成<code>app.dill</code>文件（位于<code>.dart_tool/flutter_build</code>中），后端编译失败：找不到对应的<code>&#123;flutter_sdk&#125;/bin/cache/artifacts/engine/linux-x64-release/gen_snapshot</code>程序</li>
</ol>
<p>注：<code>gen_snapshot</code>本身是个可执行程序，这个程序要在Mac主机上运行（Mac的目标代码），<code>gen_snapshot</code>同时是个编译器，我们希望在Mac上交叉编译出Linux的目标代码。</p>
<p>而Flutter SDK官方只提供了Android、iOS的交叉编译工具（gen_snapshot），以及桌面环境的本地编译工具，不支持交叉编译Linux。</p>
<p>由于<code>gen_snapshot</code>是由Flutter引擎源码编译生成的，可以尝试修改源码，生成能在Mac上运行的Linux交叉编译工具。这里简单尝试了一下，没成功：<code>./src/flutter/tools/gn --taget-os=linux --linux-cpu=x64 --release</code>。缺少llvm环境、sysroot等。</p>
<p>要想交叉编译Linux应用，可以利用Docker容器作为编译环境，参考<a href="//todo">Flutter编译环境搭建探索</a></p>
<h1 id="Flutter-Run原理"><a href="#Flutter-Run原理" class="headerlink" title="Flutter Run原理"></a>Flutter Run原理</h1><p>上面分析了如何Flutter应用的构建，那么如何将构建好的产物运行起来，程序入口是哪？</p>
<p>直接从<code>RunCommand</code>开始分析。这里不具体分析了，简单介绍下流程：</p>
<ol>
<li><code>src/commands/run.dart</code>：<code>RunCommand</code>创建FlutterDevice，根据参数判断调用<code>ColdRunner</code>还是<code>HotRunner</code></li>
<li><code>src/resident_runner.dart</code>：最终会调用Device的startApp方法</li>
<li><code>src/android/android_device.dart</code>：AndroidDevice中是通过<code>adb shell</code>安装apk，然后调用<code>am start</code>命令，并传参数给<code>FlutterActivity</code></li>
<li><code>src/desktop_device.dart</code>：DesktopDevice（桌面设备）中是直接找到可执行程序路径，通过命令启动。</li>
</ol>
<h1 id="gen-snapshot产物"><a href="#gen-snapshot产物" class="headerlink" title="gen_snapshot产物"></a>gen_snapshot产物</h1><p>上面提到了gen_snapshot将<code>app.dill</code>编译为<code>app.so</code>，主要由4个文件组成：参考<a href="https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode">Flutter-engine-operation-in-AOT-Mode</a></p>
<ul>
<li>Dart VM Snapshot：虚拟机快照，所有Isolate共享的Dart堆的初始状态，存放在数据段中</li>
<li>Dart VM Instructions：虚拟机说明，所有Isolate共享的AOT指令，存放在文本段中</li>
<li>Isolate Snapshot：Isolate快照，特定Isolate的Dart堆的初始状态，存放在数据段中</li>
<li>Isolate Instructions：Isolate说明，特定Isolate执行的AOT指令，存放在文本段中</li>
</ul>
<p><strong>注：这里的vm_snapshot_data和isolate_snapshot_data和上文Debug模式中拷贝的Flutter资源不一样。上文拷贝的是Flutter引擎编译出来的快照，这里是开发者写的Dart代码编译出来的快照。</strong></p>
<p>结合<code>gen_snapshot</code>帮助和源码分析：</p>
<p><img src="/2022/01/12/flutter-2022-01-12-Flutter%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/gen_snapshot%E5%B8%AE%E5%8A%A9.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;dart_sdk&#125;/runtime/bin/gen_snapshot.cc</span></span><br><span class="line"><span class="comment">// The ordering of this list must match the SnapshotKind enum above.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kSnapshotKindNames[] = &#123;</span><br><span class="line">    <span class="comment">// clang-format off</span></span><br><span class="line">    <span class="string">&quot;core&quot;</span>,</span><br><span class="line">    <span class="string">&quot;core-jit&quot;</span>,</span><br><span class="line">    <span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;app-jit&quot;</span>,</span><br><span class="line">    <span class="string">&quot;app-aot-assembly&quot;</span>,</span><br><span class="line">    <span class="string">&quot;app-aot-elf&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vm-aot-assembly&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">// clang-format on</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gen_snapshot支持多种编译方式：（亲测可编译）</p>
<ol>
<li>core：输出Dart VM Snapshot、Isolate Snapshot</li>
<li>core-jit：输出Dart VM Snapshot、Isolate Snapshot、Dart VM Instructions、Isolate Instructions</li>
<li>app和app-jit：输出Dart VM Snapshot、Isolate Snapshot、Isolate Instructions</li>
<li>app-aot-elf：输出ELF共享库文件，如<code>.so</code>文件</li>
<li>app-aot-assembly和vm-aot-assembly：输出<code>.S</code>汇编文件</li>
</ol>
<p>流程如下：</p>
<p><img src="/2022/01/12/flutter-2022-01-12-Flutter%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/gen_snapshot%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B.png"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>了解编译和构建流程有几大作用：</p>
<ol>
<li>便于分析定位构建错误，一般报错之后可以在<code>flutter_tools</code>中搜索关键字，找到报错的地方，分析代码上下文。</li>
<li>可以修改<code>flutter_tools</code>流程，定制构建命令，修改编译和打包流程</li>
<li>了解Flutter代码的编译，如何生成产物，合并打包</li>
</ol>
<p>Flutter SDK包含框架代码、脚手架、编译工具、调试工具和各种脚本等。</p>
<p>Flutter只是一个框架，不是一门语言，Flutter使用了Dart语言，Flutter引擎中的嵌入层（UI渲染、输入输出、以及PlatformChannel等）使用了平台原生语言（如C++，Java等）。</p>
<p>Flutter的编译和跨平台执行实际是Dart代码的编译和跨平台执行，可以看到<code>front_end</code>、<code>gen_snapshot</code>都是Dart SDK中的代码，Flutter只是对编译命令进行了一些封装，并且将Flutter框架代码也加入编译。</p>
<blockquote>
<p>通过ninja实现Dart SDK的多平台编译，生成不同平台的gen_snapshot程序，使用不同平台的gen_snapshot程序，可以生成不同平台的目标代码。</p>
<p>要定制Flutter引擎，交叉编译到不同嵌入式平台运行，可以先研究理解纯Dart程序的交叉编译和运行。</p>
</blockquote>
<p>关于Dart编译前端（生成Dart Kernel文件，即<code>.dill</code>）和编译后端（生成目标代码）过程可以参考：<a href="/2022/01/03/flutter-2022-01-05-Dart%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C/">Dart的编译和执行</a></p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/4e8ccb02e92d">研读Flutter——打包编译流程详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter源码下载和编译</title>
    <url>/2022/01/06/flutter-2022-01-06-Flutter%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="SDK下载和编译"><a href="#SDK下载和编译" class="headerlink" title="SDK下载和编译"></a>SDK下载和编译</h1><p>目的：</p>
<ol>
<li>学习源码</li>
<li>定制框架：如修改<code>flutter_tools</code>编译工具等</li>
</ol>
<p>方法和搭建Flutter开发环境类似</p>
<ol>
<li><p>直接clone或先fork到本地：<code>git clone git@github.com:flutter/flutter.git</code></p>
</li>
<li><p>配置环境变量，或者直接进入bin目录执行flutter命令</p>
</li>
<li><p>安装依赖包：<code>flutter update-packages</code></p>
</li>
<li><p>检查环境：<code>flutter doctor</code></p>
</li>
<li><p>Android Studio打开<code>&#123;flutter_framework&#125;/packages/</code>下的项目，默认会当做Android工程，IDE提示<code>Dart SDK is not configured</code>或者<code>Dart support is not enabled for the module &#39;flutter_tools&#39;</code>，如下</p>
<p><img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/AS%E6%89%93%E5%BC%80Dart%E9%85%8D%E7%BD%AE.png"></p>
</li>
<li><p>配置Flutter工程：直接点击上图的<code>Open Dart Settings</code>或者打开<code>Prefereneces&gt;Language&gt;Dart/Flutter</code>。配置Dart SDK和Flutter SDK路径，对照下Flutter应用项目的配置即可。如下</p>
<img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/AS配置DartSDK.png" style="zoom: 67%;">

<img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/AS配置FlutterSDK.png" style="zoom:67%;"></li>
<li><p>配置完之后即可在IDE查看和修改源码</p>
</li>
<li><p>编译源码</p>
<ol>
<li>删除<code>&#123;flutter_framework&#125;/bin/cache/flutter_tools.snapshot</code>（Dart快照文件）和<code>&#123;flutter_framework&#125;/bin/cache/flutter_tools.stamp</code>（当前SDK的commit id文件）</li>
<li>运行flutter命令的时候会自动编译源码，重新生成dart快照文件。</li>
</ol>
</li>
</ol>
<h1 id="Engine下载和编译"><a href="#Engine下载和编译" class="headerlink" title="Engine下载和编译"></a>Engine下载和编译</h1><p>这里只演示了官方支持的平台编译，还不涉及嵌入层的定制和交叉编译（用于定制的嵌入式平台运行Engine）。</p>
<p>主要有几个目的</p>
<ol>
<li>学习源码</li>
<li>定制引擎，使得Flutter能够在其他目标平台运行，例如树莓派，鸿蒙系统等</li>
<li>通过压缩、裁剪引擎优化包体积</li>
</ol>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">官方文档</a></p>
<p><code>depot_tools</code>安装：参考<a href="/2022/01/04/%E5%B7%A5%E5%85%B7-2022-01-04-depot_tools%E4%BB%8B%E7%BB%8D/">depot_tools介绍</a></p>
<ol>
<li>clone仓库：<code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code></li>
<li>设置环境变量：<code>.bash_profile</code>文件中添加<code>export PATH=$PATH:&#123;your_path&#125;/depot_tools/</code></li>
</ol>
<p>生成<code>.gclient</code>文件：<code>gclient config git@github.com:flutter/engine.git --unmanaged --name=src/flutter</code></p>
<blockquote>
<p>也可以手动创建文件填写。这里直接使用官方仓库地址，如果要修改提交源码，则需要fork到自己的仓库下载。</p>
</blockquote>
<p>下载源码和依赖项目（大概10个G，不要中断下载）：<code>gclient sync --verbose</code></p>
<blockquote>
<p>依赖项目如glwf、skia、dart、android sdk等，一般不需要修改，只需要修改flutter engine项目</p>
</blockquote>
<p>切换版本：默认获取master分支的版本，建议切换engine版本，与Flutter SDK保持一致，需要进入<code>src/flutter</code>目录执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> commitId使用和当前Flutter SDK对应的版本：cat bin/internal/engine.version，如下图</span></span><br><span class="line">git reset --hard &lt;commiId&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次同步代码：不同engine版本依赖的项目版本可能不同</span></span><br><span class="line">gclient sync --with_branch_heads --with_tags --verbose</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/Flutter%E5%BC%95%E6%93%8E%E7%89%88%E6%9C%AC.png"></p>
<blockquote>
<p>主机包含多个版本Dart SDK的时候。Dart编译前端、编译后端、以及Dart运行时的版本必须一致，否则会报错版本不匹配。建议切换engine版本，保持Dart SDK版本一致。否则需要进入对应路径下执行命令。</p>
<p>详情参考<a href="/2022/01/05/flutter-2022-01-05-Dart%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C/">Dart的编译和执行</a></p>
</blockquote>
<h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p><a href="https://github.com/flutter/flutter/wiki/Compiling-the-engine">官方文档</a></p>
<p>使用<code>gn</code>生成ninja构建文件（参数参考官方文档）：<code>&#123;engine_path&#125;/src/flutter/tools/gn --unoptimized --android --runtime-mode debug --android-cpu arm</code></p>
<blockquote>
<p>这里的gn只是一个shell脚本，内部调用<code>gn gen</code>命令执行</p>
<p>对应的构建产物会有多种组合：</p>
<ul>
<li>平台：iOS, Android, macOS, Linux, Windows</li>
<li>构建模式：debug, release, profile</li>
<li>是否优化：opt, unopt</li>
<li>cpu架构：arm、arm64、x86、x64</li>
</ul>
<p>产物命名格式：<code>&#123;android/ios/host&#125;_&#123;debug/profile/release&#125;_&#123;unoptimized/optimized&#125;_&#123;cpu架构&#125;</code></p>
<p>除此之外还可以根据图形后端进行编译：如OpenGL、Vulkan、software</p>
</blockquote>
<p>构建完之后生成<code>out</code>目录，根据参数生成不同文件夹，如<code>android_debug_unopt</code>、<code>ios_debug_unopt</code>等。</p>
<p>内部包括ninja构建文件、<code>compile_commands.json</code>文件（Intellisense，用于编辑器索引）、xcode项目文件等</p>
<p>进入src目录，使用<code>ninja</code>编译：<code>ninja -C out/android_debug_unopt</code></p>
<blockquote>
<p>编译生成的文件在<code>out/android_debug_unopt</code>目录下。</p>
<ul>
<li>Android引擎编译主要产物是<code>flutter.jar</code>，其中包含<code>libflutter.so</code>Flutter引擎层代码、<code>flutter_embedding_debug.jar</code>嵌入层代码。</li>
<li>iOS引擎编译主要产物是<code>Flutter.framework</code>，其中包含Flutter引擎层代码、<code>FlutterEmbedder.framework</code>嵌入层代码和<code>icudtl.dat</code>国际化数据文件。</li>
</ul>
<p>上述产物是Flutter框架本身编译出的目标代码，除此之外，还包括Dart SDK产物，如front_end和gen_snapshot编译工具等</p>
</blockquote>
<h2 id="替换Engine"><a href="#替换Engine" class="headerlink" title="替换Engine"></a>替换Engine</h2><p><a href="https://github.com/flutter/flutter/wiki/The-flutter-tool#using-a-locally-built-engine-with-the-flutter-tool">官方文档</a></p>
<p><strong>Flutter默认会下载和使用官方构建好的engine</strong>，包括各种架构的版本，位于<code>&#123;flutter_sdk&#125;/bin/cache/artifacts/engine</code>下。要替换自己编译出来的引擎，有几种方式：</p>
<p>方式一：直接用引擎编译出来的<code>frontend_server.dart.snapshot</code>和<code>gen_snapshot</code>，手动进行前端编译和后端编译。</p>
<p>方式二：将引擎编译产物拷贝到Flutter SDK缓存路径下，替换官方默认引擎。</p>
<p>方式三：使用<code>local-engine-src-path</code>和<code>--local-engine</code>选项。如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定的引擎需要与构建模式对应：debug版的引擎编译debug版的应用</span></span><br><span class="line">flutter run --local-engine-src-path &#123;path&#125;/engine/src --local-engine=&#123;path&#125;/engine/src/out/host_debug_unopt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>flutter引擎和sdk在同级目录下或者<code>-local-engine</code>使用绝对路径，可以省略<code>--local-engine-src-path</code>参数。</p>
<p>下面会分析<code>flutter_tools</code>解析该参数过程</p>
</blockquote>
<p>为Web应用构建，使用主机引擎即可：<code>flutter run --local-engine=host_debug_unopt -d chrome</code></p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>参考<a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">官方文档</a></p>
<h3 id="Clion"><a href="#Clion" class="headerlink" title="Clion"></a>Clion</h3><p>将gn生成的<code>compile_commands.json</code>文件复制到<code>src/flutter</code>中，使用Clion打开，indexing之后就可以跟踪和跳转代码</p>
<blockquote>
<p>JetBrains系列，需要激活</p>
</blockquote>
<h3 id="Xcode【Objective-C-】"><a href="#Xcode【Objective-C-】" class="headerlink" title="Xcode【Objective-C++】"></a>Xcode【Objective-C++】</h3><p>Mac电脑上，对于Objective-C++项目，可以直接打开xcode工程文件<code>open out/host_debug_unopt/flutter_engine.xcodeproj</code></p>
<h3 id="VSCode【C-C-】"><a href="#VSCode【C-C-】" class="headerlink" title="VSCode【C/C++】"></a>VSCode【C/C++】</h3><ol>
<li><p>安装cmake：<code>brew install cmake</code></p>
</li>
<li><p>安装cquery或者ccls：<code>brew install cquery</code>，<code>brew install ccls</code></p>
<blockquote>
<p><a href="https://github.com/jacobdufault/cquery">cquery</a>已经不再维护，推荐<a href="https://clangd.llvm.org/">clangd</a>和<a href="https://github.com/MaskRay/ccls">ccls</a></p>
<p>三者都是语言服务器，用于代码语义分析，通过插件与其他编辑器一起工作。可以给编辑器添加智能功能：代码提示和补全、格式化、代码跳转、编译错误提示等</p>
<p>ccls源自cquery。clangd基于Clang C++编译器，属于LLVM项目</p>
</blockquote>
</li>
<li><p><a href="https://github.com/jacobdufault/cquery/wiki/Building-cquery">构建cquery</a>或者<a href="https://github.com/MaskRay/ccls/wiki/Build">构建ccls</a></p>
</li>
<li><p>安装VSCode插件，如<code>VSCode-cquery</code>或<code>vscode-ccls</code>，配置插件（参考上面cquery和ccls文档）</p>
</li>
<li><p>配置Intellisense文件：</p>
<ol>
<li>将gn生成的<code>compile_commands.json</code>文件拷贝到要打开的项目根目录，如<code>src/flutter</code>下，打开项目</li>
<li>或者在<code>c_cpp_properties.json</code>文件中配置<code>compile_commands.json</code>的绝对路径</li>
</ol>
</li>
</ol>
<h3 id="VSCode【Java】"><a href="#VSCode【Java】" class="headerlink" title="VSCode【Java】"></a>VSCode【Java】</h3><p>对于Java项目，VSCode需要配置jar包依赖。</p>
<ol>
<li>安装VSCode插件<code>vscjava.vscode-java-pack</code>和<code>vscjava.vscode-java-dependency</code></li>
<li>添加文件夹路径，如<code>shell/platform/android</code></li>
<li>打开Java Dependencies资源管理器窗口，或者使用命令打开”Explorer: Focus on Java Dependencies View”</li>
<li>刷新视图窗口</li>
<li>配置<code>Referenced Libraries</code>，添加src/third_party/android_embedding_dependencies<code>文件夹。</code></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相当于配置settings.json如下</span></span><br><span class="line">&quot;java.project.referencedLibraries&quot;: [</span><br><span class="line">  <span class="string">&quot;&#123;path to engine&#125;/src/third_party/android_embedding_dependencies/lib/**/*.jar&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ul>
<li><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">Flutter Wiki官方文档</a></li>
</ul>
<p>gclient使用可以参考<a href="https://www.cnblogs.com/xl2432/p/11596695.html">chromium开发工具–gclient</a>、<a href="https://keyou.github.io/blog/2017/11/02/gclient/">gclient 介绍</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart的编译和执行原理</title>
    <url>/2022/01/05/flutter-2022-01-05-Dart%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="Dart简介"><a href="#Dart简介" class="headerlink" title="Dart简介"></a>Dart简介</h1><p><a href="https://dart.dev/overview">官方网站</a></p>
<p>目标是高效地开发多平台应用，提供灵活的运行时环境和编译工具。</p>
<blockquote>
<p>理论上所有高级语言都可跨平台，关键在于语法、平台库好不好用，编译工具成不成熟。下面会详细介绍下Dart的编译和执行</p>
</blockquote>
<h2 id="Dart-SDK安装"><a href="#Dart-SDK安装" class="headerlink" title="Dart SDK安装"></a>Dart SDK安装</h2><p>参考<a href="https://dart.dev/get-dart">Dart SDK安装</a>。Dart SDK中包含了Dart核心库、编译器、命令行工具等。Dart SDK是由Dart源码编译出来的归档文件。</p>
<ul>
<li>Flutter SDK内置了Dart SDK工具（Dart SDK归档文件，包括工具和核心库），位于<code>&#123;flutter_sdk&#125;/bin/cache/dart-sdk</code>中，不需要再单独下载。</li>
<li>Flutter Engine中依赖了Dart的源码，位于<code>&#123;flutter_engine&#125;/third_party/dart</code>中，通过ninja构建出Dart SDK可执行程序，供Flutter SDK使用。</li>
</ul>
<h2 id="Dart语言"><a href="#Dart语言" class="headerlink" title="Dart语言"></a>Dart语言</h2><p>支持众多特性：类型安全（静态类型检查、dynamic运行时检查）、空安全、异步调用、流、箭头函数、getter函数等。基本语法参考<a href="https://dart.dev/guides/language/language-tour">Dart语言</a></p>
<h2 id="Dart库"><a href="#Dart库" class="headerlink" title="Dart库"></a>Dart库</h2><p><a href="https://dart.dev/guides/libraries">核心库</a>和<a href="https://dart.dev/guides/libraries/useful-libraries">三方库</a></p>
<h2 id="Dart项目文件"><a href="#Dart项目文件" class="headerlink" title="Dart项目文件"></a>Dart项目文件</h2><p>Dart使用<code>pubspec.yaml</code>文件保存项目信息、发布信息、依赖包等。<a href="https://dart.dev/tools/pub/pubspec">pubspec说明</a></p>
<blockquote>
<p>类似npm的<code>package.json</code>，本地会缓存依赖包，不同项目可以共用本地缓存的依赖包</p>
</blockquote>
<p>可以使用<code>dart pub &lt;subcommand&gt;</code>命令管理项目，如add添加依赖，get获取依赖等。可以用<code>dart pub -h</code>查看帮助，也可以看<a href="https://dart.dev/tools/pub/cmd">dart pub说明</a></p>
<blockquote>
<p><strong>如果用dart开发Flutter程序，使用<code>flutter pub &lt;subcommand&gt;</code>命令替代，flutter对dart命令进行了一层包装</strong></p>
</blockquote>
<p>新建<code>pubspec.yaml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">myapp</span> <span class="comment"># 项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span> <span class="comment"># dart版本</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&quot;&gt;=2.12.0 &lt;3.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span>  <span class="comment"># 依赖包</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">^0.6.0</span></span><br></pre></td></tr></table></figure>

<p>执行<code>dart pub get</code>获取依赖，会生成几个文件。不需要提交，加到<code>.gitignore</code>中</p>
<ol>
<li><code>pubspec.lock</code>：保存项目信息</li>
<li><code>.packages</code>：已经弃用，替换为<code>package_config.json</code>文件</li>
<li><code>.dart_tool/package_config.json</code>：将依赖包映射到系统缓存该包的路径</li>
</ol>
<p><code>main.dart</code>中可以导入包使用，运行时会从<code>package_config.json</code>中查找依赖包路径</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:js/js.dart&#x27;</span> <span class="keyword">as</span> js;</span><br></pre></td></tr></table></figure>

<p><code>dart compile</code>和<code>dart --snapshot</code>可以使用<code>--packages=&lt;path&gt;</code>选项指定<code>.packages</code>文件或者<code>package_config.json</code>文件，用于编译时查找依赖包路径</p>
<h2 id="Dart工具"><a href="#Dart工具" class="headerlink" title="Dart工具"></a>Dart工具</h2><p>Dart SDK中提供了一些工具，使用<code>-h</code>查看帮助或者参考<a href="https://dart.dev/tools/dart-tool">Dart命令行工具</a>。源码入口位于<code>&#123;dart_sdk&#125;/pkg/dartdev/</code>中</p>
<p><img src="/2022/01/05/flutter-2022-01-05-Dart%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C/dart%E5%B7%A5%E5%85%B7.png"></p>
<ul>
<li><code>dart</code>：用于创建、格式化、分析、测试、编译和运行dart代码</li>
<li><code>dartaotruntime</code>：用于执行aot预编译过机器码</li>
<li><code>dartdoc</code>：用于生成API文档</li>
</ul>
<p>除了上面三个工具外，还有<code>dart2js</code>、<code>dart2native</code>、<code>dartanalyzer</code>、<code>dartdevc</code>、<code>dartfmt</code>、<code>pub</code>等工具。这些工具从2.10版本开始全部被封装到了<code>dart</code>中，通过<code>dart &lt;subcommand&gt;</code>的方式执行：</p>
<ul>
<li><code>dart2native</code>, <code>dart2aot</code>,  <code>dart2js</code> 工具被 <code>dart compile</code> 替代</li>
<li><code>dartanalyzer</code>被<code>dart analyze</code>替代</li>
<li><code>dartfmt</code>被<code>dart format</code>替代</li>
<li><code>pub</code>被<code>dart pub</code>替代</li>
</ul>
<p><code>&#123;flutter_sdk&#125;/bin/dart</code>对<code>dart-sdk</code>的工具做了一层包装，执行的时候会调用<code>dart-sdk</code>中的工具。</p>
<blockquote>
<p>由于配置Flutter SDK环境变量<code>&#123;flutter_sdk&#125;/bin</code>的时候没有配置<code>dart-sdk</code>的环境变量，如果要使用<code>dartaotruntime</code>工具，需要进入对应目录执行，或者给<code>dart-sdk</code>也配置环境变量</p>
</blockquote>
<h1 id="Dart的编译和执行"><a href="#Dart的编译和执行" class="headerlink" title="Dart的编译和执行"></a>Dart的编译和执行</h1><h2 id="Dart虚拟机"><a href="#Dart虚拟机" class="headerlink" title="Dart虚拟机"></a>Dart虚拟机</h2><p>Dart虚拟机源码位于<code>&#123;dart_sdk&#125;/runtime/vm</code>中，包含以下几个部分：</p>
<p><img src="/2022/01/05/flutter-2022-01-05-Dart%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C/DartVM.png"></p>
<p>DartVM作为虚拟机为Dart高级语言提供执行环境，但这并不表示Dart一定运行在虚拟机中。Dart的运行主要有几种方式：</p>
<ul>
<li>虚拟机执行：通过JIT即时编译+解释器，执行Dart源文件或者Kernel二进制文件，运行在Dart虚拟机中。对应<code>dart run</code>命令</li>
<li>目标代码执行：通过AOT预编译成目标代码，运行在预编译运行时环境（Precompiled Runtime）中。不包含编译器，因此无法动态加载Dart源码。对应<code>dartaotruntime</code>命令</li>
</ul>
<blockquote>
<ul>
<li>开发阶段：运行在Dart虚拟机中，通过Dart虚拟机提供的即时编译器（JIT）执行，支持增量编译，热重载和调试。</li>
<li>发布阶段：通过Dart的AOT编译器编译成目标平台的代码，在Dart预编译运行时（Precompiled Runtime）中执行，提高启动速度和执行效率。</li>
</ul>
<p>Dart 2之后，Dart VM不支持直接执行源代码，只接收Kernel AST序列化成的Kernel二进制文件（即.dill文件）。通过Dart的<a href="https://github.com/dart-lang/sdk/tree/master/pkg/front_end">编译前端（CFE，common front-end）</a>编译，并被其他工具所依赖使用，例如Dart VM、dart2js、Dart Dev Compiler。</p>
</blockquote>
<p>Dart运行时会被打包到<code>Self-Contained</code>的目标可执行程序中，同时也是Dart虚拟机的一部分，包含以下功能</p>
<ul>
<li>内存管理：提供对象分配和分代垃圾回收功能。</li>
<li>运行时类型检查和强制转换</li>
<li>管理<code>isolates</code>：包括主isolate和应用自行创建的isolate</li>
</ul>
<h2 id="虚拟机执行"><a href="#虚拟机执行" class="headerlink" title="虚拟机执行"></a>虚拟机执行</h2><p>使用<code>dart run</code>命令启动虚拟机执行程序，如下</p>
<ol>
<li><p>新建<code>main.dart</code>文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.dart</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello, World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行<code>dart main.dart</code>，输出”Hello, World!”</p>
</li>
</ol>
<blockquote>
<p>run子命令启动一个Dart虚拟机，执行未编译过的源码或者部分快照类型（JIT、Kernel快照），不支持执行aot快照。</p>
<p>可以省略，例如<code>dart main.dart</code>，<code>dart main.dill</code></p>
</blockquote>
<h2 id="Dart编译"><a href="#Dart编译" class="headerlink" title="Dart编译"></a>Dart编译</h2><h3 id="compile命令"><a href="#compile命令" class="headerlink" title="compile命令"></a>compile命令</h3><p><code>dart compile</code>命令封装了不同场景下的编译，不需要手动执行编译前端和编译后端。源码位于<code>&#123;dart_sdk&#125;/pkg/dartdev/lib/src/commands/compile.dart</code>，分为以下几种方式：</p>
<ol>
<li><code>exe</code>：生成<code>Self-Contained</code>可执行文件，<strong>包含生成的目标代码和一个小型的Dart运行时</strong>，可以直接运行<ol>
<li>编译：<code>dart compile exe main.dart</code>，生成<code>main.exe</code>文件</li>
<li>运行：<code>./main.exe</code>，输出”Hello, World!”</li>
</ol>
</li>
<li><code>aot-snapshot</code>：生成AOT快照文件，<strong>包含生成的目标代码，但不包含Dart运行时</strong>，需要使用<code>dartaotruntime</code>执行<ol>
<li>编译：<code>dart compile aot-snapshot main.dart</code>，生成<code>main.aot</code>文件</li>
<li>执行<code>dartaotruntime main.aot</code>，输出”Hello, World!”</li>
</ol>
</li>
<li><code>jit-snapshot</code>：生成JIT快照文件，<strong>包含生成的目标代码，不同的是在训练运行期间已经加载和解析过代码</strong>，使用<code>dart run</code>运行。由于在训练运行期间已经解析和编译过，Dart虚拟机不需要再进行解析和编译，因此可以更快的执行代码。（经过训练和优化，有可能比aot执行更快）<ol>
<li>编译：<code>dart compile jit-snapshot main.dart</code>，生成<code>main.jit</code>文件，并且会执行一遍程序训练，输出”Hello, World!”</li>
<li>运行：<code>dart run main.jit</code>，输出”Hello, World!”</li>
</ol>
</li>
<li><code>kernel</code>：生成<code>.dill</code>二进制的kernel快照文件，<strong>是一种中间代码，和平台无关，具有可移植性</strong>。包含二进制格式的Dart抽象语法树（Kernel AST）<ol>
<li>编译：<code>dart compile kernel main.dart</code>，生成<code>main.dill</code>文件</li>
<li>执行：<code>dart run main.dill</code>，输出”Hello, World!”</li>
</ol>
</li>
<li><code>js</code>：生成js文件<ol>
<li>编译：<code>dart compile js main.dart</code>，生成<code>out.js</code>文件</li>
<li>可以使用<code>webdev serve</code>命令启动开发服务器运行js</li>
</ol>
</li>
</ol>
<p><code>exe</code>和<code>aot-snapshot</code>存在一些限制：</p>
<ol>
<li>不支持交叉编译、只能本地编译本地运行：需要在macOS、Windows、Linux主机上分别编译出三个目标程序</li>
<li>生成的可执行程序不支持签名</li>
<li>不支持<code>dart:mirrors</code>（用于动态反射）和<code>dart:developer</code>（用于调试检查）库，参考<a href="https://dart.dev/guides/libraries">Dart核心库</a>说明</li>
</ol>
<p>对比下编译产物文件，如下：<code>exe &gt; jit-snapshot &gt; aot-snapshot &gt; kernel &gt; dart source code</code>，一般情况下执行效率刚好相反。</p>
<p><img src="/2022/01/05/flutter-2022-01-05-Dart%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C/dart%E7%BC%96%E8%AF%91%E4%BA%A7%E7%89%A9%E6%96%87%E4%BB%B6.png"></p>
<p>查看<code>dart compile</code>源码，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;dart_sdk&#125;/pkg/dartdev/lib/src/commands/compile.dart</span></span><br><span class="line"><span class="comment">//dart compile命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompileCommand</span> <span class="keyword">extends</span> <span class="title">DartdevCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> cmdName = <span class="string">&#x27;compile&#x27;</span>;</span><br><span class="line">  CompileCommand(&#123;<span class="built_in">bool</span> verbose = <span class="keyword">false</span>&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(cmdName, <span class="string">&#x27;Compile Dart to various formats.&#x27;</span>, verbose) &#123;</span><br><span class="line">    addSubcommand(CompileJSCommand(verbose: verbose));</span><br><span class="line">    addSubcommand(CompileSnapshotCommand( <span class="comment">//dart compile jit-snapshot子命令</span></span><br><span class="line">      commandName: CompileSnapshotCommand.jitSnapshotCmdName,</span><br><span class="line">      help: <span class="string">&#x27;to a JIT snapshot.\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;To run the snapshot use: dart run &lt;JIT file&gt;&#x27;</span>,</span><br><span class="line">      fileExt: <span class="string">&#x27;jit&#x27;</span>,</span><br><span class="line">      formatName: <span class="string">&#x27;app-jit&#x27;</span>,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ));</span><br><span class="line">    addSubcommand(CompileSnapshotCommand( <span class="comment">//dart compile kernel子命令</span></span><br><span class="line">      commandName: CompileSnapshotCommand.kernelCmdName,</span><br><span class="line">      help: <span class="string">&#x27;to a kernel snapshot.\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;To run the snapshot use: dart run &lt;kernel file&gt;&#x27;</span>,</span><br><span class="line">      fileExt: <span class="string">&#x27;dill&#x27;</span>,</span><br><span class="line">      formatName: <span class="string">&#x27;kernel&#x27;</span>,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ));</span><br><span class="line">    addSubcommand(CompileNativeCommand(</span><br><span class="line">      commandName: CompileNativeCommand.exeCmdName,</span><br><span class="line">      help: <span class="string">&#x27;to a self-contained executable.&#x27;</span>,</span><br><span class="line">      format: <span class="string">&#x27;exe&#x27;</span>,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ));</span><br><span class="line">    addSubcommand(CompileNativeCommand(</span><br><span class="line">      commandName: CompileNativeCommand.aotSnapshotCmdName,</span><br><span class="line">      help: <span class="string">&#x27;to an AOT snapshot.\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;To run the snapshot use: dartaotruntime &lt;AOT snapshot file&gt;&#x27;</span>,</span><br><span class="line">      format: <span class="string">&#x27;aot&#x27;</span>,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dart-–snapshot"><a href="#dart-–snapshot" class="headerlink" title="dart –snapshot"></a>dart –snapshot</h3><p>在Flutter SDK中经常看到<code>.snapshot</code>后缀的文件，如<code>flutter_tools.snapshot</code>，查看Flutter命令脚本的源码中使用了<code>dart --snapshot</code>命令，官网没有说明。使用<code>dart --snapshot</code>查看帮助如下：</p>
<p><img src="/2022/01/05/flutter-2022-01-05-Dart%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C/dart%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9.png"></p>
<p><code>--snapshot</code>用于生成快照文件，<code>--snapshot-kind</code>指定生成JIT快照还是kernel快照。默认生成kernel快照。</p>
<blockquote>
<p><code>dart --snapshot</code>源码入口位于<code>&#123;dart-sdk&#125;/runtime/bin/main.cc</code></p>
</blockquote>
<h3 id="CompileSnapshotCommand"><a href="#CompileSnapshotCommand" class="headerlink" title="CompileSnapshotCommand"></a>CompileSnapshotCommand</h3><p>查看<code>CompileSnapshotCommand</code>代码，对应<code>dart compile kernel</code>和<code>dart compile jit-snapshot</code>命令。实际就是调用<code>dart --snapshot-kind=$formatName</code>执行。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;dart_sdk&#125;/pkg/dartdev/lib/src/commands/compile.dart</span></span><br><span class="line"><span class="comment">//jit和kernel编译</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompileSnapshotCommand</span> <span class="keyword">extends</span> <span class="title">CompileSubcommandCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> jitSnapshotCmdName = <span class="string">&#x27;jit-snapshot&#x27;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> kernelCmdName = <span class="string">&#x27;kernel&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> commandName;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> help;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> fileExt;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> formatName;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  FutureOr&lt;<span class="built_in">int</span>&gt; run() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//调用dart --snapshot-kind=$formatName</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args = [];</span><br><span class="line">    args.add(<span class="string">&#x27;--snapshot-kind=<span class="subst">$formatName</span>&#x27;</span>);</span><br><span class="line">    args.add(<span class="string">&#x27;--snapshot=<span class="subst">$&#123;path.canonicalize(outputFile)&#125;</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> process = <span class="keyword">await</span> startDartProcess(sdk, args);</span><br><span class="line">    <span class="keyword">return</span> process.exitCode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dart compile kernel/jit-snapshot</code>等价于<code>dart --snapshot-kind=kernel/app-jits</code>。只不过是新版本Dart工具统一封装到compile中而已。</p>
<blockquote>
<p>例如<code>dart --snapshot=main.snapshot main.dart</code>生成<code>main.snapshot</code>，<code>dart compile kernel main.dart</code>生成<code>main.dill</code>。<code>main.dill</code>和<code>main.snapshot</code>实际上是一样的，都是Kernel快照文件，文件大小也相同。</p>
</blockquote>
<h3 id="CompileNativeCommand"><a href="#CompileNativeCommand" class="headerlink" title="CompileNativeCommand"></a>CompileNativeCommand</h3><p>查看<code>CompileNativeCommand</code>代码，对应<code>dart compile aot</code>和<code>dart compile exe</code>命令，调用了<code>dart2native</code>的<code>generateNative</code>方法，</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;dart_sdk&#125;/pkg/dartdev/lib/src/commands/compile.dart</span></span><br><span class="line"><span class="comment">//exe和aot编译</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompileNativeCommand</span> <span class="keyword">extends</span> <span class="title">CompileSubcommandCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> exeCmdName = <span class="string">&#x27;exe&#x27;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> aotSnapshotCmdName = <span class="string">&#x27;aot-snapshot&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> commandName;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> format;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> help;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  FutureOr&lt;<span class="built_in">int</span>&gt; run() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> generateNative(</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      log.stderr(<span class="string">&#x27;Error: AOT compilation failed&#x27;</span>);</span><br><span class="line">      log.stderr(e.toString());</span><br><span class="line">      <span class="keyword">return</span> compileErrorExitCode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>generateNative</code>流程如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;dart-sdk&#125;/pkg/dart2native/lib/generate.dart</span></span><br><span class="line"><span class="keyword">final</span> Directory binDir = File(Platform.resolvedExecutable).parent;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> executableSuffix = Platform.isWindows ? <span class="string">&#x27;.exe&#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> dartaotruntime = path.join(binDir.path, <span class="string">&#x27;dartaotruntime<span class="subst">$executableSuffix</span>&#x27;</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> genKernel = path.join(binDir.path, <span class="string">&#x27;snapshots&#x27;</span>, <span class="string">&#x27;gen_kernel.dart.snapshot&#x27;</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> genSnapshot = path.join(binDir.path, <span class="string">&#x27;utils&#x27;</span>, <span class="string">&#x27;gen_snapshot<span class="subst">$executableSuffix</span>&#x27;</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> productPlatformDill = path.join(binDir.parent.path, <span class="string">&#x27;lib&#x27;</span>, <span class="string">&#x27;_internal&#x27;</span>, <span class="string">&#x27;vm_platform_strong_product.dill&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; generateNative(&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> kernelFile = path.join(tempDir.path, <span class="string">&#x27;kernel.dill&#x27;</span>);</span><br><span class="line">    <span class="comment">//1. 编译前端，生成kernel文件：执行gen_kernel.dart.snapshot程序，最终会调用front_end方法</span></span><br><span class="line">    <span class="keyword">final</span> kernelResult = <span class="keyword">await</span> generateAotKernel(Platform.executable, genKernel,</span><br><span class="line">        productPlatformDill, sourcePath, kernelFile, packages, defines,</span><br><span class="line">        enableExperiment: enableExperiment,</span><br><span class="line">        extraGenKernelOptions: [</span><br><span class="line">          <span class="string">&#x27;--invocation-modes=compile&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;--verbosity=<span class="subst">$verbosity</span>&#x27;</span>,</span><br><span class="line">          <span class="keyword">if</span> (soundNullSafety != <span class="keyword">null</span>)</span><br><span class="line">            <span class="string">&#x27;--<span class="subst">$&#123;soundNullSafety ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;no-&#x27;</span>&#125;</span>sound-null-safety&#x27;</span>,</span><br><span class="line">        ]);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> snapshotFile = (outputKind == Kind.aot</span><br><span class="line">        ? outputPath</span><br><span class="line">        : path.join(tempDir.path, <span class="string">&#x27;snapshot.aot&#x27;</span>));</span><br><span class="line">    <span class="comment">//2. 编译后端，生成aot目标文件：执行gen_snapshot程序</span></span><br><span class="line">    <span class="keyword">final</span> snapshotResult = <span class="keyword">await</span> generateAotSnapshot(genSnapshot, kernelFile,</span><br><span class="line">        snapshotFile, debugPath, enableAsserts, extraOptions);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (outputKind == Kind.exe) &#123;</span><br><span class="line">      <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Generating executable.&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3. exe编译需要加上Dart运行时</span></span><br><span class="line">      <span class="keyword">await</span> writeAppendedExecutable(dartaotruntime, snapshotFile, outputPath);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (Platform.isLinux || Platform.isMacOS) &#123;</span><br><span class="line">        <span class="comment">//4. 标记为可执行</span></span><br><span class="line">        <span class="keyword">await</span> markExecutable(outputPath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Generated: <span class="subst">$outputPath</span>&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    tempDir.deleteSync(recursive: <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><ul>
<li><p>Dart编译前端（frontend，<code>&#123;dart_sdk&#125;/pkg/front_end/lib/src/api_prototype/front_end.dart</code>）：将Dart源码编译为Kernel二进制文件，是一种平台无关的中间代码。</p>
<blockquote>
<p>Dart编译前端生成的.dill文件类似于Java编译前端的.class文件，通过虚拟机执行，和平台无关。</p>
</blockquote>
</li>
<li><p>Dart编译后端（gen_snapshot，<code>&#123;dart_sdk&#125;/runtime/bin/gen_snapshot.cc</code>）：将Kernel二进制文件编译出目标代码</p>
<ul>
<li>将Kernel二进制代码生成一个控制流图（CFG，control flow graph），CFG由中间语言（IL，Intermediate Language）指令组成。</li>
<li>对IL指令进行优化</li>
<li>CFG编译成机器码，每个IL指令对应多个机器指令</li>
</ul>
<blockquote>
<p>IL指令类似于虚拟机指令，从堆栈中获取操作数，执行操作，将结果推送到堆栈中</p>
</blockquote>
</li>
<li><p>创建exe可执行文件：<code>writeAppendedExecutable</code>方法合并<code>dartaotruntime</code>和aot目标代码</p>
</li>
</ul>
<p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译前端1</span></span><br><span class="line">dart &#123;dart-sdk&#125;/bin/snapshots/frontend_server.dart.snapshot </span><br><span class="line">--sdk-root &#123;dart-sdk&#125;/lib/_internal/ </span><br><span class="line">--platform vm_platform_strong.dill </span><br><span class="line">--aot --tfa </span><br><span class="line">-Ddart.vm.profile=false </span><br><span class="line">-Ddart.vm.product=true </span><br><span class="line">--output-dill &#123;build_dir&#125;/app.dill </span><br><span class="line">main.dart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译前端2：和方式一等价，参数稍微有些差异</span></span><br><span class="line">dart &#123;dart-sdk&#125;/bin/snapshots/gen_kernel.dart.snapshot </span><br><span class="line">--platform &#123;dart-sdk&#125;/lib/_internal/vm_platform_strong.dill </span><br><span class="line">--aot --tfa </span><br><span class="line">-Ddart.vm.profile=false </span><br><span class="line">-Ddart.vm.product=true </span><br><span class="line">-o &#123;build_dir&#125;/app.dill </span><br><span class="line">main.dart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译后端</span></span><br><span class="line">&#123;dart-sdk&#125;/bin/utils/gen_snapshot </span><br><span class="line">--deterministic </span><br><span class="line">--snapshot_kind=app-aot-elf </span><br><span class="line">--elf=&#123;output_path&#125;/app.aot </span><br><span class="line">app.dill</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行aot文件</span></span><br><span class="line">&#123;dart-sdk&#125;/bin/dartaotruntime app.aot</span><br></pre></td></tr></table></figure>

<p><code>gen_kernel.dart.snapshot</code>和<code>frontend_server.dart.snapshot</code>都是调用<code>front_end</code>的方法（可以分析源码，或者执行命令异常查看方法调用栈），参数稍微有些差异</p>
<blockquote>
<p>例如<code>frontend_server.dart.snapshot</code>支持<code>--import-dill</code>参数，可以加载和链接其他dill文件。</p>
</blockquote>
<p><code>gen_kernel.dart.snapshot</code>的<code>--platform</code>参数用于指定sdk完整路径，用于将平台库加载到产物中。与<code>frontend_server.dart.snapshot</code>的<code>--sdk-root</code>和<code>--platform</code>参数作用相同，<code>--sdk-root</code>指定文件夹路径，<code>--platform</code>指定文件名，加起来是完整路径。</p>
<ul>
<li>Dart平台库位于<code>&#123;dart-sdk&#125;/lib/_internal/vm_platform_strong.dill</code>。</li>
<li>Flutter平台库中包含Dart库和Flutter框架本身，位于<code>&#123;flutter_sdk&#125;/bin/cache/artifacts/engine/common/flutter_patched_sdk/platform_strong.dill</code></li>
</ul>
<p><code>--target</code>参数：使用Dart平台库时，target值需要为vm，使用Flutter平台库时，target值需要为flutter，否则会编译失败。说明如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./dart-sdk/bin/dart ./dart-sdk/bin/snapshots/frontend_server.dart.snapshot -h</span></span><br><span class="line"><span class="meta">#</span><span class="bash">....</span></span><br><span class="line">--target Target model that determines what core libraries are available</span><br><span class="line">         [vm (default), flutter, flutter_runner, dart_runner, dartdevc]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>target相关源码位于<code>&#123;dart-sdk&#125;/pkg/vm/lib/target/</code>下</p>
</blockquote>
<p>注：target为flutter时，无法使用<code>dartaotruntime</code>执行aot文件，由于找不到对应的平台库，会报错<code>Dart_LookupLibrary: library &#39;dart:_builtin&#39; not found.</code>。</p>
<h3 id="Kernel文件踩坑"><a href="#Kernel文件踩坑" class="headerlink" title="Kernel文件踩坑"></a>Kernel文件踩坑</h3><ul>
<li><code>dart compile kernel</code>生成的Kernel文件不能用于<code>gen_snapshot</code>后端编译，会报错：<code>Unable to use class Library:&#39;dart:core&#39; Class: _List@0150898 which is not loaded yet.</code>。但是可以使用<code>dart run main.dill</code>运行。</li>
<li>编译前端<code>--no-aot</code>参数生成的Kernel文件不能用于<code>gen_snapshot</code>后端编译，会报错：<code>error: Missing table selector metadata! Probably gen_kernel was run in non-AOT mode or without TFA.</code>。但是可以使用<code>dart run main.dill</code>运行</li>
<li>编译前端<code>--aot</code>参数生成的Kernel文件可以用于<code>gen_snapshot</code>后端编译，但是不能直接用dart运行，会报错：<code>error: vm.procedure-attributes.metadata metadata is allowed in precompiled mode only</code></li>
</ul>
<blockquote>
<p>上述三者都生成了Kernel文件，但是不太一样。具体区别暂时不清楚。</p>
</blockquote>
<h3 id="Dart-SDK版本一致"><a href="#Dart-SDK版本一致" class="headerlink" title="Dart SDK版本一致"></a>Dart SDK版本一致</h3><p>Dart编译前端、编译后端、以及Dart运行时的版本必须一致，否则会报错版本不匹配。例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Dart运行不同版本的编译前端报错</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dart ~/Flutter/engine/src/out/host_debug_unopt/dart-sdk/bin/snapshots/frontend_server.dart.snapshot --sdk-root ./ --target=flutter -Ddart.vm.profile=<span class="literal">false</span> -Ddart.vm.product=<span class="literal">false</span> --aot --tfa --output-dill ~/Desktop/bin/main.dill ~/Desktop/bin/main.dart</span></span><br><span class="line">Wrong full snapshot version, expected &#x27;9cf77f4405212c45daf608e1cd646852&#x27; found &#x27;d56742caf7b3b3f4bd2df93a9bbb5503&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gen_snapshot编译不同版本的dill文件报错</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ~/Flutter/flutter/bin/cache/dart-sdk/bin/utils/gen_snapshot --snapshot_kind=app-aot-elf --elf=main.aot main.dill</span></span><br><span class="line">Can&#x27;t load Kernel binary: Invalid kernel binary format version.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Dart执行不同版本的dill文件报错</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dart main.dill</span></span><br><span class="line">Can&#x27;t load Kernel binary: Invalid kernel binary format version.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Dart预编译运行时执行不同版本的aot文件报错</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ~/Flutter/engine/src/out/host_debug_unopt/dart-sdk/bin/dartaotruntime main.aot</span></span><br><span class="line">VM initialization failed: Wrong full snapshot version, expected &#x27;d56742caf7b3b3f4bd2df93a9bbb5503&#x27; found &#x27;9cf77f4405212c45daf608e1cd646852&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成的dill文件和aot文件中带了版本信息，执行的时候会进行校验。</p>
<p>主机上有多个版本Dart SDK，例如Flutter引擎编译出来的Dart SDK和Flutter SDK中内置的Dart SDK版本不一致。此时需要分别进入对应路径下执行命令，或者配置多个环境变量。为了避免麻烦，可以切换Flutter引擎到对应的commit id，保持版本一致。</p>
</blockquote>
<h2 id="Web平台"><a href="#Web平台" class="headerlink" title="Web平台"></a>Web平台</h2><p>dart支持在Web平台上执行，既不是JIT也不是AOT：生成JavaScript代码，运行在浏览器中，而不是目标平台代码</p>
<ol>
<li>开发阶段使用<code>dartdevc</code>增量式编译器</li>
<li>生产环境使用<code>dart2js</code>编译器，高版本替换为<code>dart compile js</code>命令</li>
</ol>
<p>官方建议使用<a href="https://dart.dev/tools/webdev">webdev</a>工具，而不是直接使用<code>dartdevc</code>和<code>dart2js</code>工具。</p>
<ul>
<li><code>webdev serve</code>：编译并部署到开发服务器，使用<code>localhost:8080</code>访问。默认使用<code>dartdevc</code>编译。添加<code>--release</code>选项，替换为<code>dart2js</code>编译</li>
<li><code>webdev build</code>：默认使用<code>dart2js</code>编译，添加<code>--no-release</code>选项，替换为<code>dartdevc</code>编译</li>
</ul>
<h1 id="Dart源码下载和编译"><a href="#Dart源码下载和编译" class="headerlink" title="Dart源码下载和编译"></a>Dart源码下载和编译</h1><p>Dart SDK是Dart源码的编译产物。</p>
<h2 id="源码下载和编译"><a href="#源码下载和编译" class="headerlink" title="源码下载和编译"></a>源码下载和编译</h2><ol>
<li><p>安装<code>depot_tools</code></p>
<ol>
<li>下载：<code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code></li>
<li>设置环境变量：<code>.bash_profile</code>文件中添加<code>export PATH=/your_path/depot_tools/:$PATH</code></li>
</ol>
</li>
<li><p>下载Dart源码和DEPS依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line">mkdir dart-sdk</span><br><span class="line">cd dart-sdk</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过gclient下载dart源码和DEPS依赖</span></span><br><span class="line">fetch dart</span><br></pre></td></tr></table></figure></li>
<li><p>编译Dart SDK源码，生成Dart SDK归档文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd sdk</span><br><span class="line">./tools/build.py --no-goma --mode release --arch x64 create_sdk</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以指定多个build_targets编译</span></span><br><span class="line">./tools/build.py --mode=release --arch=x64 create_sdk runtime gen_snapshot frontend_server.dart.snapshot</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><code>build_targets</code>参数没有找到具体说明，不过可以参考<code>tools/bots/test_matrix.json</code>文件中的<code>builder_configurations</code></p>
<p>踩坑：FlutterEngine中下载的Dart SDK（<code>&#123;flutter_engine&#125;/src/third_party/dart</code>）不包含编译需要的依赖项目，无法直接用于编译，因此需要使用<code>gclient</code>重新下载Dart源码。</p>
<p>应该也可以手动创建<code>.gclient</code>文件，执行<code>gclient sync</code>下载依赖</p>
</blockquote>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><h3 id="编译生成Dart虚拟机"><a href="#编译生成Dart虚拟机" class="headerlink" title="编译生成Dart虚拟机"></a>编译生成Dart虚拟机</h3><p>交叉编译Android平台的Dart VM，可以在Android平台执行Dart应用程序</p>
<ol>
<li>下载Android需要的依赖，如NDK，SDK等<ol>
<li>修改dart-sdk目录下的<code>.gclient</code>文件：最后一行添加<code>target_os = [&#39;android&#39;]</code></li>
<li>下载依赖项目：执行<code>gclient sync</code></li>
</ol>
</li>
<li>交叉编译Arm64的Android平台的Dart VM：<code>./tools/build.py --no-goma --arch=arm64 --mode=release --os=android runtime</code></li>
<li>使用adb将编译后的Dart VM工具push到Android平台中：<code>adb push ./xcodebuild/ReleaseAndroidARM64/dart /data/local/tmp/dart</code></li>
<li>将Dart程序push到Android平台中：<code>adb push main.dart /data/local/tmp/</code></li>
<li>运行Dart程序：<code>adb shell /data/local/tmp/dart /data/local/tmp/main.dart</code></li>
</ol>
<blockquote>
<p>踩坑：这里无法使用adb shell进入Android终端执行，会报错，缺少工具和库。</p>
</blockquote>
<h3 id="编译生成Dart-SDK"><a href="#编译生成Dart-SDK" class="headerlink" title="编译生成Dart SDK"></a>编译生成Dart SDK</h3><p>可以将编译出来的整个SDK归档文件push到Android平台中并设置环境变量，此时可以像在主机上一样使用Dart SDK，编译和执行Dart应用。如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 交叉编译Android平台的Dart SDK</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./tools/build.py --no-goma -a=arm64 --mode=release --os=android create_sdk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb push ./xcodebuild/ReleaseAndroidARM64/dart-sdk/ /data/<span class="built_in">local</span>/tmp/dart-sdk/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb shell</span></span><br><span class="line">HWAUM-Q:/ $ cd /data/local/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ export PATH=&quot;$PATH:$PWD/dart-sdk/bin&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Dart虚拟机执行，输出Hello World</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ dart run main.dart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译aot快照</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ dart compile aot-snapshot main.dart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行aot文件，输出Hello World</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ dartaotruntime main.aot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译exe可执行程序</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ dart compile exe main.dart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行exe程序，输出Hello World</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ ./main.exe</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> dart编译前端，生成main.dill</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ dart dart-sdk/bin/snapshots/frontend_server.dart.snapshot --sdk-root dart-sdk/lib/_internal/ --platform vm_platform_strong.dill --aot --tfa -Ddart.vm.product=true --output-dill main.dill main.dart</span><br><span class="line"><span class="meta">#</span><span class="bash"> dart编译后端，生成main.aot</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ ./dart-sdk/bin/utils/gen_snapshot --snapshot_kind=app-aot-elf --elf=main.aot main.dill</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行main.aot文件，输出Hello World</span></span><br><span class="line">HWAUM-Q:/data/local/tmp $ dartaotruntime main.aot</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>了解Dart编译方式和不同产物，以及执行原理，主要有以下场景</p>
<ol>
<li>为动态化，分包等提供一些思路</li>
<li>使用交叉编译在嵌入式平台中执行Dart或Flutter程序</li>
<li>定制虚拟机、编译器等。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="https://dart.dev/overview">Dart官网</a></li>
<li><a href="https://mrale.ph/dartvm/">Introduction to Dart VM</a></li>
<li><a href="https://github.com/dart-lang/sdk/wiki">Dart Wiki</a>、<a href="https://github.com/dart-lang/sdk/wiki/Building">Dart Building</a>、<a href="https://github.com/dart-lang/sdk/wiki/Building-the-Dart-VM-for-Android">Building the Dart VM for Android</a></li>
<li><a href="https://www.jianshu.com/p/a5b1997a01ba">Dart VM介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>depot_tools工具介绍</title>
    <url>/2022/01/04/tool-2022-01-04-depot-tools/</url>
    <content><![CDATA[<h1 id="depot-tools介绍"><a href="#depot-tools介绍" class="headerlink" title="depot_tools介绍"></a>depot_tools介绍</h1><p>Google用python开发的git仓库管理工具，用于管理chromium源码。包括gclient、repo、gn和ninja等工具。是对Git的增强，大项目由几十个独立的git仓库构成，不便于下载、提交和管理。</p>
<ul>
<li><a href="https://chromium.googlesource.com/chromium/tools/depot_tools.git">下载地址</a></li>
<li><a href="https://www.chromium.org/developers/how-tos/depottools">简介</a></li>
<li><a href="https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html">使用手册</a></li>
</ul>
<p><code>gclient</code>：将多个git仓库组成一个<code>Solution</code>进行管理，通过gclient获取源码和依赖的仓库，类似Git submodule。</p>
<blockquote>
<ul>
<li><code>git submodule</code>：git子仓库管理工具</li>
<li><code>repo</code>：与<code>gclient</code>作用相同，gclient更新一点。gclient根据.gclient和DEPS配置文件检出依赖模块源码，repo根据manifest.xml配置文件检出模块源码。</li>
<li><code>Solution</code>：包含DEPS文件的仓库</li>
<li><code>DEPS</code>：记录Solution中的项目依赖关系</li>
<li><code>roll_deps</code>：用于更新DEPS文件中某个依赖的代码版本</li>
<li><code>Gerrit/Rietveld</code>：Code Review（代码审核）的系统，可以和<code>git/svn</code>集成</li>
<li><code>git cl</code>：Change List，用于查看代码修改，类似<code>git diff</code></li>
<li><code>LKGR</code>（Last Known Good Revision）：记录最新的测试通过的版本</li>
</ul>
</blockquote>
<p><a href="https://ninja-build.org/">ninja</a>：编译工具，负责编译最终的可执行文件。依赖其他构建工具进行高级语言编译。</p>
<p><a href="https://gn.googlesource.com/gn">gn</a>：生成ninja所需的构建文件，可以针对不同平台生成不同的ninja构建文件。<code>gn help</code>查看帮助</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>clone仓库：<code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code></li>
<li>设置环境变量：<code>.bash_profile</code>文件中添加<code>export PATH=/&#123;your_path&#125;/depot_tools/:$PATH</code></li>
</ol>
<h1 id="gn介绍"><a href="#gn介绍" class="headerlink" title="gn介绍"></a>gn介绍</h1><p>gn工具将<code>xx.gn</code>文件转换成<code>.ninja</code>文件，ninja根据<code>.ninja</code>文件生成目标程序。类似cmake和make的关系。</p>
<p>官方文档主要有两篇<a href="https://gn.googlesource.com/gn/+/refs/heads/main/docs/reference.md">gn命令</a>、<a href="https://gn.googlesource.com/gn/+/refs/heads/main/docs/language.md">gn语法</a>，语法类似python</p>
<h2 id="gn使用"><a href="#gn使用" class="headerlink" title="gn使用"></a>gn使用</h2><ol>
<li>在项目根目录创建<code>.gn</code>文件，用于指定构建配置文件路径，一般叫<code>BUILDCONFIG.gn</code></li>
<li>在构建配置文件中指定编译工具链</li>
<li>在项目根目录创建<code>BUILD.gn</code>文件，指定编译目标、配置等。</li>
<li>对应的依赖模块中也定义<code>BUILD.gn</code>文件</li>
</ol>
<h2 id="BUILD-gn文件语法"><a href="#BUILD-gn文件语法" class="headerlink" title="BUILD.gn文件语法"></a>BUILD.gn文件语法</h2><p>简单介绍下，具体参考官方文档</p>
<h3 id="添加编译参数"><a href="#添加编译参数" class="headerlink" title="添加编译参数"></a>添加编译参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare_args() &#123;</span><br><span class="line">  enable_test &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加宏"><a href="#添加宏" class="headerlink" title="添加宏"></a>添加宏</h3><p>定义的宏可以直接在C/C++的代码中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defines &#x3D; [ &quot;AWESOME_FEATURE&quot;, &quot;LOG_LEVEL&#x3D;3&quot; ]</span><br></pre></td></tr></table></figure>

<h3 id="添加编译单元"><a href="#添加编译单元" class="headerlink" title="添加编译单元"></a>添加编译单元</h3><p>target是最小的编译单元，常见的target类型如</p>
<ol>
<li><code>executable</code>：生成可执行程序</li>
<li><code>shared_library</code>：生成动态链接库，如<code>.dll</code>和<code>.so</code>文件</li>
<li><code>static_library</code>：生成静态链接库，如<code>.lib</code>和<code>.a</code>文件</li>
<li><code>source_set</code>：生成虚拟静态库，比<code>static_library</code>快</li>
<li><code>group</code>：执行一组target编译</li>
<li><code>action</code>：执行一段脚本</li>
<li><code>copy</code>：拷贝文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">executable(&quot;hello_world&quot;) &#123;</span><br><span class="line">  sources &#x3D; [</span><br><span class="line">    &quot;hello_world.cc&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p>包括编译flag、include、define等，可被其他target包含</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config(&quot;myconfig&quot;) &#123;</span><br><span class="line">  include_dirs &#x3D; [ &quot;include&#x2F;common&quot; ]</span><br><span class="line">  defines &#x3D; [ &quot;ENABLE_DOOM_MELON&quot; ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executable(&quot;hello_world&quot;) &#123;</span><br><span class="line">  configs &#x3D; [ &quot;:myconfig&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加模版"><a href="#添加模版" class="headerlink" title="添加模版"></a>添加模版</h3><p>用于定义可重用的代码，一般创建一个<code>.gni</code>文件，其他文件可以通过import引入实现共享</p>
<h3 id="添加依赖关系"><a href="#添加依赖关系" class="headerlink" title="添加依赖关系"></a>添加依赖关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deps &#x3D; [&quot;&#x2F;&#x2F;xxx&quot;]</span><br><span class="line">deps +&#x3D; [&quot;&#x2F;&#x2F;xxx&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="gn执行过程"><a href="#gn执行过程" class="headerlink" title="gn执行过程"></a>gn执行过程</h2><p>以flutter engine项目为例</p>
<ol>
<li><p>在当前目录查找<code>.gn</code>文件，如果不存在则往上一级查找，直到找到一个为止，将<code>.gn</code>所在的目录设置为source root。解析<code>.gn</code>文件找到buildconfig文件（构建配置文件）。如下<code>src/.gn</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"># This file is used by the experimental meta-buildsystem in src&#x2F;tools&#x2F;gn to</span><br><span class="line"># find the root of the source tree and to set startup options.</span><br><span class="line"></span><br><span class="line"># Use Python 3 for exec_script() calls.</span><br><span class="line"># See &#96;gn help dotfile&#96; for details.</span><br><span class="line">script_executable &#x3D; &quot;python3&quot;</span><br><span class="line"></span><br><span class="line"># The location of the build configuration file.</span><br><span class="line">buildconfig &#x3D; &quot;&#x2F;&#x2F;build&#x2F;config&#x2F;BUILDCONFIG.gn&quot;</span><br><span class="line"></span><br><span class="line"># The secondary source root is a parallel directory tree where</span><br><span class="line"># GN build files are placed when they can not be placed directly</span><br><span class="line"># in the source tree, e.g. for third party source trees.</span><br><span class="line">secondary_source &#x3D; &quot;&#x2F;&#x2F;build&#x2F;secondary&#x2F;&quot;</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure></li>
<li><p>执行构建配置文件，即<code>//build/config/BUILDCONFIG.gn</code>，整个系统只有一个，设置全局变量、默认值等，对所有build文件可见</p>
</li>
<li><p>执行root目录下的<code>BUILD.gn</code>文件</p>
</li>
<li><p>再根据root目录下的<code>BUILD.gn</code>文件加载其依赖目录下的其他<code>BUILD.gn</code>文件，如果在指定路径找不到的话，则在<code>build/secondary</code>的相应位置查找</p>
</li>
<li><p>当一个目标的依赖都解决了，编译出<code>.ninja</code>文件保存到<code>out_dir/dir</code>下，例如<code>out/android_debug_unopt/obj/</code>下</p>
</li>
<li><p>最终编译出一个根<code>build.ninja</code>文件放到<code>out_dir</code>下</p>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>gclient使用可以参考<a href="https://www.cnblogs.com/xl2432/p/11596695.html">chromium开发工具–gclient</a>、<a href="https://keyou.github.io/blog/2017/11/02/gclient/">gclient 介绍</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU和编译工具介绍</title>
    <url>/2022/01/03/tool-2022-01-03-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="GNU介绍"><a href="#GNU介绍" class="headerlink" title="GNU介绍"></a>GNU介绍</h1><ul>
<li>1983年：Richard Stallman发起GNU计划，目标是创建一套完全自由的操作系统，起因是Unix版权问题</li>
<li>1985年：成立FSF，为GNU计划提供技术、法律以及财政支持</li>
<li>1990年：完成Emacs编辑器，GCC编译器以及大部分Unix系统的程序库和工具。但操作系统内核（Hurd）仍未完成</li>
<li>1991年：Linus开发与Unix兼容的Linux内核，并采用GPL条款发布。之后许多程序员参与了开发和修改</li>
<li>1992年：Linux与其他GNU软件结合，诞生GNU/Linux操作系统，简称Linux系统。</li>
</ul>
<blockquote>
<p>内核：用于资源分派和硬件管理的程序</p>
<p>Linux只是一个内核，用户态还是使用GNU系的软件，如bash shell、emacs编辑器、gcc编译器套装、glibc（GNU的C库）等</p>
<p>GNU官方核心是GNU Hurd，GNU/Linux是变种，除了Linux之外，还有FreeBSD内核、NetBSD内核等</p>
<p>Google在Linux内核的基础上，开发了bionic库，替换了glibc库，用于Android系统</p>
</blockquote>
<p>GNU（GNU’s Not Unix!）：是一个自由的操作系统，是由多个应用程序、系统库、开发工具组成的程序集合。模仿Unix界面和使用方式（类Unix），做的一个开源的版本。</p>
<blockquote>
<p>自由软件：</p>
<ol>
<li>运行软件的自由</li>
<li>研究该软件如何工作，按需改写软件的自由</li>
<li>重新发布拷贝的自由</li>
<li>向公众发布改进版软件的自由</li>
</ol>
</blockquote>
<p>GNU计划：又称“革奴计划”，在这个计划下做了很多工作和项目，如GCC、glibc、bash shell、emacs等，并成立了FSF，起草了GPL协议条款。</p>
<h2 id="常见开源许可协议"><a href="#常见开源许可协议" class="headerlink" title="常见开源许可协议"></a>常见开源许可协议</h2><ul>
<li>FSF：（Free Software Foundation，自由软件基金会）</li>
<li>GPL：（GNU General Public License，GNU通用公共许可证）</li>
<li>LGPL：(GNU Lesser General Public License，GNU较宽松公共许可证 ) ，旧称 GNU Library General Public License (GNU 库通用公共许可证)；</li>
<li>GFDL：（GNU Free Documentation License，GNU自由文档许可证）</li>
<li>BSD：（Berkeley Software Distribution，伯克利软件套件），Unix的衍生系统（类Unix）</li>
<li>BSD许可证：允许软件闭源发布</li>
</ul>
<p>借用一下阮一峰老师的图片：</p>
<p><img src="/2022/01/03/tool-2022-01-03-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81.png"></p>
<h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><p>完整的GNU工具链包括Binutils（包括Assembler汇编器、Linker链接器）、GCC编译器、C库</p>
<h2 id="gcc-g-编译过程"><a href="#gcc-g-编译过程" class="headerlink" title="gcc/g++编译过程"></a>gcc/g++编译过程</h2><ol>
<li>预处理（pre-compile）[预处理器cpp]：删除#define并展开宏定义，处理#include等，<strong>生成.i预处理文件</strong>。<code>gcc -E file.c -o file.i</code></li>
<li>编译（compile）[编译器egcs]：语法分析、词法分析、语义分析等，<strong>生成.s汇编代码文件</strong>。<code>gcc -S file.i -o file.s</code></li>
<li>汇编（assembly）[汇编器as]：<strong>生成.o可重定位目标代码文件</strong>。<code>gcc -c file.s -o file.o</code></li>
<li>链接（link）[链接器ld]：处理各个模块之间的引用和依赖，将目标文件链接到可执行文件或其他目标文件。<strong>生成可执行文件</strong>。<code>gcc hello.o –o hello</code><ol>
<li>静态链接：目标文件直接包含到可执行文件中</li>
<li>动态链接：可执行程序运行时加载目标文件</li>
</ol>
</li>
<li>反汇编：使用<code>objdump</code>反汇编，输出机器码和对应的汇编代码</li>
</ol>
<p><img src="/2022/01/03/tool-2022-01-03-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gcc%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p>
<p>也可以直接一条命令执行：<code>gcc -o hello.out hello.c</code>，将<code>hello.c</code>编译，生成<code>hello.out</code>文件，默认生成<code>a.out</code></p>
<h3 id="静态链接：编译时链接"><a href="#静态链接：编译时链接" class="headerlink" title="静态链接：编译时链接"></a>静态链接：编译时链接</h3><p>作用：由于开发过程存在多个源代码文件（<code>.c</code>文件），且存在依赖关系，每个源文件都会生成一个目标文件（<code>.o</code>文件），因此需要将这些目标文件链接打包。</p>
<p>优点：可执行程序包含所有执行程序需要的东西，运行速度快。</p>
<p>缺点：</p>
<ul>
<li>目标文件打包在可执行程序中，多个程序依赖同一份目标文件时，造成空间浪费</li>
<li>库函数修改时，需要重新编译链接生成可执行程序。</li>
</ul>
<p>静态库：编译时链接的库。一般是<code>.a</code>文件。</p>
<p>静态链接步骤如下：</p>
<ol>
<li>编译静态库源码，生成.o目标文件：<code>gcc -c lib.c -o lib1.o</code></li>
<li>打包生成<code>.a</code>归档文件：<code>ar -q libfoo.a lib1.o lib2.o </code></li>
<li>链接生成<code>.out</code>可执行文件：<code>gcc -o main main.c -static -L. -lfoo</code></li>
</ol>
<blockquote>
<p><code>-L</code>：静态链接库搜索路径</p>
</blockquote>
<p><img src="/2022/01/03/tool-2022-01-03-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5.png"></p>
<h3 id="动态链接：运行时链接"><a href="#动态链接：运行时链接" class="headerlink" title="动态链接：运行时链接"></a>动态链接：运行时链接</h3><p>作用：解决静态链接的缺陷，将各个模块拆分成相对独立的部分，运行时才链接形成完整的程序。</p>
<p>动态库（共享库）：程序运行时链接的库。可以被多个程序共享。一般是<code>.so</code>文件。</p>
<p>动态链接步骤如下：</p>
<ol>
<li>编译动态库源码，生成<code>.so</code>文件：<code>gcc -shared -fPIC dlib1.c dlib2.c -o libfoo.so</code></li>
<li>链接动态库生成可执行程序：<code>gcc main.c -lfoo -o main.out</code>（去掉lib和so前后缀）</li>
<li>运行时在特定目录下搜索动态链接库</li>
</ol>
<blockquote>
<p><code>-fPIC</code>：使用地址无关代码（Position Independent Code）技术来生成文件。不加这个选项的话无法让其他程序共享。</p>
<p>原理：告诉GCC目标代码不要包含对函数和变量具体内存位置的引用，运行时才确定具体的内存地址空间，由每个进程自行决定。</p>
</blockquote>
<p>动态链接除了编译时指定路径外，还可以通过代码加载：</p>
<ol>
<li>使用<code>-ldl</code>选项编译（链接<code>libdl.so</code>库）：<code>gcc file.c -ldl -o file.out</code></li>
<li>代码调用<ol>
<li><code>dlopen</code>：打开动态库文件，返回句柄</li>
<li><code>dlsym</code>：查找动态库中的函数并返回调用地址</li>
<li><code>dlclose</code>：关闭动态库文件</li>
<li><code>dlerror</code>：返回动态库函数出错信息</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>目标文件</th>
<th>静态链接库</th>
<th>动态链接库</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>obj</td>
<td>lib</td>
<td>dll</td>
</tr>
<tr>
<td>Linux</td>
<td>o</td>
<td>a</td>
<td>so</td>
</tr>
<tr>
<td>MacOS</td>
<td>o</td>
<td>a</td>
<td>dylib</td>
</tr>
</tbody></table>
<h3 id="链接库搜索路径"><a href="#链接库搜索路径" class="headerlink" title="链接库搜索路径"></a>链接库搜索路径</h3><p>ld链接时有两个选项：</p>
<ul>
<li><code>-rpath-link=dir</code>：指定编译链接时查找的路径</li>
<li><code>-rpath=dir</code>：指定的路径会被记录在生成的可执行程序中，用于运行时查找.so文件。</li>
</ul>
<p>此外，还可以通过环境变量设置链接查找路径</p>
<ul>
<li><code>export LIBRARY_PATH=xxx</code>：添加gcc编译时查找链接库的路径。</li>
<li><code>export LD_LIBRARY_PATH=xxx</code>：添加程序加载运行时查找链接库的路径</li>
</ul>
<p>静态链接时搜索路径顺序：</p>
<ol>
<li><code>-L</code>和<code>-rpath-link</code>参数指定的路径</li>
<li><code>LIBRARY_PATH</code>环境变量配置的路径</li>
<li>默认目录：<code>/lib</code>、<code>usr/lib</code>、<code>/usr/local/lib</code></li>
</ol>
<p>动态链接搜索路径顺序：</p>
<ol>
<li>编译时<code>-rpath</code>指定的路径</li>
<li><code>LD_LIBRARY_PATH</code>环境变量配置的路径</li>
<li>ldconfig指定的路径：<code>/etc/ld.so.conf</code>中配置<ol>
<li>查看缓存的链接路径：<code>cat /etc/ld.so.cache</code></li>
<li><code>/etc/ld.so.conf</code>中配置一般是<code>include /etc/ld.so.conf.d/*.conf</code></li>
<li>因此可以在<code>/etc/ld.so.conf.d/</code>目录下创建<code>xxx.conf</code>文件，配置链接路径</li>
<li>添加完之后执行下<code>ldconfig</code>更新缓存</li>
</ol>
</li>
<li>默认目录：<code>/lib</code>、<code>usr/lib</code></li>
</ol>
<blockquote>
<p>自己编译链接库时，可以直接将链接库拷贝到<code>/lib</code>目录下。</p>
<p>为了不和系统混淆，可以通过环境变量或者ldconfig配置链接库搜索路径</p>
</blockquote>
<p>如何查看ld链接时的搜索路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ld --verbose | grep SEARCH_DIR | tr -s <span class="string">&#x27; ;&#x27;</span> \\012</span></span><br><span class="line">SEARCH_DIR(&quot;=/usr/local/lib/x86_64-linux-gnu&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/lib/x86_64-linux-gnu&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu64&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/local/lib64&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/lib64&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/lib64&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/local/lib&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/lib&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/lib&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib64&quot;)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -print-search-dirs | sed <span class="string">&#x27;/^lib/b 1;d;:1;s,/[^/.][^/]*/\.\./,/,;t 1;s,:[^=]*=,:;,;s,;,;  ,g&#x27;</span> | tr \; \\012</span></span><br><span class="line">libraries:</span><br><span class="line">  /usr/lib/gcc/x86_64-linux-gnu/9/:/usr/x86_64-linux-gnu/lib/x86_64-linux-gnu/9/:/usr/x86_64-linux-gnu/lib/x86_64-linux-gnu/:/usr/x86_64-linux-gnu/lib/:/usr/lib/x86_64-linux-gnu/9/:/usr/lib/x86_64-linux-gnu/:/usr/lib/:/lib/x86_64-linux-gnu/9/:/lib/x86_64-linux-gnu/:/lib/:/usr/lib/x86_64-linux-gnu/9/:/usr/lib/x86_64-linux-gnu/:/usr/lib/:/usr/x86_64-linux-gnu/lib/:/usr/lib/:/lib/:/usr/lib/</span><br></pre></td></tr></table></figure>

<h2 id="gcc和GCC"><a href="#gcc和GCC" class="headerlink" title="gcc和GCC"></a>gcc和GCC</h2><p><strong>gcc和GCC是不同的东西</strong></p>
<ul>
<li>GCC：（GNU Compiler Collection，GNU编译器套件），为GNU操作系统开发的编译器，可以编译C、C++、Java、Go、Object-c等。</li>
<li>gcc（GNU C Compiler，C 编译器）</li>
<li>g++（GNU C++ Compiler，C++编译器）</li>
</ul>
<blockquote>
<p>最早GCC是GNU C语言编译器（GNU C Compiler），只能处理C语言，后来扩展支持更多编程语言。</p>
<p>也可以理解为gcc只是一个执行入口，不是编译器，通过调用GNU C compiler进行编译。</p>
</blockquote>
<h2 id="gcc和g-区别"><a href="#gcc和g-区别" class="headerlink" title="gcc和g++区别"></a>gcc和g++区别</h2><ol>
<li>对于.c后缀的文件，gcc把它当做是C程序；g++当做是C++程序；</li>
<li>对于.cpp后缀的文件，gcc和g++都会当做c++程序。</li>
<li>编译阶段，g++会调用gcc;</li>
<li>链接阶段，通常会用g++来完成，因为gcc命令不能自动和c++程序使用的库连接。</li>
</ol>
<h1 id="GCC和Make"><a href="#GCC和Make" class="headerlink" title="GCC和Make"></a>GCC和Make</h1><ul>
<li>GCC：GNU编译套件。只有一个文件的时候使用gcc编译器比较方便。当有多个文件时，编译顺序以及依赖关系处理使用gcc很麻烦。</li>
<li>make工具：批处理工具。makefile中规定了编译和链接的顺序，make根据makefile文件进行编译，比直接调用gcc逐个编译文件方便。手写makefile文件较麻烦，并且不同平台makefile不一样。<ul>
<li>Makefile定义了多个规则，每个规则由目标、依赖、命令构成</li>
</ul>
</li>
<li>CMake工具：更加方便的生成makefile文件，并且能够跨平台，解决不同平台手写makefile较麻烦的问题，但仍然需要手写<code>CMakelist.txt</code>文件。</li>
</ul>
<blockquote>
<p>cmake除了生成makefile之外，还可以生成ninja、Xcode等构建配置文件。例如<code>cmake -G Ninja xxx</code></p>
</blockquote>
<pre class="mermaid">graph LR
编辑器--编写-->源文件-->cmakelist--cmake生成-->makefile--make批处理-->可执行程序</pre>

<p>make、mm、mmm命令</p>
<blockquote>
<p>m是对make的封装</p>
<p>make用来编译整个工程，首次编译需要使用make，</p>
<p>mm和mmm用来编译某个目录下的模块</p>
<p>默认是增量编译，使用-B选项可以强制编译所有目标文件</p>
</blockquote>
<p>make和Gradle</p>
<blockquote>
<ul>
<li>gradle命令类似make命令，根据配置文件（makefile、gradle文件）进行构建</li>
<li>gradle文件类似makefile，用于编译配置管理，语法使用groovy</li>
<li>gradle通过dependencies配置依赖库，makefile通过gcc/g++编译器的链接参数引用第三方库</li>
<li>makefile中的目标对应gradle中的task</li>
<li>由于每种工程类型构建过程较固定（如Java项目、Android项目、Android库）。因此gradle中预置了很多task，打包在plugin中。使用不同的plugin即可直接构建。</li>
<li>由于不同项目配置上存在差异，因此Gradle提供了一些自定义配置项：如项目id、sdk版本等</li>
</ul>
</blockquote>
<p>make和ninja、cmake与gn</p>
<blockquote>
<ul>
<li><a href="https://ninja-build.org/">ninja</a>：编译工具，负责编译最终的可执行文件。依赖其他构建工具进行高级语言编译。类似于make</li>
<li><a href="https://gn.googlesource.com/gn">gn</a>：生成ninja所需的构建文件，可以针对不同平台生成不同的ninja构建文件。类似于cmake</li>
</ul>
<p>chromium工程使用gn生成不同平台的ninja构建文件，再通过ninja进行编译。适用于大型项目。</p>
</blockquote>
<p>Android.bp和Android.mk文件</p>
<blockquote>
<ul>
<li>早期Android系统使用Android.mk配置文件+make工具的配置编译源码</li>
<li>Android 7.0引入ninja和kati：kati工具将Android.mk转为ninja配置文件，通过ninja工具进行编译</li>
<li>Android 8.0使用Android.bp配置文件替代Android.mk，引入soong工具将bp文件转为ninja文件，通过ninja工具进行编译</li>
<li>Android 9.0强制使用Android.bp配置文件</li>
</ul>
</blockquote>
<h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><p>经典的编译器设计分为三段：前端、优化、后端，当需要支持多种语言时，只需要添加不同的前端，当需要支持多个目标机器时，只需要添加不同的后端，优化器只处理通用的中间代码。GCC、LLVM、Java都是该模型的一种实现</p>
<p>由于GCC模块化分层做的不好，编译器代码重用难度大，需要生成完整的编译器。</p>
<p><a href="https://llvm.org/">LLVM</a>（Low Level Virtual Machine，底层虚拟机）的出现是为了解决编译器代码重用问题，采用接口和模块化的设计，便于添加定制功能，开发者只需要关注编译前端。<a href="http://www.aosabook.org/en/llvm.html">The Architecture of Open Source Applications: LLVM</a></p>
<p>LLVM是模块化、可重用的编译器和工具链集合，用于取代GCC。虽然全称是Low Level Virtual Machine（底层虚拟机），但它实际与虚拟机并没有关系。</p>
<ul>
<li>LLVM采用BSD协议，GCC采用GPL协议</li>
<li>Clang更轻量，编译提示更友好</li>
<li>GCC使用<code>libstdc++</code>标准库，Clang使用<code>libc++</code>标准库</li>
<li>Android NDK<ul>
<li>r11：建议使用Clang编译</li>
<li>r13：默认使用Clang编译</li>
<li>r18：移除GCC</li>
</ul>
</li>
</ul>
<h2 id="Clang与LLVM"><a href="#Clang与LLVM" class="headerlink" title="Clang与LLVM"></a>Clang与LLVM</h2><p>Clang是LLVM项目下的一个子项目</p>
<ul>
<li>广义的LLVM指LLVM编译器框架系统，包括前端（源码转为LLVM IR中间代码）、优化器、后端（中间代码转为汇编代码）以及相关的库或模块。如下<ul>
<li>核心库：源代码到中间代码的优化，与目标平台无关</li>
<li>Clang：C/C++/Objective-C的编译器，转换为LLVM IR（Intermediate Representation）中间语言</li>
<li>LLDB：基于Clang的调试库</li>
<li>libc++：LLVM提供的c++标准库</li>
<li>libclc：OpenCL标准库</li>
<li>LLD：链接器</li>
<li>…</li>
</ul>
</li>
<li>狭义的LLVM聚焦于编译后端，Clang对应编译前端。</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>操作系统不太了解，简单学习下，扩宽视野。</p>
<ul>
<li>CMake使用可以参考<a href="https://blog.csdn.net/kai_zone/article/details/82656964">cmake快速入门</a></li>
<li>gcc和g++具体区别可以参考<a href="https://www.cnblogs.com/samewang/p/4774180.html">GCC的gcc和g++区别</a></li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://www.gnu.org/gnu/linux-and-gnu.html">Linux和GNU系统</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter简介</title>
    <url>/2021/12/20/flutter-2021-12-20-Flutter%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h1><p>Flutter是一个跨平台的UI框架，设计初衷是在各种操作系统上复用UI代码，提供一致的交互体验，同时让应用程序能过与底层平台服务进行交互。</p>
<ul>
<li>支持移动平台（Android、iOS），桌面平台（Windows、Linux、MacOS），Web平台（浏览器），其他嵌入式平台（如车载、IoT设备、树莓派等，需要自行扩展适配）</li>
<li>支持多屏幕设备、折叠设备等</li>
</ul>
<p>Flutter SDK包含框架代码、脚手架、编译工具、调试工具和各种脚本等。</p>
<p>Flutter只是一个框架，不是一门语言，Flutter使用了Dart语言，Flutter引擎中的嵌入层（UI渲染、输入输出、以及PlatformChannel等）使用了平台原生语言（如C++，Java等）。</p>
<p>Flutter和Dart类比Android和Java的关系：</p>
<table>
<thead>
<tr>
<th></th>
<th>Flutter</th>
<th>Android</th>
</tr>
</thead>
<tbody><tr>
<td>编程语言</td>
<td>Dart</td>
<td>Java、Kotlin</td>
</tr>
<tr>
<td>编译器</td>
<td>dart compile</td>
<td>javac、dx</td>
</tr>
<tr>
<td>应用构建工具</td>
<td>flutter命令</td>
<td>gradle命令</td>
</tr>
<tr>
<td>Framework</td>
<td>Flutter Framework</td>
<td>Android Framwork</td>
</tr>
<tr>
<td>开发套件</td>
<td>Flutter SDK</td>
<td>Android SDK</td>
</tr>
<tr>
<td>底层源码</td>
<td>Flutter引擎源码</td>
<td>AOSP系统源码</td>
</tr>
<tr>
<td>源码管理工具</td>
<td>gclient</td>
<td>repo</td>
</tr>
<tr>
<td>源码编译配置</td>
<td>gn文件</td>
<td>低版本mk、高版本bp文件</td>
</tr>
<tr>
<td>源码编译工具</td>
<td>ninja</td>
<td>低版本make，高版本ninja</td>
</tr>
</tbody></table>
<h1 id="Flutter架构"><a href="#Flutter架构" class="headerlink" title="Flutter架构"></a>Flutter架构</h1><p>Flutter源码包含两部分：</p>
<ol>
<li><a href="https://github.com/flutter/engine">Flutter Engine</a>：负责Flutter渲染和与宿主机的交互。包括图形渲染、网络I/O、插件通道、Dart运行时、平台嵌入层、编译工具链等</li>
<li><a href="https://github.com/flutter/flutter">Flutter Framework</a>：为开发者提供dart封装的API接口（布局、组件、函数）和开发调试工具。应用开发者只需要下载和使用SDK，一般不需要接触引擎层。</li>
</ol>
<blockquote>
<p>Flutter SDK默认会缓存官方构建好的引擎artifact，打包到应用中</p>
</blockquote>
<p>架构如下：</p>
<img src="/2021/12/20/flutter-2021-12-20-Flutter%E7%AE%80%E4%BB%8B/Flutter架构.png" style="zoom: 33%;">

<ol>
<li><p>嵌入层：源码包含在Engine中的<code>shell/platform</code>文件夹下。适配了多个平台，使用当前平台语言编写，提供应用程序入口，程序通过嵌入层与底层操作系统交互，例如访问surface渲染、辅助功能、输入设备、线程管理、窗口管理等。</p>
</li>
<li><p>引擎层：提供Flutter核心API实现，包括图形（Skia）和动画，文本布局、文件、网络IO、插件通道、Dart运行环境以及编译环境的工具链。引擎将底层C++代码包装成Dart代码，即<code>dart:ui</code>，供上层使用。</p>
</li>
<li><p>框架层：提供Flutter应用开发的框架，包括响应式框架、布局、组件、基础库等</p>
<ol>
<li>foundation：提供上层常用的抽象和函数</li>
<li>基本模块：如 <a href="https://api.flutter-io.cn/flutter/animation/animation-library.html">animation</a>、 <a href="https://api.flutter-io.cn/flutter/painting/painting-library.html">painting</a> 和 <a href="https://api.flutter-io.cn/flutter/gestures/gestures-library.html">gestures</a></li>
<li>渲染层：提供布局操作的抽象，构建可渲染对象的树</li>
<li>widgets层：和渲染层中的渲染对象对应，并提供响应式编程模型</li>
<li>Material和Cupertino：封装widgets，实现Material和iOS设计规范</li>
</ol>
</li>
<li><p>软件包：封装开发者常用的功能，分为普通包和插件包</p>
<ol>
<li>Packages：与平台无关。如http、路由导航、依赖管理、应用内支付、组件等</li>
<li>Plugins：封装原生平台调用，如webview、camera等</li>
</ol>
</li>
<li><p>应用层：Flutter应用、模块、插件等</p>
</li>
</ol>
<blockquote>
<p>Flutter界面构建、布局、合成、绘制都由自身完成，而不是转换为原生控件。Flutter引擎与平台无关，通过嵌入层ABI调用操作系统方法。</p>
<p>应用启动时，嵌入层初始化Flutter引擎，获取UI和栅格化线程，创建Surface供Flutter写入</p>
</blockquote>
<h2 id="平台嵌入层"><a href="#平台嵌入层" class="headerlink" title="平台嵌入层"></a>平台嵌入层</h2><p>嵌入层是Flutter实现跨平台的核心。Flutter官方提供了Android、iOS、Windows、macOS、Linux、Fuchsia等平台嵌入层。</p>
<p>对于其他嵌入式平台和系统，需要定制嵌入层。后面的文章会介绍。</p>
<h2 id="Web上的Flutter"><a href="#Web上的Flutter" class="headerlink" title="Web上的Flutter"></a>Web上的Flutter</h2><p>Flutter引擎中的嵌入层是为了与底层操作系统进行交互，而Web是运行在浏览器上的，因此接入方式和其他平台有所不同。</p>
<p>将Flutter代码和框架一起编译成JavaScript。架构如下</p>
<img src="/2021/12/20/flutter-2021-12-20-Flutter%E7%AE%80%E4%BB%8B/FlutterWeb架构.png" style="zoom: 33%;">

<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><ul>
<li>统一管理：将原生工程作为Flutter工程的子工程。</li>
<li>模块集成：Flutter工程作为原生工程的一个子模块，使用aar或者pod库的方式依赖。</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>单纯学会写Flutter应用很简单，事实上我也是这么入门的：2021年5月份用了一周左右看了<a href="https://book.flutterchina.club/">Flutter实战</a>，并且实战开发了WanAndroid的Demo。后续就直接上手开发项目，架构设计也不难，一套GetX框架用到底，大部分时候是在学GetX框架，然后自定义组件，写页面和业务等。</p>
<p>学习的过程中也粗略的看了Flutter渲染流程、加载和运行原理、源码架构等文章，感觉一知半解，缺少系统性的学习和总结。刚好有需求做Flutter嵌入式平台的定制开发，涉及到一些进阶的知识，因此做一些整理，虽然对应用开发可能没什么帮助，但是也会有其他的收获和感悟。</p>
<p>研究过程和思路如下：</p>
<ol>
<li>Flutter介绍和跨平台方案对比。</li>
<li>Dart编译和执行原理，Dart源码编译：编译前端、编译后端。</li>
<li>Flutter应用构建流程、构建产物分析。</li>
<li>Flutter引擎源码分析和编译。</li>
<li>Flutter引擎和应用交叉编译编译环境搭建（使用Docker）。</li>
<li>Yocto系统编译，嵌入式平台调试。</li>
<li>Linux图形系统介绍。</li>
<li>Flutter嵌入层定制和适配。</li>
<li>Linux窗口管理器、桌面应用开发和运行。</li>
<li>源代码管理、CI搭建和部署。</li>
<li>Flutter应用加载流程、渲染原理。</li>
<li>Flutter应用开发，架构设计、产物裁剪。</li>
<li>Flutter插件开发，Dart调C接口：跨进程、FFI接口</li>
</ol>
<p><img src="/2021/12/20/flutter-2021-12-20-Flutter%E7%AE%80%E4%BB%8B/Flutter%E9%A2%84%E7%A0%94%E8%BF%87%E7%A8%8B.png"></p>
<p>参考资料：</p>
<ul>
<li><a href="https://flutterchina.club/">Flutter中文网</a></li>
<li><a href="https://book.flutterchina.club/">Flutter实战</a></li>
<li><a href="https://flutter.cn/docs/resources/architectural-overview">Flutter架构概览</a></li>
<li><a href="https://flutter.cn/desktop">Flutter桌面支持</a></li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>跨平台技术选型</title>
    <url>/2021/12/18/flutter-2021-12-18-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="跨平台技术优势"><a href="#跨平台技术优势" class="headerlink" title="跨平台技术优势"></a>跨平台技术优势</h1><p>原生开发不足：</p>
<ol>
<li>Android、iOS分开维护，开发和测试成本大。对于小团队来说成本较大。</li>
<li>动态化弱，更新需发版。</li>
</ol>
<p>跨平台优势：</p>
<ol>
<li>增加代码复用，减少开发者对多个平台差异适配的工作量，降低开发成本。</li>
<li>多端UI和交互一致。</li>
<li>动态化，热更新。</li>
<li>热重载。</li>
</ol>
<p>跨平台不足：</p>
<ol>
<li>接入成本</li>
<li>不可避免要和原生通信</li>
<li>性能弱于原生</li>
</ol>
<h1 id="跨端技术演进"><a href="#跨端技术演进" class="headerlink" title="跨端技术演进"></a>跨端技术演进</h1><img src="/2021/12/18/flutter-2021-12-18-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/跨端技术演进.png" style="zoom:100%;">

<table>
<thead>
<tr>
<th></th>
<th>WebView（Web App）</th>
<th>Hybrid（WebView+）</th>
<th>JS+原生渲染</th>
<th>自绘UI</th>
</tr>
</thead>
<tbody><tr>
<td>介绍</td>
<td>使用原生Web容器，JS引擎解析，WebKit或者Blink渲染</td>
<td>混合开发，WebView增强。通过JSBridge进行原生通信和调用</td>
<td>类RN方案，生成虚拟Dom，JSCore映射成原生控件渲染。</td>
<td>Dart编译，Flutter提供渲染引擎自绘</td>
</tr>
<tr>
<td>代表框架</td>
<td>H5、PWA</td>
<td>Cordova、Ionic、小程序、PhoneGap</td>
<td>RN、Weex、Hippy、快应用</td>
<td>Flutter、QT</td>
</tr>
<tr>
<td>虚拟机（运行时）</td>
<td>JS引擎（V8、JSC）</td>
<td>JS引擎+JSBridge</td>
<td>JS引擎</td>
<td>Dart VM</td>
</tr>
<tr>
<td>渲染引擎</td>
<td>WebKit、Blink</td>
<td>WebKit、Blink</td>
<td>Native渲染</td>
<td>2D：Skia（SGL）<br>3D：OpenGL ES</td>
</tr>
<tr>
<td>性能</td>
<td>差</td>
<td>差</td>
<td>原生渲染，运行时解析Dom树，和原生通信</td>
<td>接近原生</td>
</tr>
</tbody></table>
<p>Hybrid原理：</p>
<img src="/2021/12/18/flutter-2021-12-18-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/原理-H5混合开发.png" style="zoom:50%;">

<p>原生渲染原理：</p>
<img src="/2021/12/18/flutter-2021-12-18-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/原理-原生渲染.png" style="zoom:50%;">

<p>自绘渲染原理：</p>
<img src="/2021/12/18/flutter-2021-12-18-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/原理-Flutter.png" style="zoom:50%;">

<ul>
<li>PWA（Progressive Web App，渐进式Web App）：离线缓存、无需安装、服务端首屏渲染。</li>
<li>Weex：阿里巴巴出品，使用vue框架开发</li>
<li>快应用：国内手机厂商出品，使用JS开发，将引擎内置到ROM中，减少应用体积。</li>
<li>Taro：可以使用TSX、JSX、React语法，编译成不同平台的代码（RN、微信/支付宝/京东小程序、快应用、H5等）</li>
</ul>
<p>js调用Android方式：</p>
<ol>
<li><code>WebView.addJavaScriptInterface()</code></li>
<li><code>WebViewClient.shouldOverrideUrlLoading()</code></li>
</ol>
<p>Android调用JS方式：</p>
<ol>
<li><code>WebView.loadUrl()</code></li>
<li><code>WebView.evaluateJavaScript()</code></li>
</ol>
<h1 id="RN和Flutter对比"><a href="#RN和Flutter对比" class="headerlink" title="RN和Flutter对比"></a>RN和Flutter对比</h1><table>
<thead>
<tr>
<th>类型</th>
<th>React Native</th>
<th>Flutter</th>
</tr>
</thead>
<tbody><tr>
<td>原理</td>
<td>JSCore引擎解析React虚拟Dom，渲染成原生控件树。</td>
<td>skia引擎自绘UI</td>
</tr>
<tr>
<td>技术栈</td>
<td>React</td>
<td>Dart</td>
</tr>
<tr>
<td>开发者</td>
<td>FaceBook</td>
<td>Google</td>
</tr>
<tr>
<td>支持版本</td>
<td>Android 4.1（API level 16）以上</td>
<td>Android 4.1（API level 16）以上</td>
</tr>
<tr>
<td>支持平台</td>
<td>Android、iOS</td>
<td>Android、iOS、Web、桌面、Fuchsia</td>
</tr>
<tr>
<td>包体积</td>
<td>iOS系统自带JS Core，Android系统不带</td>
<td>Android系统内置Skia引擎，iOS系统不带</td>
</tr>
<tr>
<td>UI一致性</td>
<td>低：不同平台控件单独维护，复杂场景需要对原生控件进行扩展</td>
<td>高：一套代码，UI一致</td>
</tr>
<tr>
<td>原生调用</td>
<td>JS Bridge</td>
<td>Platform Channel</td>
</tr>
<tr>
<td>动态化</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>热重载</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>只对比Android和RN、Flutter</p>
<p>启动速度、内存、CPU多次测试取平均值。通过脚本模拟滚动列表操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>Android</th>
<th>Flutter</th>
<th>RN</th>
</tr>
</thead>
<tbody><tr>
<td>运行效率</td>
<td>1.0：Dalvik+解释器。<br>2.2：Dalvik+JIT。<br>5.0：ART+AOT。<br>7.0：混合编译。<br>9.0：编译模版</td>
<td>Debug是JIT，Release是AOT。</td>
<td>Js运行时编译，渲染需要和原生通信。</td>
</tr>
<tr>
<td>Release包</td>
<td>3.5M</td>
<td>未分包16M，分包5～6M</td>
<td>未分包30.1M，分包后10M左右</td>
</tr>
<tr>
<td>冷启动</td>
<td>329ms</td>
<td>395ms</td>
<td>341ms</td>
</tr>
<tr>
<td>温启动</td>
<td>242ms</td>
<td>288ms</td>
<td>243ms</td>
</tr>
<tr>
<td>热启动</td>
<td>89ms</td>
<td>57ms</td>
<td>53ms</td>
</tr>
<tr>
<td>内存占用</td>
<td>61.768M</td>
<td>75.747M</td>
<td>105.117M</td>
</tr>
<tr>
<td>CPU占用</td>
<td>52.040%</td>
<td>63.660%</td>
<td>67.820%</td>
</tr>
<tr>
<td>FPS（帧/s）</td>
<td>93.989</td>
<td>23.584、80.645</td>
<td>96.647</td>
</tr>
<tr>
<td>View数量</td>
<td>57</td>
<td>9</td>
<td>93</td>
</tr>
<tr>
<td>Display list</td>
<td>80.98KB</td>
<td>12.53KB</td>
<td>138KB</td>
</tr>
<tr>
<td>GPU</td>
<td>4.37MB</td>
<td>48KB</td>
<td>4.2MB</td>
</tr>
<tr>
<td>进程总耗电量</td>
<td>0.306mAh</td>
<td>0.332mAh</td>
<td>0.520mAh</td>
</tr>
<tr>
<td>进程CPU耗电量</td>
<td>0.0000800mAh</td>
<td>0.000383mAh</td>
<td>0.00154mAh</td>
</tr>
<tr>
<td>过度绘制</td>
<td><img src="/2021/12/18/flutter-2021-12-18-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/过度绘制-Android.png" style="zoom:25%;"></td>
<td><img src="/2021/12/18/flutter-2021-12-18-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/过度绘制-Flutter.png" style="zoom: 25%;"></td>
<td><img src="/2021/12/18/flutter-2021-12-18-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/过度绘制-RN.png" style="zoom:25%;"></td>
</tr>
</tbody></table>
<p>温启动：进程没被杀，Activity被回收，例如双击返回退出，或者app内存不足被回收</p>
<p>Flutter打包：<code>flutter build apk --split-per-abi</code></p>
<p>RN打包：<code>./gradlew assembleRelease</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/build.gradle</span></span><br><span class="line">android &#123;</span><br><span class="line">  splits &#123;</span><br><span class="line">        abi &#123;</span><br><span class="line">            reset()</span><br><span class="line">            enable <span class="literal">true</span></span><br><span class="line">            universalApk <span class="literal">false</span>  <span class="comment">// If true, also generate a universal APK</span></span><br><span class="line">            include <span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;x86&quot;</span>, <span class="string">&quot;arm64-v8a&quot;</span>, <span class="string">&quot;x86_64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>性能：</p>
<ul>
<li>渲染性能：原生=Flutter&gt;RN&gt;H5</li>
<li>运行效率：原生&gt;Flutter&gt;RN</li>
<li>启动速度：原生&gt;RN&gt;Flutter</li>
<li>包体积：RN&gt;Flutter&gt;原生</li>
<li>耗电量：RN&gt;Flutter&gt;原生</li>
<li>过度绘制：RN&gt;原生&gt;Flutter</li>
</ul>
</li>
<li><p>使用成本：</p>
<ul>
<li>学习曲线、成熟度、普及度、社区生态、三方库、行业趋势：容易过时，不对比了。目前主流应该是Flutter。</li>
<li>框架程度：Flutter&gt;RN&gt;H5</li>
<li>接入成本：全新项目成本较低，原有项目接入成本较高</li>
<li>维护成本：原生需要维护两套代码。RN需要封装原生控件、Flutter需要封装插件</li>
</ul>
</li>
<li><p>开发效率：</p>
<ul>
<li>热重载：RN、Flutter支持热重载</li>
<li>工具链（开发、编译、调试、测试、发布）：都挺完善的</li>
</ul>
</li>
<li><p>平台一致性：Flutter&gt;RN=原生</p>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Android性能分析请参考前面几篇<a href="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/">Android性能分析大全</a></p>
<p>Flutter性能分析参考<a href="https://flutter.cn/docs/perf">官方文档</a></p>
<p>Android性能分析脚本见<a href="https://github.com/Afauria/PerformanceCheck">GitHub-PerformanceCheck</a></p>
<p>Android、Flutter、RN测试Demo见<a href="https://github.com/Afauria/HybridPerformance">GitHub-HybridPerformance</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title>ButterKnife解析</title>
    <url>/2021/12/09/android-2021-12-09-ButterKnife/</url>
    <content><![CDATA[<h1 id="ButterKnife介绍"><a href="#ButterKnife介绍" class="headerlink" title="ButterKnife介绍"></a>ButterKnife介绍</h1><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><p><strong>已经废弃，建议切换至View Binding</strong></p>
<p>功能：使用源码注解+APT生成模版代码，进行Android视图变量和事件绑定。简化代码，提高可读性，编译时注解不会影响APP效率。</p>
<ul>
<li>视图绑定：成员变量使用<code>@BindView</code>注解避免调用<code>findViewById</code>。</li>
<li>资源绑定：字段上使用<code>@BindString、@BindColor、@BindDrawable</code>等注解，避免资源查找。</li>
<li>事件绑定：方法使用<code>@OnClick、onTextChanged</code>等注解，避免绑定监听器、创建匿名内部类。</li>
<li>绑定视图数组或列表，批量执行Action行为。<code>ViewCollections.run</code></li>
</ul>
<blockquote>
<p>运行时反射解析注解赋值，影响性能。（注解使用RUNTIME）</p>
<p>使用编译时注解+APT生成模版代码，运行时调用<code>ButterKnife.bind(...)</code>注入字段。（注解使用CLASS）</p>
<p>由于编译时处理注解较耗时，调试效率低。因此提供了两种实现，调试阶段可以使用反射，发布阶段使用编译时注解。（注解使用RUNTIME）</p>
</blockquote>
<p>项目结构如下：</p>
<p><img src="/2021/12/09/android-2021-12-09-ButterKnife/ButterKnife%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  <span class="comment">// Butterknife requires Java 8.</span></span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">&#x27;com.jakewharton:butterknife:10.2.3&#x27;</span> <span class="comment">//添加注解依赖</span></span><br><span class="line">  annotationProcessor <span class="string">&#x27;com.jakewharton:butterknife-compiler:10.2.3&#x27;</span> <span class="comment">//添加注解处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterknifeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字段不能是private或者static。否则编译会报错: @BindView fields must not be private or static.</span></span><br><span class="line">    <span class="meta">@BindView(R.id.btn1)</span></span><br><span class="line">    <span class="keyword">public</span> Button button1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_butterknife);</span><br><span class="line">        <span class="comment">//绑定activity</span></span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">        button1.setText(<span class="string">&quot;I am a button &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>bind必须在setContentView之后</li>
<li>父类bind后，子类不需要再bind</li>
<li>Fragment中使用需要传入rootView、onDestroyView中需要unbind</li>
<li>高版本AGP需要使用R2引用资源id</li>
<li>View不能使用private或static修饰，否则编译会报错</li>
</ol>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2021/12/09/android-2021-12-09-ButterKnife/ButterKnife%E5%8E%9F%E7%90%86.png"></p>
<ol>
<li>自定义注解和注解处理器</li>
<li>使用注解</li>
<li>编译时<code>butterknife-gradle-plugin</code>根据R文件生成R2文件</li>
<li>执行<code>butterknife-compile</code>APT，解析注解</li>
<li>使用JavaPoet生成XXX_ViewBinding类</li>
<li>运行时调用<code>ButterKnife.bind(...)</code>。<strong>需要使用者手动调用代理类执行，或者通过门面对象，反射找到代理类并执行</strong></li>
<li>反射实例化SimpleActivity_ViewBinding类</li>
<li>在构造方法中完成对Activity的View的绑定。</li>
</ol>
<h1 id="ButterKnife源码解析"><a href="#ButterKnife源码解析" class="headerlink" title="ButterKnife源码解析"></a>ButterKnife源码解析</h1><p>只分析View绑定部分，以Activity为例。（只保留关键代码，先源码太长，可以直接看小结部分）。</p>
<h2 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h2><ol>
<li>首先看下我们使用ButterKnife的代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="comment">//绑定视图</span></span><br><span class="line">  <span class="meta">@BindView(R.id.hello)</span> Button hello;</span><br><span class="line">  <span class="comment">//绑定监听器</span></span><br><span class="line">  <span class="meta">@OnClick(R.id.hello)</span> <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;Hello, views!&quot;</span>, LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.simple_activity);</span><br><span class="line">    <span class="comment">//进行绑定和字段注入</span></span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看<code>ButterKnife.bind(this)</code>源码，此方法有很多重载方法，区分不同目标类，如Activity、Fragment等</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnife</span> </span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(<span class="meta">@NonNull</span> Activity target)</span> </span>&#123;</span><br><span class="line">    View sourceView = target.getWindow().getDecorView();</span><br><span class="line">    <span class="comment">//构造并返回XXX_ViewBinding实例，用于主动调用unbind解除绑定</span></span><br><span class="line">    <span class="keyword">return</span> bind(target, sourceView);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(<span class="meta">@NonNull</span> Object target, <span class="meta">@NonNull</span> View source)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="comment">//根据Activity查找对应的ViewBinding类构造方法</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"> 	  <span class="comment">//实例化ViewBinding类，完成View绑定</span></span><br><span class="line">    <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">    <span class="comment">//省略异常处理...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>findBindingConstructorForClass</code>：查找对应的<code>XXX_ViewBinding</code>类构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnife</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Nullable</span> <span class="meta">@CheckResult</span> <span class="meta">@UiThread</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">    <span class="comment">//首先在缓存中查找，避免重复反射loadClass，查找构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span> || BINDINGS.containsKey(cls)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="comment">//避免查找父类找到Android源码类</span></span><br><span class="line">    <span class="keyword">if</span> (clsName.startsWith(<span class="string">&quot;android.&quot;</span>) || clsName.startsWith(<span class="string">&quot;java.&quot;</span>) || clsName.startsWith(<span class="string">&quot;androidx.&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//拼接类名，loadClass加载类对象</span></span><br><span class="line">      Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + <span class="string">&quot;_ViewBinding&quot;</span>);</span><br><span class="line">      <span class="comment">//反射获取到XXX_ViewBinding构造方法</span></span><br><span class="line">      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">//查找父类</span></span><br><span class="line">      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//省略异常处理...</span></span><br><span class="line">    <span class="comment">//缓存构造函数</span></span><br><span class="line">    <span class="comment">//此处不是缓存ViewBinding实例，而是缓存构造方法，下次进入需要重新创建实例。</span></span><br><span class="line">    <span class="comment">//由于ViewBinding会持有Activity对象，如果缓存实例，会导致无法释放</span></span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看<code>XXX_ViewBinding</code>源码，位于<code>build/generated/source/apt/</code>之下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity_ViewBinding</span> <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">  <span class="comment">//持有目标类引用</span></span><br><span class="line">  <span class="keyword">private</span> SimpleActivity target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> View view7f08001e;</span><br><span class="line">  <span class="comment">//重载构造方法</span></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleActivity_ViewBinding</span><span class="params">(SimpleActivity target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(target, target.getWindow().getDecorView());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果需要绑定监听器，target需要声明为final，供匿名内部类使用</span></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> SimpleActivity target, View source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">//findViewById并强制转换，注入Activity field，变量不能使用private或static，否则无法访问</span></span><br><span class="line">    View view;</span><br><span class="line">    view = Utils.findRequiredView(source, R.id.hello, <span class="string">&quot;field &#x27;hello&#x27; and method &#x27;sayHello&#x27;&quot;</span>);</span><br><span class="line">    target.hello = Utils.castView(view, R.id.hello, <span class="string">&quot;field &#x27;hello&#x27;&quot;</span>, Button.class);</span><br><span class="line">    view7f08001e = view;</span><br><span class="line">    <span class="comment">//使用DebouncingOnClickListener，内部实现了防抖</span></span><br><span class="line">    view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">        target.sayHello();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//外部主动调用，解除绑定，如fragment onDestroyView中调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleActivity target = <span class="keyword">this</span>.target;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Bindings already cleared.&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line">    target.hello = <span class="keyword">null</span>;</span><br><span class="line">    view7f08001e.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line">    view7f08001e = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结一下：</strong></p>
<ol>
<li>调用<code>ButterKnife.bind</code></li>
<li>拼接类名，使用ClassLoader加载<code>XXX_ViewBinding</code>类并缓存构造方法。（<strong>此处不是缓存ViewBinding实例，而是缓存构造方法，下次进入需要重新创建实例。由于ViewBinding会持有Activity对象，如果缓存实例，会导致无法释放</strong>）</li>
<li>反射创建实例</li>
<li>在构造方法中访问rootView查找View，访问Activity对象给字段赋值，或者添加监听器。并对@OnClick事件绑定做了防抖</li>
<li>返回Unbinder对象，供调用方主动解绑</li>
</ol>
<h2 id="注解解析步骤"><a href="#注解解析步骤" class="headerlink" title="注解解析步骤"></a>注解解析步骤</h2><p>上面解释了依赖注入原理，下面看看<code>XXX_ViewBinding</code>是如何生成的？</p>
<p>查看 <code>butterknife-compiler</code> 下的<code>ButterKnifeProcessor</code>类</p>
<ol>
<li>注解处理器均需要继承<code>AbstractProcessor</code>，<code>init</code>方法做初始化工作，<code>getSupportedAnnotationTypes</code>筛选需要处理的注解，<code>process</code>方法开始注解处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主要对辅助类进行初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//筛选需要处理的注解类型，也可通过@SupportedAnnotationTypes注解过滤</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span><br><span class="line">      types.add(annotation.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> types;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开始处理注解</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TypeElement表示一个类或接口，BindingSet包含需要生成的类的所有信息，用于生成java文件对象</span></span><br><span class="line">    Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);</span><br><span class="line">    <span class="comment">//遍历生成java文件 </span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</span><br><span class="line">      TypeElement typeElement = entry.getKey();</span><br><span class="line">      BindingSet binding = entry.getValue();</span><br><span class="line">      <span class="comment">//利用JavaPoet生成java文件对象，即XXX_ViewBinding.java</span></span><br><span class="line">      JavaFile javaFile = binding.brewJava(sdk, debuggable);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//写入文件</span></span><br><span class="line">        javaFile.writeTo(filer);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//使用processingEnv.getMessager()打印编译日志</span></span><br><span class="line">        error(typeElement, <span class="string">&quot;Unable to write binding for type %s: %s&quot;</span>, typeElement, e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>findAndParseTargets</code>方法：查找并解析目标注解，构建需要生成的类信息，存入Map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; <span class="title">findAndParseTargets</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key为类，值为需要绑定的成员变量或方法集合</span></span><br><span class="line">    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">//省略其他注解处理...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到所有@BindView注解的元素</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析注解和成员变量信息，加入到对应类的builder中</span></span><br><span class="line">        parseBindView(element, builderMap, erasedTargetNames);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logParsingError(element, BindView.class, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略遍历查找父类binder...</span></span><br><span class="line">    <span class="keyword">return</span> bindingMap;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>parseBindView</code>方法：解析<code>@BindView</code>注解的元素，存入对应类的<code>BindingSet.Builder</code>中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBindView</span><span class="params">(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</span></span></span><br><span class="line"><span class="function"><span class="params">      Set&lt;TypeElement&gt; erasedTargetNames)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取Field的父元素，即类，如Activity、Fragment、ViewHolder等</span></span><br><span class="line">    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查元素是否可达：</span></span><br><span class="line">    <span class="comment">//1. 字段不能为private或static，父元素为类、且类不能为private</span></span><br><span class="line">    <span class="comment">//2. 类不属于Android源码包</span></span><br><span class="line">    <span class="keyword">boolean</span> hasError = isInaccessibleViaGeneratedCode(BindView.class, <span class="string">&quot;fields&quot;</span>, element)</span><br><span class="line">        || isBindingInWrongPackage(BindView.class, element);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略检查元素是否继承自View...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注解值，即View的id</span></span><br><span class="line">    <span class="keyword">int</span> id = element.getAnnotation(BindView.class).value();</span><br><span class="line">    BindingSet.Builder builder = builderMap.get(enclosingElement);</span><br><span class="line">    <span class="comment">//解析为Id，通过Trees访问抽象语法树，保存id的值和对应的代码，如R.id.btn</span></span><br><span class="line">    Id resourceId = elementToId(element, BindView.class, id);</span><br><span class="line">    <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String existingBindingName = builder.findExistingBindingName(resourceId);</span><br><span class="line">      <span class="comment">//该资源id已经被绑定过了，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (existingBindingName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(element, <span class="string">&quot;Attempt to use @%s for an already bound ID %d on &#x27;%s&#x27;. (%s.%s)&quot;</span>,</span><br><span class="line">            BindView.class.getSimpleName(), id, existingBindingName,</span><br><span class="line">            enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果已经有对应类的builder，则直接返回。没有的话就新建一个builder，加入到map中。</span></span><br><span class="line">      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量名称</span></span><br><span class="line">    String name = simpleName.toString();</span><br><span class="line">    <span class="comment">//变量类型</span></span><br><span class="line">    TypeName type = TypeName.get(elementType);</span><br><span class="line">    <span class="comment">//变量是否有@Nullable注解</span></span><br><span class="line">    <span class="keyword">boolean</span> required = isFieldRequired(element);</span><br><span class="line">    <span class="comment">//builder中添加需要绑定的field信息</span></span><br><span class="line">    builder.addField(resourceId, <span class="keyword">new</span> FieldViewBinding(name, type, required));</span><br><span class="line">    <span class="comment">// Add the type-erased version to the valid binding targets set.</span></span><br><span class="line">    erasedTargetNames.add(enclosingElement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>BindingSet.newBuilder</code>方法：构建类基本信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingSet</span> <span class="keyword">implements</span> <span class="title">BindingInformationProvider</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">(TypeElement enclosingElement)</span> </span>&#123;</span><br><span class="line">    TypeMirror typeMirror = enclosingElement.asType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isView = isSubtypeOfType(typeMirror, VIEW_TYPE);</span><br><span class="line">    <span class="keyword">boolean</span> isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE);</span><br><span class="line">    <span class="keyword">boolean</span> isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE);</span><br><span class="line"></span><br><span class="line">    TypeName targetType = TypeName.get(typeMirror);</span><br><span class="line">    <span class="comment">//如果是泛型，则使用真实类型</span></span><br><span class="line">    <span class="keyword">if</span> (targetType <span class="keyword">instanceof</span> ParameterizedTypeName) &#123;</span><br><span class="line">      targetType = ((ParameterizedTypeName) targetType).rawType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成JavaPoet类名对象</span></span><br><span class="line">    ClassName bindingClassName = getBindingClassName(enclosingElement);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder(targetType, bindingClassName, enclosingElement, isFinal, isView, isActivity,</span><br><span class="line">        isDialog);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//得到XXX_ViewBinding类名</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> ClassName <span class="title">getBindingClassName</span><span class="params">(TypeElement typeElement)</span> </span>&#123;</span><br><span class="line">    String packageName = getPackage(typeElement).getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//如果为内部类，如Adapter.ViewHolder，会返回Adapter$ViewHolder_ViewBinding</span></span><br><span class="line">    String className = typeElement.getQualifiedName().toString().substring(</span><br><span class="line">            packageName.length() + <span class="number">1</span>).replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> ClassName.get(packageName, className + <span class="string">&quot;_ViewBinding&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaPoet生成Java文件对象"><a href="#JavaPoet生成Java文件对象" class="headerlink" title="JavaPoet生成Java文件对象"></a>JavaPoet生成Java文件对象</h2><p>这一部分简单了解一下即可，挑一部分讲，具体API使用可以看<a href="https://github.com/square/javapoet">官方文档</a>。</p>
<ol>
<li><code>binding.brewJava</code>方法：下面代码主要是使用<code>JavaPoet</code>生成Java文件对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingSet</span> <span class="keyword">implements</span> <span class="title">BindingInformationProvider</span> </span>&#123;</span><br><span class="line">  <span class="function">JavaFile <span class="title">brewJava</span><span class="params">(<span class="keyword">int</span> sdk, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    TypeSpec bindingConfiguration = createType(sdk, debuggable);</span><br><span class="line">    <span class="comment">//生成JavaPoet文件对象</span></span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(bindingClassName.packageName(), bindingConfiguration)</span><br><span class="line">        .addFileComment(<span class="string">&quot;Generated code from Butter Knife. Do not modify!&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建类型</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TypeSpec <span class="title">createType</span><span class="params">(<span class="keyword">int</span> sdk, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TypeSpec用于生成类或接口。除此之外还有MethodSpec等</span></span><br><span class="line">    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())</span><br><span class="line">        .addModifiers(PUBLIC)</span><br><span class="line">        .addOriginatingElement(enclosingElement);</span><br><span class="line">    <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">      <span class="comment">//添加final修饰符</span></span><br><span class="line">      result.addModifiers(FINAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//extends父类</span></span><br><span class="line">      result.superclass(parentBinding.getBindingClassName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//implement UnBinder接口</span></span><br><span class="line">      result.addSuperinterface(UNBINDER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加target字段，即Activity对象，需要给target的成员变量赋值</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">      result.addField(targetTypeName, <span class="string">&quot;target&quot;</span>, PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据类型生成不同的重载构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (isView) &#123;</span><br><span class="line">      result.addMethod(createBindingConstructorForView());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isActivity) &#123;</span><br><span class="line">      result.addMethod(createBindingConstructorForActivity());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDialog) &#123;</span><br><span class="line">      result.addMethod(createBindingConstructorForDialog());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constructorNeedsView()) &#123;</span><br><span class="line">      <span class="comment">// Add a delegating constructor with a target type + view signature for reflective use.</span></span><br><span class="line">      result.addMethod(createBindingViewDelegateConstructor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加构造函数</span></span><br><span class="line">    result.addMethod(createBindingConstructor(sdk, debuggable));</span><br><span class="line">    <span class="comment">//重写unbind方法</span></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings() || parentBinding == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result.addMethod(createBindingUnbindMethod(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>createBindingConstructor</code>方法：生成<code>XXX_ViewBinding</code>类的构造函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingSet</span> <span class="keyword">implements</span> <span class="title">BindingInformationProvider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> MethodSpec <span class="title">createBindingConstructor</span><span class="params">(<span class="keyword">int</span> sdk, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用MethodSpec生成方法</span></span><br><span class="line">    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()</span><br><span class="line">        .addAnnotation(UI_THREAD)</span><br><span class="line">        .addModifiers(PUBLIC);</span><br><span class="line">    <span class="comment">//添加target参数</span></span><br><span class="line">    <span class="keyword">if</span> (hasMethodBindings()) &#123;</span><br><span class="line">      <span class="comment">//需要绑定事件监听，则target要声明为final，因为匿名内部类会引用</span></span><br><span class="line">      constructor.addParameter(targetTypeName, <span class="string">&quot;target&quot;</span>, FINAL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      constructor.addParameter(targetTypeName, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加source参数</span></span><br><span class="line">    <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">      constructor.addParameter(VIEW, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      constructor.addParameter(CONTEXT, <span class="string">&quot;context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略添加SuppressWarnings注解代码...</span></span><br><span class="line">    <span class="comment">//如果有父类，需要调用父类构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parentBinding.constructorNeedsView()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;super(target, source)&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;super(target, source.getContext())&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;super(target, context)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      constructor.addCode(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给target字段赋值</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">      constructor.addStatement(<span class="string">&quot;this.target = target&quot;</span>);</span><br><span class="line">      constructor.addCode(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定视图</span></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasViewLocal()) &#123;</span><br><span class="line">        <span class="comment">// Local variable in which all views will be temporarily stored.</span></span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$T view&quot;</span>, VIEW);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//遍历添加视图绑定</span></span><br><span class="line">      <span class="keyword">for</span> (ViewBinding binding : viewBindings) &#123;</span><br><span class="line">        addViewBinding(constructor, binding, debuggable);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (FieldCollectionViewBinding binding : collectionBindings) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$L&quot;</span>, binding.render(debuggable));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">        constructor.addCode(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定资源</span></span><br><span class="line">    <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$T context = source.getContext()&quot;</span>, CONTEXT);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (hasResourceBindingsNeedingResource(sdk)) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$T res = context.getResources()&quot;</span>, RESOURCES);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (ResourceBinding binding : resourceBindings) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$L&quot;</span>, binding.render(sdk));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructor.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>addViewBinding</code>方法：添加视图绑定代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingSet</span> <span class="keyword">implements</span> <span class="title">BindingInformationProvider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewBinding</span><span class="params">(MethodSpec.Builder result, ViewBinding binding, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (binding.isSingleFieldBinding()) &#123;</span><br><span class="line">      <span class="comment">// 如果只需要绑定字段，则直接查找View，并给target的字段赋值</span></span><br><span class="line">      <span class="comment">//省略添加findViewById代码块...</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//findViewById，并保存为局部变量</span></span><br><span class="line">    List&lt;MemberViewBinding&gt; requiredBindings = binding.getRequiredBindings();</span><br><span class="line">    <span class="keyword">if</span> (!debuggable || requiredBindings.isEmpty()) &#123;</span><br><span class="line">      result.addStatement(<span class="string">&quot;view = source.findViewById($L)&quot;</span>, binding.getId().code);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!binding.isBoundToRoot()) &#123;</span><br><span class="line">      result.addStatement(<span class="string">&quot;view = $T.findRequiredView(source, $L, $S)&quot;</span>, UTILS,</span><br><span class="line">          binding.getId().code, asHumanDescription(requiredBindings));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给target的字段赋值，并进行强制转换</span></span><br><span class="line">    addFieldBinding(result, binding, debuggable);</span><br><span class="line">    <span class="comment">//绑定监听器，并调用target中注解的方法</span></span><br><span class="line">    addMethodBindings(result, binding, debuggable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结一下：</strong></p>
<ol>
<li>通过继承<code>AbstractProcessor</code>定义注解处理器，重写<code>getSupportedAnnotationTypes()</code>方法筛选需要处理的注解，重写<code>process</code>方法处理注解。</li>
<li>使用<code>javax.lang.model</code>包下的类来解析Java代码。自定义解析规则，如<ol>
<li>找到所有注解过的元素</li>
<li>解析元素：变量类型、变量名，变量修饰符，注解类型，注解值等</li>
<li>检查元素合法性：如是否为private或static、是否继承自View、是否是成员变量等</li>
<li>…</li>
</ol>
</li>
<li>自定义<code>BindingSet</code>类保存需要生成的<code>ViewBinding</code>类的信息。</li>
<li>使用<code>JavaPoet</code>库的API生成Java文件对象。</li>
<li>最后使用<code>Filer</code>类写入文件。</li>
</ol>
<h2 id="APT如何找到自定义注解处理器？"><a href="#APT如何找到自定义注解处理器？" class="headerlink" title="APT如何找到自定义注解处理器？"></a>APT如何找到自定义注解处理器？</h2><p>APT是如何找到自定义的<code>ButterKnifeProcessor</code>注解处理器并执行的呢？</p>
<blockquote>
<p>使用了JavaSPI（Service Provider Interface，服务发现接口）机制。关于JavaSPI机制可以阅读<a href="/2021/12/06/architecture-2021-12-06-SPI/">另一篇文章</a></p>
</blockquote>
<p>原理：APT运行的时候加载Processor接口，通过<code>ServiceLoader</code>读取services文件夹下的服务文件，找到Processor接口的实现类（可以有多个），遍历初始化和执行多个注解处理器。（类似于<code>AndroidManifest</code>注册组件）</p>
<p>具体介绍和配置可以参考<a href="/2021/12/08/tech-2021-12-08-APT/">APT介绍和实践</a></p>
<h2 id="增量注解处理器"><a href="#增量注解处理器" class="headerlink" title="增量注解处理器"></a>增量注解处理器</h2><p>注意到<code>ButterKnife</code>中还依赖了一个<code>incap</code>的库，并且使用了它的注解<code>@IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.DYNAMIC)</code>。</p>
<blockquote>
<p>Gradle支持配置增量注解处理器，通过在<code>main</code>目录下新建<code>resources/META-INF/gradle/incremental.annotation.processors</code>文件进行配置</p>
<p>这个库实际上就是通过注解+APT自动帮我们生成了配置文件</p>
</blockquote>
<p>具体介绍和可以参考<a href="/2021/12/08/tech-2021-12-08-APT/">APT介绍和实践</a></p>
<h1 id="Android视图绑定历程"><a href="#Android视图绑定历程" class="headerlink" title="Android视图绑定历程"></a>Android视图绑定历程</h1><h2 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h2><p>原始方式，需要在Activity、Fragment中编写大量重复代码</p>
<h2 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h2><p><strong>已经被宣布废弃</strong>。</p>
<p>通过源码注解+APT方式生成XXX_ViewBinding类，并在onCreate调用<code>ButterKnife.bind(...)</code>注入字段。</p>
<p>ButterKnife存在问题：高版本AGP（Android Gradle Plugin）生成的R文件不再是常量（模块化中可能和三方库产生id冲突），而编译时注解要求在编译期就确定值。因此在Library模块中会编译失败。</p>
<p>可以添加ButterKnife提供的插件，生成R2资源id解决。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 根目录 build.gradle引入插件</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath <span class="string">&#x27;com.jakewharton:butterknife-gradle-plugin:10.2.3&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. library模块build.gradle应用插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.jakewharton.butterknife&#x27;</span> <span class="comment">//生成R2资源id</span></span><br><span class="line"><span class="comment">//3. 代码中使用R2替代R引用资源id</span></span><br></pre></td></tr></table></figure>

<h2 id="KAE（Kotlin-Android-Extensions）"><a href="#KAE（Kotlin-Android-Extensions）" class="headerlink" title="KAE（Kotlin Android Extensions）"></a>KAE（Kotlin Android Extensions）</h2><p><strong>已经被宣布废弃</strong>。</p>
<p>使用方式：<code>build.gradle</code>添加插件即可<code>apply plugin: &#39;kotlin-android-extensions&#39;</code></p>
<p>原理：通过Gradle插件生成findViewById代码，并使用HashMap缓存控件。</p>
<p>反编译成java代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> HashMap _$_findViewCache;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      <span class="keyword">this</span>.setContentView(<span class="number">1300023</span>);</span><br><span class="line">      TextView var10000 = (TextView)<span class="keyword">this</span>._$_findCachedViewById(id.textView);</span><br><span class="line">      var10000.setText((CharSequence)<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> View _$_findCachedViewById(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache = <span class="keyword">new</span> HashMap();</span><br><span class="line">      &#125;</span><br><span class="line">      View var2 = (View)<span class="keyword">this</span>._$_findViewCache.get(var1);</span><br><span class="line">      <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">         var2 = <span class="keyword">this</span>.findViewById(var1);</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.put(var1, var2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> var2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<ul>
<li>类型安全：res下的任何id都可以被访问，有可能因访问了非当前Layout下的id而出错，难以利用lint等静态代码校验</li>
<li>空安全：运行时可能出现NPE</li>
<li>兼容性：只能在kotlin中使用，java不友好</li>
<li>局限性：不能跨module使用</li>
<li><code>RecyclerView.Adapter onBindiViewHolder</code>中直接使用，会生成findViewById代码，丧失ViewHolder复用优势</li>
</ul>
<h2 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h2><p><a href="https://developer.android.com/topic/libraries/view-binding">官方文档</a>。内置Gradle插件，根据layout布局文件生成XXXBinding类。</p>
<p>与findViewById相比：ViewBinding能保证<strong>空安全、类型安全</strong>。</p>
<p>与DataBinding相比：ViewBinding更轻量，但不支持布局变量和布局表达式，不支持数据绑定</p>
<p>使用方式如下：</p>
<ol>
<li>启动ViewBinding功能</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Android Studio3.6以上，按模块启用build.gradle配置</span></span><br><span class="line">android &#123;</span><br><span class="line">	viewBinding &#123;</span><br><span class="line">		enabled = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写layout布局文件，build生成Binding类。如果想忽略布局文件，可以添加属性<code>tools:viewBindingIgnore=&quot;true&quot;</code></li>
<li>代码中使用</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> <span class="title">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要build之后才能生成Binding类</span></span><br><span class="line">    <span class="keyword">private</span> ResultProfileBinding binding;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">        binding = ResultProfileBinding.inflate(inflater, container, <span class="literal">false</span>);</span><br><span class="line">        View view = binding.getRoot();</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onDestroyView() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">      	<span class="comment">//在Fragment中使用，onDestroyView的时候需要释放binding对象。</span></span><br><span class="line">        binding = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="未来？"><a href="#未来？" class="headerlink" title="未来？"></a>未来？</h2><p>响应式布局。</p>
<p>最好的视图绑定就是不需要findViewById</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>APT</tag>
      </tags>
  </entry>
  <entry>
    <title>注解、APT介绍和实践</title>
    <url>/2021/12/08/android-2021-12-08-APT/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按运行机制分：通过@Retention注解进行分类</p>
<blockquote>
<ul>
<li>源码注解：只在源码中存在。RetentionPolicy.SOURCE，编译为class字节码之后丢失</li>
<li>编译时注解：在class中依然存在，RetentionPolicy.CLASS。</li>
<li>运行时注解：运行阶段可见，RetentionPolicy.RUNTIME。</li>
</ul>
</blockquote>
<p>按来源分：</p>
<blockquote>
<ul>
<li>JDK自带注解<ul>
<li>内置注解：如@Override，@Deprecated、@SurpressWarnings等</li>
<li>元注解：用于修饰其他注解<ul>
<li>@Retention：注解作用域（可见性、保留策略），分为SOURCE、CLASS（默认策略）、RUNTIME</li>
<li>@Target：注解作用对象，未指定时可以作用在任何元素上。可以传入数组，如<code>@Target(&#123;TYPE, Field, ...&#125;)</code></li>
<li>@Document：可以使用javadoc工具生成文档</li>
<li>@Inherited：父类使用了@Inherited修饰的注解，子类也会继承该注解。<ul>
<li>接口使用了@Inherited修饰的注解，实现类不会继承该注解</li>
<li>父类方法使用了@Inherited修饰的注解，子类不会继承该注解</li>
</ul>
</li>
<li>@Repeatable：JDK1.8之后引入。表示一个注解可以在一个元素上使用多次</li>
</ul>
</li>
</ul>
</li>
<li>三方注解：三方库提供的注解。如Hibernate，Struts，ButterKnife，ARouter等</li>
<li>自定义注解</li>
</ul>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>同class、interface一样，注解也是一种类型。</p>
<p>使用@interface关键字定义，不支持继承其他注解或接口，会自动继承Annotation接口。示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">//声明可被javadoc生成文档</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//声明作用域</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span> <span class="comment">//声明可修饰对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  <span class="comment">//注解参数，支持数据类型：基本数据类型、String类型、Class类型、enum类型、Annotation类型，以及相应的数组类型</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//可以定义默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li>IDE检测和提示编码错误或警告</li>
<li>编译时处理：通过APT检测注解，生成代码、文档等（注解作用域：SOURCE、CLASS）。会增加代码量</li>
<li>运行时处理：反射解析注解，反射修改变量、调用方法等（注解作用域：RUNTIME）。会影响性能</li>
</ol>
<p>需要注意的是：<strong>注解本身没有作用，只是一个标签，需要编写代码来提取和处理注解信息，简称APT（Annotation Processing Tool，注解处理器）</strong></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>JUnit</li>
<li>Android Annotations：配合IDE和Lint工作<ol>
<li>防止代码混淆：@Keep</li>
<li>检查资源类型：@ColorRes</li>
<li>参数是否可空：@Nullable、@NonNull</li>
<li>指定方法需要在特定线程执行：@UiThread、@MainThread、@WorkThread、@BinderThread</li>
<li>限定取值范围：@IntRange、@Size（数组或集合大小）</li>
<li>权限检查：@RequiresPermission</li>
<li>使用@IntDef或@StringDef替代枚举：见下例。</li>
</ol>
</li>
<li>ButterKnife：高版本AGP（Android Gradle Plugin）生成的R文件不再是常量。可以添加ButterKnife提供的插件，生成R2资源id解决。</li>
<li>Dagger</li>
<li>DataBinding</li>
<li>EventBus3</li>
<li>DBFlow</li>
<li>Retrofit</li>
<li>…</li>
</ol>
<h3 id="使用-IntDef或-StringDef替代枚举"><a href="#使用-IntDef或-StringDef替代枚举" class="headerlink" title="使用@IntDef或@StringDef替代枚举"></a>使用@IntDef或@StringDef替代枚举</h3><p><strong>一般我们使用枚举来限制取值，但是枚举最终会生成对象，比常量占用更多内存</strong>。</p>
<p>源码中如View的<code>VISIBLE/INVISIBLE/GONE、FOCUSABLE/NOT_FOCUSABLE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//1. 定义可用常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//&#123;...省略部分&#125;</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//2. 定义注解，使用@IntDef限制可用常量</span></span><br><span class="line">    <span class="meta">@IntDef(&#123;SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> WeekDays &#123;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//3. 限制变量、参数、返回值等为@WeekDays定义的常量。否则编译器会报错</span></span><br><span class="line">    <span class="meta">@WeekDays</span></span><br><span class="line">    <span class="keyword">int</span> currentDay = SUNDAY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentDay</span><span class="params">(<span class="meta">@WeekDays</span> <span class="keyword">int</span> currentDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentDay = currentDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WeekDays</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentDay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行时注解实现findViewById功能"><a href="#运行时注解实现findViewById功能" class="headerlink" title="运行时注解实现findViewById功能"></a>运行时注解实现findViewById功能</h1><p>避免写大量的<code>findViewById</code>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> ViewInject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 运行时注入注解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewInjectUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectViews</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends Activity&gt; activityCls = activity.getClass(); <span class="comment">// 获取activity的Class</span></span><br><span class="line">        Field[] fields = activityCls.getDeclaredFields(); <span class="comment">// 通过Class获取activity的所有字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123; <span class="comment">// 遍历所有字段</span></span><br><span class="line">            <span class="comment">// 获取字段的注解，如果没有ViewInject注解，则返回null</span></span><br><span class="line">            ViewInject viewInject = field.getAnnotation(ViewInject.class);</span><br><span class="line">            <span class="keyword">if</span> (viewInject == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> viewId = viewInject.value(); <span class="comment">// 获取字段注解的参数，这就是我们传进去控件Id</span></span><br><span class="line">            <span class="keyword">if</span> (viewId == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 执行findViewById方法，返回View实例</span></span><br><span class="line">                <span class="comment">// 给变量赋值</span></span><br><span class="line">                field.set(activity, activity.findViewById(viewId));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. Activity中调用，解析注解给变量赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewInjectActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ViewInject(R.id.viewInjectBtn1)</span></span><br><span class="line">    <span class="keyword">private</span> Button mBtn1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ViewInject(R.id.viewInjectBtn2)</span></span><br><span class="line">    <span class="keyword">private</span> Button mBtn2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_view_inject);</span><br><span class="line">        <span class="comment">//运行时反射解析注解，给变量赋值</span></span><br><span class="line">        ViewInjectUtil.injectViews(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时注解看起来不难，为什么要使用编译时注解？</p>
<blockquote>
<p>运行时注解需要反射，项目复杂度越高，反射次数越多，性能较差。</p>
<p>编译时注解反射次数固定。</p>
</blockquote>
<h1 id="APT介绍"><a href="#APT介绍" class="headerlink" title="APT介绍"></a>APT介绍</h1><p>APT是javac的一个工具，可以在编译时扫描和处理注解，并生成java文件，参与编译。</p>
<p>原理：编译前端过程中javac进行词法分析和语法分析之后会生成<strong>抽象语法树（AST）</strong>，然后调用注解处理器（注解处理器相当于javac对外提供的插件），可以在这个阶段生成新的java文件。也可以<strong>直接修改抽象语法树</strong></p>
<blockquote>
<ul>
<li>编译前端：指Java源文件编译成class文件。</li>
<li>编译后端：class文件转为本地机器码</li>
</ul>
<p>详情见<a href="/2021/11/05/basic-2021-11-05-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/">编程语言、编译器和Android虚拟机</a></p>
</blockquote>
<p>APT特点：</p>
<ol>
<li>需要自定义APT处理器</li>
<li>需要手动拼接代理的代码：可以使用<a href="https://github.com/square/javapoet">JavaPoet</a>，调用API生成java源代码。如果是Kotlin，可以使用<a href="https://github.com/square/kotlinpoet">KotlinPoet</a></li>
<li>需要使用者手动调用代理类执行，或者通过门面对象，反射找到代理类并执行。如<code>ButterKnife.bind(this)</code></li>
<li>会生成大量代理类，导致类和方法数增多</li>
<li>无法直接在源文件中插入或修改代码，而是生成代理类。</li>
</ol>
<blockquote>
<p>其实也可以通过<code>tools.jar</code>库中的API（如JCTree、TreeMaker）直接操作抽象语法树，插入代码。</p>
<p>需要添加依赖包：<code>compileOnly files(org.gradle.internal.jvm.Jvm.current().getToolsJar())</code></p>
<p>可以参考<a href="https://fanmingyi.blog.csdn.net/article/details/113766921">Java Pluginable Annotation processing</a></p>
</blockquote>
<p>代表框架：DataBinding、Dagger2、ButterKnife、EventBus3、DBFlow</p>
<p>KAPT：Kotlin注解处理器。kotlin代码生成Java AST，然后交给javac APT处理注解。生成Kotlin代码无法再被Kotlin编译器编译。（不同版本KAPT原理有一些差异）</p>
<p>为什么不使用ASM等字节码框架？</p>
<blockquote>
<p>修改字节码复杂度较高，难以保证稳定，也不易于调试。</p>
<p>APT生成的Java类更好理解</p>
</blockquote>
<p><strong>下面介绍APT涉及到的相关知识点，内容较多，可以先跳到后面看<a href="#%E8%87%AA%E5%AE%9A%E4%B9%89APT%E6%AD%A5%E9%AA%A4">自定义APT步骤</a>，再回过头来看细节</strong></p>
<h2 id="AbstractProcessor介绍"><a href="#AbstractProcessor介绍" class="headerlink" title="AbstractProcessor介绍"></a>AbstractProcessor介绍</h2><p>自定义注解处理器需要继承<code>AbstractProcessor</code>，有几个关键的方法，如下</p>
<ol>
<li><code>init</code>：用于初始化变量</li>
<li><code>process</code>：最核心的方法，用于执行注解解析逻辑、生成文件。</li>
<li><code>getSupportedAnnotationTypes</code>：返回需要被处理的注解的<strong>完整类型名</strong>，其他注解会被过滤掉</li>
<li><code>getSupportedOptions</code>：返回注解处理器可以接收的参数。使用注解处理器的时候可以传入对应的参数值。</li>
<li><code>getSupportedSourceVersion</code>：返回支持的JDK版本</li>
</ol>
<p>其中<code>getSupportedAnnotationTypes</code>除了可以用返回值的方式指定之外，还可以用注解声明。<code>AbstractProcessor</code>中重写了该方法，反射解析对应的注解<code>@SupportedAnnotationTypes</code>，拿到注解的值然后返回。<code>getSupportedOptions</code>和<code>getSupportedSourceVersion</code>同理。</p>
<blockquote>
<p>Tips：简单的可以使用注解指定，传入完整的类型名。多个注解的时候还是通过代码返回列表，不容易出错，而且路径改变的时候可以跟着一起改。</p>
</blockquote>
<h2 id="注解处理器传入参数"><a href="#注解处理器传入参数" class="headerlink" title="注解处理器传入参数"></a>注解处理器传入参数</h2><ol>
<li>例如配置<code>@SupportedOptions(&quot;content&quot;)</code></li>
<li>使用注解处理器的时候，传入参数，gradle配置如下：</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// 在gradle文件中配置选项参数值（用于APT传参接收）</span></span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="attr">content:</span> <span class="string">&#x27;Hello World&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在注解处理器代码中通过<code>processingEnvironment.getOptions().get(&quot;content&quot;);</code>拿到参数使用</li>
</ol>
<h2 id="常用类和API"><a href="#常用类和API" class="headerlink" title="常用类和API"></a>常用类和API</h2><p>参考<a href="https://fanmingyi.blog.csdn.net/article/details/116274271">注解处理器常用类说明</a></p>
<h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a><code>Element</code></h3><p>位于<code>javax.lang.model.element.Element</code></p>
<p>Java文件是有规范和格式的，源代码有对应的结构体，主要包含以下几种元素（类似于XML文件中的DOM树）：</p>
<p><img src="/2021/12/08/android-2021-12-08-APT/Element%E6%8E%A5%E5%8F%A3%E7%B1%BB.png"></p>
<ol>
<li><code>PackageElement:</code>表示包。提供对有关包及其成员的信息的访问</li>
<li> <code>TypeElement:</code>表示类或接口程序元素。提供对有关类型及其成员的信息的访问。</li>
<li> <code>ExecutableElement:</code>表示某个类或接口的方法、构造方法或初始化程序</li>
<li> <code>VariableElement:</code>表示字段、enum常量、方法或构造方法参数、局部变量或异常参数</li>
<li><code>TypeParameterElement</code>：表示泛型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.afauria.sample.apt; <span class="comment">//PackageElement</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; <span class="comment">//TypeElement</span></span><br><span class="line">  <span class="keyword">private</span> String test = <span class="string">&quot;&quot;</span>; <span class="comment">//VariableElement</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">//ExecuteableElement</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 泛型：TypeParameterElement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用API：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>accept</td>
<td>访问者模式，传入<code>ElementVisitor</code>。用于访问该元素下的所有元素。根据元素类型进行访问</td>
</tr>
<tr>
<td>getEnclosedElements</td>
<td>获取该元素的所有<strong>直接</strong>子元素</td>
</tr>
<tr>
<td>getEnclosingElement</td>
<td>获取该元素的父元素</td>
</tr>
<tr>
<td>getKind</td>
<td>返回ElementKind枚举，例如VariableElement可以表示字段、参数等，通过ElementKind可以判断元素具体类型</td>
</tr>
<tr>
<td>getSimpleName</td>
<td>返回元素名字，如变量名，类名</td>
</tr>
<tr>
<td>getQualifiedName</td>
<td>获取全名</td>
</tr>
<tr>
<td>getModifiers</td>
<td>获取修饰符集合<code>Set&lt;Modifier&gt;</code>，如public、native、synchronized等</td>
</tr>
<tr>
<td>getParameters</td>
<td>获取方法参数列表List&lt;? extends VariableElement&gt;</td>
</tr>
<tr>
<td>getReturnType</td>
<td>获取方法返回值</td>
</tr>
<tr>
<td>asType</td>
<td>返回对应的TypeMirror</td>
</tr>
</tbody></table>
<h3 id="TypeMirror"><a href="#TypeMirror" class="headerlink" title="TypeMirror"></a><code>TypeMirror</code></h3><p>位于<code>javax.lang.model.type.TypeMirror</code></p>
<p><code>Element</code>只能表示Java文件结构，不能获取具体的Java类型，需要使用<code>TypeMirror</code>相关的类</p>
<p><img src="/2021/12/08/android-2021-12-08-APT/TypeMirror%E6%8E%A5%E5%8F%A3%E7%B1%BB.png"></p>
<p>常用API：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>accept</td>
<td>访问者模式，传入<code>TypeVisitor</code>。根据子类类型进行访问</td>
</tr>
<tr>
<td>getKind</td>
<td>返回具体类型。如boolean、String等</td>
</tr>
</tbody></table>
<h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><ol>
<li><code>javax.lang.model.util.Elements</code>：用于操作Element，可以通过<code>processingEnvironment.getElementUtils();</code>获取</li>
<li><code>javax.lang.model.util.getType</code>：用于操作TyoeMirror，可以通过<code>processingEnvironment.getTypeUtils();</code>获取</li>
<li><code>javax.annotation.processing.Messager</code>：用于输出信息，可以通过<code>processingEnvironment.getMessager();</code>获取，打印error并不会中断process执行，但是会导致编译失败，无法执行下一个Task。</li>
<li><code>javax.annotation.processing.Filer</code>：用于生成文件，可以通过<code>processingEnvironment.getFiler();</code>获取。新生成的文件分为三类，会被放到不同路径<ol>
<li><code>createSourceFile</code>：源代码文件</li>
<li><code>createClassFile</code>：类文件</li>
<li><code>createResource</code>：资源文件</li>
</ol>
</li>
</ol>
<h2 id="注册JavaSPI服务配置文件"><a href="#注册JavaSPI服务配置文件" class="headerlink" title="注册JavaSPI服务配置文件"></a>注册JavaSPI服务配置文件</h2><p>APT是如何找到我们自定义的<code>Processor</code>注解并执行的呢？</p>
<blockquote>
<p>使用了JavaSPI（Service Provider Interface，服务发现接口）机制。关于JavaSPI机制可以阅读<a href="/2021/12/06/architecture-2021-12-06-SPI/">另一篇文章</a></p>
</blockquote>
<p>APT运行的时候加载Processor接口，通过<code>ServiceLoader</code>读取services下的服务配置文件，找到Processor接口的实现类（可以有多个），<strong>遍历</strong>初始化和执行多个注解处理器。（类似于<code>AndroidManifest</code>注册组件）</p>
<p>有两种注册方式，如下：</p>
<h3 id="手动创建service文件"><a href="#手动创建service文件" class="headerlink" title="手动创建service文件"></a>手动创建service文件</h3><p>main目录下面新建<code>resources/META_INF/services/javax.annotation.processing.Processor</code>文件，在文件中写入完整的自定义注解处理器类名（配置多个注解处理器的时候需要换行）。如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">butterknife.compiler.ButterKnifeProcessor</span><br></pre></td></tr></table></figure>

<h3 id="使用AutoService库生成service文件"><a href="#使用AutoService库生成service文件" class="headerlink" title="使用AutoService库生成service文件"></a>使用AutoService库生成service文件</h3><p>原理：通过APT解析<code>@AutoSerivce</code>自动生成文件。</p>
<ol>
<li>添加依赖包和对应的注解处理器</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&quot;com.google.auto.service:auto-service-annotations:1.0&quot;</span> <span class="comment">//添加注解依赖包</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;com.google.auto.service:auto-service:1.0&quot;</span> <span class="comment">//添加注解处理器，使用compileOnly可以下载AutoService源码查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>@AutoService(Processor.class)</code>，即可自动生成SPI文件，如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Google提供的@AutoService注解</span></span><br><span class="line"><span class="comment">//自动生成/META_INF/services/javax.annotation.processing.Processor文件，并打包进jar包中</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【踩坑】：低版本<code>gradle</code>直接<code>compileOnly</code>依赖即可，会自动应用<code>annotationProcessor</code>，高版本<code>gradle</code>需要单独使用<code>annotationProcessor</code>配置注解处理器。</strong></p>
<h2 id="增量注解处理器"><a href="#增量注解处理器" class="headerlink" title="增量注解处理器"></a>增量注解处理器</h2><p>具体可以参考<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_compile">官方文档</a>、<a href="https://blog.csdn.net/qfanmingyiq/article/details/116300913">Gradle编译时注解增量教程</a></p>
<ul>
<li>全量编译：改动一个注解会删除之前已经生成过的文件，再重新生成新的文件，效率较低。</li>
<li>增量注解：从<code>Gradle 4.7</code>开始,<code>gradle</code>提供了增量<code>apt</code>,可以使上层开发者更快的编译。</li>
</ul>
<h3 id="增量注解处理器类型"><a href="#增量注解处理器类型" class="headerlink" title="增量注解处理器类型"></a>增量注解处理器类型</h3><ol>
<li>isolating注解处理器：最快的增量注解处理器。一个注解处理器只处理一个注解</li>
<li>aggregationg注解处理器：可以处理多个注解。注解的Retention必须是<code>CLASS</code> or <code>RUNTIME</code></li>
<li>dynamic注解处理器：重写<code>AbstractProcessor.getSupportedOptions</code>函数，在执行APT的时候根据自身情况决定使用哪一种增量注解处理器类型</li>
</ol>
<p>配置方式如下：</p>
<h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><p>新建<code>resources/META-INF/gradle/incremental.annotation.processors</code>文件，在文件中写入注解处理器全称和增量注解处理器类型。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.afauria.sample.apt_processor.AptProcessor,DYNAMIC</span><br></pre></td></tr></table></figure>

<h3 id="使用incap-processor自动生成"><a href="#使用incap-processor自动生成" class="headerlink" title="使用incap-processor自动生成"></a>使用<code>incap-processor</code>自动生成</h3><p>原理：通过APT解析<code>@IncrementalAnnotationProcessor</code>自动生成文件，类似<code>AutoService</code>库。</p>
<ol>
<li>添加依赖包和对应的注解处理器</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&quot;net.ltgt.gradle.incap:incap:0.2&quot;</span> <span class="comment">//添加依赖包</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;net.ltgt.gradle.incap:incap-processor:0.2&quot;</span> <span class="comment">//添加注解处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>@IncrementalAnnotationProcessor</code>注解配置增量类型，如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.DYNAMIC)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用注解处理器"><a href="#应用注解处理器" class="headerlink" title="应用注解处理器"></a>应用注解处理器</h2><p>定义好注解处理器之后，如何使用呢？</p>
<ol>
<li>Gradle2.2之前，需要先依赖三方插件<code>apply plugin: &#39;com.neenbedankt.android-apt&#39;</code>，在<code>dependencies</code>中添加<code>apt project(&#39;:xxx-processor&#39;)</code></li>
<li>Gradle2.2之后，Gradle内置了了APT工具，直接在dependencies中添加<code>annotationProcessor project(&#39;:xxx-processor&#39;)</code></li>
<li>kotlin中先依赖插件<code>apply plugin: &#39;kotlin-kapt&#39;</code>，dependencies中添加<code>kapt project(&#39;:xxx-processor&#39;)</code></li>
</ol>
<h1 id="自定义APT步骤"><a href="#自定义APT步骤" class="headerlink" title="自定义APT步骤"></a>自定义APT步骤</h1><p>上面介绍了APT涉及到的知识点，比较零散，简单串联一下整个过程：</p>
<ol>
<li>创建一个<strong>Java Module</strong>，用于定义注解，如<code>xxx-annotation</code></li>
<li>创建一个<strong>Android Module</strong>，用于封装API接口，供使用者调用，如<code>xxx-library</code>，依赖<code>xxx-annotation</code></li>
<li>编写注解处理器代码<ol>
<li>创建一个<strong>Java Module</strong>：如<code>xxx-processor</code>、<code>xxx-compiler</code>，依赖<code>xxx-annotation</code></li>
<li>定义<code>XXProcessor</code>类，继承自<code>AbstractProcessor</code></li>
<li>重写<code>getSupportedAnnotationTypes</code>方法，返回要被检测的注解</li>
<li>重写<code>process</code>方法解析注解，生成对应的文件，有几种方式：<ol>
<li>手动拼接源代码</li>
<li>定义模版java文件，通过关键字匹配替换</li>
<li>使用JavaPoet，调用JavaAPI生成，可以自动缩进、导入import包，不容易出错</li>
</ol>
</li>
</ol>
</li>
<li>注册注解处理器：JavaSPI机制</li>
<li>注册增量注解处理器类型</li>
<li>应用注解处理器：<code>annotationProcessor &quot;xxx-processor&quot;</code></li>
<li>使用者依赖<code>xxx-library</code></li>
<li>源代码中使用注解</li>
<li>编译时扫描注解，生成代理类</li>
<li>调用生成的代理类方法，或者通过<code>xxx-library</code>中的门面对象，反射找到代理类并执行。</li>
</ol>
<p>流程图就不画了，可以参考<a href="/2021/12/09/android-2021-12-09-ButterKnife/#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">ButterKnife解析</a></p>
<p>为什么需要分三个module？</p>
<blockquote>
<p><code>xxx-processor</code>只有编译时会用到，打包的时候不需要依赖，使用<code>compileOnly</code>即可，因此和<code>xxx-library</code>分开。</p>
<p><code>xxx-annotation</code>会被其他两个模块使用，因此单独抽一个module处理</p>
<p><code>xxx-library</code>：主要封装API供外部调用。也可以不定义该模块，使用自定义注解+注解处理器，生成代理类之后，直接调用代理类方法</p>
</blockquote>
<h1 id="自定义APT示例"><a href="#自定义APT示例" class="headerlink" title="自定义APT示例"></a>自定义APT示例</h1><p>代码上传至<a href="https://github.com/Afauria/AOPSample">仓库</a></p>
<h2 id="确认目标功能和生成的类信息"><a href="#确认目标功能和生成的类信息" class="headerlink" title="确认目标功能和生成的类信息"></a>确认目标功能和生成的类信息</h2><p>先确认下我们的目标功能，调用方代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用@AptBindRes找到资源，使用@AptBindView找到View，使用AptOnClick设置点击事件监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AptActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AptBindRes(R.string.app_name)</span></span><br><span class="line">    String text1;</span><br><span class="line">    <span class="meta">@AptBindView(R.id.aptBtn1)</span></span><br><span class="line">    Button btn1;</span><br><span class="line">    <span class="meta">@AptOnClick</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onBtn1Click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;AptActivity&quot;</span>, <span class="string">&quot;onBtn1Click: &quot;</span> + text1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_apt);</span><br><span class="line">        <span class="comment">//方式一：调用生成的类完成视图绑定、资源查找、事件绑定等功能</span></span><br><span class="line">        <span class="keyword">new</span> AptActivity_ViewBinding(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//方式二：封装API接口，供调用方使用</span></span><br><span class="line">        <span class="comment">//AptBinder.bind(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>AptActivity</code>为例，需要生成的类如下：APT的作用就是帮我们自动生成<code>XXX_ViewBinding</code>类，免去手写的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AptActivity_ViewBinding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AptActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> AptActivity target)</span> </span>&#123;</span><br><span class="line">        target.text1 = target.getString(R.string.app_name);</span><br><span class="line">        target.btn1 = target.findViewById(R.id.aptBtn1);</span><br><span class="line">        <span class="comment">//target.btn1.setOnClickListener，这个地方想拿到变量设置监听器较麻烦，因此直接再find一次View</span></span><br><span class="line">        target.findViewById(R.id.aptBtn1).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                target.onBtn1Click();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><ol>
<li>首先创建<code>java-library</code>，名为<code>apt-annotation</code>，用于自定义注解<code>@AptBindRes、@AptBindView、@AptOnClick</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源绑定注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AptBindString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//视图绑定注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AptBindView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件绑定注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AptOnClick &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建<code>java-library</code>，名为<code>apt-processor</code>，用于自定义注解处理器<code>AptProcessor</code>。配置依赖如下</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">&quot;:apt-annotation&quot;</span>)	<span class="comment">//依赖自定义注解包</span></span><br><span class="line">    compileOnly <span class="string">&quot;com.squareup:javapoet:1.12.1&quot;</span>	<span class="comment">//使用JavaAPI方式生成Java代码</span></span><br><span class="line">    compileOnly <span class="string">&quot;com.google.auto.service:auto-service-annotations:1.0&quot;</span>	<span class="comment">//配置服务接口实现类</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;com.google.auto.service:auto-service:1.0&quot;</span>	<span class="comment">//生成SPI服务接口文件</span></span><br><span class="line">    compileOnly <span class="string">&quot;net.ltgt.gradle.incap:incap:0.2&quot;</span>	<span class="comment">//配置增量注解处理器类型</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;net.ltgt.gradle.incap:incap-processor:0.2&quot;</span>	<span class="comment">//生成增量注解处理器类型文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自定义注解处理器：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 配置`@AutoService`自动生成服务接口配置文件</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="comment">//2. 配置`@IncrementalAnnotationProcessor`自动生成增量编译配置文件</span></span><br><span class="line"><span class="meta">@IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.DYNAMIC)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Filer mFiler;</span><br><span class="line">    <span class="keyword">private</span> Messager mMessager;</span><br><span class="line">    <span class="keyword">private</span> Elements mElements;</span><br><span class="line">    <span class="comment">//3. 初始化辅助类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line">        mFiler = processingEnvironment.getFiler();</span><br><span class="line">        mMessager = processingEnvironment.getMessager();</span><br><span class="line">        mElements = processingEnvironment.getElementUtils();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 返回需要处理的自定义注解类型名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        types.add(AptBindView.class.getCanonicalName());</span><br><span class="line">        types.add(AptBindString.class.getCanonicalName());</span><br><span class="line">        types.add(AptOnClick.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> types;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//5. 封装一个error类方便打印错误信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(Element element, String msg)</span> </span>&#123;</span><br><span class="line">        mMessager.printMessage(Diagnostic.Kind.ERROR, msg, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>定义一个<code>builderMap</code>，用于保存需要生成的类的信息，并拼接Java源代码。每解析一个元素，放到对应的类信息中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按类生成文件，一个类可能包含多个注解，因此新建一个Map，保存类和对应的类信息</span></span><br><span class="line"><span class="comment">//生成类需要的信息包括：包名、类名、资源绑定、视图绑定、事件绑定等信息</span></span><br><span class="line"><span class="comment">//定义一个FileBuilder类保存，等到所有注解解析完毕之后，再统一生成文件</span></span><br><span class="line">Map&lt;TypeElement, FileBuilder&gt; builderMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//获取缓存的类信息，如果没有则新建</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FileBuilder <span class="title">getOrCreateBuilder</span><span class="params">(TypeElement element)</span> </span>&#123;</span><br><span class="line">    FileBuilder builder = builderMap.get(element);</span><br><span class="line">    <span class="keyword">if</span> (builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder = <span class="keyword">new</span> FileBuilder(element);</span><br><span class="line">        builderMap.put(element, builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略getter、setter、add代码，直接操作成员变量</span></span><br><span class="line">    TypeElement mTypeElement;</span><br><span class="line">    String mPackageName;</span><br><span class="line">    String mClassName;</span><br><span class="line">    <span class="comment">//保存资源绑定的信息：如变量名、资源id</span></span><br><span class="line">    List&lt;BindResourceInfo&gt; mBindingResources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存视图绑定的信息：如变量名，viewId</span></span><br><span class="line">    List&lt;BindViewInfo&gt; mBindingViews = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存事件绑定的信息：如方法名，viewId</span></span><br><span class="line">    List&lt;BindMethodInfo&gt; mBindingMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileBuilder</span><span class="params">(TypeElement typeElement, Elements elementsUtil)</span> </span>&#123;</span><br><span class="line">        mTypeElement = typeElement;</span><br><span class="line">        mPackageName = elementsUtil.getPackageOf(typeElement).toString();</span><br><span class="line">        mClassName = typeElement.getSimpleName() + <span class="string">&quot;_ViewBinding&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拼接Java类代码</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> String <span class="title">generateJavaCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//添加包名</span></span><br><span class="line">        sb.append(<span class="string">&quot;package &quot;</span>).append(mPackageName).append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\nimport android.view.View;\n&quot;</span>);</span><br><span class="line">        <span class="comment">//添加类定义</span></span><br><span class="line">        sb.append(<span class="string">&quot;\npublic class &quot;</span>).append(mClassName).append(<span class="string">&quot; &#123;\n&quot;</span>);</span><br><span class="line">        <span class="comment">//添加构造方法</span></span><br><span class="line">        sb.append(<span class="string">&quot;\tpublic &quot;</span>).append(mClassName).append(<span class="string">&quot;(final &quot;</span>).append(mTypeElement.getSimpleName()).append(<span class="string">&quot; target) &#123;\n&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历添加资源绑定代码</span></span><br><span class="line">        <span class="keyword">for</span> (BindResourceInfo bindResourceInfo : mBindingResources) &#123;</span><br><span class="line">            sb.append(bindResourceInfo.bindResourceCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历添加视图绑定代码</span></span><br><span class="line">        <span class="keyword">for</span> (BindViewInfo bindViewInfo : mBindingViews) &#123;</span><br><span class="line">            sb.append(bindViewInfo.bindViewCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历添加事件绑定代码</span></span><br><span class="line">        <span class="keyword">for</span> (BindMethodInfo bindMethodInfo : mBindingMethods) &#123;</span><br><span class="line">            sb.append(bindMethodInfo.bindMethodCode());</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;\t&#125;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin可以直接使用data class，java代码确实有点长</span></span><br><span class="line"><span class="comment">//省略构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindResourceInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resId;</span><br><span class="line">    String fieldName;</span><br><span class="line">    <span class="comment">//拼接资源绑定的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bindResourceCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;\t\ttarget.%s = target.getString(%s);\n&quot;</span>, fieldName, resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindViewInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resId;</span><br><span class="line">    String fieldName;</span><br><span class="line">    <span class="comment">//拼接视图绑定的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bindViewCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;\t\ttarget.%s = target.findViewById(%s);\n&quot;</span>, fieldName, resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindMethodInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resId;</span><br><span class="line">    String methodName;</span><br><span class="line">    <span class="comment">//拼接设置监听器的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bindMethodCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;\t\ttarget.findViewById(&quot;</span>).append(resId).append(<span class="string">&quot;).setOnClickListener(new View.OnClickListener() &#123;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t\t\tpublic void onClick(View view) &#123;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t\t\t\ttarget.&quot;</span>).append(methodName).append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t\t\t&#125;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t\t&#125;);\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重写<code>process</code>方法，解析和处理注解，将需要的信息填入<code>Builder</code>中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每次执行清空下buildMap，避免下个round重复创建文件</span></span><br><span class="line">    builderMap.clear();</span><br><span class="line">    <span class="keyword">if</span> (set.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析@AptBindString注解，并加入到对应的FileBuilder中</span></span><br><span class="line">    findAndParseBindingResources(roundEnvironment);</span><br><span class="line">    <span class="comment">//解析@AptBindView注解，并加入到对应的FileBuilder中</span></span><br><span class="line">    findAndParseBindingView(roundEnvironment);</span><br><span class="line">    <span class="comment">//解析@AptOnClick注解，并加入到对应的FileBuilder中</span></span><br><span class="line">    findAndParseBindingMethod(roundEnvironment);</span><br><span class="line">    <span class="keyword">for</span> (FileBuilder fileBuilder : builderMap.values()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//方式一：使用拼接源代码方式生成Java文件</span></span><br><span class="line">            generateJavaFile(fileBuilder);</span><br><span class="line">            <span class="comment">//方式二：使用JavaPoet生成Java文件</span></span><br><span class="line">            <span class="comment">//fileBuilder.generateJavaFileByPoet().writeTo(mFiler);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//使用Messager打印日志，打印error并不会中断process执行，但是会导致编译失败</span></span><br><span class="line">            error(fileBuilder.mTypeElement, String.format(<span class="string">&quot;Unable to write ViewBinding for type %s: %s&quot;</span>, fileBuilder.mTypeElement, e.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateJavaFile</span><span class="params">(FileBuilder fileBuilder)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建Java源文件对象，完整类名</span></span><br><span class="line">    JavaFileObject javaFileObject = mFiler.createSourceFile(fileBuilder.mPackageName + <span class="string">&quot;.&quot;</span> + fileBuilder.mClassName);</span><br><span class="line">    <span class="comment">//根据存储的信息拼接Java代码</span></span><br><span class="line">    String code = fileBuilder.generateJavaCode();</span><br><span class="line">    Writer writer = javaFileObject.openWriter();</span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    writer.write(code);</span><br><span class="line">    writer.flush();</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>贴一下解析<code>@AptBindString</code>的代码，视图绑定和事件绑定类似</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAndParseBindingResources</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取所有被@BindString注解的元素</span></span><br><span class="line">    Set&lt;? extends Element&gt; s = env.getElementsAnnotatedWith(AptBindString.class);</span><br><span class="line">    <span class="keyword">for</span> (Element element : s) &#123;</span><br><span class="line">        <span class="comment">//获取注解的值</span></span><br><span class="line">        <span class="keyword">int</span> resId = element.getAnnotation(AptBindString.class).value();</span><br><span class="line">        <span class="comment">//获取Field变量名称</span></span><br><span class="line">        <span class="keyword">final</span> String name = element.getSimpleName().toString();</span><br><span class="line">        <span class="comment">//获取父元素</span></span><br><span class="line">        TypeElement parentElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line">        <span class="comment">//获取缓存的生成类信息</span></span><br><span class="line">        FileBuilder builder = getOrCreateBuilder(parentElement);</span><br><span class="line">        <span class="comment">//构造资源绑定信息，加入对应的FileBuilder中</span></span><br><span class="line">        builder.mBindingResources.add(<span class="keyword">new</span> BindResourceInfo(resId, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用JavaPoet"><a href="#使用JavaPoet" class="headerlink" title="使用JavaPoet"></a>使用JavaPoet</h2><p>第4步拼接Java源代码也可以通过调用JavaPoet API来生成，上面<code>build.gradle</code>已经添加依赖包。最终生成的结果就不贴了，和上面目标一致。</p>
<p>直接贴代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JavaFile <span class="title">generateJavaFileByPoet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义构造方法</span></span><br><span class="line">    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            .addParameter(TypeName.get(mTypeElement.asType()), <span class="string">&quot;target&quot;</span>, Modifier.FINAL);</span><br><span class="line">    <span class="comment">//遍历添加资源绑定代码</span></span><br><span class="line">    <span class="keyword">for</span> (BindResourceInfo bindResourceInfo : mBindingResources) &#123;</span><br><span class="line">        constructor.addCode(bindResourceInfo.bindResourceCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历添加视图绑定代码</span></span><br><span class="line">    <span class="keyword">for</span> (BindViewInfo bindViewInfo : mBindingViews) &#123;</span><br><span class="line">        constructor.addCode(bindViewInfo.bindViewCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历添加事件绑定代码</span></span><br><span class="line">    <span class="keyword">for</span> (BindMethodInfo bindMethodInfo : mBindingMethods) &#123;</span><br><span class="line">        <span class="comment">//创建OnClickListener匿名内部类</span></span><br><span class="line">        TypeSpec listener = TypeSpec.anonymousClassBuilder(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .addSuperinterface(ClassName.get(<span class="string">&quot;android.view&quot;</span>, <span class="string">&quot;View&quot;</span>, <span class="string">&quot;OnClickListener&quot;</span>))</span><br><span class="line">                .addMethod(MethodSpec.methodBuilder(<span class="string">&quot;onClick&quot;</span>)</span><br><span class="line">                        .addAnnotation(Override.class)</span><br><span class="line">                        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                        .returns(TypeName.VOID)</span><br><span class="line">                        .addParameter(ClassName.get(<span class="string">&quot;android.view&quot;</span>, <span class="string">&quot;View&quot;</span>), <span class="string">&quot;view&quot;</span>)</span><br><span class="line">                        .addStatement(<span class="string">&quot;target.$N()&quot;</span>, bindMethodInfo.methodName)</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//添加监听器</span></span><br><span class="line">        constructor.addStatement(<span class="string">&quot;target.findViewById($L).setOnClickListener($L)&quot;</span>, bindMethodInfo.resId, listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义类</span></span><br><span class="line">    TypeSpec typeSpec = TypeSpec</span><br><span class="line">            .classBuilder(mClassName)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            .addMethod(constructor.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//生成java文件对象</span></span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(mPackageName, typeSpec).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消第5步方式二的注释，使用JavaPoet生成文件</span></span><br><span class="line"><span class="comment">//fileBuilder.generateJavaFileByPoet().writeTo(mFiler);</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li><code>addStatement</code>会添加缩进、换行、分号结尾。<code>addCode</code>直接添加代码，不会添加缩进、换行、分号结尾</li>
<li>JavaPoet提供了一些字符串format的占位符，就是代码中的<code>$L、$N</code>等，可以查看<code>CodeBlock</code>类中的注释说明。列举几个常用的<ol>
<li><code>$L</code>：表示字面量，可以是字符串、基础数据类型、代码块等。</li>
<li><code>$N</code>：表示名称，如参数名、字段名、局部变量名、方法名等</li>
<li><code>$T</code>：表示类型，强转或者调用类静态方法、静态属性的时候会用到</li>
<li><code>$[</code>：开始一个语句，会自动添加缩进</li>
<li><code>$]</code>：结束一个语句</li>
</ol>
</li>
</ol>
<blockquote>
<p>Tips：<strong>字面量</strong>就是指这个量本身，如<code>String name = &quot;Hello World&quot;;</code>中，<code> &quot;Hello World&quot;</code>就是字面量（含引号）。</p>
<p>可以简单理解为就是<code>=</code>号右边的部分</p>
</blockquote>
<p>更多JavaPoet API可以参考<a href="https://github.com/square/javapoet">官方文档</a></p>
<h2 id="封装API接口"><a href="#封装API接口" class="headerlink" title="封装API接口"></a>封装API接口</h2><p>上面客户端是直接使用生成的代理类<code>new AptActivity_ViewBinding(this);</code>。这么写有几个不足：</p>
<ol>
<li>需要在build完之后才有代理类，没build之前代码会报红</li>
<li>不同类写法不一致，不好封装基类</li>
</ol>
<p>因此我们封装一个API接口类，让客户端能够更方便的调用。</p>
<ol>
<li>首先新建一个<code>Android Module</code>，如<code>apt-library</code>，并依赖自定义注解库<code>apt-annotation</code></li>
<li>直接贴代码，看注释即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AptBinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定Activity</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = activity.getClass();</span><br><span class="line">        <span class="comment">//找到类名：由于library中无法拿到生成的类，因此需要使用反射来动态加载类</span></span><br><span class="line">        String clsName = activity.getClass().getName() + <span class="string">&quot;_ViewBinding&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射加载类</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(clsName);</span><br><span class="line">            <span class="comment">//反射获取构造函数，并实例化。</span></span><br><span class="line">            <span class="comment">//可以缓存构造函数，避免重复反射</span></span><br><span class="line">            clazz.getConstructor(cls).newInstance(activity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>客户端依赖<code>apt-library</code>，<code>Activity</code>中调用<code>AptBinder.bind(this)</code>完成绑定</li>
</ol>
<h2 id="可优化"><a href="#可优化" class="headerlink" title="可优化"></a>可优化</h2><p>实现的是简化版的自定义注解处理器，有很多可优化的点：</p>
<ol>
<li>考虑注解不在Activity中（如Fragment、View、Adapter或者普通类中），如何获取资源、绑定视图：需要往生成类中传入context或者view。</li>
<li>添加校验：注解对象或方法非private或static，注解对象父元素<code>TypeElement</code>不能是接口或枚举类等</li>
<li>生成释放对象的代码，<code>unbind</code>方法</li>
<li><code>@OnClick</code>注解绑定多个View解析：注解参数需要使用id数组</li>
<li>监听器回调方法有参数的时候，如何获取并生成？</li>
<li>父类和子类都有注解，如何兼容？</li>
<li>资源id非final类型，如何处理？</li>
<li>在内部类中使用注解，如何处理？</li>
<li>更多资源注解，更多事件注解，如何保存builder类信息，减少重复代码？</li>
<li>增量编译这里没有实际用到</li>
<li>…</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>代码均上传至<a href="https://github.com/Afauria/AOPSample">仓库</a></p>
<p>参考资料：</p>
<ul>
<li><a href="https://fanmingyi.blog.csdn.net/article/details/113766921">Java Pluginable Annotation processing</a></li>
<li><a href="https://fanmingyi.blog.csdn.net/article/details/116274271">注解处理器常用类说明</a></li>
<li><a href="https://blog.csdn.net/qfanmingyiq/article/details/116300913">Gradle编译时注解增量教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI和API</title>
    <url>/2021/12/06/architecture-2021-12-06-SPI/</url>
    <content><![CDATA[<h1 id="SPI和API"><a href="#SPI和API" class="headerlink" title="SPI和API"></a>SPI和API</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>面向的对象的设计里，提倡模块之间<strong>基于接口编程</strong>。调用方、接口、实现方关系如下</p>
<p><img src="/2021/12/06/architecture-2021-12-06-SPI/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B.png"></p>
<p>这个时候接口应该在哪定义呢？有三种情况：</p>
<ol>
<li>接口位于实现方所在的包中：称为API（Application Programming Interface，应用程序接口）。<ol>
<li>调用方直接依赖三方库</li>
<li>从名字上理解，API是给客户端调用的接口</li>
<li>从时间上讲，先有实现方和接口，再有调用方，实现方较固定，调用方可变。</li>
<li>常用于SDK开发，接口由三方库开发者提供，并可能提供了多种实现，调用方只负责使用。（如果调用方能够自己实现功能，何必再使用三方库呢？）</li>
<li>当然有些框架也会提供SPI接口，调用方有需求的时候也可以自己实现，替换SDK中的实现，如自定义GlideModule。</li>
</ol>
</li>
<li>接口位于调用方所在的包中：称为SPI（Service Provider Interface，服务提供接口）<ol>
<li>插件依赖调用方接口</li>
<li>从名字上理解，SPI服务接口是给服务端实现的接口</li>
<li>从时间上讲，先有调用方和接口，再有具体的实现方，实现方可变，调用方较固定</li>
<li>常用于插件开发，调用方先定义好接口，并写好调用逻辑，由插件实现接口。如自定义注解处理器、插件换肤。</li>
</ol>
</li>
<li>接口位于独立的包中：接口既可以作为API，也可以作为SPI<ol>
<li>在Clean或DDD架构中，业务层对外层提供接口，被表现层或应用层调用（API），同时外层需要实现业务层提供的接口（SPI），被业务驱动。</li>
</ol>
</li>
</ol>
<p><strong>注：</strong></p>
<ol>
<li>不管是SPI或API，接口都可以组织到独立的包中，真正的区别是由调用方提供还是由实现方提供。</li>
<li>SPI和API本质上是一个谁迁就谁的问题：<ol>
<li>使用API，对调用方来说，不同的实现方API接口可能不一致，代码中需要写条件分支判断。（例如代码中同时用了ImageLoader和Glide来加载图片）</li>
<li>使用SPI，就是由调用方来决定接口行为，不同的实现方都需要遵循这个接口定义。</li>
</ol>
</li>
<li>广义上讲API是<strong>一种提供给外部调用自身的方式</strong>，不单指Java语言中的接口，例如我们常说的Restful API，实际上是网络请求的url</li>
<li>广义上讲SPI是<strong>一种让外部能够按照自己定制的规则实现功能的方式</strong>，不单指Java语言中的接口</li>
</ol>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>在SPI的情况下，插件需要依赖调用方，调用方也需要依赖插件具体实现。是否会产生依赖冲突呢，三者的依赖关系应该是怎么样的？</p>
<blockquote>
<p>从编码上讲会存在依赖冲突，当然这个时候调用方不一定是直接依赖插件，也可以通过动态加载，如自定义ClassLoader、动态链接库等。</p>
</blockquote>
<h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p>抛开依赖冲突的问题，如果接口定义在调用方的包中，插件依赖的时候会把调用方的逻辑也依赖进来，而插件只是负责实现接口而已，这是否有必要呢？</p>
<blockquote>
<p>有一个原则可以回答这个问题</p>
<p>依赖倒置：高层模块不依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖具体，具体应该依赖抽象</p>
<p>实际上就是说把接口（抽象层）抽出来，调用方和实现方都依赖接口，也就是上面的第3种情况。</p>
</blockquote>
<h2 id="服务发现机制"><a href="#服务发现机制" class="headerlink" title="服务发现机制"></a>服务发现机制</h2><p>SPI中调用方提供接口，调用方直接实例化对象，存在问题：</p>
<ol>
<li>调用方先定义好接口，无法写逻辑，需要等到实现方实现接口之后再来添加逻辑。（当然也可以先定义一个默认的Fake实现类）</li>
<li>如果要替换一种实现，需要修改调用方的代码，不符合可插拔的原则</li>
</ol>
<p>为了解决上面的问题，让调用方不需要指定具体模块，需要一种服务注册和发现的机制：服务端注册了服务之后，客户端可以找到对应的服务。</p>
<p><img src="/2021/12/06/architecture-2021-12-06-SPI/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6.png"></p>
<p>服务发现是IoC（Inversion of Control，控制反转）思想的一种实现，将初始化实例的控制权移到了程序之外。</p>
<blockquote>
<p>Tips：IoC主要有两种实现：</p>
<ul>
<li>服务提供模式：从外部服务容器抓取依赖对象</li>
<li>依赖注入：以参数的形式注入依赖对象</li>
</ul>
</blockquote>
<p>控制反转（或服务发现）有以下优势：</p>
<ul>
<li>在外部注入或配置依赖项，因此我们可以重用这些组件。当我们需要修改依赖项的实现时，只需要修改配置文件；</li>
<li>可以配置依赖项的模拟实现（Fake），让代码测试更加容易。</li>
</ul>
<h1 id="Java-SPI机制"><a href="#Java-SPI机制" class="headerlink" title="Java SPI机制"></a>Java SPI机制</h1><p>JDK6中引入了ServiceLoader，通过配置文件来装载指定的服务。也叫做Java SPI机制（<strong>这里要和上文所说的SPI接口区分开来</strong>）</p>
<p><code>ServiceLoader</code>是Java提供的一种SPI机制，但服务发现机制不是Java特有的</p>
<p>类似地，在Android中，通过Manifest注册组件，让Launcher能够找到应用程序的入口，或者让AMS能够启动应用内的Activity、Service，发送广播等</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol>
<li>客户端定义服务接口</li>
<li>服务端实现该接口</li>
<li>服务端在<code>META-INF/services</code>目录下新建一个以服务接口命名的文件，文件内填入该服务接口的具体实现类（完整类名，可以填多个）</li>
<li>客户端使用<code>ServiceLoader</code>加载配置文件中的具体实现类并返回实例化对象。存在多个实现类，通过迭代器<code>iterator</code>访问</li>
</ol>
<blockquote>
<p>Tips：这里客户端指接口调用方，服务端指接口实现方</p>
</blockquote>
<p>第4步除了使用<code>ServiceLoader</code>去加载配置文件外，我们也可以自己读取文件，通过<strong>反射创建实例</strong>。实际上<code>ServiceLoader</code>正是帮我们做了这件事</p>
<p>第3步除了手动创建之外，还可以使用<code>AutoService</code>库帮我们自动生成文件：通过APT解析<code>@AutoSerivce</code>自动生成文件。</p>
<ol>
<li>添加依赖包和对应的注解处理器</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&quot;com.google.auto.service:auto-service-annotations:1.0&quot;</span> <span class="comment">//添加注解依赖包</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;com.google.auto.service:auto-service:1.0&quot;</span> <span class="comment">//添加注解处理器，使用compileOnly可以下载AutoService源码查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>@AutoService(Processor.class)</code>，即可自动生成SPI文件，如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Google提供的@AutoService注解</span></span><br><span class="line"><span class="comment">//自动生成/META_INF/services/javax.annotation.processing.Processor文件，并打包进jar包中</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>首先看<code>Service.load</code>源码，返回<code>ServiceLoader</code>对象：可以看到这个时候还没加载实现类，一个服务接口对应一个<code>ServiceLoader</code>实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ServiceLoader类</span></span><br><span class="line"><span class="comment">//方法1：使用 SystemClassLoader 类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">loadInstalled</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">    ClassLoader prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = cl;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, prev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法2：使用线程上下文类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法3：自定义类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ServiceLoader构造函数：保存<strong>服务接口的类对象</strong>，并创建了一个<code>LazyIterator</code>对象，迭代器中暂时只是保存了<code>service</code>类对象和类加载器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; var1, ClassLoader var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.service = (Class)Objects.requireNonNull(var1, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.loader = var2 == <span class="keyword">null</span> ? ClassLoader.getSystemClassLoader() : var2;</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() != <span class="keyword">null</span> ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.reload();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空服务Providers</span></span><br><span class="line">    <span class="keyword">this</span>.providers.clear();</span><br><span class="line">    <span class="comment">//创建懒加载迭代器</span></span><br><span class="line">    <span class="keyword">this</span>.lookupIterator = <span class="keyword">new</span> ServiceLoader.LazyIterator(<span class="keyword">this</span>.service, <span class="keyword">this</span>.loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>到这里还没开始加载具体的实现类，继续看迭代器中关键的<code>nextService</code>方法：可以看到使用<code>Class.fromName</code>反射加载了<code>nextName</code>类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasNextService()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String var1 = <span class="keyword">this</span>.nextName;</span><br><span class="line">        <span class="keyword">this</span>.nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class var2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射加载nextName类</span></span><br><span class="line">            var2 = Class.forName(var1, <span class="keyword">false</span>, <span class="keyword">this</span>.loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var5) &#123;</span><br><span class="line">            ServiceLoader.fail(<span class="keyword">this</span>.service, <span class="string">&quot;Provider &quot;</span> + var1 + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查注册的类是不是服务接口的实现类</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.service.isAssignableFrom(var2)) &#123;</span><br><span class="line">            ServiceLoader.fail(<span class="keyword">this</span>.service, <span class="string">&quot;Provider &quot;</span> + var1 + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化服务对象，并强制转换成服务接口。调用的是无参构造函数</span></span><br><span class="line">            Object var3 = <span class="keyword">this</span>.service.cast(var2.newInstance());</span><br><span class="line">            <span class="comment">//缓存接口实现类的实例</span></span><br><span class="line">            ServiceLoader.<span class="keyword">this</span>.providers.put(var1, var3);</span><br><span class="line">            <span class="keyword">return</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            ServiceLoader.fail(<span class="keyword">this</span>.service, <span class="string">&quot;Provider &quot;</span> + var1 + <span class="string">&quot; could not be instantiated&quot;</span>, var4);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>nextName</code>从哪来的呢，继续看<code>hasNextService</code>方法：可以看到读取了<code>META-INF/services/</code>下的服务配置文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//读取META-INF/services/下的服务配置文件</span></span><br><span class="line">                String var1 = <span class="string">&quot;META-INF/services/&quot;</span> + <span class="keyword">this</span>.service.getName();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.configs = ClassLoader.getSystemResources(var1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.configs = <span class="keyword">this</span>.loader.getResources(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">                ServiceLoader.fail(<span class="keyword">this</span>.service, <span class="string">&quot;Error locating configuration files&quot;</span>, var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.pending == <span class="keyword">null</span> || !<span class="keyword">this</span>.pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//parse中按行读取配置文件（utf-8编码），并排除已经加载过的服务，返回配置文件中的服务类型名列表</span></span><br><span class="line">            <span class="keyword">this</span>.pending = ServiceLoader.<span class="keyword">this</span>.parse(<span class="keyword">this</span>.service, (URL)<span class="keyword">this</span>.configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给nextName赋值为下一个类的类名</span></span><br><span class="line">        <span class="keyword">this</span>.nextName = (String)<span class="keyword">this</span>.pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>继续看<code>ServiceLoader</code>的<code>iterator</code>方法，对懒加载迭代器进行了包装，首先返回已经实例化过并缓存下来的服务对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;String, S&gt;&gt; knownProviders;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取缓存的providers列表</span></span><br><span class="line">            <span class="keyword">this</span>.knownProviders = ServiceLoader.<span class="keyword">this</span>.providers.entrySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.knownProviders.hasNext() ? <span class="keyword">true</span> : ServiceLoader.<span class="keyword">this</span>.lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//首先返回缓存的provider服务对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.knownProviders.hasNext() ? ((Entry)<span class="keyword">this</span>.knownProviders.next()).getValue() : ServiceLoader.<span class="keyword">this</span>.lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：<code>ServiceLoader</code>本质就是实现了一个迭代器，读取<code>META-INF/services</code>下的文件，通过ClassLoader加载文件中的接口实现类，放到懒加载迭代器中，访问的时候才加载类并实例化对象。</p>
<p>有几个注意的点：</p>
<ol>
<li>使用了懒加载创建服务实例</li>
<li>使用<code>LinkedHashMap</code>缓存创建过的provider实例</li>
<li>服务实现类必须实现服务接口：<code>if (!service.isAssignableFrom(c))</code>；</li>
<li>服务实现类需包含无参的构造器，LazyInterator 是反射创建服务对象的：<code>S p = service.cast(c.newInstance())</code>；</li>
<li>配置文件需要使用 UTF-8 编码：<code>parse</code>方法中<code>new BufferedReader(new InputStreamReader(in, &quot;utf-8&quot;))</code>。</li>
<li>存在多个实现类的时候，并不一定需要全部使用，只能迭代筛选合适的实现类，因此可以尽可能把常用的放到配置文件前面，避免加载不常用的类</li>
<li>服务无法注销remove，只能当没有引用时被GC回收，<code>ServiceLoader</code>提供了<code>reload</code>方法清除自身的缓存</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol>
<li>JDBC加载不同的数据库驱动，服务接口为<code>java.sql.Driver</code>，由不同的数据库驱动要实现该服务接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MySQL实现JDBC服务驱动接口，即Driver类</span></span><br><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将自身存入DriverManager</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DriverManager源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//初始化所有数据库驱动</span></span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//使用ServiceLoader加载驱动类</span></span><br><span class="line">    ServiceLoader var1 = ServiceLoader.load(Driver.class);</span><br><span class="line">    Iterator var2 = var1.iterator();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//参数：数据库连接url、账号、密码</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String var0, String var1, String var2)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取数据库Driver对象，调用connect连接并返回</span></span><br><span class="line">    Iterator var5 = registeredDrivers.iterator();</span><br><span class="line">    <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">      DriverInfo var6 = (DriverInfo)var5.next();</span><br><span class="line">      <span class="keyword">if</span> (isDriverAllowed(var6.driver, var3)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          println(<span class="string">&quot;    trying &quot;</span> + var6.driver.getClass().getName());</span><br><span class="line">          Connection var7 = var6.driver.connect(var0, var1);</span><br><span class="line">          <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;getConnection returning &quot;</span> + var6.driver.getClass().getName());</span><br><span class="line">            <span class="comment">//找到一个就返回</span></span><br><span class="line">            <span class="keyword">return</span> var7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到mysql的jdbc驱动包中确实存在服务配置文件</p>
<p><img src="/2021/12/06/architecture-2021-12-06-SPI/MySQL%E9%A9%B1%E5%8A%A8.png"></p>
<p><strong>如果三方数据库驱动没有配置服务文件（例如Oracle数据库），就需要我们自己通过<code>Class.forName</code>去加载驱动类了</strong></p>
<ol start="2">
<li>APT加载不同的注解处理器。服务接口为<code>javax.annotation.processing.Processor</code>，由不同的注解处理器实现该服务接口</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本来是打算介绍JavaSPI机制，放到Java分类下的。但是研究之后发现更应该归属到架构分类。</p>
<p>了解SPI和API区别，有助于我们更好的理解IoC、依赖倒置原则、DDD（Domain Driven Design,领域驱动设计）等。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html">设计原则：小议SPI和API</a></li>
<li><a href="https://www.jianshu.com/p/a18499b5df1c">「Java 路线」| 服务发现框架 ServiceLoader</a></li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>AspectJ介绍和示例</title>
    <url>/2021/12/02/tech-2021-12-02-AspectJ%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="AspectJ介绍"><a href="#AspectJ介绍" class="headerlink" title="AspectJ介绍"></a>AspectJ介绍</h1><p>介绍：一个字节码处理框架，实现AOP的工具。</p>
<p>原理：使用专门的编译器（ajc，可以执行ajc命令编译，也可以通过java执行）操作Class字节码，内部使用<a href="https://github.com/apache/commons-bcel">BCEL框架</a>。</p>
<p>由三部分组成：</p>
<ul>
<li><code>aspectjtools</code>：包含ajc编译器</li>
<li><code>aspectjweaver</code>：织入器，包含切点表达式处理，供ajc使用。并提供了javaagent用于类加载时期织入代码</li>
<li><code>aspectjrt</code>：包含@AspectJ注解</li>
</ul>
<p>三种织入时机（参考<a href="https://www.jianshu.com/p/3c5b09f6f563">AspectJ使用介绍</a>）：</p>
<ul>
<li>compile-time：编译期织入，处理Java源文件，使用ajc编译期替代javac编译器</li>
<li>post-compile：编译后织入，处理class字节码文件，如增强三方库中的方法</li>
<li>load-time：在 JVM 进行类加载的时候进行织入，使用wearver织入器</li>
</ul>
<p>特点：</p>
<ol>
<li>使用简单：不需要了解 .class 字节码文件格式 ，在目标位置插入或替换为自定义代码;</li>
<li>成熟稳定：直接修改字节码很容易出错，导致程序无法运行。AspectJ使用了专门的编译器，基本不需要考虑生成字节码正确性的问题。</li>
<li>不受访问限制：final、static、private都可以修改</li>
<li>切入点固定：AspectJ 只能在固定的几个切入点插入，如方法调用前、方法内部、异常前后、变量修改等；</li>
<li>匹配规则：AspectJ 的匹配规则类似于正则表达式；也可以结合注解匹配；</li>
<li>使用静态织入，<strong>无法织入Android SDK</strong>。如：需要先重写生命周期方法才能被织入。</li>
<li>重复织入：同样的方法，父类和子类都会织入，除非匹配具体类型。</li>
<li>性能较低：AspectJ 插入逻辑时，会添加一些冗余代码，如果<strong>大面积使用</strong>会影响性能；</li>
<li>增加编译时间：编译时需要扫描匹配规则，插入代码。——可以排除不需要扫描的包，匹配规则尽可能具体，减少匹配时间。配置只在debug/release环境生效</li>
<li>多个切点匹配到同一个方法，需要关注通知优先级。</li>
</ol>
<h1 id="AspectJ基本使用"><a href="#AspectJ基本使用" class="headerlink" title="AspectJ基本使用"></a>AspectJ基本使用</h1><p>具体语法可参考<a href="https://www.eclipse.org/aspectj/doc/released/progguide/starting.html">AspectJ官方文档</a>、<a href="https://www.eclipse.org/aspectj/doc/released/aspectj5rt-api/index.html">文档</a></p>
<p>两种用法：</p>
<ol>
<li>创建aj文件，使用AspectJ的语言（语法类似java，多了一些关键字）定义切点和通知（即切面），<strong>需要使用ajc进行编译</strong></li>
<li>使用纯Java语言开发，通过AspectJ进行注解，简称@AspectJ，<strong>也要通过ajc进行编译</strong></li>
</ol>
<p>从切点匹配角度看，有两种方式</p>
<ol>
<li>非侵入式：通过关键字匹配目标连接点<ol>
<li>不需要修改连接点代码</li>
<li>难以精确控制切入点</li>
<li>如果有10个方法，分别需要检查不同权限，我们需要定义10个切点和通知</li>
<li>如果方法名和路径变了，需要检查和修改切面</li>
</ol>
</li>
<li>侵入式：通过自定义注解找到目标连接点。<ol>
<li>需要在连接点处加入注解</li>
<li>不需要修改切面代码，即可修改切点。</li>
<li>如果运行时需要读取注解参数，则使用<code>RetentionPolicy.RUNTIME</code>，否则可以使用<code>RetentionPolicy.CLASS</code>。</li>
</ol>
</li>
</ol>
<h2 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h2><ol>
<li>*：匹配任何数量字符；</li>
<li>..：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包；而在方法参数模式中匹配任何数量参数。</li>
<li>+：匹配指定类型的子类型；仅能作为后缀放在类型模式后边。</li>
</ol>
<p>可以使用 且（&amp;&amp;）、或（||）、非（！）来组合切入点表达式。</p>
<p>切点定义有两种写法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法1：切点和Advice一起定义</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* *..*Activity.on*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforLifecycle</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法2：先定义切点，Advice关联切点，可以复用切点</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*Activity.on*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Before(&quot;onLifecycle&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforLifecycle</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接选择JoinPoint"><a href="#直接选择JoinPoint" class="headerlink" title="直接选择JoinPoint"></a>直接选择JoinPoint</h3><p>匹配方法Signature信息。切点和连接点对应选择条件如下</p>
<table>
<thead>
<tr>
<th>Joint Point</th>
<th>Pointcuts 表达式</th>
</tr>
</thead>
<tbody><tr>
<td>Method call</td>
<td>call(MethodSignature)</td>
</tr>
<tr>
<td>Method execution</td>
<td>execution(MethodSignature)</td>
</tr>
<tr>
<td>Constructor call</td>
<td>call(ConstructorSignature)</td>
</tr>
<tr>
<td>Constructor execution</td>
<td>execution(ConstructorSignature)</td>
</tr>
<tr>
<td>Class initialization</td>
<td>staticinitialization(TypeSignature)</td>
</tr>
<tr>
<td>Field get</td>
<td>get(FieldSignature)</td>
</tr>
<tr>
<td>Field set</td>
<td>set(FieldSignature)</td>
</tr>
<tr>
<td>Exception Handler，try-catch中的catch代码块</td>
<td>handler(TypeSignature)</td>
</tr>
<tr>
<td>Object initialization</td>
<td>initialization(ConstructorSignature)</td>
</tr>
<tr>
<td>Object pre-initialization</td>
<td>preinitialization(ConstructorSignature)</td>
</tr>
</tbody></table>
<p><code>![](2021-12-02-AspectJ介绍和示例/AspectJ切点类型.png)</code></p>
<h3 id="间接选择JoinPoint"><a href="#间接选择JoinPoint" class="headerlink" title="间接选择JoinPoint"></a>间接选择JoinPoint</h3><p>除了上面与 Join Point 对应的选择外，Pointcuts 还有其他选择方法。如选择某个类中所有的JPoint、某个方法执行过程中包含的JPoint、满足某些条件的JPoint等</p>
<table>
<thead>
<tr>
<th>Pointcuts 表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>within(TypePattern)</td>
<td>TypePattern标识类或者包，表示在某个包或者类中的所有JPoint</td>
</tr>
<tr>
<td>withincode(MethodPattern|ConstructorPattern)</td>
<td>在方法/构造方法执行过程中涉及到的JPoint</td>
</tr>
<tr>
<td>cflow(Pointcut)</td>
<td>call flow，调用切点方法时所包含的JPoint，包括切点本身</td>
</tr>
<tr>
<td>cflowbelow(Pointcut)</td>
<td>调用切点方法时所包含的JPoint，不包括切点本身</td>
</tr>
<tr>
<td>this(Type)</td>
<td>JPoint 所属的 this 对象是否是Type类型</td>
</tr>
<tr>
<td>target(Type)</td>
<td>JPoint 所在的对象（例如 call 或 execution 操作符应用的对象）是否是Type类型</td>
</tr>
<tr>
<td>args(Type, …)</td>
<td>JPoint方法或构造函数参数的类型</td>
</tr>
<tr>
<td>if(BooleanExpression)</td>
<td>满足表达式的 Join Point，表达式只能使用静态属性、Pointcuts 或 Advice 暴露的参数、thisJoinPoint 对象</td>
</tr>
</tbody></table>
<p><code>![](2021-12-02-AspectJ介绍和示例/间接选择JPoint.png)</code></p>
<h2 id="this和target区别"><a href="#this和target区别" class="headerlink" title="this和target区别"></a>this和target区别</h2><ul>
<li>this：指织入代码所属类的实例对象（织入代码的地方）</li>
<li>target：指切入点方法的所有者（方法定义的地方）</li>
</ul>
<blockquote>
<p>切点为call情况下，织入代码的地方（方法调用的地方）和方法的所有者（方法定义的地方）不一样</p>
<p>切点为execution的情况下，this=target</p>
</blockquote>
<h2 id="call和execution区别"><a href="#call和execution区别" class="headerlink" title="call和execution区别"></a>call和execution区别</h2><p><strong>可以反编译对比</strong></p>
<ul>
<li>call：代表调用方法的位置，插入在函数体外面。</li>
<li>execution：代表方法执行的位置，插入在函数体内部。</li>
</ul>
<h2 id="Before、After和Around区别"><a href="#Before、After和Around区别" class="headerlink" title="Before、After和Around区别"></a>Before、After和Around区别</h2><p><strong>可以反编译对比</strong></p>
<ol>
<li>Before和After通知：在匹配到的JoinPoint前后插入代码</li>
<li>Around通知：使用代理+闭包进行替换。将原方法体放到一个闭包（<code>AroundClosure</code>）中，通过调用<code>ProceedingJoinPoint.proceed</code>方法执行原逻辑。（可以调用set$AroundClosure替换闭包，即修改原逻辑）</li>
</ol>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ol>
<li>类加载时Hook</li>
<li>对项目中的三方库进行Hook</li>
<li>增加接口实现、添加成员变量等</li>
</ol>
<h1 id="Android中引入AspectJ"><a href="#Android中引入AspectJ" class="headerlink" title="Android中引入AspectJ"></a>Android中引入AspectJ</h1><p>大部分资料和框架（如Hugo、AspectJX等）都比较老，AspectJ可能不够主流，更多用在Spring中。因此可能存在版本兼容问题（如Gradle版本、JDK版本 Lambda、R8等）。</p>
<p><strong>AspectJ需要使用ajc编译器处理，因此要配置加入Android构建流程中</strong></p>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ol>
<li>根目录<code>build.gradle</code>添加AspectJ Gradle插件</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根目录build.gradle</span></span><br><span class="line">classpath <span class="string">&#x27;org.aspectj:aspectjtools:1.8.9&#x27;</span> <span class="comment">//包含ajc编译器</span></span><br><span class="line">classpath <span class="string">&#x27;org.aspectj:aspectjweaver:1.8.9&#x27;</span> <span class="comment">//包含切点表达式处理，供ajc使用。并提供了javaagent用于类加载时期织入代码</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>模块<code>build.gradle</code>添加ajc编译</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.bridge.IMessage</span><br><span class="line"><span class="keyword">import</span> org.aspectj.bridge.MessageHandler</span><br><span class="line"><span class="keyword">import</span> org.aspectj.tools.ajc.Main</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">def</span> log = project.logger</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">def</span> variants = project.android.applicationVariants</span><br><span class="line">variants.all &#123; variant -&gt;</span><br><span class="line">    <span class="keyword">if</span> (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Skipping non-debuggable build type &#x27;$&#123;variant.buildType.name&#125;&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    JavaCompile javaCompile = variant.javaCompileProvider.get()</span><br><span class="line">    javaCompile.doLast &#123;</span><br><span class="line">      <span class="comment">//在Java编译完之后执行</span></span><br><span class="line">				print(<span class="string">&quot;——————————ajc start——————————&quot;</span>)</span><br><span class="line">        String[] args = [<span class="string">&quot;-showWeaveInfo&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;-1.8&quot;</span>,<span class="comment">//注意版本保存一致</span></span><br><span class="line">                         <span class="string">&quot;-inpath&quot;</span>, javaCompile.destinationDir.toString(),</span><br><span class="line">                         <span class="string">&quot;-aspectpath&quot;</span>, javaCompile.classpath.asPath,</span><br><span class="line">                         <span class="string">&quot;-d&quot;</span>, javaCompile.destinationDir.toString(),</span><br><span class="line">                         <span class="string">&quot;-classpath&quot;</span>, javaCompile.classpath.asPath,</span><br><span class="line">                         <span class="string">&quot;-bootclasspath&quot;</span>, project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line">        log.debug <span class="string">&quot;ajc args: &quot;</span> + Arrays.toString(args)</span><br><span class="line"></span><br><span class="line">        MessageHandler handler = <span class="keyword">new</span> MessageHandler(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">new</span> Main().run(args, handler)</span><br><span class="line">        <span class="keyword">for</span> (IMessage <span class="attr">message :</span> handler.getMessages(<span class="literal">null</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (message.getKind()) &#123;</span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">ABORT:</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">ERROR:</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">FAIL:</span></span><br><span class="line">                    log.error message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">WARNING:</span></span><br><span class="line">                    log.warn message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">INFO:</span></span><br><span class="line">                    log.info message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">DEBUG:</span></span><br><span class="line">                    log.debug message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加@AspectJ依赖库：<code>implementation &#39;org.aspectj:aspectjrt:1.8.9&#39;</code>，包含@AspectJ注解</li>
<li>使用注解定义切面</li>
</ol>
<p><strong>可以查看AspectJ构建时的打印，会提示匹配规则语法错误，或者未匹配到切点等，用于排查错误</strong></p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>自定义Gradle插件，将ajc编译脚本进行封装，使用<code>apply plugin</code>即可插入构建流程</p>
<p>插件编写可以参考：</p>
<ul>
<li><a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx">沪江AspectJX</a>：支持扫描三方库jar、aar。</li>
<li><a href="https://github.com/JakeWharton/hugo">Hugo</a>：提供@DebugLog注解用于打印方法耗时等，可以配置只在Debug环境生效。不支持扫描三方库</li>
<li><a href="https://github.com/uPhyca/gradle-android-aspectj-plugin">Gradle-Android-AspectJ-Plugin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/67563228">AspectJ在Android中的应用</a></li>
</ul>
<p>基于AspectJ实现的框架：（可以参考AOP应用场景和实现）</p>
<ul>
<li><a href="https://github.com/fengzhizi715/SAF-AOP">SAF-AOP</a>：依赖沪江AspectJX。提供子线程切换，Log打印，方法Hook、捕获异常、追踪方法耗时、动态申请权限等功能</li>
</ul>
<h2 id="配置只在Debug环境生效"><a href="#配置只在Debug环境生效" class="headerlink" title="配置只在Debug环境生效"></a>配置只在Debug环境生效</h2><ul>
<li>如果是三方库，可以使用<code>debugImplementation</code>依赖</li>
<li>如果是自己写编译脚本，可以判断buildType，不执行ajc编译</li>
</ul>
<h1 id="AspectJ示例"><a href="#AspectJ示例" class="headerlink" title="AspectJ示例"></a>AspectJ示例</h1><p>只列出切面方法，测试代码均在<code>AspectJActivity</code>中。</p>
<p>代码已上传至<a href="https://github.com/Afauria/AOPSample">仓库</a></p>
<h2 id="打印生命周期"><a href="#打印生命周期" class="headerlink" title="打印生命周期"></a>打印生命周期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;LifecycleAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义切点：匹配Activity中on开头的方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* *..*Activity.on*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在切点之前执行</span></span><br><span class="line">    <span class="meta">@Before(&quot;onLifecycle()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforLifecycle</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<ol>
<li>由于AspectJ使用静态织入，无法检测到Android SDK中的方法，因此只会对Activity中重写的生命周期生效</li>
<li>on开头的不一定是生命周期方法</li>
<li>重复织入：如果定义BaseActivity并且继承的话，会打印两遍生命周期</li>
</ol>
<p>解决方法：</p>
<ol>
<li>定义BaseActivity，以 BaseActivity 作为切入点。如：<code>execution(* BaseActivity.on**(..))</code></li>
<li>通过Application.ActivityLifecycleCallbacks监听生命周期的变化。</li>
</ol>
<h2 id="对APP中所有方法进行Systrace函数插桩，用于分析性能"><a href="#对APP中所有方法进行Systrace函数插桩，用于分析性能" class="headerlink" title="对APP中所有方法进行Systrace函数插桩，用于分析性能"></a>对APP中所有方法进行Systrace函数插桩，用于分析性能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugTraceAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Around和Before、After匹配到同一个目标的时候，Around切点需要放到前面</span></span><br><span class="line">  	<span class="comment">//匹配所有方法</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* **(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTrace</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;beginTrace: &quot;</span> + <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        Trace.beginSection(joinPoint.getSignature().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* **(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTrace</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;endTrace: &quot;</span> + <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        Trace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监测和捕获异常"><a href="#监测和捕获异常" class="headerlink" title="监测和捕获异常"></a>监测和捕获异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;ExceptionAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原理：匹配代码中的try-catch块，且catch的类型要一样，否则无法匹配。</span></span><br><span class="line">  	<span class="comment">//比如切点表达式使用Exception，如果代码中catch的是NullPointerException，则无法匹配到。</span></span><br><span class="line">    <span class="comment">//或者使用通配符</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;handler(java.lang.*Exception) &amp;&amp; args(e)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(value = &quot;onException(e)&quot;, argNames = &quot;e&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExceptionBefore</span><span class="params">(JoinPoint joinPoint, Exception e)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;handleExceptionBefore: &quot;</span> + <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; &quot;</span> + e.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原理：在目标位置加try-catch，catch之后先执行方法，再throw抛异常。并不会阻止程序崩溃</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* *(..))&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Exception e)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;afterThrowing: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//如果要捕获异常，可以使用注解，在指定方法的Around中加try-catch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 校验方法参数是否为空，为空则不执行</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckArgsAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;CheckArgsAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配有一个String类型参数的方法，可以使用..匹配多参数</span></span><br><span class="line">  	<span class="comment">//Advice方法中参数名称需要和args表达式中名称一样</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* *(String)) &amp;&amp; args(arg)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkArgs</span><span class="params">(ProceedingJoinPoint joinPoint, String arg)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;checkArgs: &quot;</span> + arg + <span class="string">&quot; [&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        <span class="keyword">if</span> (arg != <span class="keyword">null</span> &amp;&amp; !arg.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(((Context) joinPoint.getThis()), <span class="string">&quot;参数为空&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 目标：对@CheckLogin注解声明的方法进行登录校验</span></span><br><span class="line"><span class="comment">//2. 定义@CheckLogin注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckLogin &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckLoginAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;CheckLoginAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(@CheckLogin * *(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLogin</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//Aspect中只处理简单的逻辑，复杂的功能交给专业模块处理，Aspect只负责拦截收集信息</span></span><br><span class="line">        <span class="keyword">if</span> (Tools.checkLogin()) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;checkLogin: 已登录&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//或者直接跳转登录页面</span></span><br><span class="line">            Log.e(TAG, <span class="string">&quot;checkLogin: 未登录&quot;</span>);</span><br><span class="line">            Toast.makeText(((Context) joinPoint.getThis()), <span class="string">&quot;请登录...&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统计特定方法耗时"><a href="#统计特定方法耗时" class="headerlink" title="统计特定方法耗时"></a>统计特定方法耗时</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 目标：打印@DebugTrace注解方法的耗时</span></span><br><span class="line"><span class="comment">//2. 定义DebugTrace注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DebugTrace &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugTraceAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;DebugTraceAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(@DebugTrace * *(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> duration = System.currentTimeMillis() - time;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;[&quot;</span>+joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法耗时: &quot;</span> + duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出示例</span></span><br><span class="line"><span class="comment">//E/DebugTraceAspect: [MainActivity.java:34] clickEvent方法耗时: 1000</span></span><br></pre></td></tr></table></figure>

<h2 id="权限检查和动态申请"><a href="#权限检查和动态申请" class="headerlink" title="权限检查和动态申请"></a>权限检查和动态申请</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 目标：@CheckPermissions注解声明的方法需要检查权限</span></span><br><span class="line"><span class="comment">//2. 定义CheckPermission注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckPermissions &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckPermissionsAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;CheckPermissionAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(@CheckPermissions * *(..)) &amp;&amp; @annotation(annotation)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(ProceedingJoinPoint joinPoint, CheckPermissions annotation)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//复杂逻辑可以抽出去，如使用PermissionUtil</span></span><br><span class="line">        Log.e(TAG, <span class="string">&quot;checkPermission: &quot;</span> + <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName() + annotation);</span><br><span class="line">        String[] permissions = annotation.value();</span><br><span class="line">        <span class="keyword">if</span> (permissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Activity activity = (Activity) joinPoint.getTarget();</span><br><span class="line">            List&lt;String&gt; deniedPermission = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; permissions.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (activity.checkSelfPermission(permissions[i]) == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">                    deniedPermission.add(permissions[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!deniedPermission.isEmpty()) &#123;</span><br><span class="line">              	<span class="comment">//动态申请权限，需要在onRequestPermissionsResult中检查是否授权成功。也可以通过切入的方式检查</span></span><br><span class="line">                activity.requestPermissions(permissions, <span class="number">0x1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    joinPoint.proceed();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动findViewById"><a href="#自动findViewById" class="headerlink" title="自动findViewById"></a>自动findViewById</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 确定目标：@BindView注解声明的变量使用的时候自动findViewById</span></span><br><span class="line"><span class="comment">//2. 定义BindView注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindViewAspect</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//切点为@BindView注解声明的变量的get方法，传入annotation参数</span></span><br><span class="line">		<span class="meta">@Around(&quot;get(@BindView * *) &amp;&amp; @annotation(annotation)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">bindViewById</span><span class="params">(JoinPoint joinPoint, BindView annotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Activity) joinPoint.getTarget()).findViewById(annotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="点击事件节流"><a href="#点击事件节流" class="headerlink" title="点击事件节流"></a>点击事件节流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 目标：使用@ThrottleClick注解声明的方法一段时间内只会触发一次</span></span><br><span class="line"><span class="comment">//2. 定义@ThrottleClick注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ThrottleClick &#123;</span><br><span class="line">  	<span class="comment">//支持设置间隔时间</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duration</span><span class="params">()</span> <span class="keyword">default</span> 500</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrottleAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存上一次点击时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTime = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(@ThrottleClick * *(..)) &amp;&amp; @annotation(annotation)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleThrottle</span><span class="params">(ProceedingJoinPoint joinPoint, ThrottleClick annotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> duration = annotation.duration();</span><br><span class="line">        <span class="comment">//超过间隔时间才可触发点击事件</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - lastTime &gt; duration) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">                lastTime = System.currentTimeMillis();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>面向切面编程（AOP）</title>
    <url>/2021/12/01/tech-2021-12-01-AOP/</url>
    <content><![CDATA[<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><h2 id="OOP和AOP"><a href="#OOP和AOP" class="headerlink" title="OOP和AOP"></a>OOP和AOP</h2><ul>
<li>OOP（Object Oriented Program，面向对象编程）：侧重对功能进行模块化和封装继承。关注静态的对象层次结构。</li>
<li>AOP（Aspect Oriented Program，面向切面编程）：侧重对横跨各个模块中的公共功能进行统一处理。关注动态的运行时的业务流程。</li>
</ul>
<p>例如使用OOP封装了一个日志框架，包含打印、缓存、上报等功能。看起来很完美，实际上存在以下问题：</p>
<ol>
<li>对调用方来说，需要在多处地方添加方法调用，和调用方的主业务耦合，违背单一职责原则。代码分散，需求变动的时候需要改动多处。</li>
<li>难以对<strong>现有对象</strong>（如三方库中的类）动态添加功能，需要通过继承或组合的方式扩展对象功能。</li>
<li>编写代码的时候需要考虑不同类之间的共性，再提取方法或者接口。</li>
</ol>
<p>如下图</p>
<pre class="mermaid">graph TB
subgraph 验证用户方法封装
a[验证用户]
b[验证用户]
c[验证用户]
end
流程1[开始]-->a-->查询余额
流程2[开始]-->b-->取款
流程3[开始]-->c-->转账</pre>

<p>需要在每个流程中加入验证用户的步骤，即使对重复代码进行了封装，但还是免不了要调用方法。</p>
<p>解决：将验证用户的方法抽离出来（切面），在编译或者运行期间讲代码<strong>织入</strong>到目标位置（连接点）。我们把这种方法叫AOP。</p>
<p><strong>AOP能够将这些与业务无关，却被业务模块所共同调用的逻辑封装起来（切面）；在不侵入业务代码的情况下，将这些公共的功能插入到主业务流程中（连接点）。减少系统的重复代码，降低模块间的耦合度，提高可维护性。</strong></p>
<p><strong>AOP的思想可以让我们在写代码的时候只考虑主业务流程，而不用考虑这些不重要的流程。</strong></p>
<p>AOP和OOP是互补的关系</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><p>横切关注点（Cross-cutting concerns）：面向对象模型中大多数类会实现单一特定的功能，但有时候也需要添加一些公共的附属功能。例如日志、埋点等功能会分布在不同对象层次中，与对象自身的功能没有关系。这些散布在各处的无关的代码称为<strong>横切关注点</strong>。</p>
</li>
<li><p>连接点（JoinPoint）：程序运行时的一些执行点，可以在这些地方插入代码。如方法调用、方法执行、类初始化、构造、变量get和set等。</p>
</li>
<li><p>切点（Pointcut）：用于选择和匹配我们想要插入代码的目标JoinPoint。</p>
<blockquote>
<p>关于切点，有两种说法，刚开始看概念很容易混乱，两种理解都可以，只是角度不同。</p>
<ol>
<li>切点是指写匹配规则的地方，定义在切面中。关注从哪里切入（切入的点）</li>
<li>切点是指匹配到的结果（目标JoinPoint），是JoinPoint的子集。关注切到的结果（切到的点）</li>
</ol>
</blockquote>
</li>
<li><p>通知（Advice）：Pointcut拦截到JoinPoint之后要做的事情，即要增强的功能（要注入的代码，如log打印，权限检查等）。常见的通知类型如前置通知（在Pointcut之前执行）、后置通知、异常通知、最终通知、环绕通知。</p>
</li>
<li><p>切面（Aspect）：切入点+通知=切面</p>
</li>
<li><p>织入（Weaving）：注入代码（Advice）到目标位置（JoinPoint）的过程。分为静态织入（编译期或类加载期）和动态织入（运行期）</p>
</li>
<li><p>目标对象（Target）：被代理的对象</p>
</li>
<li><p>代理（Proxy）：一个类被增强实际上是生成一个代理类，调用的时候实际上是调用代理类的方法。</p>
</li>
</ul>
<p><img src="/2021/12/01/tech-2021-12-01-AOP/AOP%E6%A6%82%E5%BF%B5.png"></p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ol>
<li>静态织入：编译期织入代码。又分为不同阶段：java、class、dex代码。如APT、AspectJ、ASM、Javassit、ASMDex、DexMaker、操作AST、手动修改class文件。</li>
<li>动态织入：运行时织入代码。又分为类加载和运行。如Java动态代理、Cglib、Javassit、XPosed、Dexposed、自定义类加载器。</li>
</ol>
<pre class="mermaid">graph TB
subgraph 编译期
源代码--"APT"-->java文件--"AspectJ"-->class1[class字节码]--"Javassist、ASM、AspectJ"-->dex字节码
end
subgraph 运行期
dex字节码--"Javassist、ASM、ASMDex、DexMaker"-->ClassLoader类加载--"Dexposed、Xposed"-->运行
end</pre>

<p>Android注解解析主要分为两种：</p>
<ol>
<li>运行时反射解析当前类（注解作用域：RUNTIME）：性能较低。</li>
<li>编译期生成代理类和代理对象（注解作用域：SOURCE、CLASS）：需要生成额外代码</li>
</ol>
<h2 id="APT（Annotation-Processing-Tool，注解处理器）"><a href="#APT（Annotation-Processing-Tool，注解处理器）" class="headerlink" title="APT（Annotation Processing Tool，注解处理器）"></a>APT（Annotation Processing Tool，注解处理器）</h2><p>见<a href>APT介绍和实践</a></p>
<table>
<thead>
<tr>
<th>AOP技术</th>
<th>作用时机</th>
<th>输入</th>
<th>输出</th>
<th>代表框架</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>APT</td>
<td>编译期</td>
<td>Java文件</td>
<td>Java文件</td>
<td>DataBinding、Dagger2、ButterKnife、EventBus3、DBFlow</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="方法优缺点、难点比对"><a href="#方法优缺点、难点比对" class="headerlink" title="方法优缺点、难点比对"></a>方法优缺点、难点比对</h2><p>//todo</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用时机</th>
<th>操作对象</th>
<th>优点</th>
<th>缺点</th>
<th>为了上手，我需要掌握什么？</th>
</tr>
</thead>
<tbody><tr>
<td><strong>APT</strong></td>
<td>编译期：还未编译为 class 时</td>
<td>.java 文件</td>
<td>1. 可以织入所有类；2. 编译期代理，减少运行时消耗</td>
<td>1. 需要使用 apt 编译器编译；2. 需要手动拼接代理的代码（可以使用 Javapoet 弥补）；3. 生成大量代理类</td>
<td>设计模式和解耦思想的灵活应用</td>
</tr>
<tr>
<td><strong>AspectJ</strong></td>
<td>编译期、加载时</td>
<td>.java 文件</td>
<td>功能强大，除了 hook 之外，还可以为目标类添加变量，接口。也有抽象，继承等各种更高级的玩法。</td>
<td>1. 不够轻量级；2. 定义的切点依赖编程语言，无法兼容Lambda语法；3. 无法织入第三方库；4. 会有一些兼容性问题，如：D8、Gradle 4.x等</td>
<td>复杂的语法，但掌握几个简单的，就能实现绝大多数场景</td>
</tr>
<tr>
<td><strong>Javassist</strong></td>
<td>编译期：class 还未编译为 dex 时或运行时</td>
<td>class 字节码</td>
<td>1. 减少了生成子类的开销；2. 直接操作修改编译后的字节码，直接绕过了java编译器，所以可以做很多突破限制的事情，例如，跨 dex 引用，解决热修复中 CLASS_ISPREVERIFIED 问题。</td>
<td>运行时加入切面逻辑，产生性能开销。</td>
<td>1. 自定义 Gradle 插件；2. 掌握groovy 语言</td>
</tr>
<tr>
<td><strong>ASM</strong></td>
<td>编译期或运行期字节码注入</td>
<td>class 字节码</td>
<td>小巧轻便、性能好，效率比Javassist高</td>
<td>学习成本高</td>
<td>需要熟悉字节码语法，ASM 通过树这种数据结构来表示复杂的字节码结构，并利用 Push 模型来对树进行遍历，在遍历过程中对字节码进行修改。</td>
</tr>
<tr>
<td><strong>ASMDEX</strong></td>
<td>编译期和加载时：转化为 .dex 后</td>
<td>Dex 字节码，创建 class 文件</td>
<td>可以织入所有类</td>
<td>学习成本高</td>
<td>需要对 class 文件比较熟悉，编写过程复杂。</td>
</tr>
<tr>
<td><strong>DexMaker</strong></td>
<td>同ASMDEX</td>
<td>Dex 字节码，创建 dex 文件</td>
<td>同ASMDEX</td>
<td>同ASMDEX</td>
<td>同ASMDEX</td>
</tr>
<tr>
<td><strong>Cglib</strong></td>
<td>运行期生成子类拦截方法</td>
<td>字节码</td>
<td>没有接口也可以织入</td>
<td>1. 不能代理被final字段修饰的方法；2. 需要和 dexmaker 结合使用</td>
<td>–</td>
</tr>
<tr>
<td><strong>xposed</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>能hook自己应用进程的方法，能hook其他应用的方法，能hook系统的方法</td>
<td>依赖三方包的支持，兼容性差，手机需要root</td>
<td>–</td>
</tr>
<tr>
<td><strong>dexposed</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>只能hook自己应用进程的方法，但无需root</td>
<td>1. 依赖三方包的支持，兼容性差；2. 只能支持 Dalvik 虚拟机</td>
<td>–</td>
</tr>
<tr>
<td><strong>epic</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>支持 Dalvik 和 Art 虚拟机</td>
<td>只适合在开发调试中使用，碎片化严重有兼容性问题</td>
<td>–</td>
</tr>
</tbody></table>
<h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><p>见<a href="/2021/12/02/tech-2021-12-02-AspectJ%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B/">AspectJ介绍和案例</a></p>
<h2 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2><p><strong>ASM 插桩工具 :</strong></p>
<p><strong>操作灵活 :</strong> 可以在字节码任何位置，自定义修改、插入、删除相关逻辑 ;</p>
<p><strong>上手很难 :</strong> 对 .class 字节码文件有比较深入的了解，编写过程较复杂</p>
<table>
<thead>
<tr>
<th>AOP技术</th>
<th>功能</th>
<th>性能</th>
<th>面向接口编程</th>
<th>编程难度</th>
</tr>
</thead>
<tbody><tr>
<td>直接改写class文件</td>
<td>完全控制类</td>
<td>无明显性能代价</td>
<td>不要求</td>
<td>高，要求对class文件结构和Java字节码有深入的了解</td>
</tr>
<tr>
<td>JDK Instrument</td>
<td>完全控制类</td>
<td>无论是否改写，每个类装入时都要执行 hook 程序</td>
<td>不要求</td>
<td>高，要求对 class 文件结构和 Java 字节码有深刻了解</td>
</tr>
<tr>
<td>JDK Proxy</td>
<td>只能改写 method</td>
<td>反射引入性能代价</td>
<td>要求</td>
<td>低</td>
</tr>
<tr>
<td>ASM</td>
<td>几乎能完全控制类</td>
<td>无明显性能代价</td>
<td>不要求</td>
<td>中，能操纵需要改写部分的 Java 字节码</td>
</tr>
<tr>
<td>AspectJ</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>基于ASM的字节码处理工具：<a href="https://github.com/Leaking/Hunter/blob/master/README_ch.md">Hunter</a>、<a href="https://github.com/BryanSharp/hibeaver">Hibeaver</a></p>
<p>基于Javassist的字节码处理工具：DroidAssist</p>
<p>ASM是一个框架/库，它为您提供了一个API来操作现有的字节码和/或轻松生成新的字节码。</p>
<p>另一方面，AspectJ是一种基于Java语言的语言扩展，具有自己的语法，专门用于通过面向方面的编程概念扩展Java运行时的功能。它包括一个编译器/编织器，可以在编译时或运行时运行。</p>
<p>它们的相似之处在于它们都通过现有字节码的字节码操作和/或生成新的字节码来实现其目标。</p>
<p>ASM更通用，因为它没有关于如何修改现有字节码的意见，它只是为您提供了一个API，您可以随心所欲地使用它。另一方面，AspectJ更具体，范围更窄，它只支持一些预定义的AOP结构，但它为您提供了一个界面（aspectj语言），如果您可以在这些结构中使用它，则更容易使用它为您提供。</p>
<p>对于我见过的大多数用例，AspectJ绰绰有余，但在极少数情况下，ASM可能是一个不错的选择，但是你需要更多的编程努力取得类似的成果。</p>
<h2 id="ASMDex"><a href="#ASMDex" class="headerlink" title="ASMDex"></a>ASMDex</h2><p>类似ASM的字节码操作库，运行在Android平台，操作dex字节码</p>
<h2 id="DexMaker"><a href="#DexMaker" class="headerlink" title="DexMaker"></a>DexMaker</h2><p>提供JavaAPI，用于编译期或运行时生成Dex字节码</p>
<h2 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h2><p>原理：使用Gradle Task或Transform，在dex文件生成之前，修改class字节码。不需要生成子类代理</p>
<p>框架：热修复HotFix</p>
<p>Javassist &amp; ASM 对比<br>Javassist抽象出源代码级的API，比ASM中实际的字节码操作更容易使用<br>Javassist使用反射机制，这使得它比运行时使用Classworking技术的ASM慢。<br>总的来说ASM比Javassist快得多，并且提供了更好的性能。Javassist使用Java源代码的简化版本，然后将其编译成字节码。这使得Javassist非常容易使用，但是它也将字节码的使用限制在Javassist源代码的限制之内。<br>总之，如果有人需要更简单的方法来动态操作或创建Java类，那么应该使用Javassist API 。如果需要注重性能地方，应该使用ASM库。</p>
<h2 id="Cglib（Code-Generation-Library）"><a href="#Cglib（Code-Generation-Library）" class="headerlink" title="Cglib（Code Generation Library）"></a>Cglib（Code Generation Library）</h2><p>原理：底层采用ASM字节码框架，运行期间类加载的时候为目标类创建一个字类，代理拦截父类方法调用。解决了JDK动态代理需要定义接口的问题</p>
<p>缺点：</p>
<ol>
<li>无法代理final类和方法：Cglib是通过子类代理实现的</li>
<li>无法在Android中使用，Android加载的是dex文件，而Cglib生成的是class文件：需要结合Dexmaker生成dex字节码文件。参考<a href="https://blog.csdn.net/zhangke3016/article/details/71437287">将cglib动态代理思想带入Android开发</a></li>
</ol>
<h1 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h1><ol>
<li>参数校验和判空</li>
<li>运行时权限验证或申请</li>
<li>运行时登录验证</li>
<li>检查网络连接</li>
<li>日志管理：输出调试日志。如打印代码行数、入参、出参等</li>
<li>重要生命周期添加打印</li>
<li>无侵入埋点</li>
<li>事件防抖</li>
<li>异常统一处理</li>
<li>事务处理</li>
<li>性能监控，如统计方法耗时</li>
<li>方法调用线程切换</li>
<li>对变量和方法返回值进行缓存和注入，内存缓存和持久缓存</li>
<li>对数据和常量加密</li>
<li>热修复：新方法替换旧方法</li>
</ol>
<p>AOP和字节码插桩的区别和联系</p>
<blockquote>
<ul>
<li>AOP：是一种编程思想，OOP的延续。将系统中非核心的业务提取出来，进行单独处理。AOP中用到了IoC和DI的思想</li>
<li>字节码插桩：即修改字节码，是实现AOP的一种技术。AOP除了修改字节码之外还可以修改源码、抽象语法树等。</li>
</ul>
<p>除了上面的场景之外，字节码插桩和修改还可以应用于：</p>
<ol>
<li>三方库Hook，不需要修改三方库源码</li>
<li>应用破解</li>
</ol>
</blockquote>
<p>AOP与IoC（控制反转）、DI（依赖注入）的区别和联系</p>
<blockquote>
<p>区别：AOP强调对代码运行过程进行修改。IoC和DI强调不同对象间的依赖关系，以及如何依赖。</p>
<p>联系：AOP和IoC用到的技术类似，例如AspectJ、APT、字节码修改等，既可用于AOP，也可以用于IoC</p>
<p>Tips：IoC和DI是同一个概念的不同描述，也可以说通过依赖注入来实现控制反转。</p>
</blockquote>
<h1 id="AOP实战"><a href="#AOP实战" class="headerlink" title="AOP实战"></a>AOP实战</h1><p>编写AOP思路：</p>
<ol>
<li>考虑注入代码的时机、以及注入是否有限制（如final、private限制），选择合适的AOP工具（使用场景、性能等）<ol>
<li>编译期：生成java、class、dex文件</li>
<li>运行期：类加载、运行时</li>
</ol>
</li>
<li>考虑要注入代码的地方：如方法调用、执行、类初始化等时机</li>
<li>考虑怎么找到要注入代码的地方<ol>
<li>匹配类名、方法名</li>
<li>使用注解标记</li>
</ol>
</li>
<li>考虑怎么处理代码<ol>
<li>在代码前后插入逻辑</li>
<li>替换目标代码</li>
</ol>
</li>
</ol>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><ol>
<li>Lancet轻量级的框架，编译速度快，支持增量编译</li>
<li>Lancet语法简单，易于上手。AspectJ需要学习的语法比较多。</li>
<li>Lancet仅支持hook具体的方法，不能像AspectJ一样根据自定义的注解来Hook一个类或者任意的方法。</li>
</ol>
<h2 id="使用场景建议"><a href="#使用场景建议" class="headerlink" title="使用场景建议"></a>使用场景建议</h2><ol>
<li>如果只是相对特定的函数，aar中函数、项目中的函数、Android系统源码中的函数进行Hook，可以选择使用Lancet。</li>
<li>如果需要使用注解对某一类操作进行Hook时，例如，权限检查、性能检测等函数，可以使用AspectJ。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考文章：</p>
<ul>
<li><a href="https://juejin.cn/post/6844903728525361165">一文读懂 AOP | 你想要的最全面 AOP 方法探讨</a></li>
<li><a href="https://juejin.cn/post/6844903741808705544">一文应用 AOP | 最全选型考量 + 边剖析经典开源库边实践，美滋滋</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础之自底向上设计（TODO）</title>
    <url>/2021/11/28/network-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="自底向上设计"><a href="#自底向上设计" class="headerlink" title="自底向上设计"></a>自底向上设计</h1><p>一台主机：不需要通信，不需要连接网络</p>
<p>问题：无法和其他电脑连接，通信，只有基础的运算功能</p>
<h2 id="网线直连"><a href="#网线直连" class="headerlink" title="网线直连"></a>网线直连</h2><p>两台主机：主机添加网口，使用一根网线连接通信</p>
<p>三台主机：每台主机开两个网口，分别连接两台主机</p>
<p>N台主机：….</p>
<p>问题：随着越来越多的人加入，网口越来越多，网线密密麻麻。</p>
<h2 id="集线器（Hub）"><a href="#集线器（Hub）" class="headerlink" title="集线器（Hub）"></a>集线器（Hub）</h2><p>使用集线器做转发：只有简单的收发功能，将电信号<strong>转发到所有出口</strong>，相当于广播。如图</p>
<p><img src="/2021/11/28/network-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BA%BF%E5%99%A8.gif"></p>
<blockquote>
<ol>
<li>对接收到的信号进行再生整形放大，以扩大网络的传输距离</li>
<li>把所有节点集中在以它为中心的节点上。</li>
</ol>
</blockquote>
<p>我们把它定义在<strong>物理层</strong></p>
<p>问题：由于转发到了所有出口，接收方不知道数据包是不是发给自己的。</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>给每台设备起全局唯一的标识，使用6组8位数字表示，叫Mac地址。我们把它定义在<strong>数据链路层</strong></p>
<blockquote>
<p>MAC（Media Access Control，介质访问控制协议）</p>
<p>MAC地址可以重复，实际上只要不是同属一个数据链路就不会出现问题。</p>
</blockquote>
<p>如A设备的mac地址为<code>aa-aa-aa-aa-aa-aa</code>，B设备的mac地址为<code>bb-bb-bb-bb-bb-bb</code>。A给B发送数据的时候，带上地址，如图：</p>
<p><img src="/2021/11/28/network-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/mac%E5%9C%B0%E5%9D%80%E6%95%B0%E6%8D%AE%E5%8C%85.png"></p>
<p>设备收到数据包后，判断是自己的就收下，不是自己的就丢弃，如图：</p>
<p><img src="/2021/11/28/network-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BA%BF%E5%99%A8+Mac%E5%9C%B0%E5%9D%80.gif"></p>
<p>问题：本来只需要发送给一台设备，现在发了多台设备，既不安全，又浪费网络资源</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>使用交换机，将数据包转发给特定Mac地址的电脑。我们把它定义在<strong>数据链路层</strong></p>
<p>//rodo</p>
<h1 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h1><p>ping过程发生了什么，输入网站url发生了什么</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h2><p>有不同的划分标准，一图以蔽之～</p>
<p><img src="/2021/11/28/network-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86.png"></p>
<ul>
<li>物理层（Physics Layer）</li>
<li>数据链路层（Data Link Layer）</li>
<li>网络层（Network Layer）</li>
<li>传输层（Transport Layer）</li>
<li>会话层（Session Layer）</li>
<li>表示层（Presentation Layer）</li>
<li>应用层（Application Layer）</li>
</ul>
<p>我们有两种网：1.分组交换 ；2.电路交换（电话）</p>
<p>在很久很久以前，你记不记着，有个“<strong>拨号连接</strong>”，有个叫做“猫”的东西？？？<br>没错，就是那个，一上网就打不了座机的时代<br>此时，我们还是<strong>电路交换</strong>哟</p>
<p>这样太蠢了！！！<br>如果我只是想上网看下小电影的简介，那我打开介绍小电影的网站，就暂时不会再通信了<br>所以，没必要一直给我连接着啊！</p>
<p>于是，我们用起了<strong>分组交换</strong><br>分组交换还有两种方式：<br>1.虚电路，如ATM（模拟电话线路）；2.<strong>数据报</strong>，如因特网</p>
<p>&gt;为啥因特网不用虚电路？<br>肯定是因为，大多数时候，虚电路没必要啊，而且麻烦不好用啊</p>
<p>&gt;为啥虚电路没必要&amp;不好用？<br>因为大多数时候，互联网没有实时要求啊，&amp;他的面向连接浪费资源啊</p>
<p>好嘞，现在我们知道了，因特网使用的是，数据报<br>我们先不管数据报是什么，我们<strong>先考虑下如何传输数据报</strong></p>
<p><strong>—————————————–</strong></p>
<p>我们的因特网，肯定是基于物理电路的，<br>因此，我们需要一个，将数据转化为物理信号的层，<br>于是，<strong>物理层诞生啦</strong></p>
<p><strong>—————————————-</strong></p>
<p>有了处理物理信号的物理层，可我们还得知道，<strong>信号发给谁啊<br><strong>你肯定知道，每个主机都有一个，全球唯一的MAC地址吧<br>所以，我们可以用MAC地址来寻址啊<br>恭喜你，</strong>链路层诞生啦</strong></p>
<p><strong>—————————————-</strong></p>
<p>别急，你知道MAC地址，是扁平化的吧<br>也就是说，MAC地址的空间分布，是无规律的！！！<br>如果你有十万台主机，要通过MAC地址来寻址<br><strong>无F**K可说**，<br>不管你设计什么样的算法，数据量都太大了！！！<br>所以，</strong>我们需要IP地址啊<br><strong>&lt;PS,IP里的有趣的东西太多啦，所以我补充在了最后&gt;<br>有了IP地址，恭喜你，</strong>网络层诞生啦**</p>
<p><strong>—————————————–</strong></p>
<p>然而，一台主机不能只和一台服务器通信啊，<br>毕竟下小电影，也要同时货比三家啊<br>那如何实现<strong>并行通信</strong>呢？<br>嘿嘿，我们有端口号啊</p>
<p>再基于不同需求：<br>有人想要连得快，不介意数据丢失，比如你的小电影<br>有人必须要数据可靠，比如发一个电子邮件<br>于是产生了UDP&amp;TCP<br>恭喜你，<strong>运输层诞生啦</strong></p>
<p><strong>—————————————–</strong></p>
<p>别急，你知道的吧，不同应用，有不同的传输需求<br>比如，请求网页，发送邮件，P2P…<br>而且，还有DHCP服务器啊<br>为了方便开发者，我们就对这些<strong>常用需求</strong>，进行了封装<br>恭喜你，<strong>应用层诞生啦</strong></p>
<p>至此，自底向上，讲述了计网。<br>待我考完试，我可以写一部，<strong>计算机网络·从下向顶方法</strong><br>（斜眼笑</p>
<p>====================</p>
<p><strong>&lt;细节补充&gt;</strong><br>&gt;来我们思考先一个问题：如果有四台电脑，要互相能通信，咋办？</p>
<p>&gt;每一台电脑都和另外三台连起来？<br>那我要是再来十台电脑，你在电脑上给我再加十个接口？</p>
<p>&gt;那，把他们连接到一个小盒子上，让小盒子帮着通信？<br>哎这个可以有啊，那如果我有一万台电脑，一个小盒子能够用？</p>
<p>&gt;嘿嘿，那让每一个小盒子连一百台，然后把一百台小盒子再连给一个小盒子</p>
<p>-———————————————-</p>
<p>我们可以用“电话线，宽带，和光纤”，把电脑接给小盒子，它们被称作“<strong>接入网</strong>”<br>而<strong>ISP</strong>就像小盒子，帮你在网络里做通信<br>而ISP的分层，无非就是，终端太多了，没办法不分层</p>
<p>好了，现在你已经明白了网络的<strong>层次化</strong></p>
<p>你肯定是知道，<br>为了在辣么多计算机里，找到目标，我们采用了，有规律的IP地址<br>而路由器，又叫<strong>分组交换机</strong>，就是帮我们在公网里，做IP寻址的</p>
<p>最初，IP地址是<strong>IPv4</strong><br>首先，IP地址是分成了五类（ABCDE）</p>
<p>奈何不够用啊，于是，我们是使用了<strong>子网划分</strong><br>然鹅，手动分配子网IP，会死人的！<br>于是，<strong>DHCP</strong>来了（斜眼笑</p>
<p>md还是不好用啊，于是，诞生了无分类编址（<strong>CIDR</strong>）<br>奈何，还是不够用啊<br>于是，<strong>NAT</strong>出现啦，于是专用网的IP不再占用公网IP</p>
<p>-————————————–</p>
<p>&gt;首先，啥是<strong>专用网</strong>啊<br>1.局域网，比如，公用一个路由器的宿舍啊，家啊<br>2.部分广域网，比如军队、铁路、交通、电力等部门，拥有自己专用的通信网和计算机网。然鹅，这些网络不对内部外的用户开放。这些网络覆盖的地理范围很广，因此，这些专用网都是广域网。</p>
<p>保密性质的广域网，通信要扯到VPN，宝宝没学到这里，先埋个坑</p>
<p>-————————————–</p>
<p>来我们先谈谈<strong>局域网内的通信</strong>：<br>如果哈，我们是一个大局域网，比如我们公司有一百台电脑，<br>首先，路由器没一百个接口让我插！<br>其次，如果我不想和公网通信，那我就没必要用路由器！<br>所以，<strong>链路交换机</strong>来了！！！</p>
<p>链路交换机是基于MAC寻址的，因为局域网没大到必须用IP寻址的地步啊<br>但更准确的说话，链路交换机采用了，跨越链路层和网络层边界的协议——<strong>ARP</strong><br>毕竟，ARP要做一个IP到MAC的映射，</p>
<p>-—————————————-</p>
<p>&gt;你问我，为啥ARP要做IP到MAC的映射<br>因为，你在应用层和运输层里，目的地址都写得是IP,<br>不把IP转化为MAC，咋寻址啊？</p>
<p>&gt;你问我，局域网为啥不用路由器，为啥要用链路交换机<br>交换机功能少，接口多，比路由器划算啊</p>
<p>&gt;那，局域网和公网怎么通信呢?<br>所以，<strong>NAT来了啊</strong>！！！</p>
<p>分组交换机，也就是路由器，用自己的公网IP，帮你们局域网里的人们，给公网发信息<br>然后把接受到的信息，再转发给，那个找他帮忙的人<br>这就是NAT技术啊混蛋！！！</p>
<p>-——————————————</p>
<p>这时一群人说，NAT bulabula不好，我们要拒绝NAT,使用<strong>IPv6</strong><br>那么就牵扯到了<strong>IPv4和IPv6间</strong>的通信（双栈||隧道）</p>
<p>还有啊，IP地址太丑啦，用户根本记不住 <a href="https://link.zhihu.com/?target=http://xxx.xxx.xxx.xxx">http://xxx.xxx.xxx.xxx</a><br>于是乎，<strong>域名</strong>千呼万唤始出来<br>顺便带出来了DNS服务器</p>
<p>1.网络应该分为：电路交换网络和分组交换网络（虚电路本质上是分组交换网络，也就是你说的数据报）。</p>
<p>2.互联网有实时性需求（比如直播）。</p>
<p>3.面向连接的协议（如TCP）需要比非面向连接的协议（如UDP）更多的资源，但是这是为了提供可靠到达等一系列服务所必须的资源。花更多的资源换取更好的服务，不是浪费。</p>
<p>4.专用网与局域网不同（了解一下虚拟专用网络VPN）。</p>
<p>5.局域网即使小，按照应用程序采用的协议，局域网内也可以采用TCP或者UDP等协议通信，所以也需要网络层的支撑，就需要IP。</p>
<p>6.局域网向公网建立连接需要采用“NAT”，公网想向局域网内的设备发起连接，需要“NAT穿透”。</p>
<p>7.DHCP是为了自动分配IP、子网掩码等设置，让新加入局域网的设备自动获得自己的网络配置。（NAT之前，需要DHCP分配给设备IP。但是DHCP分配给设备IP，并不是仅用于下一步的NAT，可能该设备仅需要局域网内通信，不NAT。此时仍然需要DHCP。所以DHCP和NAT是两个独立的概念，不是为了NAT方便才有了DHCP）。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>了解每一个协议、每一层设计的背景以及要解决的问题，多问为什么。</p>
<p>“如果没有操作系统，我们的手机和电脑可以说是废铁了，如果没有计算机网络，我们的手机和电脑就是一座孤岛。”</p>
<p>参考文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">低并发编程-如果让你来设计网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/372288743">小林coding-图解网络</a></li>
<li><a href="https://www.zhihu.com/column/c_1367181480708345856">知乎专栏-图解网络</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础之IP地址</title>
    <url>/2021/11/27/network-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p>IPv4：使用32位（4字节）表示IP地址。</p>
<blockquote>
<p>可以用十六进制、十进制、八进制表示。也可以用点分格式表示，将IP地址分为4段，每段一个字节，中间用点分隔，包括点分十进制、点分十六进制、点分八进制</p>
<p>为了便于阅读和分析，通常写作点分十进制格式：将IP地址分为4段，每段1个字节，每段用十进制表示，中间用点分隔。</p>
<p>点分格式中每一段可以用不同的进制表示，合法但是不常用，如：192.0x00（16进制）.0002（八进制）.235（十进制）</p>
</blockquote>
<h2 id="私有地址和公有地址"><a href="#私有地址和公有地址" class="headerlink" title="私有地址和公有地址"></a>私有地址和公有地址</h2><p>公有地址：向InterNIC注册申请，可以直接访问互联网。</p>
<p>私有地址（专用地址）：非注册地址，供组织机构内部使用，自行分配和管理，无法被其他网络发现，因此可以重复。和互联网通信需要通过网关。</p>
<blockquote>
<p>IP地址类似家庭住址，一台主机向另一台主机发送数据，类似于寄信。</p>
<p>公有地址由组织统一分配注册，不可重复，如解放路44号。邮递员可以直接把信送到该地址。</p>
<p>私有地址相当于小区内的门牌号，如1栋101，其他小区也可以叫1栋101。邮递员只能找到注册的地址，因此只能送到小区门口的保卫处（网关），由保卫处送到具体的门牌号。同样的，发信也要经过保卫处。</p>
</blockquote>
<p>私有地址如果要连到Internet，需要将私有地址转换为公有地址，这个过程称为NAT（Network Address Translation，网络地址转换）。</p>
<h2 id="网关和路由"><a href="#网关和路由" class="headerlink" title="网关和路由"></a>网关和路由</h2><p>网关：将一个网络连接到另一个网络的关口。</p>
<p>设备会配置网关，如果两台主机不在同一个网络下，会将数据包发到网关，再转发给另一台主机。网关也有自己的IP地址，一般是本地网络下的第一个主机号。</p>
<p>一台主机可以有多个网关，如果找不到可用的网关，会将数据包发给默认网关</p>
<p>在windows上叫网关，在mac上叫路由器。路由器是网关的一种。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>将IP地址划分为网络地址和主机地址两部分。转换为2进制，为1的部分对应网络段，为0的部分对应主机段</p>
<p>如C类网络：子网掩码是255.255.255.0，也就是说前三段为网络号，最后一段为主机号。</p>
<p>用途：可以用于判断不同主机是否在同一个子网内：将两个IP分别与子网掩码进行与运算，如果相等则表示在同一个子网内。</p>
<p>表示方法：IP地址（子网掩码）、IP地址/子网掩码位数。如192.168.0.0（255.255.255.0）=192.168.0.0/24</p>
<h2 id="分类网络（有类网络）"><a href="#分类网络（有类网络）" class="headerlink" title="分类网络（有类网络）"></a>分类网络（有类网络）</h2><p><img src="/2021/11/27/network-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%88%86%E7%B1%BBIP%E5%9C%B0%E5%9D%80.png"></p>
<p>对IP进行分类便于更好的路由，判断第一位为0则是A类地址，判断第二位为0则是B类地址…….</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>定义</th>
<th>默认子网掩码</th>
<th>IP地址范围</th>
<th>私有IP地址范围</th>
<th>最大网络数</th>
<th>单个网段最大主机数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>第1段为网络号，最高位固定为0，即1~127</td>
<td>255.0.0.0</td>
<td>0.0.0.0到127.255.255.255</td>
<td>10.0.0.0-10.255.255.255</td>
<td>126（减去0和127）</td>
<td>16777214</td>
<td>大型网络</td>
</tr>
<tr>
<td>B</td>
<td>前2段为网络号，最高位固定为10，即128~191</td>
<td>255.255.0.0</td>
<td>128.0.0.0到191.255.255.255</td>
<td>172.16.0.0-172.31.255.255</td>
<td>16384</td>
<td>65534</td>
<td>中型网络，一般用于大公司和政府机构</td>
</tr>
<tr>
<td>C</td>
<td>前3段为网络号，最高位固定为110，即192~223</td>
<td>255.255.255.0</td>
<td>192.0.0.0到223.255.255.255</td>
<td>192.168.0.0-192.168.255.255</td>
<td>2097152</td>
<td>254</td>
<td>小型网络，分配给任何有需要的人或组织，如校园网，小型办公网络</td>
</tr>
<tr>
<td>D</td>
<td>不分网络号和主机号，最高位固定为1110，即224~239</td>
<td></td>
<td>224.0.0.0到239.255.255.255</td>
<td></td>
<td></td>
<td></td>
<td>用于组播</td>
</tr>
<tr>
<td>E</td>
<td>不区分网络号和主机号，最高位为1111，即240~255</td>
<td></td>
<td>240.0.0.0到255.255.255.255</td>
<td></td>
<td></td>
<td></td>
<td>科研保留地址段</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li>其中D、E类为特殊地址，不能用于分配。<strong>D类用作组播地址，E类为科研保留地址段</strong>。</li>
<li>每个分类下还存在一些特殊用途的地址，不能用于主机分配，如环回地址（127开头，如127.0.0.1表示本机地址，一般用于测试），受限广播地址（255.255.255.255），本机地址（0.0.0.0）等</li>
<li>最大网络数：<ol>
<li>由于A类地址最高位固定为0，且用一个字节表示网络号，由于0和127不能使用，因此需要减去2，因此最大网络数=2^7-2，</li>
<li>由于B类地址最高位固定为10，且用两个字节表示网络号，因此最大网络数=2^14</li>
<li>由于C类地址最高位固定为110，且用三个字节表示网络号，因此最大网络数=2^21</li>
</ol>
</li>
<li>单个网段最大主机数=2^主机号位数-2，（减去头和尾，规定第一个主机号表示网络地址，最后一个主机号表示广播地址，已经被分配，无法再分配给主机）</li>
<li><strong>在分类网络中，子网掩码只有三种（A类：255.0.0.0、B类：255.255.0.0、C类：255.255.255.0）。在CIDR中使用可变长子网掩码（VLSM）</strong></li>
<li>以0或255结尾的地址不能分配给主机：<strong>只在子网掩码至少为24位（即C类地址或者CIDR中24-32位子网掩码）的前提下才成立</strong>。<ol>
<li><strong>以255结尾的地址不一定是广播地址</strong>（主机段全为1）：如B类地址172.16.0.0/255.255.0.0，后8位都是主机位，广播地址为172.16.255.255。172.16.1.255、172.16.2.255等不是广播地址，可以分配给主机</li>
<li><strong>广播地址不一定以255结尾</strong>：如192.168.1.0-63/26，子网掩码为26位，主机号为6位，192.168.1.63、192.168.127、192.168.1.191、192.168.1.255（即每个子网下最后一台主机号）主机位都为1，因此都是广播地址。</li>
</ol>
</li>
</ol>
<h3 id="分类网络面临的问题"><a href="#分类网络面临的问题" class="headerlink" title="分类网络面临的问题"></a>分类网络面临的问题</h3><blockquote>
<ol>
<li>对于企业来说，C类地址只有254个偏少（不够用），而B类地址包含65534个偏多（浪费）。—&gt;CIDR划分子网</li>
<li>B类地址很快将要分配完毕：最大网络数为16384。—&gt;CIDR划分子网</li>
<li>同一网络下没有地址层次：如一个公司用了B类地址，但是需要划分开发环境、测试环境、生产环境IP。—&gt;CIDR划分子网</li>
<li>路由表需要维护大量的表项：C类网络分散在不同地域，难以聚合。—&gt;CIDR将前缀相同的网络聚合成超网，分配给企业，此外还可以按世界地区进行分配</li>
<li>整个IPv4地址最终将会全部耗尽：总数为2^32个地址，去掉私有地址、多播地址、以及一些特殊保留地址，可分配的IP地址不多。—&gt;通过新版本IP协议（IPv6）解决</li>
</ol>
</blockquote>
<h2 id="子网划分与聚合"><a href="#子网划分与聚合" class="headerlink" title="子网划分与聚合"></a>子网划分与聚合</h2><p>意义：如上述，分类网络只有三种分配方式：C类2^8台主机、B类2^16台主机、A类2^24台主机。会造成大量浪费和不够用。因此在分类网络基础上，采用子网划分技术（<strong>VLSM和CIDR</strong>）得到更多类型大小的网络，提高IP地址利用率。</p>
<blockquote>
<ul>
<li>等长子网划分：将分类网络等分成多个网络，所有子网的子网掩码相同</li>
<li>变长子网划分：将分类网络分成多个网络，不同子网使用不同的子网掩码</li>
</ul>
</blockquote>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ol>
<li>主机：互联网中的一个设备</li>
<li>网络：多台机器组成一个网络，网络号相同则在一个网络下</li>
<li>网络地址：一般是该网络的第一个IP地址，不可分配给主机，<strong>主机号全为0</strong>。用于标识该网络。</li>
<li>广播地址：一般是该网络的最后一个IP地址，不可分配给主机，<strong>主机号全为1</strong>。用于向本地网络的所有机器发送广播。</li>
<li>可用主机地址：网络下所有IP地址减去第一个和最后一个IP地址，可用分配给主机的IP地址。用于标识主机</li>
<li>子网：将分类网络划分成更小后的网络，称为子网。其中第一个子网称为全0子网，最后一个子网为全1子网。<ol>
<li>全0子网对应子网号全为0，全1子网对应子网号全为1</li>
<li>旧标准（RFC950）里面全0和全1子网不可分配：为了避免全0子网网络地址（192.168.1.0）和全1子网的广播地址（192.168.1.255）分别与没有划分子网前的网络地址和广播地址冲突。</li>
<li>新标准（RFC1878）废弃，全0子网和全1子网也可用于分配</li>
</ol>
</li>
<li>超网：把多个小网络组成一个大网络。</li>
<li>分类网络：将IP地址分为A、B、C、D、E类，使用标准的默认子网掩码。只有三种（A类：255.0.0.0、B类：255.255.0.0、C类：255.255.255.0）</li>
<li>无类网络（CIDR）：基于VLSM可变长子网掩码，可以进行任意长度前缀分配，并且将多个前缀相同的地址块（CIDR地址块）组合到一个路由表项中，分配给企业使用，减少路由表项。</li>
</ol>
<blockquote>
<p>VLSM（Variable Length Subnet Mask，可变长子网掩码）：通过增加掩码位数，可以划分更多的子网。</p>
<p>CIDR（Classless Inter-Domain Routing，无类别域间路由）：基于VLSM，聚合超网。取代分类网络划分IP地址。</p>
</blockquote>
<h3 id="子网划分原理"><a href="#子网划分原理" class="headerlink" title="子网划分原理"></a>子网划分原理</h3><p>从主机位取出部分位用作子网位（借位），和原网络号合并为新的网络号，这样就可以将标准的IP网络划分成几个小的网络。</p>
<p><img src="/2021/11/27/network-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91.png"></p>
<p>如将C类地址192.168.1.0/24，划分为2个子网：</p>
<ol>
<li>需要向主机位借1位作为子网位</li>
<li>子网掩码由255.255.255.0（/24）变为255.255.255.128（/25）</li>
<li>主机位数从8变为7</li>
<li>每个子网IP地址数从256变为128=2^7</li>
<li>每个子网可用主机数从254变为126=2^7-2</li>
<li>第一个子网段为192.168.1.0-127/25，其中192.168.1.0/25为网络地址，192.168.1.127/25为广播地址。</li>
<li>第二个子网段为192.168.1.128-255/25，其中192.168.1.128/25为网络地址，192.168.1.255/25为广播地址。</li>
</ol>
<p><strong>借1位可以划分两个子网0、1，借2位可以划分4个子网00、01、10、11….（可以看出第一个子网为全0子网、最后一个子网为全1子网）</strong></p>
<h2 id="各种概念换算"><a href="#各种概念换算" class="headerlink" title="各种概念换算"></a>各种概念换算</h2><p>以下全部转换为2进制计算，判断是否属于同一个网段，主要看他们的网络标识是否一样</p>
<ul>
<li><p>网络标识（网络号）：<strong>主机段全为0的IP地址</strong>，子网掩码和IP地址进行”与”操作。用于区分不同的网段</p>
</li>
<li><p>主机标识（主机号）：子网掩码取反和IP地址进行“与”操作，用于区分同一网段下的不同主机</p>
</li>
<li><p>广播地址：<strong>主机段全为1的IP地址</strong>，广播地址不一定是255结尾，以255结尾的也不一定是广播地址，需要结合子网掩码判断。</p>
</li>
<li><p>子网数量：2^子网段位数。</p>
<ul>
<li>C类网络下：主机段位数+子网段位数=8，即IP地址数量*子网数量=2^8</li>
<li>B类网络下，主机段位数+子网段位数=16，即IP地址数量*子网数量=2^16</li>
</ul>
</li>
<li><p>IP地址数量：2^主机段位数</p>
</li>
<li><p>可用主机数量（可分配IP地址数）：IP地址数量-2（减去头和尾，规定第一个主机号表示网络地址，最后一个主机号表示广播地址，已经被分配，无法再分配给主机）</p>
</li>
<li><p>该子网可用IP地址段：将网络地址下的所有主机分段，段数为子网数量，去掉头和尾，即为该子网可用IP地址段</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>如IP地址192.168.1.53</p>
<blockquote>
<ul>
<li>C类地址默认子网掩码为255.255.255.0</li>
<li>网络标识为192.168.1.0</li>
<li>主机标识为53</li>
<li>子网数量为1</li>
<li>广播地址为192.168.1.255，主机号全为1，即255</li>
<li>IP地址数量为256</li>
<li>可用主机数位254</li>
<li>该子网可用IP地址段为192.168.1.1-192.168.1.254</li>
</ul>
</blockquote>
<p>如IP地址192.168.1.53/27</p>
<blockquote>
<ol>
<li>27表示子网掩码有27个1，即：11111111 11111111 11111111 11100000。即子网掩码为255.255.255.224。</li>
<li>网络段有27位，主机段有5位，得一个子网IP地址数量为32，可用主机数为30，子网数量为8。</li>
<li>IP地址转换为二进制：11000000 10101000 00000001 00110101</li>
<li>和子网掩码进行与操作，得：11000000 10101000 00000001 00100000，即网络地址192.168.1.32。</li>
<li>和子网掩码取反后进行与操作，得：00000000 00000000 00000000 00010101，即主机标识为21，表示这个子网下的第21台主机</li>
<li>主机段全部置为1，得：11000000 10101000 00000001 00111111，即广播地址192.168.1.63</li>
<li>将网络分为8段：<ol>
<li>第一个子网：192.168.1.0-192.168.1.31</li>
<li>第二个子网：192.168.1.32-192.168.1.63</li>
<li>第三个子网：192.168.1.64-192.168.1.95</li>
<li>第四个子网：192.168.1.96-192.168.1.127</li>
<li>……</li>
</ol>
</li>
<li>53位于第二个子网，该子网的广播地址为192.168.1.63</li>
<li>该子网可用IP段为：192.168.1.33-192.168.1.62</li>
</ol>
</blockquote>
<p>将B类地址168.195.0.0划分为27个子网，求子网掩码和每个子网下IP地址数量？</p>
<blockquote>
<ol>
<li>27=11011，需要向主机位借5位。</li>
<li>借的是高位，即255.255.11111000.0</li>
<li>换算成10进制为255.255.248.0</li>
<li>主机号占11位，IP地址数量=2^11</li>
</ol>
</blockquote>
<p>将B类地址168.195.0.0划分成若干子网后，每个子网内有700台主机，求子网掩码和可划分子网数？</p>
<blockquote>
<ol>
<li>700=1010111100，主机号占10位，网络号占22位。</li>
<li>即向主机号借了6位。255.255.11111100.0</li>
<li>换算成10进制为255.255.252.0</li>
<li>借了6位，可划分2^6个子网</li>
</ol>
</blockquote>
<h1 id="单播、广播、组播（多播）"><a href="#单播、广播、组播（多播）" class="headerlink" title="单播、广播、组播（多播）"></a>单播、广播、组播（多播）</h1><p>这里的单播、广播、组播是针对网络层的说法，传输层TCP、UDP是对网络层的封装</p>
<h2 id="单播（一对一）"><a href="#单播（一对一）" class="headerlink" title="单播（一对一）"></a>单播（一对一）</h2><p>单播地址是IP网络中最常见的。包含单播目标地址的分组发送给特定主机。源地址-&gt;目标地址</p>
<ul>
<li>以太网帧报头中必须有目标IP地址和目标MAC地址。（目标IP地址+目标MAC地址）</li>
<li>如果目标地址属于另一个网络，则目标MAC地址为源地址所在网络的路由器的MAC地址。（目标IP地址+源地址的路由器MAC地址）</li>
</ul>
<p><img src="/2021/11/27/network-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%8D%95%E6%92%AD.jpg" alt="单播"></p>
<p>缺点：服务器压力大，服务器流量＝客户机数量×客户机流量</p>
<p>优点：针对不同客户做出不同响应，容易实现个性化的服务</p>
<h2 id="广播（一对所有）"><a href="#广播（一对所有）" class="headerlink" title="广播（一对所有）"></a>广播（一对所有）</h2><p>广播分组的目标IP地址的主机部分全为1，这意味着本地网络（广播域）中的所有主机都将接收并查看该分组。</p>
<ul>
<li>以太网帧报头中必须有目标IP地址和广播MAC地址。（目标IP地址+广播MAC地址）</li>
<li>在以太网中，广播MAC地址长48位，其十六进制表示为FF-FF-FF-FF-FF-FF。</li>
</ul>
<p><img src="/2021/11/27/network-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%B9%BF%E6%92%AD.jpg" alt="广播"></p>
<p>优点：网络设备简单，维护简单，布网成本低</p>
<p>缺点：无法针对不同客户做出不同响应。</p>
<h3 id="受限广播"><a href="#受限广播" class="headerlink" title="受限广播"></a>受限广播</h3><p>不会被路由器转发，但会被送到相同物理网络段上的所有主机，只能用于本地网络。</p>
<p>IP地址的网络字段和主机字段全为1，即地址：<strong>255.255.255.255</strong></p>
<h3 id="直接广播"><a href="#直接广播" class="headerlink" title="直接广播"></a>直接广播</h3><p>通过路由发送到该网络下的每台主机</p>
<p>IP地址的网络字段定义这个网络，<strong>主机字段</strong>通常全为1，如：</p>
<ul>
<li>C类网络192.168.1.0的默认子网掩码为255.255.255.0，其广播地址为192.168.1.255。</li>
<li>B类网络172.16.0.0的默认子网掩码为255.255.0.0，其广播地址为172.16.255.255。</li>
<li>A类网络10.0.0.0的默认子网掩码为255.0.0.0，其广播地址为10.255.255.255。</li>
</ul>
<h2 id="多播（一对多）"><a href="#多播（一对多）" class="headerlink" title="多播（一对多）"></a>多播（一对多）</h2><p>让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个多播组IP地址，多播地址范围为224.0.0.0～239.255.255.255。由于多播地址表示一组设备（有时被称为主机组），因此只能用作分组的目标地址。源地址总是为单播地址。</p>
<ol>
<li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域⽹中，路由器是不会进⾏转发的。</li>
<li>224.0.1.0 ~ 238.255.255.255 为⽤户可⽤的组播地址，可以⽤于 Internet 上。</li>
<li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部⽹在内部使⽤，仅在特定的本地范围内有效。</li>
</ol>
<ul>
<li>以太网帧报头中必须有目标IP地址和多播MAC地址。</li>
<li>多播MAC地址以十六进制值01-00-5E打头，余下的6个十六进制位是根据IP多播组地址的最后23位转换得到的。</li>
</ul>
<p><img src="/2021/11/27/network-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%A4%9A%E6%92%AD.jpg" alt="多播"></p>
<p>优点：多个客户端加入同一个组，共享一条数据流，节省服务器负载</p>
<p>缺点：丢包错包之后难以弥补</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Tips：</p>
<ul>
<li>DHCP：动态分配IP</li>
<li>HOST：<ul>
<li>Internet主机指互联网中的一台设备，有自己的IP地址，每台主机在互联网上的地位是平等的</li>
<li>指电脑主机</li>
</ul>
</li>
<li>PC：个人计算机</li>
<li>SERVER：服务器，指运行服务程序的计算机</li>
<li>InterNIC（Internet Network Information Center，因特网信息中心）：提供IP分配、域名管理等服务。此外还有ENIC（欧洲）、APNIC（亚太）等负责不同地区IP分配。在中国是由 CNNIC 的机构进⾏管理。</li>
<li>ISP（Internet Service Provider，互联网服务提供商）：如中国电信、中国移动等。</li>
</ul>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.51cto.com/u_6930123/2113151">IP地址和子网划分学习笔记之《子网划分详解》</a></li>
<li><a href="https://www.cnblogs.com/therock/articles/2798653.html">单播、广播和多播IP地址</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言、编译器和Android虚拟机</title>
    <url>/2021/11/05/basic-2021-11-05-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="芯片架构、操作系统、应用之间的关系"><a href="#芯片架构、操作系统、应用之间的关系" class="headerlink" title="芯片架构、操作系统、应用之间的关系"></a>芯片架构、操作系统、应用之间的关系</h1><p>操作系统：管理计算机硬件和软件资源的计算机程序，是多个程序的集合，一般可以分为几个部分</p>
<ol>
<li>控制程序，也叫内核（进程管理、存储管理、设备管理、文件管理、作业管理）</li>
<li>实用程序（文本编辑器、dump程序、shell、桌面程序等）</li>
<li>编译工具（汇编、编译、解析）</li>
</ol>
<p>操作系统封装了硬件接口，应用是在操作系统之上运行的程序，通过调用系统API来运行，由于不同系统提供的API存在差异，因此高级语言编写的应用程序一般无法跨平台。就算不调用系统API，也需要依赖对应系统的编译程序。</p>
<p>应用程序对系统的依赖体现在哪方面？</p>
<blockquote>
<ol>
<li>开发时应用依赖操作系统中的编译程序</li>
<li>运行时应用依赖操作系统提供的程序库（如网络库、线程库等）</li>
</ol>
</blockquote>
<p>不管是操作系统程序还是应用程序，其实都是由CPU运行的。而CPU只认识对应的机器语言（指令集），同时提供了汇编语法便于记忆，汇编语言是对机器语言的一种映射，因此汇编写的程序只适用于一种或者一系列的CPU。</p>
<p>不同CPU指的是架构不同（指令集不同），和厂商没有关系，例如AMD和Intel都使用x86架构，可能不同厂商会有各自的增强指令，但是不影响x86程序的执行。</p>
<p>一支编译程序只生成一种机器代码。不同架构使用的编译器不同，并且生成不同的目标代码，例如x86，x64架构上的GCC是不一样的。要在一种CPU架构上生成另一个平台的目标代码，需要使用<strong>交叉编译</strong>。</p>
<p>同一个CPU架构可以运行不同的操作系统，同一个操作系统可以在不同CPU架构上运行，但是需要针对目标平台分别进行编译，使用不同的编译工具链。例如Linux for x86，Linux for arm，WindowsNT for x86。</p>
<p>现代的操作系统一般都是使用高级语言编写，不依赖硬件特性，只要针对目标平台重新进行编译即可使用，例如ubuntu系统，有桌面版、Server版、以及各种嵌入式、IoT版（如树莓派）</p>
<blockquote>
<p>高级语言发明之前，同一个操作系统需要针对不同的CPU分别编写。高级语言发明之后，只需要使用对应平台的编译器编译成目标代码即可。</p>
<p>之所以下载的同一个windows系统可以运行在不同芯片上，主要是因为PC基本都是AMD和Intel的芯片，而两家都使用x86架构，指令集是通用的。</p>
</blockquote>
<p>为什么应用一般以操作系统来分类，如windows版、linux版、mac版，不以CPU架构分类？</p>
<blockquote>
<p>应用程序的运行需要CPU架构和操作系统都支持。例如x86_64位的目标程序无法在x86_32位机器上运行。</p>
<p>之所以Windows应用能够装在不同芯片的主机上，主要是因为PC基本都是AMD和Intel的芯片，两家都使用x86架构，指令集是通用的。如果应用编译的时候使用新的指令集，在老的机器还是无法运行。商业软件一般会先用基础指令集，再根据CPU判断是否使用扩展指令集</p>
</blockquote>
<p>应用跨平台兼容不同CPU架构一般有几种做法：</p>
<blockquote>
<ol>
<li>多套目标代码放到同一个执行文件中。</li>
<li>操作系统层面支持其他架构的目标代码。例如64位操作系统兼容32位CPU，并且可以运行32位的应用程序</li>
<li>CPU架构向下兼容，例如arm64-v8a兼容arm和armv7a指令集。应用目标平台为armv7a，可以运行到arm64-v8a的设备上，但是反过来不支持。</li>
<li>通过虚拟机运行，可执行程序不是目标平台代码，而是一种中间代码，通过虚拟机解释执行。例如Java、.Net等</li>
</ol>
</blockquote>
<p>为什么操作系统无法屏蔽CPU架构差异？</p>
<blockquote>
<p>有两种思路：</p>
<ol>
<li>由操作系统来编译生成目标代码，在程序安装时进行编译</li>
<li>由操作系统解释运行源代码或中间代码</li>
</ol>
<p>之所以不这么做有以下原因：</p>
<ol>
<li>理论上操作系统拿到源码之后可以编译成当前架构的代码，但是软件开发商不愿意公开源代码，因此往往会编译成目标代码之后再进行发布。</li>
<li>如果都交由操作系统来运行的话，程序运行会比较慢。例如Android系统，早期由虚拟机解释运行，后来改进通过应用安装时预编译成目标代码，提高了效率。</li>
<li>如果操作系统需要为不同语言、不同CPU架构提供编译器，会使操作系统变得越来越大，如果CPU架构更新操作系统也要更新</li>
</ol>
</blockquote>
<p>Java程序为什么不需要根据CPU架构编译？</p>
<blockquote>
<p>Java之所以不需要根据CPU架构进行编译，是因为Java程序是通过虚拟机运行的，VM屏蔽了CPU架构的差异。</p>
</blockquote>
<p>Android中的目标代码编译</p>
<blockquote>
<p>由于VM功能不完备（如串口通讯需要依赖C写的库）或者性能问题，有时候需要使用C/C++开发，因此Android开放了NDK编译。</p>
<p>这意味着不同CPU架构需要生成不同的目标代码，如arm、x86、mips等。（Android一般使用arm架构，模拟器运行在PC上，一般是x86架构）</p>
<p>NDK开发者需要针对不同架构进行编译，生成不同的so文件，Android打包的时候将多份目标代码一起打包，安装的时候根据设备选择对应的so安装。</p>
</blockquote>
<h1 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h1><h2 id="机器语言、汇编语言、高级语言"><a href="#机器语言、汇编语言、高级语言" class="headerlink" title="机器语言、汇编语言、高级语言"></a>机器语言、汇编语言、高级语言</h2><ol>
<li>机器语言（本地机器码，native code）：<ol>
<li>计算机执行的二进制命令，由0和1组成。</li>
<li>和CPU有关，不同计算机对应不同的机器语言指令集。</li>
<li>一条指令就是机器语言的一个语句，由操作码和操作数组成。</li>
<li>不便于阅读</li>
</ol>
</li>
<li>汇编语言（符号语言、伪机器语言）：<ol>
<li>汇编语言和机器语言一一对应。</li>
<li>用助记符替代机器指令的操作码，用地址符号或标号替代操作数的地址。（如用“ADD”代表逻辑加）</li>
<li>本质是一套语法规则和助记符的集合。</li>
<li>不同CPU指令集不同，因此需要不同的汇编器（汇编语言翻译成机器语言），对应不同的汇编语言。但汇编语言语法规则本身可能通用，也可能不通用，由厂商定义</li>
<li>不便于书写</li>
</ol>
</li>
<li>高级语言：相对于低级语言（<strong>机器语言和汇编语言都是低级语言</strong>）。<ol>
<li>和硬件结构及指令系统无关，可移植性更强。要操作硬件资源必须调用汇编程序的接口。</li>
<li>经过不同平台的编译器编译成目标平台的程序。高级语言和汇编语言不再是一一对应</li>
<li>高度封装的编程语言，更容易理解和修改</li>
</ol>
</li>
</ol>
<p>高级语言转为低级语言需要通过编译，编译器屏蔽了不同平台CPU架构的差异，开发者实际上是面向编译器编程。</p>
<p><strong>为了提升效率，编译器会分为前端和后端。前端将源代码生成统一的中间代码，后端将中间代码编译为不同目标架构下的汇编代码（中间代码隔开了编译前端和编译后端）。再交由这些架构下的汇编器汇编成机器码。</strong></p>
<h2 id="跨平台、程序可移植性"><a href="#跨平台、程序可移植性" class="headerlink" title="跨平台、程序可移植性"></a>跨平台、程序可移植性</h2><ul>
<li>write once, compile anywhere（一次编写，处处编译）：同样的代码在不同系统和开发环境中都可以编译运行，体现了代码的<strong>可移植性</strong>。</li>
<li>write once , run anywhere（一次编写，处处运行）：Java特性。编译出来的<code>.class</code>，只要在装了jre环境（java运行环境）的机器上就可以执行。</li>
</ul>
<blockquote>
<p>JVM是Java实现跨平台的核心，可以将Java编译的字节码解释成对应的机器码，不同系统有不同的JVM实现。</p>
<p>核心思想是定义了一层中间语言进行适配。</p>
</blockquote>
<p><strong>JDK&gt;JRE&gt;JVM</strong></p>
<ol>
<li>JDK（Java Development Kit）：Java 开发工具包，包含JRE和一些开发工具，如<code>javac、javap、jar</code>等</li>
<li>JRE（Java Runtime Environment）：Java 运行时环境，包含JVM和Java一些基本类库</li>
<li>JVM（Java Virtual Machine）：Java 虚拟机。将class字节码解释成机器码执行，是Java能够跨平台的核心</li>
</ol>
<p>观点总结：</p>
<ol>
<li>高级语言和硬件结构及指令系统无关，从这个角度来说，高级语言都是跨平台的（平台无关性）。</li>
<li>严格来说，高级语言只是语言规则，没有平台概念，语言本身也没法运行，运行的是编译后的本地代码。而本地代码是无法跨平台的。</li>
<li>程序的可移植性指的是源代码，而不是本地代码。</li>
<li>打包好的可执行程序要支持跨平台、移植，需要加一层中间代码，借助虚拟机或解释器将中间代码翻译成本地代码执行。</li>
</ol>
<h3 id="C-C-是否跨平台？"><a href="#C-C-是否跨平台？" class="headerlink" title="C/C++是否跨平台？"></a>C/C++是否跨平台？</h3><p>结论：C/C++语言本身是跨平台的，但是应用程序本身是否跨平台取决于该平台上有没有适用的库及编译器。C语言提供了不同CPU架构的编译器</p>
<p>为什么说C/C++无法跨平台？</p>
<blockquote>
<p>C++标准库的东西太少了，没有多线程没有界面，内存管理很弱。这些都依赖于具体平台的API，而系统接口API不统一。比如在Windows下有WIN32、MFC，在Linux和Unix系列下，有pthread。</p>
<p>想要用c进行跨平台开发，需要封装各个平台实现，添加判断，通过编译参数选择对应的平台。</p>
</blockquote>
<p>为什么说Java是跨平台的？</p>
<blockquote>
<p>将Java源代码编译成中间代码（字节码），由JVM解释执行。</p>
<p>Java虚拟机将不同平台的系统API统一封装了，并定义了一套规范，由JVM实现不同平台的调用。</p>
<p>JVM本身就是一个平台，JVM的目标代码就是JVM规范定义的Class字节码。</p>
</blockquote>
<h3 id="JVM语言无关性"><a href="#JVM语言无关性" class="headerlink" title="JVM语言无关性"></a>JVM语言无关性</h3><p><strong>JVM只认识Class文件，并不关心Class文件从哪来，是否是Java语言编写的程序</strong>。换句话说，Java虚拟机和Java语言没什么关系，其实更应该叫Class文件虚拟机。</p>
<blockquote>
<p>sun团队在设计之初就把Java规范分为了Java语言规范《The Java Language Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。</p>
</blockquote>
<p>其他语言只要有对应的编译器，能够输出Class文件，就能够在JVM上运行。如Groovy、JRuby、Jython、Scala等。</p>
<p><img src="/2021/11/05/basic-2021-11-05-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/JVM%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7.png"></p>
<h2 id="编译型语言-amp-解释型语言"><a href="#编译型语言-amp-解释型语言" class="headerlink" title="编译型语言 &amp; 解释型语言"></a>编译型语言 &amp; 解释型语言</h2><h3 id="什么是编译？"><a href="#什么是编译？" class="headerlink" title="什么是编译？"></a>什么是编译？</h3><p>编译就是高级语言转为低级语言的过程，将源代码转换为目标代码的过程。（目标代码可以是中间代码，也可以是本地代码）</p>
<p><img src="/2021/11/05/basic-2021-11-05-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%BB%8F%E5%85%B8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p>
<p><strong>编译和解释都是翻译，区别在于翻译的时机不同：编译在程序执行之前，解释在程序执行过程中。</strong></p>
<ul>
<li>编译型语言：程序执行之前，将源代码一次性转换成本地代码。C、C++、Delphi、Pascal、Fortran等</li>
<li>解释型语言：程序执行的时候。将代码逐条转换成本地代码运行。Java、Basic、JavaScript、Python、PHP等</li>
<li>脚本语言：也是解释型语言，不需要编译，代码即可执行文件，由解释器运行。</li>
</ul>
<p>编译型语言和解释型语言实现的关键在于有没有生成中间代码，由于CPU只认识特定的机器代码，要想可执行程序能够跨平台，需要由虚拟机或解释器来执行程序，由虚拟机或解释器将中间代码翻译成机器代码执行。</p>
<table>
<thead>
<tr>
<th></th>
<th>编译型程序</th>
<th>解释型程序</th>
</tr>
</thead>
<tbody><tr>
<td>执行速度</td>
<td>快</td>
<td>慢：运行时需要解释成机器码</td>
</tr>
<tr>
<td>内存和CPU资源占用</td>
<td>少</td>
<td>多：需要运行解释器，代码逐条解释运行，并且进行一些检查</td>
</tr>
<tr>
<td>目标代码大小</td>
<td>更大：编译后的程序多了很多东西。如C/C++的可执行文件比同样功能的字节码文件大很多</td>
<td>更小</td>
</tr>
<tr>
<td>调试难度</td>
<td>困难：难以定位到异常的源码位置</td>
<td>容易：JVM提供异常信息和堆栈跟踪</td>
</tr>
<tr>
<td>平台依赖性</td>
<td>需要针对不同平台进行编译，只能在特定平台运行</td>
<td>平台独立，只要机器支持jre即可</td>
</tr>
<tr>
<td>安全性</td>
<td>安全性较低：可以直接访问内存区域，如外挂、病毒等</td>
<td>安全性更高</td>
</tr>
<tr>
<td>编写难度</td>
<td>编译器实现难度更高</td>
<td>解释器更容易实现</td>
</tr>
<tr>
<td>适用领域</td>
<td>适合开发操作系统、数据库系统、对速度和内存要求高的库</td>
<td>适用于开发Web应用、脚本等</td>
</tr>
</tbody></table>
<h3 id="C-C-编译过程"><a href="#C-C-编译过程" class="headerlink" title="C/C++编译过程"></a>C/C++编译过程</h3><ol>
<li>预处理（pre-compile）：删除#define并展开宏定义，处理#include等。<code>gcc -E file.c -o file.i</code></li>
<li>编译（compile）：语法分析、词法分析、语义分析等，生成汇编代码.s文件。<code>gcc -S file.i -o file.s</code></li>
<li>汇编（assembly）：汇编代码转为机器指令.o文件。<code>gcc -c file.s -o file.o</code></li>
<li>链接（link）：处理各个模块之间的引用和依赖，将目标文件链接到可执行文件或其他目标文件。<ol>
<li>静态链接：目标文件直接进入可执行文件<ol>
<li>编译静态库源码，生成.o文件：<code>gcc -c lib.c -o lib.o</code></li>
<li>生成静态库文件，归档，生成.a文件：<code>ar -q lib.a lib.o</code></li>
<li>使用静态库编译，生成.out可执行文件：<code>gcc main.c lib.a -o main.out</code></li>
</ol>
</li>
<li>动态链接：可执行程序运行时加载目标文件<ol>
<li>编译动态库源码，生成.so文件：<code>gcc -shared dlib.c -o dlib.so</code></li>
<li>使用动态库编译：<code>gcc main -ldl -o main.out</code></li>
<li>代码调用<ol>
<li><code>dlopen</code>打开动态库文件</li>
<li><code>dlsym</code>查找动态库中的函数并返回调用地址</li>
<li><code>dlclose</code>关闭动态库文件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>反汇编：使用<code>objdump</code>反汇编.o文件，输出机器码和对应的汇编代码</li>
</ol>
<h3 id="为什么说Java是解释型语言？"><a href="#为什么说Java是解释型语言？" class="headerlink" title="为什么说Java是解释型语言？"></a>为什么说Java是解释型语言？</h3><p>Java也有一个编译过程，但并不是将程序直接编译成本地机器语言，而是编译成<strong>中间语言（字节码）</strong>，运行的时候由JVM将字节码翻译成机器语言。</p>
<p>现在的JVM大部分使用了JIT、AOT技术，会在执行之前将字节码编译成本地代码缓存下来，直接运行。因此，也可以说Java是编译的。</p>
<blockquote>
<p>有一个有趣的趋势：编译型语言在越来越解释（追求目标程序跨平台），解释型语言在越来越编译（使用AOT等技术，追求性能）</p>
</blockquote>
<h1 id="Java编译器"><a href="#Java编译器" class="headerlink" title="Java编译器"></a>Java编译器</h1><p>在Java中，编译通常指Java文件转换为Class文件的过程，也被叫做<strong>编译前端</strong>，主要包括词法分析、语法分析、注解处理、语义分析等步骤。不依赖虚拟机。</p>
<p>除此之外编译也可以用来指即时编译（JIT）和提前编译（AOT），称为<strong>编译后端</strong>，主要用于生成更高效的机器码，提高运行效率。</p>
<p>java常见的编译器有以下类型：在JVM中一般是将几种方式结合，提高运行速度和效率。</p>
<ul>
<li><strong>前端编译器</strong>：把<code>.java</code>文件转变成<code>.class</code>文件。比如Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</li>
<li><strong>JIT编译器（Just In Time，即时编译）</strong>：运行时将<strong>热点代码</strong>编译成成本地代码。比如HotSpot VM的C1、C2编译器。<ul>
<li>将字节码编译成的机器码缓存下来，下次可以直接使用，提高运行效率。但是会牺牲一定的启动速度，占用更多的内存。</li>
<li>JIT会编译热点代码，而不是全部编译。非热点代码还是解释执行。监控收集热点代码会影响程序运行。</li>
<li>除了缓存之外，JIT还会对代码进行<strong>编译优化</strong>，提高执行效率</li>
</ul>
</li>
<li><strong>AOT编译器（Ahead Of Time，提前编译）</strong>：程序运行前，直接把java代码或字节码编译成本地机器代码，保存到磁盘中。 比如GNU Compiler for the Java（GCJ）、Excelsior JET、Android Runtime（ART）。<ul>
<li>提前预热，避免JIT运行时的消耗</li>
<li>一些动态代码无法在运行前得知，因此编译质量不如JIT</li>
</ul>
</li>
</ul>
<h2 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h2><p><strong>语法糖</strong> 指的是高级语言中的某种语法，编译前端进行语义分析的时候会进行脱糖（解语法糖），转换为无糖语法。</p>
<p>常用的语法糖如下：</p>
<ol>
<li>泛型（ParamterizedType，参数化类型）：类型擦除</li>
<li>自动拆装箱：基本数据类型与包装类互相转换</li>
<li>条件编译：条件分支剪支优化</li>
<li>for-each循环：转换为迭代器</li>
<li>枚举对象转换为普通对象</li>
<li>内部类：非静态内部类持有外部类的引用</li>
<li>可变长参数：转换为数组</li>
</ol>
<h2 id="JIT如何检测热点代码？"><a href="#JIT如何检测热点代码？" class="headerlink" title="JIT如何检测热点代码？"></a>JIT如何检测热点代码？</h2><ol>
<li>基于采样方式探测：周期性检查线程栈顶，如果某个方法经常在栈顶就认为是热点代码。</li>
<li>基于计数器探测：为方法或代码块建立计数器，统计执行次数，超过一定阈值就会触发JIT编译<ol>
<li>方法计数器：统计方法被调用次数</li>
<li>回边计数器：统计for或while循环的运行次数</li>
</ol>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结构有点乱，基本是想到哪写到哪，不断延伸扩展出来相关的一些知识点</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/jmsjh/p/7808764.html">C为什么不能跨平台</a></li>
<li><a href="https://www.jianshu.com/p/b1d2608848dd">Java | 编译过程（编译前端 &amp; 编译后端）</a></li>
<li><a href="/2022/01/20/tool-2022-01-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91">交叉编译</a></li>
</ul>
]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>程序基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android打包和破解、应用安全</title>
    <url>/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="Android打包"><a href="#Android打包" class="headerlink" title="Android打包"></a>Android打包</h1><h2 id="APK文件结构"><a href="#APK文件结构" class="headerlink" title="APK文件结构"></a>APK文件结构</h2><ul>
<li><strong>classes.dex</strong>：Dalvik虚拟机的可执行文件，Google为Android平台定制了Dalvik虚拟机，而不是使用Java虚拟机。</li>
<li><strong>resources.arsc</strong>：将部分资源编译成二进制文件。记录资源名称、类型、值、ID等信息，用于快速索引找到资源。</li>
<li><strong>AndroidManifest.xml</strong>：声明应用信息和权限，四大组件注册等</li>
<li><strong>lib</strong>：存放的so动态链接库。</li>
<li><strong>META-INF</strong>：签名文件夹，里面存放三个文件，有两个是对资源文件做的SHA1 hash处理，一个是签名和公钥证书。</li>
<li><strong>res</strong>：资源文件夹。会被映射到<code>R.java</code>中，通过资源id访问</li>
<li><strong>assets</strong>：资源文件夹。不会被映射到<code>R.java</code>中，需要使用AssetManager访问</li>
</ul>
<p>构建安装流程：</p>
<img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/apk简单打包流程.png" style="zoom:100%;">

<h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/apk打包流程.png" style="zoom:100%;">

<h2 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h2><table>
<thead>
<tr>
<th align="left">工具名称</th>
<th align="left">功能介绍</th>
<th align="left">Sdk路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aapt</td>
<td align="left">Android资源打包工具：生成R.java、resources.asrc和res文件夹</td>
<td align="left">${ANDROID_SDK_HOME}/platform-tools/appt</td>
</tr>
<tr>
<td align="left">aidl</td>
<td align="left">Android接口描述语言转化为.java文件</td>
<td align="left">${ANDROID_SDK_HOME}/platform-tools/aidl</td>
</tr>
<tr>
<td align="left">javac</td>
<td align="left">Java Compiler：将java源代码编译为class文件</td>
<td align="left">${JDK_HOME}/javac或/usr/bin/javac</td>
</tr>
<tr>
<td align="left">dex</td>
<td align="left">将.class文件转化为.dex文件</td>
<td align="left">${ANDROID_SDK_HOME}/platform-tools/dx</td>
</tr>
<tr>
<td align="left">apkbuilder</td>
<td align="left">生成apk包</td>
<td align="left">${ANDROID_SDK_HOME}/tools/opkbuilder</td>
</tr>
<tr>
<td align="left">jarsigner</td>
<td align="left">.jar文件的签名工具</td>
<td align="left">${JDK_HOME}/jarsigner或/usr/bin/jarsigner</td>
</tr>
<tr>
<td align="left">zipalign</td>
<td align="left">字节码对齐工具，release模式下将apk中未压缩的数据进行4字节对齐。方便使用mmap访问，减少内存占用</td>
<td align="left">${ANDROID_SDK_HOME}/tools/zipalign</td>
</tr>
</tbody></table>
<p>class转dex命令：<code>dx --dex output=生成的dex文件 class文件路径</code></p>
<p>注：zipalign使用时机取决于签名工具：</p>
<blockquote>
<ul>
<li>如果使用 <code>apksigner</code>，只能在为 APK 文件签名<strong>之前</strong>执行 zipalign。否则会导致签名失效</li>
<li>如果使用 <code>jarsigner</code>，只能在为 APK 文件签名<strong>之后</strong>执行 zipalign。</li>
</ul>
</blockquote>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>详情见<a href="/2021/11/05/android-2021-11-05-Android%E7%AD%BE%E5%90%8D%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/">Android签名知识汇总</a></p>
<ol>
<li><p>生成keystore文件：<code>keytool -genkey -alias &lt;别名&gt; -keyalg &lt;加密算法，如RSA&gt; -validity &lt;有效天数&gt; -keystore &lt;输出文件&gt;</code></p>
</li>
<li><p>生成系统签名keystore文件：系统应用需要使用系统签名，拥有更高的权限</p>
<ol>
<li>获取Android源码签名文件：<code>platform.pk8 </code>和<code> platform.x509.pem</code>，位于`release/android/n-cn/build/target/product/security/``</li>
<li><code>openssl pkcs8 -in &lt;platform.pk8&gt; -inform DER -outform PEM -out shared.priv.pem -nocrypt</code></li>
<li><code>openssl pkcs12 -export -in &lt;platform.x509.pem&gt; -inkey shared.priv.pem -out shared.pk12 -name &lt;platform&gt;</code></li>
<li><code>keytool -importkeystore -deststorepass &lt;password&gt; -destkeypass &lt;password&gt; -destkeystore &lt;keystore文件名称&gt; -srckeystore shared.pk12 -srcstoretype PKCS12 -srcstorepass &lt;password&gt; -alias &lt;keystore别名&gt;</code></li>
</ol>
</li>
<li><p><code>jarsigner</code>签名：<code>jarsigner [-verbose -keystore &lt;keystore文件&gt; -signedjar &lt;输出文件名称&gt; -storepass &lt;口令&gt;] &lt;jar-file&gt; &lt;alias&gt;</code></p>
</li>
</ol>
<h1 id="混淆、压缩、优化"><a href="#混淆、压缩、优化" class="headerlink" title="混淆、压缩、优化"></a>混淆、压缩、优化</h1><p>参考<a href="/2018/11/24/android-2018-11-24-Android%E6%B7%B7%E6%B7%86/">另一篇文章</a></p>
<h1 id="Android反编译和破解"><a href="#Android反编译和破解" class="headerlink" title="Android反编译和破解"></a>Android反编译和破解</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="https://ibotpeaches.github.io/Apktool/"><code>apktool</code></a>：编译和反编译apk，从apk中提取图片和布局资源<ul>
<li>反编译：<code>apktool d -o &lt;output_dir&gt; test.apk</code>，得到资源文件和smali文件、或者dex文件</li>
<li>编译：<code>apktool b -o &lt;output.apk&gt; &lt;input_dir&gt;</code></li>
</ul>
</li>
<li><a href="https://github.com/pxb1988/dex2jar"><code>dex2jar</code></a>：将可运行文件classes.dex反编译为jar源码文件<ul>
<li><code>d2j-dex2jar.sh &lt;input.dex&gt; -o &lt;output-jarfile&gt;</code>将dex转为jar文件</li>
<li><code>d2j-jar2dex.sh &lt;input.jar&gt; -o &lt;output-dexfile&gt;</code>将jar转为dex文件</li>
</ul>
</li>
<li><a href="http://java-decompiler.github.io/"><code>jd-gui</code></a>：反编译jar包或class文件查看源码</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><pre class="mermaid">graph LR
apk--解压-->dex文件--dex2jar-->jar文件-->使用jd-gui查看java源代码
apk--apktool-->smali文件-->对照java源代码修改smali汇编代码-->apktool打包-->重签名
apk--apktool-->资源文件-->修改资源文件-->apktool打包
apk--解压-->二进制资源文件-->使用AXMLEditor修改二进制文件--压缩-->修改zip为apk-->重签名</pre>

<p>除了通过修改smail文件之外，也可以使用jbe修改class文件，如修改本地依赖的三方库，或者修改使用dex2jar生成的jar</p>
<pre class="mermaid">graph LR
dex文件--dex2jar-->jar文件--解压-->classs[class文件]-->jbe修改字节码--重新压缩-->jar文件--jar2dex-->dex文件
三方库-->jar文件</pre>

<blockquote>
<p>targetSdk版本为30（Android 11）时，apk需要按4字节边界对齐，否则应用无法安装，报错如下：</p>
<p><code>Failure [-124: Failed parse during installPackageLI: Targeting R+ (version 30 and above) requires the resources.arsc of installed APKs to be stored uncompressed and aligned on a 4-byte boundary]</code></p>
<p>需要用<code>zipalign</code>工具对齐之后，再使用apksigner签名</p>
</blockquote>
<p>其他工具：</p>
<ul>
<li><a href="https://github.com/skylot/jadx">jadx</a>（强力推荐）：反编译dex、aar、aab、apk、资源等，可视化操作界面。支持导出Gradle工程。</li>
<li><a href="https://github.com/Jermic/Android-Crack-Tool">CrackTool</a>：反编译、签名、可视化工具</li>
<li><a href="http://set.ee/jbe/">jbe</a>：字节码编辑器，用于查看和修改class字节码文件</li>
<li><a href="https://github.com/fourbrother/AXMLEditor">AXMLEditor</a>：<code>AndroidManifest.xml</code>打包之后会被编译成二进制文件，使用apktool可以反编译回来，但是使用apktool有时候无法再编译回apk。可以直接解压apk，使用该工具直接修改二进制文件，再压缩回apk</li>
<li><a href="https://github.com/demitsuri/smali2java">smali2jar</a>：smali文件转jar文件</li>
<li><a href="https://github.com/JesusFreke/smali">smali</a>：可以clone源码自行编译jar，也可以直接下载<a href="https://bitbucket.org/JesusFreke/smali/downloads/">构建好的jar</a>。使用<code>java -jar baksmali.jar help</code>命令运行</li>
</ul>
<h2 id="vdex转dex"><a href="#vdex转dex" class="headerlink" title="vdex转dex"></a>vdex转dex</h2><p>高版本framework和system app等预编译成了vdex文件，无法通过jadx工具反编译查看源码。</p>
<p>可以使用<a href="https://github.com/anestisb/vdexExtractor">vdexExtractor</a>和<a href="https://github.com/anestisb/vdexExtractor/issues/23">compact_dex_converter</a>工具将vdex文件转为dex文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载compact_dex_converter工具</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 克隆vdexExtractor仓库源码</span></span><br><span class="line">git clone https://github.com/anestisb/vdexExtractor.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译源码，生成`bin/vdexExtractor`可执行文件</span></span><br><span class="line">cd vdexExtractor</span><br><span class="line">./make.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将vdex转化为cdex</span></span><br><span class="line">./vdexExtractor -i ~/Desktop/services.vdex</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将compact_dex_converter和cdex文件拷贝到设备中</span></span><br><span class="line">adb push compact_dex_converter /data/local/tmp/</span><br><span class="line">adb shell chmod 777 /data/local/tmp/bin/compact_dex_converter</span><br><span class="line">adb push your.cdex /data/local/tmp/classes.cdex</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用compact_dex_converter将cdex转化为dex</span></span><br><span class="line">adb shell &quot;/data/local/tmp/compact_dex_converter /data/local/tmp/classes.cdex&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将生成的dex文件拷贝出来，可以使用jadx工具查看</span></span><br><span class="line">adb pull /data/local/tmp/classes.cdex.new your.dex</span><br></pre></td></tr></table></figure>

<h2 id="各类文件说明和转换"><a href="#各类文件说明和转换" class="headerlink" title="各类文件说明和转换"></a>各类文件说明和转换</h2><h3 id="安装前"><a href="#安装前" class="headerlink" title="安装前"></a>安装前</h3><ol>
<li>jar文件：Java归档文件，以zip格式构建，包含java和一些元数与资源文件</li>
<li>apk文件：安卓应用安装包，本质是一个压缩包，可以将后缀名改为zip直接解压，解压缩后会得到dex文件、资源文件、so文件等</li>
<li>class文件：Java字节码文件，JVM的可执行文件，可以对照JVM字节码规范修改，可读性差</li>
<li>dex文件：Dalvik字节码文件，DVM的可执行文件，，可以对照DVM字节码规范修改，可读性差</li>
<li>smali文件：Dalvik汇编文件，dex文件反编译得到，相当于dalvik虚拟机的汇编语言，便于阅读</li>
</ol>
<img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/Java和Android编译各类文件格式转换.png" style="zoom:40%;">

<blockquote>
<p>javap：将class字节码文件反汇编，用于查看java字节码，了解JVM指令执行过程。常用参数<code>-v -l -s -c</code>等。JVM汇编指令参考<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5">官方文档</a></p>
<p>有助于了解原理，如</p>
<ul>
<li>java枚举</li>
<li>java运行时栈</li>
<li>java泛型</li>
<li>非静态内部类持有外部类的引用</li>
</ul>
</blockquote>
<h3 id="安装后"><a href="#安装后" class="headerlink" title="安装后"></a>安装后</h3><p>除了上述文件外，不同版本的Android系统虚拟机会在应用安装之后进行JIT和AOT，生成另外一些文件，存在于系统中</p>
<ol>
<li>odex文件(optimized dex)：针对系统和平台优化过的dex。ART上AOT编译过的机器码也保存在odex文件中。<ol>
<li>DVM中使用<code>dexopt</code>对dex字节码进行优化，保存到<code>/data/dalvik-cache</code>目录。运行的时候JIT编译成本地代码。（JIT）</li>
<li>ART中使用<code>dex2oat</code>，将dex字节码转换为oat文件，包含原始dex和预编译生成的本地代码。（AOT）</li>
<li>ART中Android O之后，从vdex中提取出部分代码进行编译优化，生成odex。<code>odex+vdex=apk源码</code>。</li>
</ol>
</li>
<li>oat文件：本质是ELF格式文件。包含原始dex字节码(oatdata)和翻译过的本地代码(oatexec)</li>
<li>vdex文件：Android O新增，dex代码直接转化的可执行二进制文件。</li>
<li>art文件：odex优化生成的文件，主要是apk 启动的常用函数相关地址的记录，方便寻址相关；ART可以直接加载使用，避免解析耗时</li>
</ol>
<blockquote>
<p>JVM上的可执行文件是class文件，DVM上的可执行文件是odex，ART上的可执行文件是oat文件(odex)。</p>
</blockquote>
<p><img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/dex%E4%BC%98%E5%8C%96.png" alt="dex优化图片"></p>
<h1 id="反混淆"><a href="#反混淆" class="headerlink" title="反混淆"></a>反混淆</h1><p>当应用出现异常崩溃时，打印的堆栈信息是混淆过的不好分析，需要还原成真实的方法名。</p>
<p>方法：代码混淆之后会产生<code>mapping.txt</code>文件，保存混淆前后类名和方法名的对比文件。可以通过SDK中的retrace工具解析mapping文件。</p>
<p>使用GUI工具：</p>
<ol>
<li>运行<code>&lt;android-sdk&gt;/tools/proguard/bin/proguardgui.sh</code></li>
<li>选择<code>ReTrace</code>菜单</li>
<li>选择mapping文件</li>
<li>输入要还原的堆栈代码</li>
<li>点击ReTrace按钮</li>
</ol>
<img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/反混淆工具.png" style="zoom: 67%;">

<p>也可以使用命令行工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用说明</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /Users/Afauria/Library/Android/sdk/tools/proguard/bin/retrace.sh</span></span><br><span class="line">Usage: java proguard.ReTrace [-verbose] &lt;mapping_file&gt; [&lt;stacktrace_file&gt;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /Users/Afauria/Library/Android/sdk/tools/proguard/bin/retrace.sh mapping.txt stacktrace.txt &gt; out.txt</span></span><br></pre></td></tr></table></figure>

<h1 id="堆栈跳转"><a href="#堆栈跳转" class="headerlink" title="堆栈跳转"></a>堆栈跳转</h1><p>AS中logcat调试的时候会打印错误堆栈，可以跳转对应代码位置。如果不是在调试过程中生成的堆栈（例如Bugly、反混淆得到）。此时需要进行代码跳转，可以参考：<a href="https://developer.android.com/studio/debug/stacktraces">分析堆栈轨迹</a></p>
<p>步骤：</p>
<ol>
<li><p>在AS中打开项目（源代码版本和生成堆栈的应用版本相同）</p>
</li>
<li><p>打开菜单<code>Analyze-&gt;Stack Trace or Thread Dump</code></p>
</li>
<li><p>将堆栈粘贴到输入框中，点击OK（盗一下官方的图）</p>
<img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/analyze-stacktrace.png" style="zoom: 50%;"></li>
<li><p>此时会打开StactTrace页面，显示堆栈轨迹。</p>
<img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/stacktrace-window.png" style="zoom: 50%;"></li>
</ol>
<h1 id="防破解"><a href="#防破解" class="headerlink" title="防破解"></a>防破解</h1><ol>
<li>混淆</li>
<li>加固：加密dex和so，先运行壳dex代码，通过壳dex代码自定义DexClassLoader解析加密后的dex运行</li>
<li>敏感计算、数据、不要放客户端</li>
<li>核心方法使用Native</li>
<li>不要在代码中直接使用字符串，通过资源获取</li>
<li>签名校验：运行时在代码中对应用签名进行校验</li>
<li>插入代码花指令，使反编译工具报错：可以结合apt、asm插入，避免影响原代码阅读</li>
<li>…</li>
</ol>
<h1 id="应用安全CheckList"><a href="#应用安全CheckList" class="headerlink" title="应用安全CheckList"></a>应用安全CheckList</h1><p>引自：<a href="https://www.jianshu.com/p/4ff48b761ff6">Android应用加固原理</a></p>
<table>
<thead>
<tr>
<th>风险名称</th>
<th align="center">风险</th>
<th align="right">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>App防止反编译</td>
<td align="center">被反编译的暴露客户端逻辑，加密算法，密钥，等等</td>
<td align="right">加固</td>
</tr>
<tr>
<td>java层代码源代码反编译风险</td>
<td align="center">被反编译的暴露客户端逻辑，加密算法，密钥，等等</td>
<td align="right">加固 ，混淆</td>
</tr>
<tr>
<td>so文件破解风险</td>
<td align="center">导致核心代码泄漏。</td>
<td align="right">so文件加固</td>
</tr>
<tr>
<td>篡改和二次打包风险</td>
<td align="center">修改文件资源等，二次打包的添加病毒，广告，或者窃取支付密码，拦截短信等</td>
<td align="right">资源文件混淆和校验签名的hash值</td>
</tr>
<tr>
<td>资源文件泄露风险</td>
<td align="center">获取图片，js文件等文件，通过植入病毒，钓鱼页面获取用户敏感信息</td>
<td align="right">资源混淆，加固等等</td>
</tr>
<tr>
<td>应用签名未交验风险</td>
<td align="center">反编译或者二次打包，添加病毒代码，恶意代码，上传盗版App</td>
<td align="right">对App进行签名证书校验</td>
</tr>
<tr>
<td>代码为混淆风险</td>
<td align="center">业务逻辑暴露，加密算法，账号信息等等。</td>
<td align="right">混淆（中文混淆）</td>
</tr>
<tr>
<td>webview明文存储密码风险</td>
<td align="center">用户使用webview默认存储密码到databases/webview.db root的手机可以产看webview数据库，获取用户敏感信息</td>
<td align="right">关闭webview存储密码功能</td>
</tr>
<tr>
<td>明文数字证书风险</td>
<td align="center">APK使用的数字证书用来校验服务器的合法性，保证数据的保密性和完成性 明文存储的证书被篡改造成数据被获取等</td>
<td align="right">客户端校验服务器域名和数字证书等</td>
</tr>
<tr>
<td>调试日志函数调用风险</td>
<td align="center">日志信息里面含有用户敏感信息等</td>
<td align="right">关闭调试日志函数，删除打印的日志信息</td>
</tr>
<tr>
<td>AES/DES加密方法不安全使用风险</td>
<td align="center">在使用AES/DES加密使用了ECB或者OFB工作模式，加密数据被选择明文攻击破解等</td>
<td align="right">使用CBC和CFB工作模式等</td>
</tr>
<tr>
<td>RSA加密算法不安全风险</td>
<td align="center">密数据被选择明文攻击破解和中间人攻击等导致用户敏感信息泄露</td>
<td align="right">密码不要太短，使用正确的工作模式</td>
</tr>
<tr>
<td>密钥硬编码风险</td>
<td align="center">用户使用加密算法的密钥设置成一个固定值导致密钥泄漏</td>
<td align="right">动态生成加密密钥或者将密钥进程分段存储等</td>
</tr>
<tr>
<td>动态调试攻击风险</td>
<td align="center">攻击者使用GDB，IDA调试追踪目标程序，获取用户敏感信息等</td>
<td align="right">在so文件里面实现对调试进程的监听</td>
</tr>
<tr>
<td>应用数据任意备份风险</td>
<td align="center">AndroidMainfest中allowBackup=true 攻击者可以使用adb命令对APP应用数据进行备份造成用户数据泄露</td>
<td align="right">allowBackup=false</td>
</tr>
<tr>
<td>全局可读写内部文件风险。</td>
<td align="center">实现不同软件之间数据共享，设置内部文件全局可读写造成其他应用也可以读取或者修改文件等</td>
<td align="right">（1）.使用MODE_PRIVATE模式创建内部存储文件（2）.加密存储敏感数据3.避免在文件中存储明文和敏感信息</td>
</tr>
<tr>
<td>SharedPrefs全局可读写内部文件风险。</td>
<td align="center">被其他应用读取或者修改文件等</td>
<td align="right">使用正确的权限</td>
</tr>
<tr>
<td>Internal Storage数据全局可读写风险</td>
<td align="center">当设置MODE_WORLD_READBLE或者设置android:sharedUserId导致敏感信息被其他应用程序读取等</td>
<td align="right">设置正确的模式等</td>
</tr>
<tr>
<td>getDir数据全局可读写风险</td>
<td align="center">当设置MODE_WORLD_READBLE或者设置android:sharedUserId导致敏感信息被其他应用程序读取等</td>
<td align="right">设置正确的模式等</td>
</tr>
<tr>
<td>java层动态调试风险</td>
<td align="center">AndroidManifest中调试的标记可以使用jdb进行调试，窃取用户敏感信息。</td>
<td align="right">android：debuggable=“false”</td>
</tr>
<tr>
<td>内网测试信息残留风险</td>
<td align="center">通过测试的Url，测试账号等对正式服务器进行攻击等</td>
<td align="right">讲测试内网的日志清除，或者测试服务器和生产服务器不要使用同一个</td>
</tr>
<tr>
<td>随机数不安全使用风险</td>
<td align="center">在使用SecureRandom类来生成随机数，其实并不是随机，导致使用的随机数和加密算法被破解。</td>
<td align="right">（1）不使用setSeed方法（2）使用/dev/urandom或者/dev/random来初始化伪随机数生成器</td>
</tr>
<tr>
<td>Http传输数据风险</td>
<td align="center">未加密的数据被第三方获取，造成数据泄露</td>
<td align="right">使用Hpps</td>
</tr>
<tr>
<td>Htpps未校验服务器证书风险，Https未校验主机名风险，Https允许任意主机名风险</td>
<td align="center">客户端没有对服务器进行身份完整性校验，造成中间人攻击</td>
<td align="right">（1）.在X509TrustManager中的checkServerTrusted方法对服务器进行校验（2）.判断证书是否过期（3）.使用HostnameVerifier类检查证书中的主机名与使用证书的主机名是否一致</td>
</tr>
<tr>
<td>webview绕过证书校验风险</td>
<td align="center">webview使用https协议加密的url没有校验服务器导致中间人攻击</td>
<td align="right">校验服务器证书时候正确</td>
</tr>
<tr>
<td>界面劫持风险</td>
<td align="center">用户输入密码的时候被一个假冒的页面遮挡获取用户信息等</td>
<td align="right">（1）.使用第三方专业防界面劫持SDK（2）.校验当前是否是自己的页面</td>
</tr>
<tr>
<td>输入监听风险</td>
<td align="center">用户输入的信息被监听或者按键位置被监听造成用户信息泄露等</td>
<td align="right">自定义键盘</td>
</tr>
<tr>
<td>截屏攻击风险</td>
<td align="center">对APP运行中的界面进行截图或者录制来获取用户信息</td>
<td align="right">添加属性getWindow().setFlags(FLAG_SECURE)不让用户截图和录屏</td>
</tr>
<tr>
<td>动态注册Receiver风险</td>
<td align="center">当动态注册Receiver默认生命周期是可以导出的可以被任意应用访问</td>
<td align="right">使用带权限检验的registerReceiver API进行动态广播的注册</td>
</tr>
<tr>
<td>Content Provider数据泄露风险</td>
<td align="center">权限设置不当导致用户信息</td>
<td align="right">正确的使用权限</td>
</tr>
<tr>
<td>Service ，Activity，Broadcast,content provider组件导出风险</td>
<td align="center">Activity被第三方应用访问导致被任意应用恶意调用</td>
<td align="right">自定义权限</td>
</tr>
<tr>
<td>PendingIntent错误使用Intent风险</td>
<td align="center">使用PendingIntent的时候，如果使用了一个空Intent，会导致恶意用户劫持修改Intent的内容</td>
<td align="right">禁止使用一个空Intent去构造PendingIntent</td>
</tr>
<tr>
<td>Intent组件隐式调用风险</td>
<td align="center">使用隐式Intent没有对接收端进行限制导致敏感信息被劫持</td>
<td align="right">1.对接收端进行限制 2.建议使用显示调用方式发送Intent</td>
</tr>
<tr>
<td>Intent Scheme URL攻击风险</td>
<td align="center">webview恶意调用App</td>
<td align="right">对Intent做安全限制</td>
</tr>
<tr>
<td>Fragment注入攻击风险</td>
<td align="center">出的PreferenceActivity的子类中，没有加入isValidFragment方法，进行fragment名的合法性校验，攻击者可能会绕过限制，访问未授权的界面</td>
<td align="right">（1）.如果应用的Activity组件不必要导出，或者组件配置了intent filter标签，建议显示设置组件的“android:exported”属性为false（2）.重写isValidFragment方法，验证fragment来源的正确性</td>
</tr>
<tr>
<td>webview远程代码执行风险</td>
<td align="center">风险：WebView.addJavascriptInterface方法注册可供JavaScript调用的Java对象，通过反射调用其他java类等</td>
<td align="right">建议不使用addJavascriptInterface接口，对于Android API Level为17或者以上的Android系统，Google规定允许被调用的函数，必须在Java的远程方法上面声明一个@JavascriptInterface注解</td>
</tr>
<tr>
<td>zip文件解压目录遍历风险</td>
<td align="center">Java代码在解压ZIP文件时，会使用到ZipEntry类的getName()方法，如果ZIP文件中包含“../”的字符串，该方法返回值里面原样返回，如果没有过滤掉getName()返回值中的“../”字符串，继续解压缩操作，就会在其他目录中创建解压的文件</td>
<td align="right">（1）. 对重要的ZIP压缩包文件进行数字签名校验，校验通过才进行解压。 （2）. 检查Zip压缩包中使用ZipEntry.getName()获取的文件名中是否包含”../”或者”..”，检查”../”的时候不必进行URI Decode（以防通过URI编码”..%2F”来进行绕过），测试发现ZipEntry.getName()对于Zip包中有“..%2F”的文件路径不会进行处理。</td>
</tr>
<tr>
<td>Root设备运行风险</td>
<td align="center">已经root的手机通过获取应用的敏感信息等</td>
<td align="right">检测是否是root的手机禁止应用启动</td>
</tr>
<tr>
<td>模拟器运行风险</td>
<td align="center">刷单，模拟虚拟位置等</td>
<td align="right">禁止在虚拟器上运行</td>
</tr>
<tr>
<td>从sdcard加载Dex和so风险</td>
<td align="center">未对Dex和So文件进行安全，完整性及校验，导致被替换，造成用户敏感信息泄露</td>
<td align="right">（1）.放在APP的私有目录    （2）.对文件进行完成性校验。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Pages介绍和使用</title>
    <url>/2021/10/01/blog-2021-10-01-GitPages/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本来是在Hexo中介绍如何部署到GitHub Pages，为了避免介绍其他工具的时候重复写，因此单独把GitHub Pages抽出来介绍。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GitHub Pages是GitHub提供的免费的静态站点托管服务。通过Hexo、Jekyll灯静态博客生成器生成静态站点文件之后，可以部署到GitHub Pages上。默认使用<code>github.io</code>子域名。</p>
<p>GitHub Pages本质就是一个GitHub仓库，只不过GitHub自动将仓库路径下的文件部署到了静态站点服务器<code>github.io</code>上，通过特定的url即可访问。（该仓库可以是Private的）</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li>GitPages创建：登录GitHub，创建一个仓库，命名为：**&lt;用户名&gt;.github.io<strong>。例如</strong>Afauria.github.io**</li>
<li>【Settings-Pages】中选择站点路径</li>
<li>本地生成静态文件<ol>
<li>使用静态站点生成器生成静态博客站点，例如Hexo、Hugo</li>
<li>GitHub内置了Jekyll支持，因此可以直接推送源工程，由GitHub远程构建</li>
<li>可以本地手写Html前端页面，部署</li>
</ol>
</li>
<li>使用Git命令将静态文件推到GitHub上</li>
<li>访问地址 <code>https://afauria.github.io/</code> 。</li>
<li>域名绑定，见下文</li>
</ol>
<p><img src="/2021/10/01/blog-2021-10-01-GitPages/GitPages%E9%85%8D%E7%BD%AE.png" alt="域名添加DNS记录"></p>
<p>可以看到GitHub Pages提供了两个两个站点路径，一个是根路径，一个是<code>/docs</code>路径。意味着我们可以部署两个文件夹到对应的路径下。</p>
<p>我个人是用根路径部署博客的静态站点，用<code>/docs</code>路径部署GitBook静态站点。</p>
<p>注意：</p>
<ol>
<li>使用根路径的时候，GitHub仓库根目录即站点入口。</li>
<li>使用<code>/docs</code>的时候，GitHub仓库要创建docs文件夹，将静态站点文件放到该文件夹下，作为站点入口。</li>
</ol>
<h1 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h1><p>申请域名：万网、阿里云、腾讯云都可以申请</p>
<h2 id="配置DNS解析"><a href="#配置DNS解析" class="headerlink" title="配置DNS解析"></a>配置DNS解析</h2><p>以阿里云为例</p>
<p><img src="/2021/10/01/blog-2021-10-01-GitPages/%E5%9F%9F%E5%90%8D%E6%B7%BB%E5%8A%A0DNS%E8%AE%B0%E5%BD%95.png" alt="域名添加DNS记录"></p>
<h2 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h2><p><strong>注：方式二会在远程仓库生成CNAME文件和新的提交，会产生分支冲突，导致本地发布博客失败，建议使用方式一</strong></p>
<blockquote>
<p>产生冲突的时候可以执行<code>hexo clean</code>再发布</p>
</blockquote>
<p>方式一：在Hexo博客站点<code>source</code>目录下添加<code>CNAME</code>文件，文件中填写域名地址即可。<code>hexo clean &amp; hexo g -d</code>重新发布</p>
<p>方式二：GitPage中配置自定义域名，会生成CNAME文件并发布</p>
<p><img src="/2021/10/01/blog-2021-10-01-GitPages/GitPage%E9%85%8D%E7%BD%AECNAME.png" alt="GitPage配置CNAME"></p>
<h1 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h1><p>域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。</p>
<p>DNS服务器会存储记录，记录类型有多种类型，起到不同的作用，这里简单介绍下A记录、CNAME记录和NS记录</p>
<h2 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h2><p>Address记录。存储域名到对应IP的记录，将域名解析成IP</p>
<h2 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h2><p>别名记录，将一个域名解析成另一个域名。</p>
<p>CNAME记录有如下作用</p>
<h3 id="将多个域名映射到同一个域名"><a href="#将多个域名映射到同一个域名" class="headerlink" title="将多个域名映射到同一个域名"></a>将多个域名映射到同一个域名</h3><p>当需要多个域名指向同一个IP时，如果使用A记录，如下，一旦IP变更，需要修改多条A记录。</p>
<blockquote>
<ol>
<li><code>www.aaa.com--&gt;1.1.1.1</code></li>
<li><code>www.bbb.com--&gt;1.1.1.1</code></li>
</ol>
</blockquote>
<p>如果使用CNAME记录，如下，只需要修改A记录即可</p>
<blockquote>
<ol>
<li><code>www.aaa.com--&gt;www.xxx.com--&gt;1.1.1.1</code></li>
<li><code>www.bbb.com--&gt;www.xxx.com--&gt;1.1.1.1</code></li>
</ol>
</blockquote>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>使用CNAME将域名指向CDN服务器，由CDN服务器把最近的（或者负载较低的）服务器IP返回给本地DNS，让客户端能够快速访问。</p>
<blockquote>
<p>CDN（Content Delivery Network，内容分发网络）：自动选择靠近用户的服务器，更快的分发网络资源，并且提供缓存能力。</p>
</blockquote>
<h2 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h2><p>域名服务器记录。指定域名由哪个DNS服务器解析</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>DNS解析流程：客户端==&gt;本地hosts查询==&gt;ISP本地运营商查询DNS缓存==&gt;权威DNS服务器解析</p>
<p>本地hosts文件：保存常用的网址域名与其对应IP地址的映射。</p>
<blockquote>
<p>当用户在浏览器中输入一个需要登录的网址域名时，系统会首先自动从hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会将网址提交DNS服务器进行IP地址的解析，再进行访问。</p>
</blockquote>
<p>可以使用<code>ipconfig /flushdns</code>命令清除DNS缓存</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：<a href="https://blog.csdn.net/DD_orz/article/details/100034049">简单的解释下什么是CNAME？</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>曼德拉效应</title>
    <url>/2021/09/26/personal-2021-09-26-%E6%9B%BC%E5%BE%B7%E6%8B%89%E6%95%88%E5%BA%94/</url>
    <content><![CDATA[<h1 id="曼德拉效应"><a href="#曼德拉效应" class="headerlink" title="曼德拉效应"></a>曼德拉效应</h1><blockquote>
<p>指大众对历史的集体记忆与史实不符</p>
</blockquote>
<ol>
<li>许多人表示，在自己的记忆中，南非总统<strong>曼德拉</strong>应该在20世纪80年代已经在监狱中死亡”，但现实是曼德拉没有在20世纪80年代死去，后来还被释放，还当上南非总统，直至2010年时仍然在世（曼德拉在2013年才逝世）。</li>
<li>“真”和“直”这两个字在记忆中，方框里面的横线是两条，而且这么写非常顺手。然而，如果仔细观察，就会发现这两个字的方框里面其实是三横。</li>
<li>记忆中叮当是口字旁的，实际不是，并且也搜不到口字旁的当。</li>
<li>记忆中的皮卡丘尾巴有一条黑色条纹，实际是纯黄色</li>
<li>86版《西游记》中没有羊力大仙下油锅炸，但有很多人认为有这个情节。</li>
<li>86版《西游记》中没有虎力大仙砍头被狗叼走了，但有很多人认为有这个情节。</li>
<li>从小听的《爱我中华》歌词：“56个民族，56枝花”，实际上是“56个星座，56枝花”</li>
<li>台湾电影《那些年，我们一起追的女孩》，但是很多人认为是《那些年，我们一起追<strong>过</strong>的女孩》。</li>
<li>美国米老鼠穿什么衣服，很多人回忆是<strong>背带裤</strong>，但其实是上<strong>半裸的短裤</strong>，根本没有背带。同样，很多人认为米老鼠<strong>没有尾巴，或者尾巴画得极度不明显</strong>到可以忽略；但实际上迪士尼原版的米老鼠<strong>尾巴画得又显眼又长</strong>。</li>
<li>记忆中狮子是犬科动物，实际是猫科动物</li>
<li>法国著名雕塑思考者，原本记忆中应该是用手握拳，而现在的思考者却是把手张平。</li>
</ol>
<p>所以记忆这东西，到底是为了证明过去的存在，还是证明过去的虚幻呢？</p>
<p><strong>部分摘自百度百科</strong></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>线程同步的方式【转】</title>
    <url>/2021/09/15/kotlin-2021-09-15-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>引自：<a href="https://mp.weixin.qq.com/s/eLxDiOgUiOl9BWu7FrvR2A">建议收藏！Kotlin 线程同步的 N 种方法</a></p>
<h1 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h1><p>问题： 现有 Task1、Task2 等多个并行任务，如何等待全部任务执行完成后，开始执行 Task3 ? </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> task1: () -&gt; String = &#123;</span><br><span class="line">    sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="string">&quot;Hello&quot;</span>.also &#123; println(<span class="string">&quot;task1 finished: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> task2: () -&gt; String = &#123;</span><br><span class="line">    sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="string">&quot;World&quot;</span>.also &#123; println(<span class="string">&quot;task2 finished: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> task3: (String, String) -&gt; String = &#123; p1, p2 -&gt;</span><br><span class="line">    sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="string">&quot;<span class="variable">$p1</span> <span class="variable">$p2</span>&quot;</span>.also &#123; println(<span class="string">&quot;task3 finished: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join"></a>Thread.join</h2><p><code>join</code>方法：让当前所在线程挂起，让指定线程先执行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_join</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> t1 = Thread &#123; s1 = task1() &#125;</span><br><span class="line">    <span class="keyword">val</span> t2 = Thread &#123; s2 = task2() &#125;</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    </span><br><span class="line">    task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><code>synchronized</code>：锁住一个对象，使其他线程无法访问该对象的同步代码块，但可以访问该对象的非同步代码块。</p>
<ol>
<li>修饰代码块：<code>synchronized(this)&#123;&#125;</code>，锁住当前对象，作用范围是{}代码块</li>
<li>修饰方法：锁住当前对象，作用范围是整个方法</li>
<li>修饰静态方法：锁住当前类的所有对象，作用范围是整个静态方法</li>
<li>修饰类：<code>synchronized(XXX.class)&#123;&#125;</code>，锁住类的所有对象，作用范围是{}代码块</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_synchrnoized</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	Thread &#123;</span><br><span class="line">		synchronized(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">			s1 =l task1()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;.start()</span><br><span class="line">	s2 = task2()</span><br><span class="line">  <span class="comment">//task3在task2之后执行，task1执行完之后释放锁，才能执行task3</span></span><br><span class="line">	synchronized(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">		task3(s1, s2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个并行任务写法比较复杂，需要嵌套synchronized</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code>是<code>JUC（java.util .concurrent，并发工具包）</code>提供的线程锁，可以替换Synchronized使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_ReentrantLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> lock = ReentrantLock()</span><br><span class="line">	Thread &#123;</span><br><span class="line">		lock.lock()</span><br><span class="line">		s1 = task1()</span><br><span class="line">		lock.unlock()</span><br><span class="line">	&#125;.start()</span><br><span class="line">  </span><br><span class="line">	s2 = task2()</span><br><span class="line">  </span><br><span class="line">	lock.lock()</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">	lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个并行任务需要创建多个Lock管理不同的任务</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列：阻塞队列内部也是通过 ReentrantLock 实现的。</p>
<p>阻塞队列更多是使用在生产/消费场景中的同步。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_blockingQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> queue = SynchronousQueue&lt;<span class="built_in">Unit</span>&gt;()</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		queue.put(<span class="built_in">Unit</span>)</span><br><span class="line">	&#125;.start()</span><br><span class="line">	s2 = task2()</span><br><span class="line">	queue.take()</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>JUC 中的锁大都基于 <code>AQS</code> 实现的，可以分为独享锁和共享锁。<code>ReentrantLock</code> 就是一种独享锁。相比之下，共享锁更适合本场景。例如 <code>CountDownLatch</code>，它可以让一个线程一直处于阻塞状态，直到其他线程的执行全部完成：</p>
<p>共享锁的好处是不必为了每个任务都创建单独的锁，即使再多并行任务写起来也很轻松</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_countdownlatch</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> cd = CountDownLatch(<span class="number">2</span>)</span><br><span class="line">	Thread() &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		cd.countDown()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	Thread() &#123;</span><br><span class="line">		s2 = task2()</span><br><span class="line">		cd.countDown()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	cd.await()</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code> 是 JUC 提供的另一种共享锁机制，它可以让一组线程到达一个同步点后再一起继续运行，其中任意一个线程未达到同步点，其他已到达的线程均会被阻塞。</p>
<p>与 <code>CountDownLatch</code> 的区别在于 <code>CountDownLatch</code> 是一次性的，而 <code>CyclicBarrier</code> 可以被重置后重复使用，这也正是 <code>Cyclic</code> 的命名由来，可以循环使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_CyclicBarrier</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> cb = CyclicBarrier(<span class="number">3</span>)</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		cb.await()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	Thread() &#123;</span><br><span class="line">		s2 = task1()</span><br><span class="line">		cb.await()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	cb.await()</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>AQS 内部通过自旋锁实现同步，自旋锁的本质是利用 <code>CompareAndSwap</code> 避免线程阻塞的开销。因此，我们可以使用基于 CAS 的原子类计数，达到实现无锁操作的目的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_cas</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> cas = AtomicInteger(<span class="number">2</span>)</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		cas.getAndDecrement()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s2 = task2()</span><br><span class="line">		cas.getAndDecrement()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	<span class="keyword">while</span> (cas.<span class="keyword">get</span>() != <span class="number">0</span>) &#123;&#125;</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>while</code> 循环空转看起来有些浪费资源，但是自旋锁的本质就是这样，所以 CAS 仅仅适用于一些cpu密集型的短任务同步。</p>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">2</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_Volatile</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		cnt--</span><br><span class="line">	&#125;.start()</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s2 = task2()</span><br><span class="line">		cnt--</span><br><span class="line">	&#125;.start()</span><br><span class="line">	<span class="keyword">while</span> (cnt != <span class="number">0</span>) &#123;&#125;</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，这种写法是错误的，<code>volatile</code> 能保证可见性，但是不能保证原子性，<code>cnt--</code> 并非线程安全，需要加锁操作</strong></p>
<ol>
<li>获取cnt变量为2</li>
<li>操作数-1</li>
<li>写回内存</li>
</ol>
<p>volatile只能保证读取的时候是最新的，当两个线程都读完之后，分别执行了2步骤，再写回内存，结果被覆盖</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>上面无论有锁操作还是无锁操作，都需要定义两个变量<code>s1</code>、<code>s2</code>记录结果非常不方便。Java 1.5 开始，提供了 <code>Callable</code> 和 <code>Future</code> ，可以在任务执行结束时返回结果。</p>
<p>通过 <code>future.get()</code>，可以同步等待结果返回，写起来非常方便</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_future</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> future1 = FutureTask(Callable(task1))</span><br><span class="line">	<span class="keyword">val</span> future2 = FutureTask(Callable(task2))</span><br><span class="line">	Executors.newCachedThreadPool().execute(future1)</span><br><span class="line">	Executors.newCachedThreadPool().execute(future2)</span><br><span class="line">	task3(future1.<span class="keyword">get</span>(), future2.<span class="keyword">get</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>future.get()</code> 虽然方便，但是会阻塞线程。Java 8 中引入了 <code>CompletableFuture</code> ，他实现了 Future 接口的同时实现了 <code>CompletionStage</code> 接口。<code>CompletableFuture</code> 可以针对多个 <code>CompletionStage</code> 进行逻辑组合、实现复杂的异步编程。这些逻辑组合的方法以回调的形式避免了线程阻塞：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_CompletableFuture</span><span class="params">()</span></span> &#123;</span><br><span class="line">	CompletableFuture.supplyAsync(task1)</span><br><span class="line">		.thenCombine(CompletableFuture.supplyAsync(task2)) &#123; p1, p2 -&gt;</span><br><span class="line">				task3(p1, p2)</span><br><span class="line">		&#125;.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p><code>RxJava</code> 提供的各种操作符以及线程切换能力同样可以帮助我们实现需求：<code>zip</code> 操作符可以组合两个 <code>Observable</code> 的结果；<code>subscribeOn</code> 用来启动异步任务</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_Rxjava</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Observable.zip(</span><br><span class="line">		Observable.fromCallable(Callable(task1))</span><br><span class="line">			.subscribeOn(Schedulers.newThread()),</span><br><span class="line">		Observable.fromCallable(Callable(task2))</span><br><span class="line">			.subscribeOn(Schedulers.newThread()),</span><br><span class="line">    BiFunction(task3)</span><br><span class="line">  ).test().awaitTerminalEvent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>协程：<code>kotlin</code>特有</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_coroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> c1 = async(Dispatchers.IO) &#123;</span><br><span class="line">      task1()</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">val</span> c2 = async(Dispatchers.IO) &#123;</span><br><span class="line">      task2()</span><br><span class="line">    &#125;</span><br><span class="line">    task3(c1.await(), c2.await())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_flow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> flow1 = flow&lt;String&gt; &#123; emit(task1()) &#125;</span><br><span class="line">	<span class="keyword">val</span> flow2 = flow&lt;String&gt; &#123; emit(task2()) &#125;    </span><br><span class="line">	runBlocking &#123;</span><br><span class="line">		flow1.zip(flow2) &#123; t1, t2 -&gt;</span><br><span class="line">			task3(t1, t2)</span><br><span class="line">		&#125;.flowOn(Dispatchers.IO)</span><br><span class="line">		.collect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flowOn</code> 使得 Task 在异步计算并发射结果。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖（debounce）和节流（throttle）</title>
    <url>/2021/09/14/tech-2021-09-14-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖（debounce）和节流（throttle）"><a href="#防抖（debounce）和节流（throttle）" class="headerlink" title="防抖（debounce）和节流（throttle）"></a>防抖（debounce）和节流（throttle）</h1><ol>
<li>防抖：一段时间，多次点击，只保留最后一次事件。</li>
<li>节流：一段时间，多次点击，只执行第一次事件，之后的几次事件都会被过滤。</li>
</ol>
<p>使用场景：</p>
<ol>
<li>防抖：输入框连续输入，停下来之后再触发搜索。连续点击收藏按钮，只请求最后一次的状态</li>
<li>节流：防止按钮连续点击，如页面跳转事件，可能会打开多个页面。</li>
</ol>
<p>其他说法：</p>
<ol>
<li>防抖：连续触发事件时，只执行一次动作。每次触发事件，重新设定周期。</li>
<li>节流：一段时间内，触发多次事件，只执行一次动作。周期固定，动作定期执行，响应平滑。</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonUtil</span> </span>&#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _defaultDuration = <span class="number">500</span>;</span><br><span class="line">  <span class="keyword">static</span> Timer? _timer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现：延时执行，持续触发时取消定时</span></span><br><span class="line">  <span class="keyword">static</span> debounce(<span class="built_in">Function</span> func, &#123;durationTime = _defaultDuration&#125;) &#123;</span><br><span class="line">    _timer?.cancel();</span><br><span class="line">    _timer = <span class="keyword">new</span> Timer(<span class="built_in">Duration</span>(milliseconds: durationTime), () &#123;</span><br><span class="line">      func.call();</span><br><span class="line">      _timer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">int</span> _lastTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现1：保存上一次点击时间，间隔时间内不重复触发</span></span><br><span class="line">  <span class="keyword">static</span> throttle(<span class="built_in">Function</span> func, &#123;durationTime = _defaultDuration&#125;) &#123;</span><br><span class="line">    <span class="built_in">int</span> currentTime = <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch;</span><br><span class="line">    <span class="keyword">if</span> (currentTime - _lastTime &gt; durationTime) &#123;</span><br><span class="line">      func.call();</span><br><span class="line">      _lastTime = <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonUtil</span> </span>&#123; </span><br><span class="line">  <span class="keyword">static</span> debounce(<span class="built_in">Function</span> func, &#123;durationTime = _defaultDuration&#125;) &#123;</span><br><span class="line">    Timer? timer;</span><br><span class="line">    <span class="built_in">Function</span> target = () &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer?.isActive ?? <span class="keyword">false</span>) &#123;</span><br><span class="line">        timer?.cancel();</span><br><span class="line">      &#125;</span><br><span class="line">      timer = Timer(<span class="built_in">Duration</span>(milliseconds: durationTime), () &#123;</span><br><span class="line">        func.call();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现2：添加enable标记，通过Future或者await等待上一次事件执行完成，再接收下一个事件。</span></span><br><span class="line">  <span class="keyword">static</span> throttle(Future <span class="built_in">Function</span>() func) &#123;</span><br><span class="line">    <span class="built_in">bool</span> enable = <span class="keyword">true</span>;</span><br><span class="line">    <span class="built_in">Function</span> target = () &#123;</span><br><span class="line">      <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        enable = <span class="keyword">false</span>;</span><br><span class="line">	    func().then((_) =&gt; enable = <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考文章：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/375076538">Android&amp;RN&amp;Flutter实战——防抖节流函数</a></li>
<li><a href="https://blog.csdn.net/sinat_17775997/article/details/107108687">Flutter中的节流与防抖</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>UML-统一建模语言</title>
    <url>/2021/09/13/note-2021-09-13-UML/</url>
    <content><![CDATA[<h1 id="UML-Unified-Modeling-Language，-统一建模语言"><a href="#UML-Unified-Modeling-Language，-统一建模语言" class="headerlink" title="UML(Unified Modeling Language， 统一建模语言)"></a>UML(Unified Modeling Language， 统一建模语言)</h1><h2 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h2><ol>
<li>功能模型：从用户的角度展示系统的功能，包含用例图；</li>
<li>对象模型： 采用对象，属性，操作，关联等概念展示系统的结构，包括类图、对象图。</li>
<li>动态模型： 展现系统的内部行为，包括时序图，活动图，状态图。</li>
</ol>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li>需求分析： 用例图，对外部的参与者以及其需要的系统功能建模，表示客户需求；</li>
<li>概要设计： 类图、状态图、协作图、活动图，描述系统的静态结构、动态特征；</li>
<li>详细设计：状态图、协作图、活动图、序列图，产生技术解决方案；</li>
<li>测试：类图、构件图、部署图，单元测试使用类图，集成测试使用构件图、部署图。</li>
</ul>
<h1 id="用例图（Use-Case-Diagram）"><a href="#用例图（Use-Case-Diagram）" class="headerlink" title="用例图（Use Case Diagram）"></a>用例图（Use Case Diagram）</h1><ol>
<li>静态图</li>
<li>表现了系统角色划分，角色和用例间的关系，用例和用例间的关系</li>
<li>用于<strong>描述软件功能和需求</strong></li>
</ol>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><ol>
<li>角色（Actor）：与应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。</li>
<li>用例（Use Case）：用例就是外部可见的系统功能，对系统提供的服务进行描述。用椭圆表示。</li>
<li>子系统（Sub System）：用来展示系统的一部分功能，这部分功能联系紧密。</li>
</ol>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ol>
<li>关联(Association)：对象和用例之间的联系。</li>
<li>泛化(Inheritance)：对象和对象间、用例和用例间的继承关系。</li>
<li>包含(Include)：基础用例的子用例</li>
<li>扩展(Extend)：对基础用例的扩展，子用例是一个可选的过程</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li>导游继承游客</li>
<li>导游可以办理团队手续</li>
<li>游客可以办理个人手续</li>
<li>团队手续包含个人手续</li>
<li>办理个人手续的时候可以选择是否需要行李托运</li>
</ol>
<p><img src="https://g.gravizo.com/svg?
@startuml;
left to right direction;
actor 导游;
actor 游客;
导游 --|> 游客;
(团队手续办理) as A;
(个人手续办理) as B;
(行李托运) as C;
导游--A;
A -.-> B: [《include》];
C -.-> B: [《extend》];
游客 -- B;
@enduml
"></p>
<h1 id="活动图（Activity-Diagram）"><a href="#活动图（Activity-Diagram）" class="headerlink" title="活动图（Activity Diagram）"></a>活动图（Activity Diagram）</h1><ol>
<li>动态图</li>
<li>可以用<strong>泳道</strong>区分用例归属的角色，体现角色间的交互关系</li>
<li>用于<strong>描述软件功能和需求</strong></li>
</ol>
<h2 id="元素-1"><a href="#元素-1" class="headerlink" title="元素"></a>元素</h2><ol>
<li>初始节点：只有一个。实心圆表示。</li>
<li>活动终点：<strong>可以有多个</strong>。圆圈内加一个实心圆表示。</li>
<li>转换：转换到下一个活动，箭头表示</li>
<li>决策：根据条件判断转换到不同活动。菱形表示</li>
<li>分叉和汇合：分叉用于将动作分为多个并行的分支，汇合用于同步这些分支。使用圆角矩形表示</li>
<li>泳道：将活动划分到不同对象进行</li>
</ol>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><img src="https://g.gravizo.com/svg?
@startuml;
title 考试活动;
|学生|;
start;
-进入考场;
fork;
-对号入座;
|监考老师|;
fork again;
if (检查证件) then (证件忘带);
|学生|;
stop;
note right: 退出考场;
else (证件正确);
|监考老师|;
-发考卷;
endif;
end fork;
|学生|;
-开始答题;
stop;
note right: 考试结束;
@enduml
"></p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><ol>
<li>描述的是系统的静态结构，表达期望的软件实现方案</li>
<li>描述系统中类、接口级别的设计，描述每个类的功能和关系</li>
</ol>
<h2 id="元素-2"><a href="#元素-2" class="headerlink" title="元素"></a>元素</h2><ul>
<li><code>+</code> public</li>
<li><code>-</code> private</li>
<li><code>#</code> protected</li>
<li><code>~</code> package/internal</li>
<li><code>*</code> abstract: <code>someAbstractMethod()*</code>，抽象方法，斜体</li>
<li><code>$</code> static: <code>someStaticMethod()$</code>，静态方法，下划线</li>
</ul>
<h2 id="关系-1"><a href="#关系-1" class="headerlink" title="关系"></a>关系</h2><ol>
<li>泛化：继承关系，空心三角实线表示</li>
<li>实现：接口实现，空心三角虚线表示</li>
<li>依赖：弱一点的关联，一般是局部变量、参数，虚线箭头表示</li>
<li>关联（单向关联、双向关联、自关联）：持有关系，一般是成员变量，自关联如链表节点，实线箭头表示。</li>
<li>组合：关联关系的一种，A组合B，B不可以脱离A单独存在，实心菱形直线表示</li>
<li>聚合：关联关系的一种，A聚合B，B可以脱离A单独存在，空心菱形直线表示</li>
</ol>
<p>关系强弱：泛化&gt;= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖</p>
<p>关联、组合、聚合在代码中的体现都是成员变量，需要结合语义上下文才能判断是什么关系。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><pre class="mermaid">classDiagram
class IName{
<<interface>>
+name()
}
class Person{
<<abstract>>
+name()
+say()
+drive(Car car)
}
class Car
class Student{
+say()
+name()
}
class Teacher{
+say()
+name()
+setCompany(Company company)
}
class Company{
- departments: Department[]
}
class Department

Person ..|> IName : 实现
Student --|> Person : 继承
Teacher --|> Person : 继承
Person ..> Car : 依赖
Company *--> Department : 1对多
Teacher o--> Company : 1对1</abstract></interface></pre>

<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><ol>
<li>动态图</li>
<li>描述对象之间的消息类型和交互顺序</li>
</ol>
<h2 id="元素-3"><a href="#元素-3" class="headerlink" title="元素"></a>元素</h2><ol>
<li>角色</li>
<li>对象：时序图顶部，矩形表示</li>
<li>生命线：表示对象的生命周期，垂直虚线表示</li>
<li>控制焦点：对象在某个时间段内执行的操作，控制焦点两端不要超过矩形</li>
<li>消息<ol>
<li>同步消息：消息发送者把控制传递给消息接受者，然后停止活动，等待接收者放弃或者返回控制，实心三角箭头实线表示</li>
<li>异步消息：消息发送者把控制传递给消息接受者，然后继续自己的活动，不等待接收者返回，实线箭头表示</li>
<li>返回消息：虚线箭头表示</li>
<li>自关联消息：对象调用自身方法，指向自身</li>
</ol>
</li>
<li>组合片段：指定条件或者子进程应用区域<ol>
<li>抉择（Alt）：片段包含多个备用消息序列，只发生一个消息序列，相当于if…else</li>
<li>选项（Opt）：片段包含一个可能发生或者不发生的消息序列，相当于if…</li>
<li>循环（Loop）：片段重复一定次数，可以指定片段重复条件，相当于for…</li>
<li>中断（Break）：如果执行此片段，则放弃序列中其余部分</li>
<li>并行（Par）：片段中的事件可以并行交错执行，相当于多线程</li>
<li>….</li>
</ol>
</li>
</ol>
<p>注：同步消息和返回消息不一定是成对的，返回为void时可省略</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><pre class="mermaid">sequenceDiagram
participant 用户
participant 系统
participant 后台
note right of 用户: 不支持异步消息画法，都使用实线三角
note right of 用户: 不支持控制焦点矩形
用户->>系统: 登录
系统-->>用户: 返回登陆页面
用户->>系统: 输入账号密码
系统->>后台: 提交用户信息
后台->>后台: 校验用户信息
后台-->>系统: 返回登录结果
alt 校验失败
系统->>用户: 显示登录失败
else 校验成功
系统->>用户: 显示登录成功
end</pre>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>只介绍了一部分常用的图和用法，其余的不展开介绍了</p>
<p>注：</p>
<p><code>mermaid</code>不支持用例图、活动图，可以使用<code>gravizo</code>生成<code>plantuml</code>图，不能空行，结尾要加分号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&#39;https:&#x2F;&#x2F;g.gravizo.com&#x2F;svg?</span><br><span class="line">@startuml;</span><br><span class="line">...</span><br><span class="line">@enduml;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参考文章</strong>：</p>
<ul>
<li><a href="https://g.gravizo.com/">gravizo</a></li>
<li><a href="https://plantuml.com/zh/">plantuml</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>CI——回首毕业论文</title>
    <url>/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文源于本人本科毕业论文—— 《面向Android项目的持续集成系统的设计与实现》，把论文内容整理成博客。</p>
<p>时隔两年多再看，当时整体的思想和系统设计还是比较领先的。当然经历了更多的项目，见识过了大团队的CI，也有了更多的感悟，发现一些功能和细节可以更加完善。</p>
<h1 id="论文内容"><a href="#论文内容" class="headerlink" title="论文内容"></a>论文内容</h1><p><strong>标题</strong>：面向Android项目的持续集成系统的设计与开发</p>
<p>DESIGN AND IMPLEMENTATION OF CONTINUOUS INTEGRATION SYSTEM FOR ANDROID PROJECT</p>
<p><strong>摘要</strong>: 本文结合Android组件化架构设计了一套基于Jenkins的持续集成方案，通过自动化构建、集成、打包等一系列环节，规范软件开发流程、缩短迭代周期、及时发现问题、减少发布风险、保证软件质量，能够快速地响应需求变化，随时提供可以运行的软件版本，提高了软件在开发过程中的可见性。</p>
<p>该系统主要由Web前端、Web后端、Jenkins服务、Maven私有仓库等多个部分组成。其中前端用于进行组件、项目的管理和构建以及日志查看；后端实现了请求响应、数据存储、WebSocket即时推送通知等功能；Jenkins服务提供了统一的开发环境，根据配置和脚本执行构建任务，并推送构建结果到后端和个人邮箱；Maven私有仓库用于存放依赖包。</p>
<p>本文前半部分介绍了持续集成的相关理论以及项目中所用到的技术，后半部分详细说明了持续集成方案的实施步骤和开发过程，并通过具体项目案例，验证了系统的可行性和意义。</p>
<p><strong>关键词</strong>：持续集成；敏捷开发；Jenkins；Android组件化</p>
<p><strong>DESIGN AND IMPLEMENTATION OF CONTINUOUS INTEGRATION SYSTEM FOR ANDROID PROJECT</strong></p>
<p><strong>Abstract:</strong> This paper desgin a Continuous Integration scheme based on Jenkins which is combined with Android Component-based Architecture. Through a series of links such as build, integrate and package automatically, it can standardize the process of software development, shorten the cycle of iteration, find the problem of project in time, reduce the risk of release and ensure the quality of software. What’s more, it can respond to the change of demand quickly and provide runnable software versions at any time which has improved the visibility of software in the development. </p>
<p>This system is mainly composed of Web front-end, Web back-end, Jenkins service and Maven repository. The front-end is used to manage and build components or project as well as checking log. The back-end can respond the request from front-end, save data and realize the instant push by WebSocket. Jenkins service provides a unified environment of development and execute the task according to the configuration and scripts. In addition, it can push the result of buildings to the back-end and the mailboxes. The Maven repository is used to store the dependency files. </p>
<p>The first part of this paper introduces the related theory of Continuous Integration and some technology used in the project. The second part describes the implementation steps and development process of my Continuous Integration scheme in detail. Moreover, it verifies the significance and feasibility of the system through a specific case. </p>
<p><strong>Keywords:</strong> Continuous Integration；Agile Development；Jenkins；Android Component-Based Architecture</p>
<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="1-1-课题背景"><a href="#1-1-课题背景" class="headerlink" title="1.1 课题背景"></a>1.1 课题背景</h2><p>随着互联网的飞速发展、软件架构日益复杂，传统的瀑布式开发、集中式软件测试已不能适应需求频繁变更、快速迭代的要求。如何应对频繁的需求变更，并且在缩短软件开发周期的同时保证产品质量[1]、减少发布风险，成了人们研究的问题。敏捷软件开发模式应运而生。</p>
<p>敏捷开发的概念源于Kent Beck在90年代初期提出的软件开发思想——极限编程（简称XP[2]），持续集成（简称CI）便是XP中提出的实践。</p>
<p>2000年，Martin Fowler定义了持续集成：持续集成是一种软件开发实践，项目成员需要频繁对他们的工作进行集成，每天至少集成一次，并且进行自动化测试，这样就能够及时地发现项目缺陷[3]。</p>
<p>国外团队对持续集成的探索和实践起步较早。相继出现了CruiseControl、Hudson、LuntBuild、QuickBuild和Bamboo，以及近几年发展起来的Jenkins等持续集成工具[4]。</p>
<p>近几年国内许多团队也开始引入到实际项目开发中，实现了快速迭代，提高了开发效率。如何选择持续集成方案需要根据团队、业务和项目情况等因素综合考虑。</p>
<h2 id="1-2-研究目标和内容"><a href="#1-2-研究目标和内容" class="headerlink" title="1.2 研究目标和内容"></a>1.2 研究目标和内容</h2><p>本课题在研究持续集成理论的基础上，利用Git（版本控制工具）、Gradle（构建工具）、Maven（构件仓库）、Jenkins（持续集成工具）等多种工具和技术，针对Android组件化项目的架构和存在的问题，实现了一套的持续集成系统。由Web前端、Web后端、Jenkins服务、代码仓库和构件仓库等各部分组成，实现了一条Android项目构建、集成到部署的流水线，用于规范开发流程、减少重复工作、及时发现问题、缩短迭代周期，方便对组件和项目进行管理，提高效率，快速迭代，真正达到敏捷开发。</p>
<p>本系统预期实现的目标如下：</p>
<p>（1）减少重复劳动，降低手动维护成本和出错概率，提高效率。</p>
<p>（2）避免构建环境不一致出现的问题，减少环境部署时间。</p>
<p>（3）通过版本控制系统统一管理代码。</p>
<p>（4）通过邮件和前端通知及时反馈问题，并可以通过链接查看和定位问题。</p>
<p>（5）实现代码质量检查、测试、构建、发布自动化，无需开发者手动执行脚本。</p>
<p>（6）Jenkins后台执行构建，避免开发者本地编译忙等，耗时费力，且无法保存构建记录，不便于事后追溯。</p>
<p>（7）能够随时提供可运行的软件供测试团队进行测试。</p>
<p>（8）项目进度可见可控，降低了沟通成本。</p>
<p>（9）避免软件最终集成时一次性暴露大量错误，难以定位等问题。</p>
<p>（10）前端统一对组件、项目进行管理，能够及时收到更新通知，能够查看组件和项目信息、构建历史、责任人等，易于追溯问题，并且可以在这一环节加入权限控制。</p>
<p>（11）后端实现响应请求、对数据进行存储、验证，与Jenkins服务交互，并实现主动推送等功能。</p>
<h2 id="1-3-论文结构安排"><a href="#1-3-论文结构安排" class="headerlink" title="1.3 论文结构安排"></a>1.3 论文结构安排</h2><p>第一章：介绍课题背景、研究目标和内容以及论文的结构。</p>
<p>第二章：对比传统的瀑布式开发模型，针对其问题和不足引出持续集成理论。研究和分析本课题相关技术，包括Android组件化架构和技术，Docker虚拟化技术等。</p>
<p>第三章：通过对比两种开发模式和流程分析了系统的需求和实现的意义。</p>
<p>第四章：设计持续集成系统功能和架构以及关键流程，能够进行Android组件和项目的可视化管理，执行Android组件和项目的构建、打包、部署等任务，将构建结果反馈到前端，并且通过邮件通知用户。</p>
<p>第五章：详细讲述了系统的实施步骤和流程，包括组件化方案设计和实现，Maven私服和Jenkins服务搭建，以及前后端的关键实现等。</p>
<p>第六章：搭建Android组件化架构，通过具体的项目案例演示了开发流程和系统的使用流程。</p>
<p>第七章：总结课题内容，提出系统下一步的优化方案。</p>
<p>致谢和参考文献。</p>
<h1 id="2-相关理论与技术"><a href="#2-相关理论与技术" class="headerlink" title="2 相关理论与技术"></a>2 相关理论与技术</h1><h2 id="2-1-瀑布式开发和敏捷开发"><a href="#2-1-瀑布式开发和敏捷开发" class="headerlink" title="2.1 瀑布式开发和敏捷开发"></a>2.1 瀑布式开发和敏捷开发</h2><p>传统软件开发流程采用“瀑布式”开发模型[5]，这种模式源于工业生产，它的开发过程包括市场调研、需求分析、产品设计、程序开发、软件测试、成品发布、后期维护等阶段，每个阶段都需要制定明确的目标，并且提供详尽的文档，按照计划一步步执行，步骤清晰明确，可预见性强，能够避免资源的无效投入，保证开发质量。但在这种开发模式下，只有项目初期的想法和建议允许加入开发计划中，在开发过程中不允许加入新的需求。而事实上，随着开发过程逐渐深入、技术架构的日新月异和市场的快速变化，好的想法和建议也会不断涌现[6]。因此，这种开发模式在需要快速产出、占领市场先机和需求不明的情况下基本是不可行的。同时在此期间，项目程序将长期不能运行[7]，需要等到所有分支开发结束后才能进行测试和集成的工作，并且一旦分支偏离主干太远，会造成项目集成困难、问题频发且不容易定位，导致项目发布前混乱紧张的局面甚至延期发布。</p>
<p>敏捷开发提倡拥抱变化，进行软件迭代开发，将大项目分为一个个子项目，每个子项目都可以独立的运行、测试、集成等，因此软件能够随时地集成使用和交付。敏捷开发借鉴了XP的思想，提出了12条原则[8]，并建立了以下价值观：</p>
<p>（1）个体和互动高于流程和工具</p>
<p>（2）可运行的软件高于详尽的文档</p>
<p>（3）客户合作高于合同谈判</p>
<p>（4）响应变化高于遵循计划</p>
<p>相比传统的瀑布开发，敏捷开发模式具有更强地适应性和灵活性，它强调“以人为本、目标导向、客户为先、拥抱变化”，要求快速迭代和及早测试，它的出现影响了团队开发的工作方式，也改变了软件发布的方式。</p>
<h2 id="2-2-持续集成"><a href="#2-2-持续集成" class="headerlink" title="2.2 持续集成"></a>2.2 持续集成</h2><p>为了验证开发者提交的最新代码能否编译成功，能否通过自动化测试用例，以及是否会影响项目集成等。可以通过频繁地进行集成，可以快速得到反馈，容易知道是哪次提交导致集成失败，易于开发者定位问题。我们将这种方法称为持续集成，也叫作每日构建[9]。</p>
<p>CI是敏捷开发最为成功的实践之一[10]，它最大的好处在于降低风险，它无法消除问题，但是可以帮助你快速发现问题，及时反馈。通过自动化构建、代码检查、测试和发布流水线[11]，能够减少开发人员手动编译、打包的时间，有效提高软件开发效率、及时发现项目缺陷，降低发布风险，保障软件开发质量，同时对团队所有成员来说整个开发过程可见，能够辅助项目负责人把控项目整体进度，帮助开发者定位问题，还能增强大家对产品的信心。</p>
<p>持续集成有以下几点原则：</p>
<p>（1）要求开发者控制好代码提交粒度，及时push，不然就失去了持续构建的意义。</p>
<p>（2）使用专门的机器进行每日构建。</p>
<p>（3）优先修复失败构建。</p>
<p>（4）保证每次构建都通过，能够生成可运行和发布的软件。</p>
<p>持续集成具体流程如图2-1所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="持续集成开发流程图"> </p>
<center> 图2-1 持续集成开发流程图[12]</center>

<h2 id="2-3-Android组件化架构和技术"><a href="#2-3-Android组件化架构和技术" class="headerlink" title="2.3 Android组件化架构和技术"></a>2.3 Android组件化架构和技术</h2><p>随着APP业务逐渐复杂，功能不断增加，项目工程会越来越庞大。为了减少代码间的耦合，通过Gradle的Module功能，将项目分成一个个子模块。每个模块能够单独进行开发、编译、打包、调试，可以拆卸和移植，通过依赖的方式进行管理，并且组件间可以相互通信。组件化架构能够很好地实现业务和代码的解耦，还便于控制代码权限。</p>
<p>Android组件化架构[13]利用了Gradle的这一特性，建议将模块分类进行管理，由上往下进行依赖，分为：</p>
<p>（1）壳组件：用于将整个项目进行打包，生成可安装的apk文件，即安卓安装包。</p>
<p>（2）业务组件：根据业务的不同进行划分，实现了完整的业务功能。</p>
<p>（3）功能组件：封装了一些常用功能，供业务组件使用。如网络、数据库、图片加载、日志、UI等框架。</p>
<p>（4）基础组件：封装了通用的工具类、基础类和资源等，供其他业务组件使用。</p>
<p>（5）三方库：一些开源的三方框架，由框架作者进行维护，存放在远程仓库中。</p>
<p>安卓组件化架构如图2-2。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Android组件化架构图"> </p>
<center>图2-2 Android组件化架构图</center>

<p>目前流行的组件化方案主要有两种，如下：</p>
<p>（1）Sub-Module方案：整个项目只有一个工程，所有模块共用一个仓库，或者每个module创建自己的仓库，通过Git的子仓库功能进行管理。缺点是仓库分支复杂，代码耦合度较高，团队协作的时候容易发生冲突，而且每次调试都需要对所有的模块进行编译，耗时费力。</p>
<p>Sub-Module架构如图2-3所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Sub-Module%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A8%A1%E5%BC%8F.png" alt="Sub-Module组件化模式"> </p>
<center>图2-3 Sub-Module组件化模式</center>

<p>（2）Multi-Project模式：根据业务拆分工程，每个工程都包含壳模块和业务模块，将业务模块编译打包成aar上传至构件仓库，通过修改壳工程的依赖配置集成项目，通过git仓库的权限管理，可以保证代码不被他人修改查看，并且项目编译的时候不需要编译其他组件。</p>
<p>Multi-Project架构如图2-4所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Multi-Project%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A8%A1%E5%BC%8F.png" alt="Multi-Project组件化模式"> </p>
<center>图2-4 Multi-Project组件化模式</center>

<p>两种模式需要根据项目情况选择，主要取决于业务特性、团队规模、组件化细分粒度等条件。对于小型且不需要频繁迭代的团队选择Submodule模式较合适。对于大型团队且迭代频繁的团队选择Multi-Project方案较合适。本毕业设计决定选择第二种方案实现组件化方架构，并针对Multi-Project模式设计软件开发流程、前端交互和数据库结构等。</p>
<h2 id="2-4-Docker虚拟化技术"><a href="#2-4-Docker虚拟化技术" class="headerlink" title="2.4 Docker虚拟化技术"></a>2.4 Docker虚拟化技术</h2><p>Docker有几个概念[14]：</p>
<p>（1）Image（镜像）：用于创建Docker容器的模板。</p>
<p>（2）Container（容器）：是独立运行的一个或一组应用。</p>
<p>（3）Registry（仓库）：用于保存镜像，类似代码仓库，Docker Hub是官方的镜像仓库，提供了大量的镜像。</p>
<p>Docker的基本架构如下图2-5：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="Docker架构图"> </p>
<center>图2-5 Docker架构图</center>

<p>开发者能够将他们的应用或服务打包成一个镜像，发布到镜像仓库上，用户可以从远程仓库中下载镜像，并且以镜像为模板创建具体的容器来运行软件。Docker使用操作系统虚拟化技术，为应用提供隔离的运行环境，不同容器之间没有任何关联。容器拥有独立的权限管理和资源管理，以及独立的网络环境，相当于一个独立的虚拟机，也就是说所有的程序开发环境都需要在容器内再安装一遍，并且需要配置环境变量。通过容器可移植的特性，可以实现一次构建、处处运行，而不需要针对不同系统重新进行构建和部署。</p>
<p>与虚拟机相比，它具有更轻量，启动更加快速等特点，并且同一台主机上可以运行多个Docker容器。Docker容器的原理是利用了Linux的命名空间、控制组等特性对容器进行隔离，降低了每个容器的系统开销。</p>
<p>另外容器删除后，容器内的数据会清空，因此需要使用类似Linux的挂载技术，将主机路径挂载到容器中，容器数据存放在主机目录下，重新创建容器时只需要指定数据挂载目录，即可实现持久化数据。</p>
<h1 id="3-系统需求分析"><a href="#3-系统需求分析" class="headerlink" title="3 系统需求分析"></a>3 系统需求分析</h1><p>本章将针对项目在接入持续集成平台前后的开发模式进行详细对比，来分析开发这套系统的必要性。</p>
<p>以Multi-Project组件化方案为例，在接入持续集成平台之前，整体的开发流程如图3-1所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%97%A9%E6%9C%9F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="早期项目开发流程图"> </p>
<center>图3-1 早期项目开发流程图</center>

<p>在上述流程中，存在以下几个缺陷：</p>
<p>（1）开发者需要手动在代码中定义构件名称并修改组件版本号，随源代码一起提交。可能会存在构件名称或版本命名不统一（包括版本前后命名不统一、不同成员间的不统一），测试版和正式版需要分别构建等，造成构件仓库混乱的问题。且Maven仓库限制除了snapshot的构件以外，其他构件不能拥有两个一样的版本号，因此可能会存在发布失败的情况。</p>
<p>（2）开发人员手动构建时间长，浪费了大部分开发时间，且开发者们的构建环境不一致，容易出现问题。</p>
<p>（3）管理员需要和多个开发者沟通、频繁进行重复性操作更新依赖配置，效率低下且容易出错。管理员每天都需要等待项目打包成功，将apk交付测试。</p>
<p>（4）集成操作复杂，需要各个组件负责人配合，可以合并为一个步骤。</p>
<p>在接入持续集成平台之后，整体的开发流程如图3-2所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%8E%A5%E5%85%A5%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="接入系统后项目开发流程图"> </p>
<center>图3-2 接入系统之后项目开发流程图</center>

<p>相比之前的方式，有了以下几点改进：</p>
<p>（1）平台可以对组件进行管理，组件创建需要指定代码仓库、分支等，由服务端记录和保存，并可以进行校验，如不允许添加重复组件等。且组件版本号按照一定规则递增，开发者不需要关心，只需要在平台上确认构建。避免了构件仓库混乱的现象。</p>
<p>（2）构建和集成的任务都在Jenkins服务中执行，减少了开发者编译和构建代码的时间，并且确保了构建环境统一。</p>
<p>（3）减少了管理员和开发者或者测试团队的沟通成本。所有组件和项目信息和构建历史记录都保存下来，所有人都能够随时查看，方便地定位错误，追溯问题。</p>
<p>（4）平台操作简便，学习成本低，可以供产品经理或者测试人员共同使用。</p>
<p>（5）平台可以实现自动化构建、质量检查、测试、集成、打包等功能，减少重复性操作，节约时间。</p>
<h1 id="4-系统概要设计"><a href="#4-系统概要设计" class="headerlink" title="4 系统概要设计"></a>4 系统概要设计</h1><p>如何合理的管理组件和项目，建立项目组件关联，方便用户使用是本系统要研究的最大的问题。并且需要结合团队和项目情况选择合适的方案，如构建时机选择手动触发、还是git自动触发或者定时触发。只有优化了管理和开发流程，本系统的意义才能真正体现出来。</p>
<h2 id="4-1-系统功能"><a href="#4-1-系统功能" class="headerlink" title="4.1 系统功能"></a>4.1 系统功能</h2><p>本系统主要分为五个部分：</p>
<p>（1）Android组件化项目：用于系统功能测试和演示。</p>
<p>（2）Maven私服：用于存放依赖包，通过Gradle插件可以进行软件包的上传和依赖库管理。</p>
<p>（3）前端网页：用于提供可视化的操作页面，供项目管理者、开发者、测试人员等使用。可以进行组件和项目的管理、构建，并且可以查看构建日志、应用下载地址等。并且实现表单检查、数据排序、筛选、查找等功能。简单易用，提高了项目开发过程的可见性。</p>
<p>（4）Web后端：用于响应前端请求，进行数据连接和CRUD操作，调用Jenkins API，接收Jenkins消息等，通过WebSocket实现主动推送。并且需要实现异常拦截、错误处理、日志记录等功能。</p>
<p>（5）Jenkins服务端：提供统一的构建环境，如git、python、gradle、java等，可以创建或执行后台自动化构建、发布等Job，并且实现版本控制和邮件通知功能。</p>
<p>由于Docker容器的隔离性，各容器之间系统、网络、端口等都是独立的，导致难以通信，包括宿主机访问容器，容器访问宿主机，容器访问公网，容器之间互相访问等存在问题。因此本系统实现的一个关键点在于系统间各个部分如何通信、连接，相互协作完成整个工作流程，以及如何进行事务控制，保证数据的正确性等。本系统最终采用以下方案：</p>
<p>（1）前后端使用http协议通信，前端发起http请求，后端进行业务处理，然后对请求进行响应，关闭连接。</p>
<p>（2）由于某些请求如后台构建，无法立即响应结果，因此需要实现后端主动向前端推送通知的功能。可以通过轮询、长连接、WebSocket实现，本系统采用WebSocket。</p>
<p>（3）后端与Jenkins之间可以通过http或者RPC协议进行通信，这里选择http，Jenkins服务提供了RESTFul API供后端调用。Jenkins在执行完任务之后可以通过python或者shell脚本发起http请求。</p>
<p>（4）Jenkins服务通过gradle插件上传应用包到Maven仓库。</p>
<p>（5）Jenkins服务使用Git工具对Android项目进行版本控制。</p>
<h2 id="4-2-架构设计"><a href="#4-2-架构设计" class="headerlink" title="4.2 架构设计"></a>4.2 架构设计</h2><p>系统架构设计如图4-1所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/CI%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="CI系统架构图"> </p>
<center>图4-1 CI系统架构图</center>

<h2 id="4-3-团队协作开发流程"><a href="#4-3-团队协作开发流程" class="headerlink" title="4.3 团队协作开发流程"></a>4.3 团队协作开发流程</h2><p>接入持续集成系统后大大地能够优化团队android组件化项目的开发流程，减化了开发者和管理员的部分重复性操作，降低了沟通成本，所有的构建都在远程执行，保证了构建环境的一致，并且开发人员不需要忙等。预期工作流程如图4-2所示，流程如下：</p>
<p>（1）开启新项目时由管理员在平台上创建并配置好项目信息。开发人员创建或更新各自的组件信息。</p>
<p>（2）开发人员拉取最新代码，进行开发或修复问题，提交代码到远程仓库，之后在平台上点击构建组件。</p>
<p>（3）管理员更新项目依赖的组件版本，通过邮件或者红点提示知道是否有新版本。</p>
<p>（4）管理人员在平台上手动点击构建项目，也可以设置定时自动构建，或者git触发构建。项目构建完成后自动上传apk到蒲公英应用托管仓库，并且返回下载地址。</p>
<p>（5）测试团队可以在平台上点击下载地址，进入下载页面，获取最新的应用包进行测试，并反馈测试结果给开发者。</p>
<p>（6）循环3-5步，直到项目开发完成，测试通过，管理员可以集成并发布项目。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A2%84%E6%9C%9F%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.jpg" alt="预期团队开发流程"> </p>
<center>图4-2 预期团队开发流程</center>

<h2 id="4-4-系统内部运行关键流程"><a href="#4-4-系统内部运行关键流程" class="headerlink" title="4.4 系统内部运行关键流程"></a>4.4 系统内部运行关键流程</h2><h3 id="4-4-1-创建组件流程"><a href="#4-4-1-创建组件流程" class="headerlink" title="4.4.1 创建组件流程"></a>4.4.1 创建组件流程</h3><p>创建组件需要填写组件基本信息，限制不允许出现同名组件，同时Jenkins服务端根据配置模板创建相应的Job，创建成功之后数据库会插入组件信息，创建失败则不插入，最后前端根据返回的结果弹出相应提示。具体流程如图4-3所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" alt="组件创建流程"> </p>
<center>图4-3 组件创建流程</center>

<h3 id="4-4-2-组件构建流程"><a href="#4-4-2-组件构建流程" class="headerlink" title="4.4.2 组件构建流程"></a>4.4.2 组件构建流程</h3><p>构建组件会在后台执行，前端请求成功之后更新组件状态为正在构建，同时Jenkins服务端开始执行Job，从远程仓库拉取代码，修改版本号，接着对组件源码进行编译和打包，上传aar包到Maven私服，然后提交代码。最后通知后端任务执行结果，后端保存构建记录并将结果发送到前端，前端更新组件信息和构建历史。同时任务执行结果还会以邮件形式通知到用户。具体流程如图4-4所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" alt="组件构建流程"> </p>
<center>图4-4 组件构建流程</center>

<h3 id="4-4-3-项目集成流程"><a href="#4-4-3-项目集成流程" class="headerlink" title="4.4.3 项目集成流程"></a>4.4.3 项目集成流程</h3><p>项目集成同样在后台执行，Jenkins Job会更新项目依赖，获取最新依赖包，进行项目编译和打包，将打出来的应用上传到应用托管仓库，并且提交代码。最后通知后端任务执行结果，后端保存记录并将结果发送到前端，前端更新项目信息和构建历史，并且能够链接到应用下载地址。同时任务执行结果会以邮件形式通知到用户。具体流程如图4-5所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E6%B5%81%E7%A8%8B.jpg" alt="项目集成流程"> </p>
<center>图4-5 项目集成流程</center>

<h1 id="5-系统实现"><a href="#5-系统实现" class="headerlink" title="5 系统实现"></a>5 系统实现</h1><p>整个系统实现步骤和流程如图5-1，首先研究相应的技术，各部分先单独实现和测试，再进行各个部分的联调测试。最终通过案例进行整体的流程测试，优化功能和代码结构。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%E5%92%8C%E6%B5%81%E7%A8%8B.jpg" alt="系统实现步骤和流程"> </p>
<center>图5-1 系统实现步骤和流程</center>

<h2 id="5-1-组件化方案实现"><a href="#5-1-组件化方案实现" class="headerlink" title="5.1 组件化方案实现"></a>5.1 组件化方案实现</h2><p>从GitHub下载了一个开源的Android项目作为演示项目，功能较简单，实现了主页、每日新闻，每日图片等功能[15]。案例效果图如5-2</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C.jpg" alt="组件化案例效果"> </p>
<center>图5-2 组件化案例效果</center>

<p>使用Multi-Project组件化方案对其进行改造，所有组件都包含壳模块，最终拆分为6个工程，分别为：</p>
<p>（1）壳模块：只包含Android工程中主模块的代码，用于管理依赖包、存放项目构建和打包等配置以及其他一些资源，如apk签名文件，多国语言包等。</p>
<p>（2）壳组件：不包含业务模块，只作为壳工程，用于打包apk。</p>
<p>（3）公共组件：属于基础组件，包含基础类、公共类等代码和公共资源，作为底层库供所有业务组件使用。</p>
<p>（4）主页组件：实现了应用的Home业务，由Home页面可以跳转到新闻页面和图片欣赏页面。</p>
<p>（5）新闻组件：实现了查看每日新闻业务。</p>
<p>（6）美女图片组件：实现了图片欣赏业务。</p>
<h3 id="5-1-1-代码版本控制工具"><a href="#5-1-1-代码版本控制工具" class="headerlink" title="5.1.1 代码版本控制工具"></a>5.1.1 代码版本控制工具</h3><p>本系统使用GitHub作为代码仓库，共建立了6个代码仓库，分别存放上述6个工程。其中壳模块使用Git工具的submodule功能，作为所有组件的子模块，存在于其他5个工程之中。子模块本质也是一个代码仓库，只不过通过submodule将其与其他工程关联起来。</p>
<p>本方案中壳模块只用于存放依赖配置和部分资源，由管理员或持续集成平台对其进行更新和提交代码，其他组件只能通过壳模块获取最新的配置，并用其进行打包，在其他组件中不建议直接修改壳模块文件，或者向壳模块提交代码，即使修改了也应该只用于本地临时使用，正式使用仍然需要拉取远程仓库的代码覆盖本地配置，可以对该仓库进行代码提交的权限控制。</p>
<p>Git的sumodule相关配置在.gitmodules文件中，如图5-3所示，声明了子模块的名称，仓库地址，分支等。在工程目录下可以通过git submodule update –remote命令拉取子模块的最新代码，或者进入子模块目录下使用git pull命令拉取代码。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Git%E5%AD%90%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="Git子模块配置文件"> </p>
<center>图5-3 Git子模块配置文件</center>

<h3 id="5-1-2-Gradle构建工具"><a href="#5-1-2-Gradle构建工具" class="headerlink" title="5.1.2 Gradle构建工具"></a>5.1.2 Gradle构建工具</h3><p>Gradle是一个类似Ant和Maven的开源项目构建工具，使用Groovy语言的DSL（领域特定语言）来配置项目。提供依赖管理、多工程管理和局部构建功能，并且对脚本和插件支持良好。</p>
<p>可以通过IDE或者使用Gradle命令行执行构建、打包等Task。此外，Android项目还支持使用Gradle包装命令的方式来构建、打包Android的组件和项目：</p>
<p>（1）构建组件：使用maven插件配置构件名称、版本等信息。如图5-4所示。然后在工程目录下执行gradlew :组件名:upload，即可自动构建组件，并上传aar包到依赖仓库。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E9%85%8D%E7%BD%AE.jpg" alt="组件打包上传配置"> </p>
<center>图5-4 组件打包上传配置</center>

<p>（2）打包项目：进行Android项目的相关配置，然后在工程目录下执行gradlew assembleDebug来打包Debug版apk，通过assembleRelease来打包正式版的apk。</p>
<h2 id="5-2-Docker搭建Maven私服"><a href="#5-2-Docker搭建Maven私服" class="headerlink" title="5.2 Docker搭建Maven私服"></a>5.2 Docker搭建Maven私服</h2><h3 id="5-2-1-Docker安装"><a href="#5-2-1-Docker安装" class="headerlink" title="5.2.1 Docker安装"></a>5.2.1 Docker安装</h3><p>本系统通过Docker部署Maven私有仓库，需要安装Docker，步骤如下：</p>
<p>首先需要开启Win10虚拟化技术：打开【Windows程序和功能-&gt;启用或关闭Windows功能-&gt;选中Hyper-V】。如图5-5所示。然后从官网下载Docker for windows并按照提示安装即可。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Win10%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.png" alt="Win10开启虚拟化技术"> </p>
<center>图5-5 Win10开启虚拟化技术</center>

<p>由于国内下载Docker镜像速度较慢，因此需要配置镜像加速器，这里使用官方中国区镜像地址，配置方式如图5-6所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F.jpg" alt="Docker配置国内镜像"> </p>
<center>图5-6 Docker国内镜像源地址</center>

<h3 id="5-2-2-Nexus服务搭建"><a href="#5-2-2-Nexus服务搭建" class="headerlink" title="5.2.2 Nexus服务搭建"></a>5.2.2 Nexus服务搭建</h3><p>首先通过【docker search nexus】命令查找Nexus镜像，如图5-7可以看到有很多镜像可以选择，这里选择第一个镜像：sonatype/nexus3。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E6%90%9C%E7%B4%A2Nexus%E9%95%9C%E5%83%8F.jpg" alt="Docker搜索Nexus镜像"> </p>
<center>图5-7 Docker搜索Nexus镜像</center>

<p>然后使用【docker run -d -p 8081:8081 –name nexus3 -v /d/Docker/Volume/Nexus3:/nexus-data sonatype/nexus3】命令运行nexus3容器。其中【docker run [OPTIONS] <IMAGE>】命令用来创建并运行容器，如果本地没有镜像，则会从Docker Hub获取。</IMAGE></p>
<p>运行成功后，可以访问8081端口，出现图5-8页面则表示Nexus服务成功运行。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Nexus%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="Nexus服务运行结果"> </p>
<center>图5-8 Nexus服务运行结果</center>

<p>可以使用docker ps命令查看正在运行的容器，如图5-9所示</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8.jpg" alt="Docker查看正在运行的容器"> </p>
<center>图5-9 Docker查看正在运行的容器</center>

<h2 id="5-3-持续集成服务器搭建"><a href="#5-3-持续集成服务器搭建" class="headerlink" title="5.3 持续集成服务器搭建"></a>5.3 持续集成服务器搭建</h2><h3 id="5-3-1-Jenkins持续集成工具"><a href="#5-3-1-Jenkins持续集成工具" class="headerlink" title="5.3.1 Jenkins持续集成工具"></a>5.3.1 Jenkins持续集成工具</h3><p>Jenkins是一款开源的持续集成工具[16]，具有丰富的插件系统，支持任何类型的构建或集成，并且提供自动化构建、分布式构建、邮件通知等功能。其本质上是一个服务，用户可以通过可视化的Web操作页面配置和执行任务，并且提供了RESTful Api的访问形式，开发者可以通过调用相应的Api来动态的配置任务、执行任务、获取任务信息和构建信息等。</p>
<h3 id="5-3-2-Jenkins安装与配置"><a href="#5-3-2-Jenkins安装与配置" class="headerlink" title="5.3.2 Jenkins安装与配置"></a>5.3.2 Jenkins安装与配置</h3><p>本系统使用Docker来安装和运行Jenkins。</p>
<p>（1）首先执行docker search jenkins命令查找Jenkins镜像，如图5-10，这里选择第二个镜像：jenkins/jenkins。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E6%90%9C%E7%B4%A2Jenkins%E9%95%9C%E5%83%8F.jpg" alt="Docker搜索Jenkins镜像"> </p>
<center>图5-10 Docker搜索Jenkins镜像</center>

<p>（2）运行docker pull jenkins/jenkins拉取镜像到本地。</p>
<p>（3）输入【docker run -p 8082:8080 -d –name myjenkins -v /e/ASproject:/var/as_project -v /d/android-sdk-windows:/var/android_sdk -v /d/Docker/Volume/Jenkins:/var/jenkins_home jenkins/jenkins:lts】命令运行Jenkins容器。</p>
<p>（4）浏览器访问8082端口，出现页面则表示Jenkins服务启动成功[17]，如图5-11。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="Jenkins服务运行结果"> </p>
<center>图5-11 Jenkins服务运行结果</center>

<p>（5）首次启动需要初始化密码，上图所示路径为Jenkins容器中的路径，无法直接通过宿主机访问，需要进入该容器内部访问，使用docker exec命令访问容器，然后进入/var/jenkins_home/secrets/文件夹下查看初始密码。如图5-12所示。输入密码进入下一步。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6.jpg" alt="Jenkins进入容器内部查看文件"> </p>
<center>图5-12 Jenkins进入容器内部查看文件</center>

<p>（6）根据提示安装插件，创建Jenkins用户，完成之后进入Jenkins主页，如图5-13所示</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%B8%BB%E9%A1%B5.jpg" alt="Jenkins主页"> </p>
<center>图5-13 Jenkins主页</center>

<p>（7）Jenkins的说明文档采用REST API样式，URL格式如Jenkins资源/api。常用的资源有主机名、Job和Build等。如：localhost:8082/api</p>
<h3 id="5-3-3-Jenkins容器内部环境搭建"><a href="#5-3-3-Jenkins容器内部环境搭建" class="headerlink" title="5.3.3 Jenkins容器内部环境搭建"></a>5.3.3 Jenkins容器内部环境搭建</h3><p>由于容器与宿主机是完全隔离的，因此容器内无法使用宿主机环境，需要在容器内部重新设置环境变量。在Docker容器中配置环境变量有以下方式：</p>
<p>（1）由于Docker基于Linux操作系统，因此可以通过【docker exec -it myjenkins /bin/bash】命令开启交互模式终端，进入容器内部，接着使用Linux的方式，如apt或者wget等工具安装软件即可。</p>
<p>（2）使用挂载的方式，将宿主机已经安装好的软件目录挂载到容器中的某个目录下，接着进入容器内部设置环境变量即可。</p>
<p>接下来介绍下本系统中Jenkins如何搭建需要的环境：</p>
<p>（1）Java环境：本版本的镜像自带了Java环境，因此不需要再次安装，可以进入容器内部，执行【java -version】命令查看java版本。如下图5-14所示</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%AA%8C%E8%AF%81Java%E7%8E%AF%E5%A2%83.jpg" alt="Jenkins验证Java环境"> </p>
<center>图5-14 Jenkins验证java环境</center>

<p>（2）Android环境：上面启动容器的时候已经将宿主机的Android SDK目录挂载到了Jenkins容器中，因此直接配置环境变量即可。在主页-&gt;系统管理-&gt;系统设置-&gt;找到环境变量，如下图5-15配置。注意这里的路径为挂载后容器内的路径。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%85%8D%E7%BD%AEAndroid%E7%8E%AF%E5%A2%83.jpg" alt="Jenkins配置Android环境"> </p>
<center>图5-15 Jenkins配置Android环境</center>

<p>（3）Gradle：同样地，将宿主机Gradle安装文件夹挂载到容器内部，在主页-&gt;系统管理-&gt;全局工具配置-&gt;找到Gradle，如下图5-16配置。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%85%8D%E7%BD%AEGradle.jpg" alt="Jenkins配置Gradle"> </p>
<center>图5-16 Jenkins配置Gradle</center>

<p>（4）Python环境：这个版本的Jenkins镜像自带了Python2的环境，可以进入容器内部，使用【python –v】命令查看Python版本。但是缺少Pip工具，同样地进入容器内，如图5-17完成安装。出现Pip版本号则表示安装成功。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E5%AE%89%E8%A3%85pip.jpg" alt="Jenkins安装pip"> </p>
<center>图5-17 Jenkins安装pip</center>

<p>（5）Git环境和SSH登录配置：这个版本的Jenkins镜像自带了Git环境，可以进入容器内部，使用git -v命令打印版本信息。GitHub支持以SSH协议访问Git仓库，避免每次输入用户名和密码。</p>
<p>首先进入容器内部，通过【ssh-keygen -t rsa -C 邮箱】生成密钥对，然后进入~/.ssh目录下，查看公钥信息，如图5-18所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%85%8D%E7%BD%AESSH%E7%99%BB%E9%99%86.jpg" alt="Jenkins配置SSH登录"> </p>
<center>图5-18 Jenkins配置SSH登录</center>

<p>将公钥拷贝到GitHub设置页面的如下图5-19的位置，然后点击添加。</p>
<p>![GitHub配置SSH keys](./2021-09-04-CI回首毕业论文/GitHub配置SSH Key.jpg) </p>
<center>图5-19 GitHub配置SSH keys</center>

<p>最后可以使用<code>ssh -T git@github.com</code>命令验证是否配置成功。</p>
<h3 id="5-3-4-Jenkins任务配置"><a href="#5-3-4-Jenkins任务配置" class="headerlink" title="5.3.4 Jenkins任务配置"></a>5.3.4 Jenkins任务配置</h3><p>在Jenkins主页点击新建任务-&gt;输入名称-&gt;选择任务类型-&gt;……，这几步较简单，创建完成后任务界面如图5-20所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E9%A1%B5%E9%9D%A2.jpg" alt="Jenkins任务页面"> </p>
<center>图5-20 Jenkins任务页面</center>

<p>从左侧Configure项进入任务配置页面，这里只介绍几项关键配置：</p>
<p>（1）参数和工作区配置：点开General-&gt;Advanced，定义构建任务需要传入的参数，参数可以有多种类型，如下图5-21所示，输入工作区路径，注意这里的路径是Jenkins容器内部路径。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2.jpg" alt="Jenkins任务配置页面"> </p>
<center>图5-21 Jenkins任务配置页面</center>

<p>（2）脚本配置：即任务执行的具体内容，可以执行多种类型的脚本，或者根据需要安装不同的插件来执行命令。如图5-22所示，</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE.jpg" alt="Jenkins任务脚本配置"> </p>
<center>图5-22 Jenkins任务脚本配置</center>

<p>（3）Jenkins的任务配置是以xml文件形式保存的，可以通过Jenkins的API接口查看指定任务的配置，如图5-23所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/JenkinsAPI%E5%BD%A2%E5%BC%8F%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE.jpg" alt="JenkinsAPI形式查看配置"> </p>
<center>图5-23 Jenkins API形式查看配置</center>

<p>（4）在任务界面点击Build With Parameters执行参数化构建-&gt;输入参数值-&gt;点击Build开始构建任务-&gt;点击任务界面左侧构建历史可以查看构建结果。如下图5-24</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E6%9E%84%E5%BB%BA%E7%BB%93%E6%9E%9C%E6%97%A5%E5%BF%97.jpg" alt="Jenkins构建结果日志"> </p>
<center>图5-24 Jenkins构建结果日志</center>

<h3 id="5-3-5-脚本实现"><a href="#5-3-5-脚本实现" class="headerlink" title="5.3.5 脚本实现"></a>5.3.5 脚本实现</h3><p>Jenkins自动化构建实质上就是定时执行各种任务脚本，如shell脚本、python脚本、gradle等，或者根据需要安装其他插件，本系统主要使用python语言，其中封装了shell命令、gradle命令，git命令等，由python统一运行。</p>
<h3 id="5-3-6-邮件通知"><a href="#5-3-6-邮件通知" class="headerlink" title="5.3.6 邮件通知"></a>5.3.6 邮件通知</h3><p>由于Jenkins是在后台执行，用户不用在任务执行的时候忙等，但是这样有可能造成用户因为某些原因没有及时查看构建记录或者及时修复失败构建。因此需要加入邮件通知的功能，及时推送构建结果到用户邮箱。</p>
<p>Jenkins集成了邮件通知功能，完成任务时可发送邮件通知指定用户，但是由于格式固定，不够灵活，因此本系统决定采用Email Extension插件实现邮件发送，配置如下：</p>
<p>（1）安装插件：在Jenkins主页面点击系统管理-&gt;插件管理-&gt;找到Email Extension Plugin并安装。安装完插件后在系统管理-&gt;系统设置中会显示Extended E-mail Notification配置项。</p>
<p>（2）邮件全局配置：用于定义邮件模板，邮件发送人等，并开启邮箱服务，邮箱服务可以有多种选择，这里使用腾讯邮箱提供的SMTP服务，如图5-25。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE.jpg" alt="Jenkins邮箱服务配置"> </p>
<center>图5-25 Jenkins邮箱服务配置</center>

<p>（3）任务添加邮件通知：配置了邮件模板之后还需要在具体的任务中添加邮箱通知功能。如图5-26所示，在任务配置-&gt;Post Build Actions-&gt;选择Editable Email Notification。出现邮件插件配置项。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE.jpg" alt="Jenkins任务邮件配置"> </p>
<center>图5-26 Jenkins任务邮件配置</center>

<p>（4）邮件具体配置：如图5-27所示，可以针对具体的任务修改邮件内容。并且提供了邮件触发条件的功能，如Always表示总是发送邮件，Success表示只在任务执行成功的时候才触发邮件通知等。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE2.jpg" alt="Jenkins任务邮件配置2"> </p>
<center>图5-27 Jenkins任务邮件配置</center>

<p>（5）邮件通知结果：如图5-28为邮件内容，包含组件信息，构建编号，构建状态，构建结果地址等。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5%E7%BB%93%E6%9E%9C.jpg" alt="Jenkins邮件通知结果"> </p>
<center>图5-28 Jenkins邮件通知结果</center>

<h2 id="5-4-前端实现"><a href="#5-4-前端实现" class="headerlink" title="5.4 前端实现"></a>5.4 前端实现</h2><h3 id="5-4-1-Node-js环境安装"><a href="#5-4-1-Node-js环境安装" class="headerlink" title="5.4.1 Node.js环境安装"></a>5.4.1 Node.js环境安装</h3><p>Node提供了模块化功能，可以方便的引入模块，并且可以使得JavaScript能够进行服务端的开发。Node的出现影响着前端开发的模式，促进了前端工程化的发展。本系统使用Node中的Npm的包管理功能进行前端开发。</p>
<p>首先从官网上下载Node.js并安装，程序会自动设置好环境变量，安装成功后使用【node –v】和【npm –v】命令检查Node和Npm版本。Npm通过模块下的package.json来定义包的属性，包括包名、版本号、作者、依赖包信息等，可以使用【npm install <Module name>】命令安装Node模块。由于国内使用npm的官方镜像下载模块速度比较慢，因此使用其他镜像替代。以淘宝镜像源为例，主要有三种配置方式，本项目采用第三种配置方法，配置方式如下：</Module></p>
<p>（1）使用【npm config set registry <a href="http://registry.npm.taobao.org】命令设置镜像,使用npm/">http://registry.npm.taobao.org】命令设置镜像，使用npm</a> config get registry查看镜像。使用本方式可以持久使用，缺点是对当前机器的所有项目起作用。</p>
<p>（2）使用【npm –registry <a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a> install <Module name>】安装模块，本方式只适合临时使用，缺点是每次安装模块都需要指定镜像源。</Module></p>
<p>（3）在工程目录的.npmrc配置文件中写入镜像源地址，添加【registry=<a href="http://registry.npm.taobao.org】.这样做的好处是只针对当前项目起作用,并且只需要拷贝这份配置文件即可移植到新工程中./">http://registry.npm.taobao.org】。这样做的好处是只针对当前项目起作用，并且只需要拷贝这份配置文件即可移植到新工程中。</a></p>
<h3 id="5-4-2-前端工程化建立"><a href="#5-4-2-前端工程化建立" class="headerlink" title="5.4.2 前端工程化建立"></a>5.4.2 前端工程化建立</h3><p>随着前后端分离概念的流行，后端工程师不用再关注前端页面，前端工程师的职责越来越重，能做的事情更加多了，随之而来的是前端项目逐渐庞大，需要考虑开发效率和后期维护等问题，因此，势必走上前端工程化的道路。前端工程化简单的讲就是把复杂不可控的项目变成简单可控的流程，从而提供开发效率，降低风险，是软件工程化在Web前端开发实践中的应用。具体到实践则包含技术框架选型、应用脚手架、代码版本控制、UI组件化、代码质量检查、代码编译、应用构建、打包发布等流程。由此也产生了各种框架和工具。</p>
<p>本系统前端使用Next.js服务端渲染框架搭建，基于React框架，使用Redux框架实现React状态管理，使用TypeScript和Sass等预处理语言替代JS和CSS，UI框架主要使用蚂蚁金服的AntDesign，使用axios框架进行网络请求，WebSocket则利用socket.io框架实现。</p>
<p>本系统脚手架工具使用create-next-app，其中提供了Next.js+AntDesign方案。具体步骤如下：</p>
<p>（1）执行【npm install -g create-next-app】命令安装脚手架。</p>
<p>（2）执行【create-next-app next-ant-app】初始化工程。</p>
<p>（3）在package.json文件中配置依赖库、npm脚本、应用名、版本等信息，如图5-29所示，并运行【npm install】命令安装依赖库。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%89%8D%E7%AB%AFnpm%E9%85%8D%E7%BD%AE.png" alt="前端npm配置"> </p>
<center>图5-29 前端npm配置</center>

<p>（4）在.babelrc添加babel配置，如图5-30所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%89%8D%E7%AB%AFBabel%E9%85%8D%E7%BD%AE.png" alt="前端Babel配置"> </p>
<center>图5-30 前端babel插件配置</center>

<p>（5）在next.config.js文件中配置TypeScript、Sass处理以及图片、CSS资源等打包，如图5-31所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%89%8D%E7%AB%AFnextjs%E9%85%8D%E7%BD%AE.jpg" alt="前端nextjs配置"> </p>
<center>图5-31 前端next.js配置</center>

<p>（6）工程目录划分如图5-32。其中components目录可以存放ui组件，layouts存放公共布局，lib封装了http请求方法，pages存放页面代码，static存放静态资源，styles存放公共样式，utils存放工具类。.babelrc用于配置babel插件，tsconfig.json用于配置TypeScript处理等。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95.jpg" alt="前端工程目录"> </p>
<center>图5-32 前端工程目录</center>

<p>（7）配置完毕后执行npm run dev运行服务，默认端口号为3000，可以在浏览器上访问3000端口打开前端页面。</p>
<h3 id="5-4-3-前端部分页面展示"><a href="#5-4-3-前端部分页面展示" class="headerlink" title="5.4.3 前端部分页面展示"></a>5.4.3 前端部分页面展示</h3><p>前端页面布局主要分为侧边栏，右侧分为顶部导航、Breadcrumbs、内容、页脚。交互方面主要实现了全局消息提示、通知弹窗、确认弹窗以及表单对话框等。</p>
<p>（1）组件管理页面，实现了分页和排序功能，超过十条数据自动分页。请求成功后，顶部出现消息提示交互。效果如图5-33。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2.jpg" alt="组件管理页面"> </p>
<center>图5-33 组件管理页面</center>

<p>（2）表单对话框，实现了表单验证功能。效果如图5-34。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E9%A1%B5%E9%9D%A2.png" alt="创建组件页面"> </p>
<center>图5-34 创建组件页面</center>

<p>（3）构建历史页面，使用表格控件，倒序显示。效果如图5-35。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2%E9%A1%B5%E9%9D%A2.jpg" alt="构建历史页面"> </p>
<center>图5-35 构建历史页面</center>

<p>（4）项目详情页面，实现了下拉框联想功能，即根据条件自动更新下拉框选项。效果如图5-36。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2.jpg" alt="项目详情页面"> </p>
<center>图5-36 项目详情页面</center>

<p>（1）交互效果：通知弹窗和确认弹窗如图5-37所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%80%9A%E7%9F%A5%E5%BC%B9%E7%AA%97%E6%95%88%E6%9E%9C.png" alt="通知弹窗效果"> </p>
<center>图5-37 通知和确认弹窗效果</center>

<h2 id="5-5-后端实现"><a href="#5-5-后端实现" class="headerlink" title="5.5 后端实现"></a>5.5 后端实现</h2><h3 id="5-5-1-后端架构"><a href="#5-5-1-后端架构" class="headerlink" title="5.5.1 后端架构"></a>5.5.1 后端架构</h3><p>本系统采用前后端分离方式开发，后端只负责提供接口数据，不涉及View层，基于Springboot和Mybatis框架实现，共分为三层：</p>
<p>（1）Controller层（控制层）：负责接收前端请求，并调用相应的业务模块执行逻辑。同时可以在这一层对数据进行拆装，转换为前端和业务层需要的数据。</p>
<p>（2）Service层（业务层）：实现业务模块逻辑，包括任务执行，调度，事务控制和异常处理等。还负责调用Dao层操作数据。对外只暴露业务接口。</p>
<p>（3）Dao层（数据操作层）：实现数据库操作，在xml文件中定义数据库操作语句，通过mybatis框架解析和执行。</p>
<p>架构图如5-38所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="后端架构图"> </p>
<center>图5-38 Web后端架构图</center>

<h3 id="5-5-2-功能实现概述"><a href="#5-5-2-功能实现概述" class="headerlink" title="5.5.2 功能实现概述"></a>5.5.2 功能实现概述</h3><p>（1）组件管理业务：包含组件、组件构建记录、Jenkins组件任务的CRUD功能，以及组件构建和Jenkins组件任务的执行。</p>
<p>（2）项目管理业务：包含项目、项目构建记录、Jenkins项目任务的CRUD功能，以及项目构建、集成和Jenkins项目任务的执行。</p>
<p>（3）跨域问题解决：由于浏览器的同源策略限制导致不同源的前端页面请求服务端会被拒绝，也就是跨域问题，为了解决这一问题，需要服务端指定允许访问的源。建立CorsConfig.java文件，配置如图5-39所示</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.jpg" alt="跨域问题处理"> </p>
<center>图5-39 跨域问题处理</center>

<p>（4）全局异常处理：通过Springboot提供的@ControllerAdvice注解开启全局异常捕获，通过@ExceptionHandler注解捕获特定异常。如图5-40所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.jpg" alt="全局异常处理"> </p>
<center>图5-40全局异常处理</center>

<p>（5）正则匹配修改：Jenkins任务配置是以xml文件形式保存的，创建任务时需要上传配置，为了针对不同组件配置Job，需要修改模板配置文件，这里使用正则表达式修改文件，部分关键代码如图5-41和图5-42所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E8%AF%BB%E5%8F%96%E6%A8%A1%E7%89%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="读取模板配置文件"> </p>
<center>图5-41读取模板配置文件</center>

<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E4%BF%AE%E6%94%B9.jpg" alt="正则匹配修改"> </p>
<center>图5-42 正则匹配修改</center>

<h3 id="5-5-3-数据库设计"><a href="#5-5-3-数据库设计" class="headerlink" title="5.5.3 数据库设计"></a>5.5.3 数据库设计</h3><p>本系统使用MySQL进行数据存储，共有4个实体集，组件、项目、组件构建记录、项目构建记录。其中，一个组件或者项目可以有多条构建记录，每次构建都是一个版本，项目依赖组件的某个版本，一个项目依赖多个组件的某个版本，一个组件的某个版本可以被多个项目依赖。</p>
<p>（1）数据库实体关系图（ER图）设计如图5-43：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%95%B0%E6%8D%AE%E5%BA%93ER%E5%9B%BE.jpg" alt="数据库ER图"> </p>
<center>图5-43 数据库ER图</center>

<p>（2）数据库关系模型如下：</p>
<p> 组件（组件id，组件名称，仓库地址，分支，目录，当前版本，构建状态，组件描述，创建时间，最近操作时间）</p>
<p>组件构建记录（组件构建id，组件id，组件名称，构建序号，构建状态，构建版本，构建信息，构建时间）</p>
<p>项目（项目id，项目名称，仓库地址，分支，当前版本，构建状态，集成状态，项目描述，创建时间，最近操作时间）</p>
<p>项目构建记录（项目构建id，项目id，项目名称，类型构建状态，构建序号，apk下载地址，构建信息，构建时间）</p>
<p>项目组件关系（id，项目id，组件构建id，关联类型）</p>
<p>（3）数据库表设计如下：</p>
<p>表1 组件表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_module</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>备注</td>
<td>中文名称</td>
</tr>
<tr>
<td>module_id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>组件id</td>
</tr>
<tr>
<td>name</td>
<td>varchar(30)</td>
<td>非空</td>
<td>唯一</td>
<td>组件名称</td>
</tr>
<tr>
<td>repo</td>
<td>varchar(70)</td>
<td>非空</td>
<td></td>
<td>仓库地址</td>
</tr>
<tr>
<td>branch</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>分支</td>
</tr>
<tr>
<td>catalog</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>目录</td>
</tr>
<tr>
<td>cur_version</td>
<td>varchar(10)</td>
<td></td>
<td></td>
<td>当前版本</td>
</tr>
<tr>
<td>build_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>构建状态</td>
</tr>
<tr>
<td>descr</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>组件描述</td>
</tr>
<tr>
<td>gmt_create</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>创建时间</td>
</tr>
<tr>
<td>gmt_update</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>最近操作时间</td>
</tr>
</tbody></table>
<p>表2 组件构建记录表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_module_build</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>约束条件</td>
<td>中文名称</td>
</tr>
<tr>
<td>module_build_id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>组件构建id</td>
</tr>
<tr>
<td>module_id</td>
<td>int</td>
<td>非空</td>
<td>外键</td>
<td>组件id</td>
</tr>
<tr>
<td>module_name</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>组件名称</td>
</tr>
<tr>
<td>build_num</td>
<td>int</td>
<td>非空</td>
<td></td>
<td>构建number</td>
</tr>
<tr>
<td>build_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>构建状态</td>
</tr>
<tr>
<td>version</td>
<td>varchar(10)</td>
<td>非空</td>
<td></td>
<td>构建版本</td>
</tr>
<tr>
<td>message</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>构建信息</td>
</tr>
<tr>
<td>gmt_create</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>构建时间</td>
</tr>
</tbody></table>
<p>表3 项目表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_project</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>约束条件</td>
<td>中文名称</td>
</tr>
<tr>
<td>project_id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>项目id</td>
</tr>
<tr>
<td>name</td>
<td>varchar(30)</td>
<td>非空</td>
<td>唯一</td>
<td>项目名称</td>
</tr>
<tr>
<td>repo</td>
<td>varchar(70)</td>
<td>非空</td>
<td></td>
<td>仓库地址</td>
</tr>
<tr>
<td>branch</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>分支</td>
</tr>
<tr>
<td>cur_version</td>
<td>varchar(10)</td>
<td></td>
<td></td>
<td>当前版本</td>
</tr>
<tr>
<td>build_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>构建状态</td>
</tr>
<tr>
<td>integrate_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>集成状态</td>
</tr>
<tr>
<td>descr</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>项目描述</td>
</tr>
<tr>
<td>gmt_create</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>创建时间</td>
</tr>
<tr>
<td>gmt_update</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>最近操作时间</td>
</tr>
</tbody></table>
<p>表4 项目构建记录表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_project_build</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>约束条件</td>
<td>中文名称</td>
</tr>
<tr>
<td>project_build_id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>项目构建id</td>
</tr>
<tr>
<td>project_id</td>
<td>int</td>
<td>非空</td>
<td>外键</td>
<td>项目id</td>
</tr>
<tr>
<td>project_name</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>项目名称</td>
</tr>
<tr>
<td>build_num</td>
<td>int</td>
<td></td>
<td></td>
<td>构建number</td>
</tr>
<tr>
<td>build_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>构建状态</td>
</tr>
<tr>
<td>type</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>类型</td>
</tr>
<tr>
<td>download_url</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>Apk下载地址</td>
</tr>
<tr>
<td>message</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>构建信息</td>
</tr>
<tr>
<td>gmt_create</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>构建时间</td>
</tr>
</tbody></table>
<p>表5 项目组件关系表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_project_module</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>约束条件</td>
<td>中文名称</td>
</tr>
<tr>
<td>id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>关联关系id</td>
</tr>
<tr>
<td>project_id</td>
<td>int</td>
<td>非空</td>
<td>外键</td>
<td>项目id</td>
</tr>
<tr>
<td>module_build_id</td>
<td>int</td>
<td>非空</td>
<td>外键</td>
<td>组件构建id</td>
</tr>
<tr>
<td>type</td>
<td>int</td>
<td></td>
<td></td>
<td>关联类型</td>
</tr>
</tbody></table>
<h1 id="6-案例测试和演示"><a href="#6-案例测试和演示" class="headerlink" title="6 案例测试和演示"></a>6 案例测试和演示</h1><p>本章将以5.1节中实现的Android组件化项目作为案例，演示实际项目是如何结合本系统进行开发的。</p>
<p>（1）首先在平台项目管理中创建项目，输入项目基本信息，如图6-1。输入为空或项目已存在会出现错误提示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA.jpg" alt="项目创建"> </p>
<center>图6-1 项目创建</center>

<p>创建完成之后可以看到Jenkins页面成功创建了一个项目Job，如图6-2。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AEJob%E5%88%9B%E5%BB%BA.jpg" alt="项目Job创建"> </p>
<center>图6-2 项目Job创建</center>

<p>进入项目详情查看，项目组件为空，如图6-3。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E8%AF%A6%E6%83%85.jpg" alt="项目详情"> </p>
<center>图6-3 项目详情</center>

<p>进入项目构建历史查看，构建记录为空，如图6-4。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2.jpg" alt="项目构建历史"> </p>
<center>图6-4 项目构建历史</center>

<p>（2）在平台组件管理中创建组件，输入组件的基本信息，如图6-5。同样地，可以看到Jenkins页面成功创建了一个组件Job。组件构建历史为空。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA.jpg" alt="组件创建"> </p>
<center>图6-5 组件创建</center>

<p>（3）在组件的指定分支上开发完成，提交了代码之后，在平台组件管理中点击构建组件，第一次构建需要输入起始版本号，如图6-6，后面版本号会自动生成，不需要再次输入。开始构建之后，前端显示正在构建，Jenkins会在远程、后台执行该任务，不会影响开发者，可以查看构建进度，如图6-7和图6-8。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA.jpg" alt="组件构建"> </p>
<center>图6-6 组件构建</center>

<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E8%BF%9B%E5%BA%A6%E5%85%A5%E5%8F%A3.jpg" alt="组件构建进度入口"> </p>
<center>图6-7 组件构建进度入口</center>

<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E8%BF%9B%E5%BA%A6.jpg" alt="组件构建进度"> </p>
<center>图6-8 组件构建进度</center>

<p>（3）构建完成后前端会收到通知，如图6-9。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E9%80%9A%E7%9F%A5.jpg" alt="组件构建通知"> </p>
<center>图6-9 组件构建通知</center>

<p>可以查看构建历史和构建日志。如图6-10和图6-11。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2.jpg" alt="组件构建历史"> </p>
<center>图6-10 组件构建历史</center>

<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E6%97%A5%E5%BF%97.jpg" alt="组件构建日志"> </p>
<center>图6-11 组件构建日志</center>

<p>能够看到日志显示构建成功，并且发送构建结果的邮件到了配置的邮箱。如图6-12。可以点击超链接查看具体日志。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5.jpg" alt="组件构建邮件通知"> </p>
<center>图6-12 组件构建邮件通知</center>

<p>（4）依次构建好其他几个组件后，在项目详情页面中可以添加项目组件，只能搜索到构建成功的组件版本，且一个项目只能有一个同名组件，保存成功后会弹出提示，如图6-13。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%B7%BB%E5%8A%A0%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6.jpg" alt="添加项目组件"> </p>
<center>图6-13 添加项目组件</center>

<p>（5）配置完毕之后点击项目构建，即和组件构建一样开始后台执行Job，可以在Jenkins后台查看构建进度等。构建完成之后同样会收到消息通知和邮件通知，内容有所区别。可以查看项目构建历史。如图6-14。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.jpg" alt="项目构建历史记录"> </p>
<center>图6-14 项目构建历史记录</center>

<p>能够看到出现了安装包地址，跳转到apk下载地址，供用户下载最新应用，如图6-15。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/apk%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80.jpg" alt="apk下载地址"> </p>
<center>图6-15 apk下载地址</center>

<p>（6）至此完成了一次集成，根据持续集成的定义，每天都要进行构建，通过平台简化了一系列重复繁琐的操作，实现了远程构建，提高了效率，能够及时暴露和反馈问题，增强项目开发过程的可见性，并且能够随时随地提供可以运行的软件。安装并运行应用，效果如图6-16所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%BA%94%E7%94%A8%E6%95%88%E6%9E%9C%E5%89%8D.jpg" alt="应用效果前"> </p>
<center>图6-16 应用效果前</center>

<p>（7）假设提出了测试bug或者新增了需求，如要求在首页新增一个入口，跳转到其他页面。首页组件的开发者实现了该功能，并且将源码推送到远程仓库。如图6-17。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%BC%80%E5%8F%91%E5%85%B6%E4%BB%96%E9%A1%B5%E9%9D%A2.jpg" alt="开发其他页面"> </p>
<center>图6-17 开发其他页面</center>

<p>按照上述流程在平台上构建首页组件，修改项目依赖组件版本，进行集成，即可打出新的apk包，供其他角色进行验收测试等。同样地进行下载和安装。运行效果如图6-18所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%BA%94%E7%94%A8%E6%95%88%E6%9E%9C%E5%90%8E.jpg" alt="应用效果后"> </p>
<center>图6-18 应用效果后</center>

<p>（8）循环上述步骤，直到应用开发完成，进行项目最终集成和发布应用。通过案例可以看到持续集成与瀑布式开发流程的明显区别，在开发过程中可以不断提出新建议或者问题，开发者可以快速实现，并且提交测试，而不用分阶段完成任务，等到最终集成之后才进行测试，这也就是敏捷的来源。</p>
<h1 id="7-总结与展望"><a href="#7-总结与展望" class="headerlink" title="7 总结与展望"></a>7 总结与展望</h1><p>通过平台可视化界面对组件化项目进行管理和构建，可以减少重复、耗时的操作，降低沟通成本，大大地提高了开发效率，增强了开发过程的可见性和可控性，开发者不需要手动的构建、测试、发布等。通过每日构建和频繁集成能够及时发现项目缺陷，降低发布风险，提高软件质量，快速迭代软件产品。</p>
<p>本文提出和设计了一套持续集成方案，并实现了一套简易版的持续集成生态。目前已实现基本功能，各端联调通信，能够正常走完所有流程，需要在使用过程中通过实际大量的数据和测试暴露问题，改进方案。目前本系统还有一些可以优化的点，如下：</p>
<p>（1）加入用户管理系统和用户权限系统：项目和组件可以有各自的负责人，负责人拥有所有的权限，对其他成员只保持可见权限，提高系统的安全性，减少风险，团队成员各司其职。同时平台的每次操作都会记录用户，便于事后追溯问题。</p>
<p>（2）前端优化数据筛选、搜索、排序等功能：目前只实现了部分功能，由于数据量较少，因此功能暂时用处不大，当数据量大的时候，这些用户友好功能就能体现出相应的价值。丰富反馈机制如红点提示等，报错标红等UI效果。</p>
<p>（3）Jenkins添加静态代码质量检查任务：可以在构建之前执行检查任务，执行完成之后会生成检查报告，展示到平台，提醒开发者优化代码，并且可是设置分数低于合格值构建不通过。</p>
<p>（4）Jenkins添加自动化测试任务：可以在项目构建完毕之后执行自动化测试任务，执行完后生成测试日志，一定程度上减少手动重复测试，避免测试人员反复测试同一个问题并且提交。</p>
<p>（5）优化组件管理和项目管理的流程：如通过平台直接创建项目分支，不需要手动创建分支，项目集成之后自动打TAG、优化版本变化流程等。</p>
<p>（6）增加看板功能：即类似jira等敏捷开发工具，产品或测试人员可以通过平台针对某个开发者发布问题或者任务，把项目的进度、个人完成率、超时完成等数据统计显示在看板上，开发者完成任务或者修复问题之后在平台上修改状态，测试人员测试通过之后关闭问题，形成一个闭环。看板数据还可以作为绩效管理等的有力依据。</p>
<p>新的感悟：</p>
<ol>
<li>根据项目类型配置不同Jenkins任务模板</li>
<li>应用可以发布到构件仓库，不需要上传蒲公英</li>
<li>应用配置管理或者配置分发</li>
<li>版本号不写死在代码里面，生成提交：可以通过gradle读取外部变量</li>
<li>系统组件化：将系统构建作为项目，组件可能是应用、配置等</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]Paul M D,Steve Matyas,Andrew Glover.持续集成：软件质量改进和降低风险之道[M].王海鹏译.北京：电子工业出版社，2013.</p>
<p>[2]Kent Beck,Cynthia Andres. Extreme Programming Explained: Embrace Change[M].</p>
<p>[3]Fowler M. Continuous Integration[EB/OL]. <a href="https://martinfowler.com/articles/continuousIntegration.html,2006-5-1/2018-12-20">https://martinfowler.com/articles/continuousIntegration.html,2006-5-1/2018-12-20</a>.</p>
<p>[4]<a href="http://yuanjian.cnki.com.cn/Search/Result?author=%E6%9C%B1%E7%BA%A2">朱红</a>,<a href="http://yuanjian.cnki.com.cn/Search/Result?author=%E4%BB%87%E6%B6%A6%E9%B9%A4">仇润鹤</a>.基于Jenkins的移动通信业务自动化测试平台的设计与测试[J].科技与创新，2016,(7).</p>
<p>[5]陈松乔,任胜兵,王国军.现代软件工程[M].北方交通大学出版社，2002-11-13.</p>
<p>[6]张力文.基于Jenkins的项目持续集成方案研究与实现[D].西南交通大学，2017.</p>
<p>[7]Jez Humble,David Farley.持续交付：发布可靠软件的系统方法.乔梁译[M].北京：人民邮电出版社，2011.</p>
<p>[8]Kent Beck,Fowler M,et al. Manifesto for Agile Software Development [EB/OL]. <a href="http://agilemanifesto.org/,2001/2018-12-30">http://agilemanifesto.org/,2001/2018-12-30</a>.</p>
<p>[9]inter_peng.持续集成（Continuous Integration）基本概念与实践[EB/OL]. <a href="https://blog.csdn.net/inter_peng/article/details/53131831%EF%BC%8C2016-11-11/2019-5-5">https://blog.csdn.net/inter_peng/article/details/53131831，2016-11-11/2019-5-5</a>.</p>
<p>[10]王宁.基于Jenkins的持续集成系统的设计与实现[D].北京邮电大学，2014.</p>
<p>[11]Swartout P. Continuous Deliver and DevOps-A Quickstart Guide[M]. Birmingham:Packt Publishing Ltd，2014:3.</p>
<p>[12]Ekaterina Novoseltseva. <a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/">Top benefits of continuous integration</a>[EB/OL]. <a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/%EF%BC%8C2015-12-28/2018-11-22">https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/，2015-12-28/2018-11-22</a>.</p>
<p>[13]曾家乐.Android组件化架构[M].电子工业出版社，2018-03-01.</p>
<p>[14] runoob.Docker架构[EB/OL]. <a href="https://www.runoob.com/docker/docker-architecture.html%EF%BC%8C2019-5-5">https://www.runoob.com/docker/docker-architecture.html，2019-5-5</a>.</p>
<p>[15]guiying712.Android组件化方案[EB/OL]. <a href="https://blog.csdn.net/guiying712/article/details/55213884%EF%BC%8C2017-2-15/2019-5-5">https://blog.csdn.net/guiying712/article/details/55213884，2017-2-15/2019-5-5</a>.</p>
<p>[16]Jonhn Ferguson Smart. Jenkins:The Definitive Guide[M]. O’REILLY,2011.</p>
<p>[17]dnsliu.基于Jenkins实现Android项目的持续集成[EB/OL].<a href="https://blog.csdn.net/dnsliu/article/details/81019086%EF%BC%8C2018-7-12/2019-5-5">https://blog.csdn.net/dnsliu/article/details/81019086，2018-7-12/2019-5-5</a>.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>持续集成</tag>
        <tag>组件化</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的MVC、MVP、MVVM</title>
    <url>/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/</url>
    <content><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="MVC基础"><a href="#MVC基础" class="headerlink" title="MVC基础"></a>MVC基础</h2><p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVC%E6%A8%A1%E5%BC%8F.png"></p>
<blockquote>
<p>Tips：箭头可以理解为引用、依赖，也可以理解为调用，因为引用了必然要调用。</p>
<p>有的MVC模式图包含了虚线和实线：虚线一般表现为临时变量，参数回调，实线表现为成员变量</p>
</blockquote>
<ol>
<li>Model：数据模型，负责数据获取、修改。代码中表现为Model、Repository（对数据进行隔离）、ApiService（访问网络）、Dao（访问数据库）、数据实体Entity等。</li>
<li>View：视图，负责视图显示和视图控制。代码中表现为Layout+Activity，如findViewById，setText、动画等。</li>
<li>Controller：控制器，负责所有的行为逻辑。代码中表现为Activity+各种管理类，如网络请求、SP存储、数据库访问、电量信息、网络状态等。除了对Model的调用外，还包含一些逻辑处理，如调用登录接口之前，对账号密码进行合法校验，加密等。</li>
</ol>
<p>样例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mModel = LoginModel()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">      	<span class="comment">//账号密码校验，加密等逻辑</span></span><br><span class="line">        mModel.login(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="keyword">object</span> : ResultCallback&lt;String?&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                <span class="comment">//回调方式返回数据</span></span><br><span class="line">                onLogin(result)</span><br><span class="line">                <span class="comment">//View直接从Model层获取数据显示</span></span><br><span class="line">                <span class="comment">//setText(mModel.user)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(errorCode: <span class="type">String</span>?, errorMsg: <span class="type">String</span>?)</span></span> &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLogin</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//runOnUIThread...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>?, password: <span class="type">String</span>?, callback: <span class="type">ResultCallback</span>&lt;<span class="type">String</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//runOnIOThread...</span></span><br><span class="line">        callback.onSuccess(<span class="string">&quot;Afauria&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ResultCallback</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(errorCode: <span class="type">String</span>?, errorMsg: <span class="type">String</span>?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大家常说的缺点："><a href="#大家常说的缺点：" class="headerlink" title="大家常说的缺点："></a>大家常说的缺点：</h2><ol>
<li>Activity负责View和Controller的工作，较臃肿，违背单一职责原则</li>
<li>View和Model可以直接交互，存在耦合，违背最小知识原则</li>
</ol>
<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><h3 id="何为Model？"><a href="#何为Model？" class="headerlink" title="何为Model？"></a>何为Model？</h3><blockquote>
<p>Model指数据模型。</p>
<ul>
<li>狭义的Model指API接口、数据库、文件存储等数据。</li>
<li>广义的Model不止是业务数据对象，还包含外部对象，如定位信息、网络状态、电量等。这些都属于Model层数据交互部分。</li>
</ul>
<p>因此，从这个角度讲，可以把电量管理、定位管理、网络管理等认为是Controller，命名可能叫<code>LocationManager</code>、<code>NetwrokHelper</code>、<code>BatteryManager</code>…</p>
<p>在MVC中，View需要对接各种管理器。</p>
<p>在MVP中，View只关心自己的Presenter，由Presenter对接不同的Model。</p>
</blockquote>
<h3 id="何为Controller？"><a href="#何为Controller？" class="headerlink" title="何为Controller？"></a>何为Controller？</h3><ul>
<li>狭义的Controller：即Controller类</li>
<li>广义的Controller：Controller不具体指哪一个类，而是指逻辑行为代码，可能是一个类（有的时候命名为Controller、Helper、Manager）、可能是一个方法或者代码块。</li>
</ul>
<h3 id="怎么理解View和Model关联？"><a href="#怎么理解View和Model关联？" class="headerlink" title="怎么理解View和Model关联？"></a>怎么理解View和Model关联？</h3><p>Android MVC中Activity既包含了视图、又包含了逻辑，View和Controller没有分离。</p>
<ul>
<li>站在Activity类的角度讲，可以说View和Model有交互，也可以说Controller和Model有交互。</li>
<li>站在代码逻辑上讲，调用Model方法本身也是行为逻辑，因此和Model交互的永远是Controller，不会是View。</li>
</ul>
<p>将MVC原本的图改为下图，实际是M&lt;-&gt;V/C：</p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVC%E8%A7%A3%E8%AF%BB.png"></p>
<p>注：<strong>这里的MVC不是标准的MVC模式，严格来说只能算M&lt;-&gt;V/C</strong>。在传统Web开发中，Model、Controller、View（JSP）是分离的。</p>
<h2 id="MVC的其他理解"><a href="#MVC的其他理解" class="headerlink" title="MVC的其他理解"></a>MVC的其他理解</h2><p>网上有很多MVC的关系图，箭头关系表示都不一样，到底哪种是正确的呢？</p>
<ol>
<li>将Activity中逻辑处理部分抽到Controller中，避免Activity包含逻辑处理，并转发Callback。</li>
</ol>
<p>代码见<a href="https://github.com/Afauria/ArchitectureSample">MVCSample1</a></p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVC%E7%9A%84%E5%85%B6%E4%BB%96%E7%90%86%E8%A7%A31.png"></p>
<ol start="2">
<li>将Activity中逻辑处理部分抽到Controller中，View可以直接调用Model获取数据</li>
</ol>
<p>代码见<a href="https://github.com/Afauria/ArchitectureSample">MVCSample2</a></p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVC%E7%9A%84%E5%85%B6%E4%BB%96%E7%90%86%E8%A7%A32.png"></p>
<p>View调用Model获取数据，包括直接获取、回调获取，此时Activity既是View，又包含了一部分Controller的逻辑，和Model层直接交互</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>MVC有多种理解和实现，核心的点在于将代码划分为Model、View、Controller三个部分，至于三个部分怎么通信耦合、Activity究竟是属于View还是Controller没有严格规定。</li>
<li>我们一直在说“Activity既包含了视图逻辑，又包含了业务逻辑，导致臃肿，违背单一职责原则”。实际上这只是MVC的其中一种理解，上述两种实现，即使把业务逻辑抽出去，创建一个Controller类，但实际上还是MVC。</li>
</ol>
<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><h2 id="MVP基础"><a href="#MVP基础" class="headerlink" title="MVP基础"></a>MVP基础</h2><p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVP%E6%A8%A1%E5%BC%8F.png"></p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVP%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p>
<p>除了Model之外，Presenter还和其他外部对象交互，只需要保证View不包含逻辑代码</p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVP%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9D%97.png" alt="MVP架构模块"></p>
<p>以登录业务为例，MVP类图如下</p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVP%E7%B1%BB%E5%9B%BE.png"></p>
<p><strong>注：Callback可以通过异步框架替换，见<a href="/2021/07/15/basic-2021-07-15-%E5%BC%82%E6%AD%A5%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0/">异步概念和常见实现</a></strong></p>
<p>样例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 定义Contract接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginContract</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IView</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onLogin</span><span class="params">(name: <span class="type">String</span>?)</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IPresenter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>?, password: <span class="type">String</span>?)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Activity、Fragment实现IView接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> : <span class="type">LoginContract.IView &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> mPresenter: LoginContract.IPresenter = LoginPresenter(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mPresenter.login(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLogin</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//runOnUIThread...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. Presenter实现IPresenter接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> mView: LoginContract.IView) : LoginContract.IPresenter &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mModel = LoginModel()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>?, password: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        mModel.login(username, password, <span class="keyword">object</span> : ResultCallback&lt;String?&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                mView.onLogin(result)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(errorCode: <span class="type">String</span>?, errorMsg: <span class="type">String</span>?)</span></span> &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ResultCallback</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(errorCode: <span class="type">String</span>?, errorMsg: <span class="type">String</span>?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>?, password: <span class="type">String</span>?, callback: <span class="type">ResultCallback</span>&lt;<span class="type">String</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//runOnIOThread...</span></span><br><span class="line">        callback.onSuccess(<span class="string">&quot;Afauria&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大家常说的缺点"><a href="#大家常说的缺点" class="headerlink" title="大家常说的缺点"></a>大家常说的缺点</h2><ol>
<li>Presenter持有View的引用，需要及时释放</li>
<li>需要定义大量的接口</li>
</ol>
<h2 id="MVP改造"><a href="#MVP改造" class="headerlink" title="MVP改造"></a>MVP改造</h2><ol>
<li>重复代码、公共接口：使用基类+泛型抽取公共接口和实现<ol>
<li>BasePresenter绑定和释放View、SafeHandler创建和释放等</li>
<li>BaseView公共进度条、弹窗、getContext等</li>
</ol>
</li>
<li>Presenter直接创建具体Model。<ol>
<li>替换的时候需要修改Presenter类。</li>
<li>单元测试中，不方便mock Model。</li>
</ol>
</li>
</ol>
<blockquote>
<p>可以通过依赖注入的方式进行解耦，变量初始化放到外部，可以随时替换，方便单元测试。</p>
<p>代码见<a href="https://github.com/Afauria/ArchitectureSample/tree/master/app/src/main/java/com/afauria/sample/architecture/injectmvp">InjectMVP和InjectMVPTest</a></p>
</blockquote>
<ol start="3">
<li>结合Dagger框架：实现Model、Presenter、View依赖注入</li>
<li>结合RxJava框架：通过Observable包装Model实现可观察数据源，和线程切换</li>
</ol>
<h2 id="提问-1"><a href="#提问-1" class="headerlink" title="提问"></a>提问</h2><h3 id="MVP如何定义接口？"><a href="#MVP如何定义接口？" class="headerlink" title="MVP如何定义接口？"></a>MVP如何定义接口？</h3><p>最常见的MVP实现是P和V定义接口，Model不抽。</p>
<p>反过来问，Presenter、View、Model是否可以不定义接口？</p>
<blockquote>
<p>可以抽，也可以不抽，看实际需要。不要为了抽接口而抽接口，明确抽接口的目的和意义。</p>
<p>“如果抽象没有带来显著的好处，应该避免抽象”——<a href="https://developer.android.com/topic/performance/memory?hl=zh-cn#Abstractions">谷歌开发者文档</a></p>
</blockquote>
<h3 id="为什么抽接口，抽接口和抽基类有什么区别？"><a href="#为什么抽接口，抽接口和抽基类有什么区别？" class="headerlink" title="为什么抽接口，抽接口和抽基类有什么区别？"></a>为什么抽接口，抽接口和抽基类有什么区别？</h3><blockquote>
<p>抽接口目的</p>
<ol>
<li>实现多态：便于替换不同实现</li>
<li>屏蔽实现细节，迪米特法则</li>
<li>依赖倒置：Presenter修改实现，View不需要修改。View修改实现，Presenter不需要修改</li>
<li>代码逻辑清晰，可读性强：都在Contract中</li>
</ol>
<p>抽Base类是为了抽取公共逻辑，Base类是后续衍生出来的，不在架构模式定义中</p>
</blockquote>
<h3 id="MVP中V层可以是Fragment吗？一个Activity有多个Fragment呢？"><a href="#MVP中V层可以是Fragment吗？一个Activity有多个Fragment呢？" class="headerlink" title="MVP中V层可以是Fragment吗？一个Activity有多个Fragment呢？"></a>MVP中V层可以是Fragment吗？一个Activity有多个Fragment呢？</h3><blockquote>
<p>可以，每个Fragment实现不同的View接口，对应不同的Presenter。</p>
</blockquote>
<h3 id="如果两个Fragment需要用到一个Presenter中的数据该怎么做"><a href="#如果两个Fragment需要用到一个Presenter中的数据该怎么做" class="headerlink" title="如果两个Fragment需要用到一个Presenter中的数据该怎么做"></a>如果两个Fragment需要用到一个Presenter中的数据该怎么做</h3><ol>
<li>将Activity作为View，对应一个Presenter，Activity拿到数据之后调用Fragment更新</li>
<li>两个Fragment分别对应两个Presenter，两个Presenter共用一个Model，都从该Model中获取数据</li>
<li>将该功能拆分出来：Activity中创建Presenter2对象，两个Fragment除了依赖自己的Presenter之外，再依赖一个共同的Presenter2</li>
</ol>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVVM%E6%9E%B6%E6%9E%84.png"></p>
<p>MVVM核心：可观察数据驱动UI。</p>
<p>优势：</p>
<ol>
<li>ViewModel不持有View引用</li>
<li>消除了MVP的样板代码，不需要定义大量接口</li>
</ol>
<h2 id="提问-2"><a href="#提问-2" class="headerlink" title="提问"></a>提问</h2><h3 id="如何理解ViewModel？"><a href="#如何理解ViewModel？" class="headerlink" title="如何理解ViewModel？"></a>如何理解ViewModel？</h3><blockquote>
<p>Model实际指DataModel，通常对应数据库或网络返回的数据结构。有的时候还会拆分业务层Model，持久层Model等，参考<a href="/2021/07/29/architecture-2021-07-29-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/">软件设计中的三层架构</a>。</p>
<p>而ViewModel即视图的Model，对应View的对象，对应UI上的控件。</p>
<p>例如：网络返回User数据对象包含很多信息，可以持久化存储到本地。而UI上需要显示用户名，可以用户名包装成可观察对象，保存到ViewModel中</p>
</blockquote>
<h1 id="MVC和MVP对比解读"><a href="#MVC和MVP对比解读" class="headerlink" title="MVC和MVP对比解读"></a>MVC和MVP对比解读</h1><h2 id="MVC-gt-MVP"><a href="#MVC-gt-MVP" class="headerlink" title="MVC-&gt;MVP?"></a>MVC-&gt;MVP?</h2><p>有的人说MVC中Activity承担Controller的功能，MVP将Controller逻辑抽离出去，Activity只负责视图控制。那么</p>
<ol>
<li>把Activity中的逻辑处理抽出去，就是MVP了吗?</li>
</ol>
<blockquote>
<p>上面讲了几种MVC的实现，即使抽出了Controller，还是MVC</p>
</blockquote>
<p>有的人会说MVP相比MVC需要定义接口</p>
<ol start="2">
<li><p>把Activity中的逻辑处理抽出去，再定义View和Controller的接口，就是MVP了吗？</p>
<blockquote>
<p>反过来问，MVP中是否可以不定义View和Presenter接口？</p>
<p>上面讲了MVP接口是根据需要定义的。</p>
</blockquote>
</li>
</ol>
<p>有的人会说MVP中View和Model不能直接依赖</p>
<ol start="3">
<li>View层定义一个Callback，Controller定义一个Callback，避免View和Model直接耦合，就是MVP了吗？</li>
</ol>
<h2 id="MVP和MVC区别"><a href="#MVP和MVC区别" class="headerlink" title="MVP和MVC区别"></a>MVP和MVC区别</h2><ol>
<li>MVP在MVC的基础上，增加了一些限定规则，使得代码更加的模版化、统一、一致。MVC可以有多种实现，没有太大约束，可以使用工具类、静态方法等抽取逻辑，不和View绑定。</li>
<li>Controller和Presenter作用不一样<ol>
<li>Presenter：展示器。Controller：控制器。</li>
<li>Presenter决定页面的逻辑，包括显示逻辑、事件逻辑。Controller是基于行为的，不和页面绑定，负责处理事件行为。</li>
<li>View和Presenter一般情况下是一对一。View和Controller是多对多，一个页面可以包含多个控制器，一个控制器可以被多个页面使用。</li>
</ol>
</li>
<li>MVC做到了视图和数据的<strong>分离</strong>，MVP做到了视图和逻辑的<strong>分离</strong>，数据和视图的<strong>隔离</strong></li>
</ol>
<h1 id="Android架构模式演变：MVC-gt-MVP-gt-MVVM"><a href="#Android架构模式演变：MVC-gt-MVP-gt-MVVM" class="headerlink" title="Android架构模式演变：MVC-&gt;MVP-&gt;MVVM"></a>Android架构模式演变：MVC-&gt;MVP-&gt;MVVM</h1><ol>
<li>MVC问题：Activity承担了View和Controller的职责，同时View和Model存在耦合</li>
<li>MVP：抽取业务逻辑放到Presenter中，隔离了View和Model，View只能和Presenter交互</li>
<li>MVP问题：存在大量样板代码（接口），Presenter持有View引用</li>
<li>MVVM：消除样板代码，避免定义大量接口，通过可观察数据主动刷新UI。ViewModel不持有View的引用</li>
<li>MVVM问题：ViewModel和视图绑定，不利于代码重用。</li>
</ol>
<p>这些是大家通用的理解和说法，但如上文所说，MVC、MVP都存在各式各样的变种和理解。这些架构模式的边界是模糊的，没有一个明确的定义，也不是固定的模版。</p>
<p>MVC和MVP存在的问题也可以通过其他方式、变种来解决，不一定要通过“升级”架构解决。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ol>
<li>没有最好的架构，只有最合适的架构</li>
<li>架构模式不是固定的模版，不要单纯的套模板，而要理解其精髓，掌握基本设计原则之后可以灵活转换、变通。</li>
</ol>
]]></content>
      <categories>
        <category>架构和设计模式</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计中的Clean架构</title>
    <url>/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Clean架构"><a href="#Clean架构" class="headerlink" title="Clean架构"></a>Clean架构</h1><p><img src="/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/Clean%E6%9E%B6%E6%9E%84.png"></p>
<h2 id="层级解释"><a href="#层级解释" class="headerlink" title="层级解释"></a>层级解释</h2><ol>
<li>框架和驱动层：一般由一些框架和工具组成，如UI、DB、Web、Device，包含具体实现，可以随时替换。</li>
<li>接口适配层：如Presenter、Controller、ViewModel等，用于数据转换。</li>
<li>UseCase：用例、业务逻辑。纯Java，不依赖Android</li>
<li>Entity：业务对象</li>
</ol>
<blockquote>
<p> Tips：</p>
<ul>
<li>Flow of control：数据流向</li>
<li>Gateways：架构模式中的入口模式，用于封装访问外部资源接口，方便替换测试资源。如数据源为DB、XML、JSON等</li>
</ul>
</blockquote>
<p>入口模式和外观模式区别？</p>
<blockquote>
<p>设计思想是一样的，都是屏蔽细节，符合迪米特原则（最少知道）。</p>
<p>外观模式一般由服务内部提供，入口模式由调用方自行封装。</p>
<p>Gateway、Repository主要针对数据访问，可以说是外观模式的一种应用。</p>
</blockquote>
<p>入口模式和仓储模式（Repository）区别？</p>
<blockquote>
<p>相同点：都是对业务逻辑屏蔽数据获取细节，方便替换测试数据。</p>
</blockquote>
<h2 id="依赖规则"><a href="#依赖规则" class="headerlink" title="依赖规则"></a>依赖规则</h2><p>外层依赖内层，内层不能依赖外层：指外层定义的函数、变量、类不能被内层引用。</p>
<p>抽象：外层是具体实现，可以随时替换，越往内抽象层次越高，内层不知道外层实现细节</p>
<h2 id="层间通信"><a href="#层间通信" class="headerlink" title="层间通信"></a>层间通信</h2><p><img src="/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/Clean%E6%9E%B6%E6%9E%84%E5%B1%82%E9%97%B4%E9%80%9A%E4%BF%A1.png"></p>
<p>Presenter调用UseCase，传入Callback，UseCase调用Repository接口获取数据，通过Callback返回数据。伪代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> <span class="title">implements</span> <span class="title">UseCase</span>.<span class="title">Callback</span>&lt;<span class="type">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mUserUseCase.getUser(userId, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCallback</span><span class="params">(result : <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">        println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserUseCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mRepository: IUserRepository</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId : <span class="type">String</span>, callback : <span class="type">UseCase</span>.<span class="type">Callback</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        mRepository.getUser(userId, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUserRepository</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId : <span class="type">String</span>, callback : <span class="type">UseCase</span>.<span class="type">Callback</span>&lt;<span class="type">User</span>&gt;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="title">implements</span> <span class="title">IUserRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId : <span class="type">String</span>, callback : <span class="type">UseCase</span>.<span class="type">Callback</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        mService.getUser(userId, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：Callback可以通过异步框架替换，见<a href="/2021/07/15/basic-2021-07-15-%E5%BC%82%E6%AD%A5%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0/">异步概念和常见实现</a></strong></p>
<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><h3 id="UseCase调用外层获取数据是否破坏了依赖规则？"><a href="#UseCase调用外层获取数据是否破坏了依赖规则？" class="headerlink" title="UseCase调用外层获取数据是否破坏了依赖规则？"></a>UseCase调用外层获取数据是否破坏了依赖规则？</h3><blockquote>
<p>可以通过依赖倒置原则解决：内层定义接口，外层实现接口。内层业务逻辑制定抽象规则，不关心外层实现。</p>
</blockquote>
<p>Presenter调用View刷新页面同理：Presenter层定义IView接口，View层实现。获取到数据之后Presenter层调用IView接口刷新数据</p>
<h3 id="Clean架构只需要四层吗？"><a href="#Clean架构只需要四层吗？" class="headerlink" title="Clean架构只需要四层吗？"></a>Clean架构只需要四层吗？</h3><blockquote>
<p>可以根据实际情况增删，只要满足依赖规则</p>
</blockquote>
<h3 id="数据对象如何跨越边界？"><a href="#数据对象如何跨越边界？" class="headerlink" title="数据对象如何跨越边界？"></a>数据对象如何跨越边界？</h3><blockquote>
<p>各层可能有自己定义的数据对象：如DB的数据对象为数据库行，Presenter数据对象为Model</p>
<p>跨边界传递数据时，应该使用内层的数据对象，在外层进行数据Mapper。避免内层依赖外层数据对象，违背依赖规则。</p>
</blockquote>
<h3 id="Clean和MVP"><a href="#Clean和MVP" class="headerlink" title="Clean和MVP"></a>Clean和MVP</h3><p>Clean比MVP多了一层Domain业务层，一般适用于大型项目，业务较复杂的情况。</p>
<p><img src="/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/MVP%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9D%97.png" alt="MVP架构模块"><br><img src="/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/Clean%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9D%97.png" alt="Clean架构模块"></p>
<h3 id="什么是业务逻辑？"><a href="#什么是业务逻辑？" class="headerlink" title="什么是业务逻辑？"></a>什么是业务逻辑？</h3><p><a href="http://www.uml.org.cn/zjjs/201008021.asp">细说业务逻辑</a></p>
<blockquote>
<ul>
<li>狭义：三层架构中的业务层（Domain），Clean架构中的Use Case层</li>
<li>广义：软件产品=界面和交互+业务逻辑，非界面和交互部分，数据也属于业务。某些业务为数据操作集中型，因此抽取出数据访问层。</li>
<li>从空间上讲，数据属于业务的一部分。</li>
<li>从时间上讲，先有业务，再有数据对象。</li>
<li>一个APP可以没有数据，如计算器等，但不能没有业务逻辑。</li>
</ul>
</blockquote>
<p>由于大部分业务只是简单的CRUD，因此业务逻辑层看起来只是简单的封装了一下数据访问层的操作，尤其在客户端业务层被无限弱化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="架构设计目标"><a href="#架构设计目标" class="headerlink" title="架构设计目标"></a>架构设计目标</h3><ul>
<li>框架无关：不依赖于外层框架，如UseCase不需要模拟器、数据库也可以运行</li>
<li>外部类库无关：不依赖于三方库功能</li>
<li>可测试性：每个模块可以独立测试。</li>
<li>UI无关：系统可以任意更换UI，不需要更改业务逻辑</li>
<li>数据源无关：可以修改任意数据来源，如Web、文件、不同数据库</li>
</ul>
<h3 id="Clean架构优缺点"><a href="#Clean架构优缺点" class="headerlink" title="Clean架构优缺点"></a>Clean架构优缺点</h3><p>优点：</p>
<ul>
<li>业务逻辑易于测试</li>
<li>漏洞更容易被隔离</li>
<li>易于功能扩展和添加</li>
<li>代码更易读和可维护</li>
<li>单向依赖、数据驱动编程</li>
</ul>
<p>缺点</p>
<ul>
<li>结构复杂</li>
<li>粒度太细</li>
<li>Usecase 的复用率极低</li>
<li>急剧的增加类和重复代码</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/u014644594/article/details/87858315">Clean架构探讨</a></li>
<li><a href="http://www.uml.org.cn/zjjs/201008021.asp">细说业务逻辑</a></li>
</ul>
<blockquote>
<p>Tips: Robert C. Martin：被称为Uncle Bob，Clean架构提出者，著有《代码整洁之道》、《架构整洁之道》等书</p>
</blockquote>
]]></content>
      <categories>
        <category>架构和设计模式</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计中的三层架构</title>
    <url>/2021/07/29/architecture-2021-07-29-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><h2 id="表示层、业务层、数据访问层"><a href="#表示层、业务层、数据访问层" class="headerlink" title="表示层、业务层、数据访问层"></a>表示层、业务层、数据访问层</h2><ol>
<li>表示层（User Interface Layer，UI）：也叫视图层，视图层常用架构如MVC、MVP、MVVM等，可以有自己的数据对象</li>
<li>业务层（Business Logic Layer，BLL）：包含业务逻辑，数据对象等，有不同的叫法如Domain、Use Case、Service、Bussiness</li>
<li>数据访问层（Data Access Layer，DAL）：封装数据访问逻辑。</li>
<li>持久层（Persistent Layer）：数据物理存储空间，有时候会指代数据访问层。实际不属于三层架构。</li>
</ol>
<p><img src="/2021/07/29/architecture-2021-07-29-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="三层架构"></p>
<blockquote>
<p>Tips：从上往下表示代码调用顺序，从下往上表示数据传输顺序</p>
<p>理解为抽屉结构，框架不变，可以随时抽取替换某一层实现</p>
</blockquote>
<p>三层架构中各层通信通过接口，不依赖具体实现，符合依赖倒置原则</p>
<blockquote>
<p>Tips：依赖倒置原则（DIP）：高层模块不应该依赖低层模块，两者都依赖于抽象，抽象不应该依赖细节，细节应该依赖抽象。——面向接口</p>
</blockquote>
<p>依赖倒置的理解：</p>
<ol>
<li>倒置的是顺序，不是对象：正常情况下，业务层依赖数据层，我们要写业务层之前要先写数据层，数据层修改，业务层要跟着修改。倒置之后可以先写好业务层，再去实现数据层。</li>
<li>依赖关系倒置：原先A直接依赖B，现在A依赖接口，B再实现接口。B不再被A依赖，B反过来依赖接口</li>
</ol>
<h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><h3 id="PO、BO、DTO、VO、POJO、DAO"><a href="#PO、BO、DTO、VO、POJO、DAO" class="headerlink" title="PO、BO、DTO、VO、POJO、DAO"></a>PO、BO、DTO、VO、POJO、DAO</h3><ul>
<li>PO（Persistent Object）：持久对象，数据库中的字段ORM映射，一个PO就是一条数据库记录。可能包含主键、时间戳等信息</li>
<li>BO（Bussiness Object）：业务对象，某个领域内的实体，可以包含业务逻辑。可能由多个PO组成，通常需要把BO转换成PO才能进行数据的持久化</li>
<li>DO（Domain Object）：领域对象，类似BO</li>
<li>DTO（Data Transfer Object）：数据传输对象，BO抽取组装而成，一般用于跨进程或者网络数据传输。</li>
<li>VO（View Object）：视图对象，对应页面上显示的数据。DTO抽取组装而成，例如接口返回通用数据，某个页面只需要特定字段，需要转换成视图对象，一般出现在使用三方接口的情况。</li>
<li>DAO（Data Access Object）：数据访问对象，封装对数据库的访问</li>
<li>Entity：接近原始数据</li>
<li>Model：接近业务对象</li>
<li>POJO（Plain Ordinary Java Object）：简单Java对象。上面的对象其实都是Java对象，是POJO在不同架构层级或者不同场景中的体现</li>
</ul>
<p><strong>根据业务复杂度进行删减</strong>，如客户端中一般直接使用后台返回DTO作为视图对象、持久对象</p>
<h3 id="架构模式和设计模式"><a href="#架构模式和设计模式" class="headerlink" title="架构模式和设计模式"></a>架构模式和设计模式</h3><ul>
<li>架构模式：软件架构设计中的模式，如分层架构模式、MVC架构模式、ORM映射等</li>
<li>设计模式：具体代码实现的模式</li>
</ul>
<p>一般来说：框架 &gt; 架构模式 &gt; 设计模式 &gt; 设计原则</p>
<p>参考《企业应用架构模式》</p>
<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><h3 id="三层架构与MVC"><a href="#三层架构与MVC" class="headerlink" title="三层架构与MVC"></a>三层架构与MVC</h3><blockquote>
<p>两者有一定联系，不完全相同。</p>
<p>三层架构符合依赖倒置原则，面向接口编程，上层调用下层接口，下层定义抽象接口，上层负责实现细节，下层业务逻辑执行完后回调抽象接口。</p>
<p>MVC常用于表现层的的架构模式，MVC三个模块之间没有层级关系。</p>
<p>在业务较简单的情况下，Controller可以取代业务层逻辑，Model可以取代数据访问层功能，看起来MVC就是三层架构</p>
</blockquote>
<h3 id="持久层属不属于三层架构？"><a href="#持久层属不属于三层架构？" class="headerlink" title="持久层属不属于三层架构？"></a>持久层属不属于三层架构？</h3><blockquote>
<p>不属于。</p>
<ul>
<li>三层架构属于逻辑层面的分层，持久层是物理上的分层。</li>
<li>三层架构是代码层面的，持久层不在代码逻辑中</li>
</ul>
</blockquote>
<h3 id="为什么要有数据访问层，业务层直接获取数据？"><a href="#为什么要有数据访问层，业务层直接获取数据？" class="headerlink" title="为什么要有数据访问层，业务层直接获取数据？"></a>为什么要有数据访问层，业务层直接获取数据？</h3><blockquote>
<p>当有多个数据源的时候，业务层直接获取看起来比较乱，因此抽一层专门获取数据</p>
</blockquote>
<h3 id="三层架构中每一层都定义Model对象（UserModel、User、UserEntity），并且提供对应的Mapper，是否有必要？"><a href="#三层架构中每一层都定义Model对象（UserModel、User、UserEntity），并且提供对应的Mapper，是否有必要？" class="headerlink" title="三层架构中每一层都定义Model对象（UserModel、User、UserEntity），并且提供对应的Mapper，是否有必要？"></a>三层架构中每一层都定义Model对象（UserModel、User、UserEntity），并且提供对应的Mapper，是否有必要？</h3><blockquote>
<p>复杂的设计可以通过增加中间层来简化，反过来一样，如果设计很简单，那压根就不需要中间层。自己要掌握这个度。</p>
<p>每一层的数据传递都有对象的丰富和隐藏，用不同的Model对象指代更容易解耦。</p>
<p>更具体的说主要是因为手机端的use case基本上都是CRUD，Domain层没有发挥太大作用，因此可以删掉Model层，Presenter直接获取业务对象。没有破坏依赖规则。</p>
</blockquote>
<h3 id="什么是业务逻辑？"><a href="#什么是业务逻辑？" class="headerlink" title="什么是业务逻辑？"></a>什么是业务逻辑？</h3><p><a href="http://www.uml.org.cn/zjjs/201008021.asp">细说业务逻辑</a></p>
<blockquote>
<ul>
<li>狭义：三层架构中的业务层（Domain），Clean架构中的Use Case层</li>
<li>广义：软件产品=界面和交互+业务逻辑，非界面和交互部分，数据也属于业务。某些业务为数据操作集中型，因此抽取出数据访问层。</li>
<li>从空间上讲，数据属于业务的一部分。</li>
<li>从时间上讲，先有业务，再有数据对象。</li>
<li>一个APP可以没有数据，如计算器等，但不能没有业务逻辑。</li>
</ul>
</blockquote>
<p>由于大部分业务只是简单的CRUD，因此业务逻辑层看起来只是简单的封装了一下数据访问层的操作，尤其在客户端业务层被无限弱化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>架构层次取决于业务复杂度</strong></p>
<p>在C/S、B/S软件中，表示层指的客户端（前端）、业务层和数据访问层在服务端，随着客户端功能的增多，客户端也可以抽取业务层和数据访问层。</p>
<p>传统Web应用中，表示层也在服务端，后来做了前后端分离</p>
<p>前端发展历程：</p>
<ol>
<li>前后端未分离：前端负责写UI模版，后端往模版填数据和逻辑。后端开发完之后统一打包部署。<ol>
<li>后端MVC模式：JSP、PHP、ASP等：后端收到浏览器请求，生成静态页面返回，根据url地址和参数返回不同页面</li>
</ol>
</li>
<li>前后端分离：前端和后端单独开发、分开部署（前端服务、后端服务）。<ol>
<li>SPA单页应用：Ajax，返回不带数据的网页，JS使用Ajax请求数据，局部动态刷新页面。</li>
<li>前端模块化：NodeJS，NPM包管理。前端可以</li>
<li>前端工程化：webpack，编译打包、压缩、优化等</li>
<li>前端MV*架构：Vue、React、Angular等</li>
<li>服务端渲染：把一部分网络请求放到前端的服务端，返回带数据的页面给浏览器，优化首屏体验。后续页面更新通过浏览器请求后端数据</li>
</ol>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/u014644594/article/details/87858315">Clean架构探讨</a></li>
<li><a href="http://www.uml.org.cn/zjjs/201008021.asp">细说业务逻辑</a></li>
<li>《企业应用架构模式》-Martin Flower.</li>
</ul>
<blockquote>
<p>Tips：Martin Flower.：敏捷开发提出者。著有《重构》和《企业应用架构模式》等书</p>
</blockquote>
]]></content>
      <categories>
        <category>架构和设计模式</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>VR技术分类</title>
    <url>/2021/06/11/tech-2021-06-11-VR%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="VR介绍"><a href="#VR介绍" class="headerlink" title="VR介绍"></a>VR介绍</h1><p>VR：综合利用计算机图形系统和各种现实及控制等接口设备，在计算机上生成的、可交互的三维环境中提供沉浸感觉的技术。其中，计算机生成的、可交互的三维环境成为虚拟环境(即Virtual Environment，简称VE)。</p>
<p>人眼双眼看到画面不一样，这种差别让我们能够感知到深度，使事物看起来立体。VR借助了这一原理，给双眼传输不同的画面。</p>
<p>相关技术：头部追踪、空间定位、3D建模、眼球追踪等</p>
<h1 id="VR分类"><a href="#VR分类" class="headerlink" title="VR分类"></a>VR分类</h1><p>VR头盔、VR眼镜这些只是形态上的叫法，这里根据原理进行分类</p>
<table>
<thead>
<tr>
<th></th>
<th>移动端VR</th>
<th>PC端VR</th>
<th>VR一体机</th>
</tr>
</thead>
<tbody><tr>
<td>相同概念</td>
<td>VR盒子、VR眼镜</td>
<td>VR头显、VR头盔、VR眼镜</td>
<td>VR眼镜、VR头盔</td>
</tr>
<tr>
<td>举例</td>
<td>CardBoard、DayDream</td>
<td>HTC Vive、Oculus Rift</td>
<td>三星Gear VR、大鹏一体机、Pico NeoVR</td>
</tr>
<tr>
<td>原理</td>
<td>由两块透镜加盒子组成，将手机放到盒子中，屏蔽外界感知。手机充当屏幕和运算硬件</td>
<td>VR头盔内有两块显示器，借助高性能PC运算能力，将画面传输到VR眼镜中显示。只具备显示和传感、定位功能</td>
<td>具备独立处理器、wifi、蓝牙等的头显。也可以接收HDMI外部输入。</td>
</tr>
<tr>
<td>设备要求</td>
<td>高端手机</td>
<td>高性能PC、高端显卡</td>
<td>可定制软硬件，不需要外部设备</td>
</tr>
<tr>
<td>操作系统</td>
<td>无操作系统</td>
<td>以PC系统Windows 为主</td>
<td>以Android移动系统为主</td>
</tr>
<tr>
<td>交互能力</td>
<td>低。借助手机传感，也可以配备控制器</td>
<td>高。可以搭配各种外设（如手柄、跑道、机车、手枪等），具备空间定位能力</td>
<td>中。带传感、按键、控制器等</td>
</tr>
<tr>
<td>沉浸式体验</td>
<td>低</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>便携性</td>
<td>中</td>
<td>低，需要连HDMI线传输画面，以及各种外设，手柄、定位设备等</td>
<td>中</td>
</tr>
<tr>
<td>价格</td>
<td>便宜</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p>清晰度由屏幕分辨率决定。</p>
<p>画面延迟和刷新率由GPU运算能力和网速决定。</p>
<h1 id="VR视频和全景视频"><a href="#VR视频和全景视频" class="headerlink" title="VR视频和全景视频"></a>VR视频和全景视频</h1><p>全景视频：通过360°全景摄像机拍摄，将一定范围内的某个时间段，记录周围所发生的一切，经过后期的剪辑拼接，将静态的全景图片转化为动态的视频图像展现出来。用户在观看视频的时候，可以随意调节视频上下左右进行观看。</p>
<p>VR视频是用彼此分开的多个摄像机进行拍摄，这样可以捕获左眼和右眼之间的差异。然后再将视频拼合在一起，从而创建出更接近于现实世界的影像，用户在视频中可以获得更具沉浸感的体验。VR视频可以允许用户在同一时间，站在不同的位置观看；</p>
<p>区别：</p>
<ol>
<li>全景视频有别于传统视频单一的观看视角，让人们可以360度自由观看；而VR视频在此基础上，还允许人们在视频场景中任意位置的360度自由观看。</li>
<li>全景视频可以是3D的，也可以是2D的；而VR视频必须是3D的；</li>
<li>全景视频可以通过屏幕观看，也可以带上眼镜观看；而VR视频必须带上头显（即VR眼镜）观看。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>如何把A网站的数据爬到B网站显示</title>
    <url>/2021/05/16/tech-2021-05-16-%E5%A6%82%E4%BD%95%E6%8A%8AA%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%88%B0B%E7%BD%91%E7%AB%99%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="爬虫介绍"><a href="#爬虫介绍" class="headerlink" title="爬虫介绍"></a>爬虫介绍</h1><p>主要有两种方式</p>
<ol>
<li>通过网站提供的API进行爬取<ol>
<li>有的网站不提供API。</li>
<li>API可能收费。</li>
<li>API可能有速率限制</li>
<li>API可能不会公开部分数据</li>
</ol>
</li>
<li>基于HTML的数据抓取：通过访问网页的HTML代码，并从中抓取到所需节点上的数据。网页结构一旦变化，抓取代码可能需要重写。<ol>
<li>全网爬虫：主要用于搜索引擎。深度优先策略、广度优先策略。</li>
<li>聚焦网络爬虫：爬取特定主题页面。</li>
<li>增量式网络爬虫：只爬取新产生或者发生变化的页面。</li>
<li>Deep Web爬虫：需要提交表单才能获取到页面</li>
</ol>
</li>
</ol>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>大体有两种思路</p>
<ol>
<li>使用python定期抓取数据，写入自己的数据库，再自己写个后端服务，前端请求自己的后端数据</li>
</ol>
<pre class="mermaid">graph TB
A网站--定期拉取数据-->python脚本
B网站--请求数据-->后台服务
subgraph 后端
python脚本--保存数据-->数据库
后台服务-->数据库
end</pre>

<ol start="2">
<li>不需要搭建后端和数据库，直接前端请求A网站后端接口数据</li>
</ol>
<p>这里采用第二种方式，坑有点多，下面一一介绍。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="找到请求URL并模拟请求获取数据"><a href="#找到请求URL并模拟请求获取数据" class="headerlink" title="找到请求URL并模拟请求获取数据"></a>找到请求URL并模拟请求获取数据</h2><ol>
<li>控制台找到接口url和请求头等，postman模拟请求</li>
<li>由于后端有做校验，请求会失败，返回403或者500</li>
<li>从控制台中找到<code>Request Header</code>和<code>Cookie</code>等，复制到postman中模拟请求，成功说明爬数据可行。<ol>
<li>大部分header信息是没用的，可以一个一个删除，尝试请求，最后只留下关键的请求头和cookie。</li>
</ol>
</li>
<li>这里发现主要有两个信息，一个是csrfToken，一个是loginToken（实际名称不是这个）。<ol>
<li>csrfToken为自定义请求头，保存在headers中，错误服务端会返回500，并提示<code>invalid csrf token</code></li>
<li>loginToken保存在headers的cookie字段中，错误会返回200，提示登录失效，请重新登录</li>
<li>还有两个koa字段，用来配合csrfToken做校验，这三个值需要对应。由于保存在cookie中，获取方式和loginToken类似，因此不做详细说明</li>
</ol>
</li>
</ol>
<p><code>RequestHeader</code>关键信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Cookie为浏览器自带的Header</span></span><br><span class="line">Cookie: loginToken=***; koa.xxx=***; koa.xxx.sig=***;</span><br><span class="line"><span class="meta">#</span><span class="bash"> csrf-token为服务端自定义Header</span></span><br><span class="line">csrf-token: *** </span><br></pre></td></tr></table></figure>

<p><strong>这里token可能会过期，我们不可能每次都去手动复制、粘贴请求头。因此需要动态抓取csrfToken和loginToken。</strong></p>
<p>控制台中可以查到在登录页面，后端返回的<code>Response Header</code>中的<code>Set-Cookie</code>字段带了loginToken，设置到了浏览器</p>
<p>csrfToken找了半天发现嵌在网页的body中。</p>
<p>我们的目标就是获取到该页面，通过正则从html中提取csrfToken。</p>
<img src="/2021/05/16/tech-2021-05-16-%E5%A6%82%E4%BD%95%E6%8A%8AA%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%88%B0B%E7%BD%91%E7%AB%99%E6%98%BE%E7%A4%BA/csrfToken获取.png" width="800">

<h2 id="Python模拟登录获取Cookie和Token等信息"><a href="#Python模拟登录获取Cookie和Token等信息" class="headerlink" title="Python模拟登录获取Cookie和Token等信息"></a>Python模拟登录获取Cookie和Token等信息</h2><blockquote>
<p><strong>可以先用postman模拟，验证可行性。</strong></p>
</blockquote>
<h3 id="获取loginToken"><a href="#获取loginToken" class="headerlink" title="获取loginToken"></a>获取loginToken</h3><ol>
<li>使用python请求登录页面url：需要设置相应的登录信息，如用户名和密码等。<ol>
<li>这里看到请求数据也是保存在cookie，而不是在<code>RequestBody</code>中，不过这一部分基本是不变的，因此可以直接复制粘贴cookie到<code>RequestHeader</code>中。</li>
</ol>
</li>
<li>登录成功后从<code>Response Header</code>中获取到相应的cookie，代码如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    <span class="keyword">global</span> loginToken</span><br><span class="line">    url = <span class="string">&quot;登录url&quot;</span></span><br><span class="line">    cookie = http.cookiejar.CookieJar()</span><br><span class="line">    handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">    opener = urllib.request.build_opener(handler)</span><br><span class="line">    opener.addheaders = [</span><br><span class="line">    		<span class="comment">#...</span></span><br><span class="line">      	<span class="comment"># 直接拷贝该url的cookie到Header中即可</span></span><br><span class="line">        (<span class="string">&#x27;Cookie&#x27;</span>, <span class="string">&#x27;...包含用户名之类的信息&#x27;</span>),</span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    ]</span><br><span class="line">    request = urllib.request.Request(method=<span class="string">&quot;GET&quot;</span>, url=url)</span><br><span class="line">    response = opener.<span class="built_in">open</span>(request)</span><br><span class="line">    <span class="comment"># 获取ResponseHeader中的Cookie</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cookies: %s = %s&#x27;</span> % (item.name, item.value))</span><br><span class="line">        <span class="keyword">if</span> item.name == <span class="string">&quot;loginToken&quot;</span>:</span><br><span class="line">            loginToken = item.value</span><br></pre></td></tr></table></figure>

<p>这里使用python的<code>requests</code>包请求会失败，原因应该是登录url有几次重定向。</p>
<blockquote>
<p> 使用<code>urllib.request + http.cookiejar</code>这两个包请求并获取cookie</p>
</blockquote>
<h3 id="获取csrfToken"><a href="#获取csrfToken" class="headerlink" title="获取csrfToken"></a>获取csrfToken</h3><p>请求html网页，使用正则提取csrfToken的值，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKey</span>():</span></span><br><span class="line">    <span class="keyword">global</span> csrfToken</span><br><span class="line">    <span class="keyword">global</span> koa1</span><br><span class="line">    <span class="keyword">global</span> koa2</span><br><span class="line">    cookie = http.cookiejar.CookieJar()</span><br><span class="line">    handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">    opener = urllib.request.build_opener(handler)</span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">&#x27;请求url&#x27;</span>)</span><br><span class="line">    <span class="comment"># read读取结果</span></span><br><span class="line">    code_of_html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">		<span class="comment"># 正则提取CSRFToken字段的值</span></span><br><span class="line">    csrfToken = re.search(<span class="string">&#x27;&#x27;&#x27;(?&lt;=CSRFToken&amp;quot;:&amp;quot;).*?(?=&amp;quot;)&#x27;&#x27;&#x27;</span>, code_of_html).group()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;csrfToken: &quot;</span> + csrfToken)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">      	<span class="comment"># 这里其实除了csrfToken之外还有两个保存在cookie字段，是用来配合csrfToken做校验的。由于获取方式和loginToken类似，因此不做详细说明</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cookies: %s = %s&#x27;</span> % (item.name, item.value))</span><br><span class="line">        <span class="keyword">if</span> item.name == <span class="string">&quot;koa.***&quot;</span>:</span><br><span class="line">            koa1 = item.value</span><br><span class="line">        <span class="keyword">if</span> item.name == <span class="string">&quot;koa.***.sig&quot;</span>:</span><br><span class="line">            koa2 = item.value</span><br></pre></td></tr></table></figure>

<h2 id="python请求接口数据"><a href="#python请求接口数据" class="headerlink" title="python请求接口数据"></a>python请求接口数据</h2><p>获取到token信息之后，添加到相应的请求头中即可，模拟请求成功，结果同postman。</p>
<p>走到这一步方案一和方案二还是一样的。用python请求数据先验证可行性，后面实在走不通也可以切换到方案一，将python爬到的数据保存到数据库。</p>
<p>事实上，由于前端浏览器环境和直接用python有很大的不同，后面会有很多坑。</p>
<h2 id="前端请求接口数据"><a href="#前端请求接口数据" class="headerlink" title="前端请求接口数据"></a>前端请求接口数据</h2><p>这里先不管请求头怎么设置，直接请求数据，可以使用Chrome ModHeader插件手动填写请求头。</p>
<h3 id="浏览器跨域请求问题"><a href="#浏览器跨域请求问题" class="headerlink" title="浏览器跨域请求问题"></a>浏览器跨域请求问题</h3><ol>
<li>方法1：服务器设置允许跨域。由于是爬别人的数据，没有后端，因此走不通。</li>
<li>方法2：使用代理，将请求转发到代理服务，由代理服务拿到结果后返回给浏览器。</li>
</ol>
<p>以vue+vite配置为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vite.config.js配置代理</span></span><br><span class="line">server: &#123;</span><br><span class="line">	<span class="comment">//配置代理解决跨域问题</span></span><br><span class="line">	proxy: &#123;</span><br><span class="line">		<span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">			target: <span class="string">&quot;https://hostname.com/&quot;</span>, <span class="comment">// 你请求的第三方接口</span></span><br><span class="line">			changeOrigin: <span class="literal">true</span>, <span class="comment">// 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题</span></span><br><span class="line">			rewrite: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/api/</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="vite和nginx部署"><a href="#vite和nginx部署" class="headerlink" title="vite和nginx部署"></a>vite和nginx部署</h4><p>vite和nginx都可以作为Web服务器运行前端页面，也支持配置代理服务。vite内部还是通过nodejs启动服务器</p>
<p>在我看来，他们的区别只在于<strong>nginx是专业的服务器，性能更好。而vite是一个开发工具</strong>。（PS：如负载均衡、并发强、支持反向代理等，这一块没接触过不懂）</p>
<p>一般情况下vite只在开发时使用，正式环境需要编译打包代码，部署到nginx之类的专业服务器，这个时候vite的配置就不生效了，因此再使用nginx做反向代理。</p>
<p>考虑到内部使用的小型网站，直接使用vite部署即可。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vite build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vite preview&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//npm run build &amp; npm run serve运行</span></span><br></pre></td></tr></table></figure>

<h3 id="Axios设置请求头问题"><a href="#Axios设置请求头问题" class="headerlink" title="Axios设置请求头问题"></a>Axios设置请求头问题</h3><h4 id="Refused-to-set-unsafe-header-“Cookie”"><a href="#Refused-to-set-unsafe-header-“Cookie”" class="headerlink" title="Refused to set unsafe header “Cookie”"></a>Refused to set unsafe header “Cookie”</h4><p>axios请求配置headers报错： Refused to set unsafe header “Cookie”。</p>
<blockquote>
<p>w3c规定，添加以下不安全的请求头，浏览器会终止请求。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Charset</span><br><span class="line">Accept-Encoding</span><br><span class="line">Connection</span><br><span class="line">Content-Length</span><br><span class="line">Cookie</span><br><span class="line">Cookie2</span><br><span class="line">Content-Transfer-Encoding</span><br><span class="line">Date</span><br><span class="line">Expect</span><br><span class="line">Host</span><br><span class="line">Keep-Alive</span><br><span class="line">Referer</span><br><span class="line">TE</span><br><span class="line">Trailer</span><br><span class="line">Transfer-Encoding</span><br><span class="line">Upgrade</span><br><span class="line">User-Agent</span><br><span class="line">Via</span><br></pre></td></tr></table></figure>

<p>服务端自定义的请求头csrfToken不会有问题。因此关键信息只有cookie。</p>
<p>解决方案：</p>
<blockquote>
<p>js使用document.cookie给浏览器设置cookie，请求的时候浏览器会自动带上</p>
</blockquote>
<p><strong>如果还有其他不安全的Header需要设置，暂时不知道怎么解决，这取决于服务端</strong></p>
<p>实在走不通就只能换回方案一，或者通过Mod Header手动填写Headers。由于token会过期，因此隔一段时间就要改很麻烦</p>
<h4 id="带Http-Only的cookie，无法通过document-cookie获取和设置"><a href="#带Http-Only的cookie，无法通过document-cookie获取和设置" class="headerlink" title="带Http Only的cookie，无法通过document.cookie获取和设置"></a>带Http Only的cookie，无法通过document.cookie获取和设置</h4><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/36197012">浅谈Js 操作Cookie，以及HttpOnly 的限制</a></p>
<p>简单来说，后端通过<code>ResponseHeader</code>的<code>Set-Cookie</code>字段设置浏览器Cookie，如果带了httponly标志，表示该cookie只能通过服务端修改，客户端浏览器无法通过JS的document.cookie获取和设置该cookie。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set-Cookie: loginToken=***; path=/; httponly</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HttpOnly是包含在Set-Cookie HTTP响应头文件中的附加标志。生成cookie时使用HttpOnly标志有助于降低客户端脚本访问受保护cookie的风险（如果浏览器支持）</p>
</blockquote>
<p>解决方案：</p>
<blockquote>
<p>浏览器设置退出的时候清除该网站cookie。</p>
<p>原因：网页首次加载的时候可以设置该Cookie，因为该httponly的标志是服务端Response的时候设置的。只要清除该Cookie，每次打开网页通过document.cookie设置即可。</p>
</blockquote>
<h2 id="前端模拟登录动态获取请求头和Token"><a href="#前端模拟登录动态获取请求头和Token" class="headerlink" title="前端模拟登录动态获取请求头和Token"></a>前端模拟登录动态获取请求头和Token</h2><p>这里存在很多问题：</p>
<ol>
<li>跨域问题</li>
<li>登录url重定向：前端请求不知道支不支持处理重定向后的结果</li>
<li>用户信息加密：如果不知道加密算法，即使输入了账号密码也不行</li>
<li>4A登录：大部分公司有单点登录的门户，单点登录返回的token，不是实际业务网站的token，因此即使登录了也没法通过这个token请求接口数据。</li>
</ol>
<p>这些问题前端比较难解决，除非知道正式的登录接口如何请求。因此最终选了其他方案。</p>
<blockquote>
<p>前面通过python模拟登录，可以拿到token等信息，只要自己写个接口，返回token信息的json即可。</p>
<p>取巧的方式：不需要写代码和接口，直接把token写到一个文件中，使用python内置的http服务器开启服务端口，访问该文件即可。</p>
<ul>
<li>Python2：<code>python -m SimpleHTTPServer 8081 </code>，指定端口8081，默认端口8080</li>
<li>Python3：<code>python -m http.server 8081</code></li>
</ul>
</blockquote>
<h2 id="python定期更新token"><a href="#python定期更新token" class="headerlink" title="python定期更新token"></a>python定期更新token</h2><p>token隔一段时间会更新，通过python的schedule定期执行脚本，更新token</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span>():</span></span><br><span class="line">    os.system(<span class="string">&quot;python3 generate_cookie.py&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    schedule.every(<span class="number">4</span>).hours.do(job)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Press Ctrl+&#123;0&#125; to exit&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Break&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    os.system(<span class="string">&quot;python start.py &amp;&quot;</span>)</span><br><span class="line">    job()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        schedule.run_pending()</span><br></pre></td></tr></table></figure>



<h2 id="python-http服务器跨域问题"><a href="#python-http服务器跨域问题" class="headerlink" title="python http服务器跨域问题"></a>python http服务器跨域问题</h2><p>使用python服务器开放cookie文件之后，前端请求cookie文件，提示跨域（域名相同，端口号不一样也会跨域）</p>
<blockquote>
<p>python服务器设置允许跨域。代码如下</p>
<p>通过该脚本启动服务<code>python start.py &amp;</code>，替代<code>python -m http.server 8080</code>。&amp;表示后台执行脚本</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Python 3</span></span><br><span class="line">    <span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, SimpleHTTPRequestHandler, test <span class="keyword">as</span> test_orig</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span> (<span class="params">*args</span>):</span></span><br><span class="line">        test_orig(*args, port=<span class="built_in">int</span>(sys.argv[<span class="number">1</span>]) <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">8080</span>)</span><br><span class="line"><span class="keyword">except</span> ImportError: <span class="comment"># Python 2</span></span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer, test</span><br><span class="line">    <span class="keyword">from</span> SimpleHTTPServer <span class="keyword">import</span> SimpleHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORSRequestHandler</span> (<span class="params">SimpleHTTPRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end_headers</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.send_header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        SimpleHTTPRequestHandler.end_headers(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test(CORSRequestHandler, HTTPServer)</span><br></pre></td></tr></table></figure>

<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里前端网页已经能够拿到其他网站的数据了，具体拿到这个数据怎么处理，怎么组装就要写逻辑了。</p>
<p>别人网站的接口数据格式一般情况下就只适用于自身的UI和业务，放到我们自己的网站UI肯定需要组装和适配。</p>
<p>总结：一步一个坑</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>前端网站部署</title>
    <url>/2021/05/16/webdev-2021-05-16-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="虚拟主机、VPS、云服务器"><a href="#虚拟主机、VPS、云服务器" class="headerlink" title="虚拟主机、VPS、云服务器"></a>虚拟主机、VPS、云服务器</h1><p>不用分的很清楚，简单记几个区别：</p>
<ol>
<li>VPS（Virtual Private Server）和虚拟主机没有root权限，云服务器有root权限</li>
<li>VPS是对单台服务器通过虚拟化成多个虚拟服务器，受限于单台服务器性能和资源，主机宕机之后VPS也宕机。云服务器是对多台服务器资源进行虚拟化，具有更好的容灾能力和伸缩性。</li>
</ol>
<h1 id="http-server部署"><a href="#http-server部署" class="headerlink" title="http server部署"></a>http server部署</h1><p><code>npm run build</code>打包出dist之后通过http服务部署，浏览器限制无法直接访问本地html文件</p>
<img src="/2021/05/16/webdev-2021-05-16-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/dist部署.png">

<ol>
<li>使用python内置服务器开启端口访问文件<ol>
<li>Python2：<code>python -m SimpleHTTPServer 8081 </code>，指定端口8081，默认端口8080</li>
<li>Python3：<code>python -m http.server 8081</code></li>
</ol>
</li>
<li>使用node的http server<ol>
<li>安装http server：<code>npm install http-server -g</code></li>
<li>进入dist目录，启动服务端口：<code>http-server -p 3000</code></li>
</ol>
</li>
</ol>
<h1 id="开发脚手架部署"><a href="#开发脚手架部署" class="headerlink" title="开发脚手架部署"></a>开发脚手架部署</h1><p>vite、next等脚手架框架本质也是起了个服务端口。内部使用nodejs实现。</p>
<p>可以把代码拷到云服务器上，直接<code>npm run dev</code>或者<code>npm run build &amp; npm run serve</code>在远程运行，通过ip或者域名+端口访问。</p>
<p>vite和nginx都可以作为Web服务器运行前端页面，也支持配置代理服务。</p>
<p>在我看来，他们的区别只在于<strong>nginx是专业的服务器，性能更好。而vite是一个开发工具</strong>。（PS：如负载均衡、并发强、支持反向代理等，这一块没接触过不懂）</p>
<p>一般情况下vite只在开发时使用，正式环境需要编译打包代码，部署到nginx之类的专业服务器，这个时候vite的配置就不生效了，因此需要使用nginx做反向代理。</p>
<h1 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h1><p><code>npm run build</code>打包出dist之后部署到Nginx服务器上，Nginx服务器支持反向代理，域名，内网穿透等。（Nginx配置不是很熟悉）</p>
<h1 id="结合Docker部署"><a href="#结合Docker部署" class="headerlink" title="结合Docker部署"></a>结合Docker部署</h1><ol>
<li>Docker下载Nginx镜像或者Node镜像：<code>docker pull 镜像名称[:版本号]</code></li>
<li>将代码或者静态资源打包拷贝或者挂载到Docker容器中：<code>docker run</code>的时候加<code>-v  主机路径:容器路径</code></li>
<li>主机端口映射到容器端口：<code>docker run</code>的时候加<code>-p 主机端口:容器端口</code></li>
<li>在容器中启动相应的服务：<code>docker exec</code>进入容器，按照前面提到的几种方式启动服务</li>
</ol>
<h2 id="Dockerfile打包Docker镜像"><a href="#Dockerfile打包Docker镜像" class="headerlink" title="Dockerfile打包Docker镜像"></a>Dockerfile打包Docker镜像</h2><h3 id="使用Nginx镜像"><a href="#使用Nginx镜像" class="headerlink" title="使用Nginx镜像"></a>使用Nginx镜像</h3><ol>
<li>编写Dockerfile</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据nginx镜像创建新的镜像(可以加上:tag)</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="comment"># 将dist文件拷贝到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dist/ /usr/share/nginx/html/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打包Docker镜像<code>docker build -t 镜像名称[:镜像版本] .</code>，<code>.</code>表示当前路径</li>
<li>启动容器：<code>docker run -itd --name 容器名称 -p 主机端口:容器端口 镜像名称</code></li>
<li>进入容器：<code>docker exec -it 容器名称 /bin/bash</code></li>
<li>启动nginx服务：<code>/usr/sbin/nginx</code>命令开启nginx服务</li>
</ol>
<p>如果有其他配置，可以进入容器下载vi工具编辑。也可以将宿主机上的配置文件挂载到容器中。</p>
<p>可能会出现<code>403 forbidden</code>或者<code>open() failed (13 permission denied)</code>：</p>
<ol>
<li>使用<code>chmod -R 777</code>修改读写权限</li>
<li>Nginx用户配置</li>
<li>Nginx文件路径和网页入口配置</li>
<li>关闭SELinux：修改<code>/etc/selinux/config</code>文件，将SELINUX的值设置为disabled。重启生效。<ol>
<li>临时关闭：<code>setenforce 0</code>，重启失效</li>
</ol>
</li>
</ol>
<p>参考文章：<a href="https://blog.csdn.net/onlysunnyboy/article/details/75270533">解决Nginx出现403 forbidden (13: Permission denied)报错的四种方法</a></p>
<h3 id="使用Node镜像"><a href="#使用Node镜像" class="headerlink" title="使用Node镜像"></a>使用Node镜像</h3><ol>
<li>编写Dockerfile</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据node镜像创建新的镜像(可以加上:tag)</span></span><br><span class="line"><span class="keyword">FROM</span> node</span><br><span class="line"><span class="comment"># 创建容器目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /home/myservice</span></span><br><span class="line"><span class="comment"># 容器工作区，进入容器的时候默认进入该目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home/myservice</span></span><br><span class="line"><span class="comment"># 将文件拷贝到工作区中</span></span><br><span class="line"><span class="comment"># 为了避免node_modules里面的文件也copy，可以配置.dockerignore</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /home/myservice</span></span><br><span class="line"><span class="comment"># npm安装依赖，RUN指令会在构建image的时候执行</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="comment"># 启动npm服务，CMD指令会在容器启动的时候执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> npm run serve</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打包Docker镜像</li>
<li>启动容器</li>
<li>由于配置了CMD指令，启动的时候就会执行<code>npm run serve</code></li>
</ol>
<p>除了拷贝文件到容器中，还可以使用挂载，将文件挂载到容器工作区中。</p>
<blockquote>
<p>挂载不能在Dockerfile中编写，需要启动容器的时候指定，因为镜像可以下载到不同宿主机，导致路径不正确</p>
</blockquote>
<h2 id="Docker-Compose运行容器"><a href="#Docker-Compose运行容器" class="headerlink" title="Docker Compose运行容器"></a>Docker Compose运行容器</h2><ol>
<li>每次创建容器都需要指定挂载路径、端口映射等较麻烦。</li>
<li>多个容器启动需要一个一个执行<code>docker run</code>不方便。</li>
</ol>
<p>可以使用docker compose+yml配置文件创建和启动容器</p>
<ol>
<li>安装docker compose工具</li>
<li>编写yml配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">recruit-front:</span>  <span class="comment"># 指定服务名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">recruit-front</span> <span class="comment"># 镜像名称</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">recruit-front</span> <span class="comment"># 容器名称</span></span><br><span class="line">    <span class="attr">ports:</span>    <span class="comment"># 指定端口映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 指定挂载路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/cloud/recruit:/home/recruit</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动服务：<code>docker-compose up</code>，-d表示后台执行<ol>
<li>启动指定服务：<code>docker-compose up SERVICE_NAME</code>，如该服务依赖了其他服务，会自动启动依赖项。</li>
<li>停止服务：<code>docker-compose stop [SERVICE_NAME]</code></li>
</ol>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>简单的网站使用http server部署即可。如果需要配置代理服务等使用下面的方式</li>
<li>内部网站使用vite或者node等开发工具部署。</li>
<li>公共网站打包部署到nginx或者其他专业服务器上。</li>
<li>结合Docker部署，可以使用现成的环境，并且打包镜像可以移植到不同平台，保证环境一致</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>远程服务器操作</title>
    <url>/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h1><h2 id="ssh登录远程主机"><a href="#ssh登录远程主机" class="headerlink" title="ssh登录远程主机"></a>ssh登录远程主机</h2><p>登录远程主机：<code>ssh -p 端口号 远程主机用户名@远程主机域名或ip</code>，输入远程主机密码</p>
<p>ssh（Secure Shell）： Linux下实现远程登录功能的服务，默认 ssh 服务端口号为 22。</p>
<h2 id="堡垒机登录远程主机"><a href="#堡垒机登录远程主机" class="headerlink" title="堡垒机登录远程主机"></a>堡垒机登录远程主机</h2><p>有的公司会采用堡垒机来访问服务器，堡垒机用于多台服务器统一监控和管理、身份认证、账号管理、登录等。</p>
<p>使用堡垒机登录不需要知道主机用户名和密码，而是输入统一4A账号。堡垒机验证之后选择该账号下的主机登录</p>
<p><img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/%E5%A0%A1%E5%9E%92%E6%9C%BA%E7%99%BB%E5%BD%95.png"></p>
<h1 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h1><p>如何将本地文件拷贝到远程主机上？</p>
<h2 id="SMB连接：知道主机用户名和密码"><a href="#SMB连接：知道主机用户名和密码" class="headerlink" title="SMB连接：知道主机用户名和密码"></a>SMB连接：知道主机用户名和密码</h2><p>SMB（Server Message Block）：可以用于跨平台文件传输</p>
<p>Mac电脑连接步骤：Finder-&gt;前往-&gt;连接服务器-&gt;输入<code>smb:username@host</code>-&gt;输入远程主机密码</p>
<img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/连接smb1.png" width="200">

<img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/连接smb2.png" width="500">

<p>连接成功之后可以通过Finder访问或者拷贝文件夹</p>
<img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/连接smb3.png" width="700">

<h2 id="SCP：不知道主机用户名和密码"><a href="#SCP：不知道主机用户名和密码" class="headerlink" title="SCP：不知道主机用户名和密码"></a>SCP：不知道主机用户名和密码</h2><p>scp（secure copy）：scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p>
<blockquote>
<p>除了scp之外，还可以使用rsync同步文件</p>
</blockquote>
<p>如果使用堡垒机登录，不知道用户名和密码，无法通过SMB传输文件。此时可以使用SCP命令。步骤如下</p>
<ol>
<li>打开本机ssh服务，让远程主机能够通过ssh登录到本机。没打开的话ssh登录本机会报错<code>ssh: connect to host localhost port 22: Connection refused</code><ol>
<li>打开系统偏好设置-&gt;共享-&gt;远程登录</li>
<li>或者使用命令<code>sudo systemsetup -f -setremotelogin on</code></li>
</ol>
</li>
</ol>
<img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/mac允许远程登录.png" width="600">

<ol start="2">
<li>通过堡垒机登录远程主机</li>
<li>在远程终端上使用scp命令拷贝文件<code>scp -r 用户名@源主机IP:源主机路径 目标主机路径</code>，输入本机密码：-r表示拷贝文件夹，例如<code>scp -r build Afauria@172.19.232.28:/Users/Afauria/Desktop/</code></li>
</ol>
<h2 id="通过远程仓库获取文件"><a href="#通过远程仓库获取文件" class="headerlink" title="通过远程仓库获取文件"></a>通过远程仓库获取文件</h2><p>一种取巧的方式</p>
<ol>
<li>将本地文件push到远程仓库如git仓库、docker仓库等。</li>
<li>登录远程主机，使用pull获取文件。</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Github笔记</title>
    <url>/2021/04/12/note-2021-04-12-Github/</url>
    <content><![CDATA[<h1 id="GitHub笔记"><a href="#GitHub笔记" class="headerlink" title="GitHub笔记"></a>GitHub笔记</h1><ol>
<li>学习GitHub项目时，首先看看有没有Wiki。</li>
<li>发现GitHub新功能：仓库中按下<code>.</code>，可以打开VSCode网页编辑器模式，或者直接跳转url：<code>github.dev</code></li>
</ol>
<img src="/2021/04/12/note-2021-04-12-Github/GitHub编辑器模式.png" alt="GitHub网页编辑器" style="zoom: 67%;">

<h1 id="GitHub访问不稳定"><a href="#GitHub访问不稳定" class="headerlink" title="GitHub访问不稳定"></a>GitHub访问不稳定</h1><h2 id="访问慢的原因"><a href="#访问慢的原因" class="headerlink" title="访问慢的原因"></a>访问慢的原因</h2><p>DNS解析耗时。</p>
<ul>
<li>DNS（域名系统，Domain Name System）：将<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D">域名</a>和<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>相互映射的一个分布式数据库。</li>
<li>DNS（域名服务器，Domain Name Server）：将域名转换为IP地址的服务器。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>手动修改系统hosts文件，将github域名对应的ip保存到hosts文件中，访问github的时候可以直接访问该ip，不需要dns解析。</p>
<ul>
<li>windows系统在<code>C:\Windows\System32\drivers\etc\hosts</code>，打开普通用户读写权限<code>右键-属性-安全-选择当前用户-编辑-修改权限-确认</code></li>
<li>mac系统在<code>/etc/hosts</code>，sudo申请权限</li>
</ul>
<blockquote>
<p>Hosts是一个没有扩展名的系统文件，其作用就是保存常用的网址域名与其对应IP地址的映射，当用户在浏览器中输入一个需要登录的网址域名时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会将网址提交DNS服务器进行IP地址的解析，再进行访问。</p>
</blockquote>
<p>步骤如下：</p>
<ol>
<li><p><a href="https://github.com.ipaddress.com/">查询github网站IP</a></p>
</li>
<li><p><a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">查询github域名IP</a></p>
</li>
<li><p><a href="https://github.com.ipaddress.com/assets-cdn.github.com">查询github静态资源IP</a></p>
</li>
<li><p>修改hosts文件，添加如下映射。前三个步骤如果查到多个IP的话可以配置多个</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure></li>
<li><p>cmd执行命令，刷新DNS缓存：<code>ipconfig /flushdns</code></p>
</li>
<li><p>隔一段时间ip可能会变，需要重新配置</p>
</li>
</ol>
<blockquote>
<p>Github上有牛人提供了脚本，一键获取github最新的IP，并更新hosts文件，clone下来，执行index.cmd即可：<a href="https://github.com/luozheao/setHost">setHost</a></p>
</blockquote>
<p>附：查询ip地址的网站：<a href="https://www.ipaddress.com/">ipaddress网站</a>、<a href="http://tool.chinaz.com/dns">站长工具</a></p>
<h2 id="GitPage博客无法访问"><a href="#GitPage博客无法访问" class="headerlink" title="GitPage博客无法访问"></a>GitPage博客无法访问</h2><p>同理，只需要查询博客地址对应的IP，配置hosts就可以解决了。</p>
<p>困扰已久的问题，一直以为是需要翻墙vpn，原来是DNS服务器限制。</p>
<p>当然有时候也确实和网络有关。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>NPM笔记</title>
    <url>/2021/04/12/note-2021-04-12-NPM/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>NPM（Node Package Manager）：NodeJS的包管理工具和服务，已被GitHub收购。</p>
<p>使用方法参考<a href="https://www.npmjs.com.cn/">NPM中文文档</a>或者<code>npm help</code></p>
<ul>
<li>-g：表示全局安装，默认只安装到当前目录的node_modules中</li>
<li>–save：安装组件，并添加到<code>package.json</code>中的<code>dependencies</code>，即运行中需要用到的包，默认开启</li>
<li>–save-dev：安装组件，并添加到<code>package.json</code>中的<code>devDependencies</code>，即开发和编译时需要用到的包</li>
<li>–no-save：只安装组件，不保存</li>
</ul>
<h1 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h1><p>如果npm下载较慢，可以设置<a href="https://npm.taobao.org/">淘宝国内镜像</a>，有几种方式</p>
<ol>
<li>永久使用：<code>npm config set registry https://registry.npm.taobao.org</code></li>
<li>临时使用：<code>npm --registry https://registry.npm.taobao.org</code></li>
<li>可保存配置： 编辑.npmrc文件，加入<code>registry = https://registry.npm.taobao.org</code></li>
<li>使用cnpm替代npm命令：<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>、<code>cnpm install -g hexo-cli</code></li>
</ol>
<p>配置成功后可通过<code>npm config get registry</code>命令验证是否成功</p>
<h1 id="使用n管理node版本"><a href="#使用n管理node版本" class="headerlink" title="使用n管理node版本"></a>使用<strong>n</strong>管理node版本</h1><p>在使用hexo和gitbook-cli的时候，由于gitbook-cli不再维护，只能使用旧版本node，而hexo需要新版本node，无法共存，因此使用n管理node版本。</p>
<p>使用hexo时切换到<code>n node/14.17.6</code>，使用gitbook-cli时切换到<code>n node/10.24.0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装node管理工具</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install n -g</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装新版本node</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> n stable</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> n latest</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查安装了哪些版本node</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> n list</span></span><br><span class="line">node/10.24.0</span><br><span class="line">node/12.22.1</span><br><span class="line">node/14.17.6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换版本</span></span><br><span class="line">n &lt;版本号&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> n rm &lt;版本号&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="npm包版本规则"><a href="#npm包版本规则" class="headerlink" title="npm包版本规则"></a>npm包版本规则</h1><p>范围语法：版本号表示<code>[major, minor, patch]</code>即<code>[大版本, 小版本, 补丁版本]</code></p>
<ol>
<li><code>-</code>：匹配两个版本之间的范围。<code>X.Y.Z - A.B.C</code>表示版本号<code>X.Y.Z &lt;= version &lt;= A.B.C</code><ul>
<li>省略的版本位只需要满足开头部分：如<code>1.2 - 2.3</code>表示<code>1.2.0 &lt;= version &lt; 2.4.0</code>。即匹配<code>1.2</code>和<code>2.3</code>开头的版本</li>
</ul>
</li>
<li><code>*</code>或者<code>X</code>、<code>x</code>：通配符，表示该位可以是任意版本。也可以省略不写<ul>
<li><code>*</code>：表示<code>&gt;=0.0.0</code>，即任意版本。<code>&quot;*&quot; == &quot;&quot;</code></li>
<li><code>1.x</code>：表示<code>1.0.0 &lt;= version &lt; 2.0.0</code>，即只匹配major位，minor和patch位可以是任意版本。<code>&quot;1.x&quot; == &quot;1&quot;</code></li>
</ul>
</li>
<li><code>~</code>：如果指定了次要版本，则允许更新补丁版本，次要版本号不变。如果没有指定次要版本，则允许次要版本更改<ul>
<li><code>~1.2.3</code>：表示<code>1.2.3 &lt;= version &lt; 1.3.0</code></li>
<li><code>~1.2</code>：表示<code>1.2.0 &lt;= version &lt; 1.3.0</code></li>
<li><code>~0.2.3</code>：表示<code>0.2.3 &lt;= version &lt; 0.3.0</code></li>
<li><code>~0</code>：表示<code>0.0.0 &lt;= version &lt; 1.0.0</code>。（允许次要版本更改）</li>
<li><code>~1</code>：表示<code>1.0.0 &lt;= version &lt; 2.0.0</code>。（允许次要版本更改）</li>
</ul>
</li>
<li><code>^</code>：不会修改最左侧的第一个非0数字。第一个非0位后边才可修改。<ul>
<li><code>^1.2.3</code>：表示<code>1.2.3 &lt;= version &lt; 2.0.0</code>。第一个非0位是大版本，大版本不变，允许更新小版本和次要版本</li>
<li><code>^0.2.3</code>：表示<code>0.2.3 &lt;= version &lt; 0.3.0</code>。第一个非0位是小版本，小版本不变，允许更新补丁版本</li>
<li><code>^0.0.3</code>：表示<code>0.0.3 &lt;= version &lt; 0.0.4</code>。第一个非0位是补丁版本，补丁版本不变，可能有beta版本，如<code>0.0.3-beta</code></li>
</ul>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：<a href="../note/2021-4-12-NPM.md">npm依赖包版本说明</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown生成目录结构树</title>
    <url>/2021/04/12/tool-2021-4-12-FileTree/</url>
    <content><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>全局安装tree：<code>npm install tree-node-cli -g</code></li>
<li>查看帮助：<code>tree --help</code>，-L 确定目录层级，-I排除某个文件夹</li>
<li>进入文件夹：示例输入<code>tree -L 4 -I node_modules</code>，效果如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sample-shopping</span><br><span class="line">├── index.html</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   └── favicon.ico</span><br><span class="line">├── README.md</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   ├── assets</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   └── HelloWorld.vue</span><br><span class="line">│   ├── main.ts</span><br><span class="line">│   └── shims-vue.d.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── vite.config.ts</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>Windows下系统自带了一个tree命令，直接输入tree会调用系统的命令</p>
<blockquote>
<p>可以使用treee命令，如上示例改为<code>treee -L 4 -I node_modules</code></p>
<p>npm帮我们创建了两个cmd文件</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能分析大全-ANR</title>
    <url>/2021/01/14/android-2021-01-14-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-ANR/</url>
    <content><![CDATA[<h1 id="ANR分析"><a href="#ANR分析" class="headerlink" title="ANR分析"></a>ANR分析</h1><p>ANR（Application Not Response，应用无响应）：ANR可以看作是卡顿的极端情况，系统有一套检测机制</p>
<p>原因：</p>
<ol>
<li><strong>主线程</strong>做了太多阻塞耗时操作：<ol>
<li>I/O</li>
<li>同步Binder调用</li>
<li>长时间计算</li>
<li>等待阻塞其他线程资源的锁：Thread的join、sleep、wait方法</li>
</ol>
</li>
<li>系统整体性能慢：CPU和内存满载、内存碎片化、GC慢等</li>
</ol>
<p>分析：</p>
<ol>
<li>使用严格模式</li>
<li>打开【开发者选项&gt;显示所有ANR】：一般情况下只有前台会显示ANR对话框，但是后台广播、服务也可能发生ANR。</li>
<li>CPU分析耗时方法</li>
<li>出现anr之后会在<code>/data/anr/</code>路径下生成anr trace文件。找到对应的进程pid，搜索<code>main</code>线程，查看anr堆栈。</li>
</ol>
<p>解决：</p>
<ol>
<li>优化应用内存</li>
<li>将耗时操作放到子线程</li>
<li>避免频繁实时刷新UI</li>
<li>onReceive中耗时操作可以通过启动IntentService处理</li>
<li>代码设计避免出现同步、死锁等异常情况</li>
</ol>
<h1 id="ANR机制"><a href="#ANR机制" class="headerlink" title="ANR机制"></a>ANR机制</h1><p>先介绍大致的流程，源码分析之后再补（TODO）</p>
<p>主要原理：</p>
<ol>
<li>埋炸弹：向system_server埋入定时炸弹，在规定时间内没有完成任务，则引爆炸弹，炸毁目标进程。</li>
<li>拆炸弹：在规定时间内完成任务，拆除炸弹</li>
<li>引爆炸弹：system_server封装现场，抓取快照，收集Trace，便于后续分析。弹出ANR提示框</li>
</ol>
<p>触发机制</p>
<ul>
<li>Service生命周期超时：前台20s、后台200s<ul>
<li><code>Reason: Executing service</code></li>
</ul>
</li>
<li>BroadcastReceiver生命周期超时：前台10s、后台60s<ul>
<li><code>Reason: Broadcast of Intent &#123; ... &#125;</code></li>
</ul>
</li>
<li>ContentProvider启动超时：10s<ul>
<li><code>Reason: ContentProvider not responding</code></li>
</ul>
</li>
<li>前台Activity响应输入事件超时：5s<ul>
<li><code>Reason: Input dispatching timed out (Waiting because the focused window has not finished processing the input events that were previously delivered to it.)</code></li>
</ul>
</li>
<li>窗口获取焦点超时：5s<ul>
<li><code>Reason: Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)</code></li>
</ul>
</li>
</ul>
<p>注：</p>
<p>前台广播和后台广播？</p>
<blockquote>
<p>广播默认是后台的，通过指定Intent的flag为<code>FLAG_RECEIVER_FOREGROUND</code>，设置为前台广播。</p>
<p>AMS中有两个广播队列：mFgBroadcastQueue和mBgBroadcastQueue</p>
</blockquote>
<p>只有有序广播才会超时，无序广播一次循环分发，不存在前一个receiver处理慢的问题</p>
<p>Service、BroadcastReceiver、ContentProvider原理类似，都采用”定时雷”的方式，超时会主动引爆炸弹。</p>
<p>输入事件超时和窗口获取焦点超时，采用的是”扫雷”的方式，超时不会主动引爆炸弹，等新的事件来了之后踩雷。</p>
<p>后台广播和服务ANR不会有提示框，而是Log输出异常。</p>
<p>LMK机制可能刚好把广播进程杀掉，导致ANR，此时pid为0。（自动化测试时可以判断pid为0时不报ANR异常）</p>
<h2 id="Service超时"><a href="#Service超时" class="headerlink" title="Service超时"></a>Service超时</h2><img src="/2021/01/14/android-2021-01-14-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-ANR/ANR-Service超时原理.png" alt="GPU渲染" style="zoom:67%;">

<ol>
<li>客户端启动服务</li>
<li>system_server接收请求，向AMS发送消息，埋”定时雷”。如果时间到了没有拆除则触发ANR。</li>
<li>system_server通知Service进程创建Service</li>
<li>Service进程接收消息，发到主线程</li>
<li>主线程调用Service生命周期，执行任务，并等待SP持久化</li>
<li>执行完成之后向system_server汇报</li>
<li>system_server向AMS发送消息，拆除定时炸弹</li>
</ol>
<h2 id="BroadcastReceiver超时"><a href="#BroadcastReceiver超时" class="headerlink" title="BroadcastReceiver超时"></a>BroadcastReceiver超时</h2><img src="/2021/01/14/android-2021-01-14-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-ANR/ANR-BroadcastReceiver超时原理.png" alt="GPU渲染" style="zoom:67%;">



<ol>
<li>客户端发送广播</li>
<li>system_server接收广播，向AMS发送消息</li>
<li>AMS埋”定时雷”。如果时间到了没有拆除则触发ANR。</li>
<li>AMS通知注册的BroadcastReceiver进程</li>
<li>BroadcastReceiver进程接收消息，发到主线程。主线程调用BroadcastReceiver生命周期，执行任务</li>
<li>执行完成向通知system_server汇报</li>
<li>system_server向AMS发送消息，拆除定时炸弹</li>
</ol>
<h2 id="ContentProvider超时"><a href="#ContentProvider超时" class="headerlink" title="ContentProvider超时"></a>ContentProvider超时</h2><img src="/2021/01/14/android-2021-01-14-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-ANR/ANR-ContentProvider超时原理.png" alt="GPU渲染" style="zoom:67%;">

<ol>
<li>客户端请求ContentProvider数据</li>
<li>system_server接收请求，如果未启动，则先通过zygote fork新进程</li>
<li>ContentProvider进程向system_server注册</li>
<li>AMS埋”定时雷”。如果时间到了没有拆除则触发ANR。</li>
<li>system_server通知Provider进程</li>
<li>Provider进程接收消息，发到主线程执行任务</li>
<li>执行完成向通知system_server汇报</li>
<li>system_server向AMS发送消息，拆除定时炸弹</li>
</ol>
<h2 id="输入事件无响应"><a href="#输入事件无响应" class="headerlink" title="输入事件无响应"></a>输入事件无响应</h2><img src="/2021/01/14/android-2021-01-14-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-ANR/ANR-Input超时原理.png" alt="GPU渲染" style="zoom:67%;">

<ol>
<li>InputReader线程通过EventHub监听<code>/dev/input</code>读取输入事件，发给InputDispatcher。InputDispatcher线程负责将事件分发给目标应用窗口<ol>
<li>mInboundQueue队列记录接收的事件</li>
<li>outboundQueue队列记录即将分发的事件</li>
<li>waitQueue记录已分发，且目标应用未处理完成的事件</li>
</ol>
</li>
<li>InputDispatcher开始分发事件<ol>
<li>先检测是否有正在处理的事件（mPendingEvent），如果没有则取出mInboundQueue队头的事件，赋值给mPendingEvent，并重置ANR时间。否则不会取出事件，也不会重置时间</li>
<li>检查窗口是否就绪（checkWindowReadyForMoreInputLocked）</li>
<li>满足以下条件，进入扫雷，终止本轮事件分发<ol>
<li>对于按键事件判断outboundQueue或者waitQueue不为空</li>
<li>对于非按键事件，判断waitQueue不为空且等待队头时间超时5s</li>
</ol>
</li>
</ol>
</li>
<li>当窗口准备就绪后，将mPendingEvent放到outboundQueue队列</li>
<li>从outboundQueue中取出事件，放入waitQueue队列</li>
<li>InputDispatcher通过Socket发送事件给目标应用进程（APP进程初始化时就已经创建双向通信Socket）</li>
<li>目标进程收到事件后，转发给目标窗口处理，进行View事件分发处理</li>
<li>处理完成后向system_server汇报，从waitQueue队列中移除事件</li>
</ol>
<p>原理：InputDispatcher运行在system_server中，接收底层传上来的设备事件，然后检测上一个事件是否已经处理完毕，如果超时，会调用WMS的notifyANR提示弹窗。应用程序主线程通过InputChannel读取输入事件，交给View处理。</p>
<p>如果没有新事件，即使超时了也不会主动上报。系统推测这个时候用户可能没有关注手机，过一段时间阻塞可能会自行消失，因此会”隐瞒不报”。</p>
<h2 id="窗口获取焦点超时"><a href="#窗口获取焦点超时" class="headerlink" title="窗口获取焦点超时"></a>窗口获取焦点超时</h2><p>属于输入事件超时：由于窗口获取不到焦点，导致应用无法接收事件，因此InputDispatcher会上报ANR。</p>
<p>一般发生在窗口切换时：</p>
<ol>
<li>焦点在A应用窗口</li>
<li>切换应用B</li>
<li>A应用onPause，焦点丢失</li>
<li>B进程创建，焦点丢失</li>
<li>B应用onResume，获取焦点</li>
</ol>
<p>其中3、4过程中焦点为null，如果超过了5s，且新事件到来，则会产生ANR。</p>
<p>此时报告ANR的应用可能是A或者B，但不一定是真正超时的应用，需要具体分析：</p>
<ul>
<li>A应用onPause慢</li>
<li>B应用创建慢，onCreate、onStart、onResume耗时</li>
<li>系统整体性能慢</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ul>
<li><a href="http://gityuan.com/2016/07/02/android-anr/">理解Android ANR的触发原理</a></li>
<li><a href="https://blog.csdn.net/zjy764219923/article/details/102897066">ANR解决方法研究</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能分析大全-优化篇</title>
    <url>/2021/01/06/android-2021-01-06-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E4%BC%98%E5%8C%96%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里只介绍思路，不介绍具体实现方法（持续补充），光一个内存泄漏就可以写一篇。针对内容较多的点，后续可能会单独写文章。</p>
<p>之所以不放在分析方法中，是因为很难归类，穿插到性能分析中的话会有很多重复的地方。（强迫症纠结了好久）</p>
<p>例如布局优化，同时包括了CPU、内存、卡顿优化方法；图片压缩能同时提高运行效率，降低内存占用。</p>
<p><img src="/2021/01/06/android-2021-01-06-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E4%BC%98%E5%8C%96%E7%AF%87/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B1%87%E6%80%BB.png"></p>
<p>通用思路：</p>
<ol>
<li>监控：<ol>
<li>Hook源码关键点</li>
<li>ASM插桩修改</li>
<li>静态代码质量检查</li>
</ol>
</li>
<li>收集、分析、上报：自定义收集、dumpHprof等<ol>
<li>IdleHandler空闲时</li>
<li>开启子进程</li>
</ol>
</li>
<li>优化：<ol>
<li>ASM插桩</li>
<li>编码规范、静态代码质量检查</li>
<li>Gradle编译流程插入</li>
</ol>
</li>
</ol>
<h1 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h1><h2 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h2><ol>
<li>去除无用背景，包括Theme的背景</li>
<li>减少布局层级<ol>
<li>merge标签：替代顶层无用布局</li>
<li>ViewStub标签：懒加载，适当的时机手动inflate</li>
<li>include：布局复用</li>
<li>使用ConstraintLayout</li>
<li>图标+文字：使用TextView+CompoundDrawable</li>
</ol>
</li>
<li>减少半透明对象：例如灰色文本，可以使用黑色+半透明实现，也可以直接用灰色文本</li>
</ol>
<h2 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h2><ol>
<li>子线程处理位图，例如圆角、渐变、叠加、混合等</li>
<li>复杂图形可以开启硬件加速</li>
<li>使用saveLayer离屏绘制</li>
<li>避免使用LinearLayout的weight或者RelativeLayout：计算复杂，可能会触发子布局的多次测量，影响性能</li>
<li>复杂布局使用SurfaceView或TextureView，可以在子线程渲染。TextureView支持移动、旋转、缩放，SurfaceView不支持</li>
<li>使用不同分辨率资源</li>
</ol>
<h2 id="RecyclerView优化"><a href="#RecyclerView优化" class="headerlink" title="RecyclerView优化"></a>RecyclerView优化</h2><ol>
<li>使用局部刷新，利用DiffUtil，避免<code>notifyDatasetChanged</code>、<code>setAdapter</code>等</li>
<li>多个RecyclerView嵌套，可以共享RecycledViewPool</li>
<li>避免inflate多种布局，相似的布局可以共用，bind的时候进行修改即可</li>
<li>上拉预取数据，避免用户等待加载</li>
</ol>
<h1 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h1><ol>
<li>懒加载或异步加载SDK</li>
<li>布局优化：复杂布局解析耗时</li>
<li>白屏优化：<ol>
<li>禁用启动页：主题设置windowDisablePreview属性。在Activity onCreate之前恢复正常主题</li>
<li>设置启动页：主题设置windowBackground属性，可以使用layer-list图片替代大图。在Activity onCreate之前恢复正常主题</li>
</ol>
</li>
</ol>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>基本和常见内存泄漏场景对应</p>
<ol>
<li>使用静态内部类</li>
<li>使用弱引用WeakReference</li>
<li>Activity退出时移除Handler消息、取消AsyncTask、TimerTask任务</li>
<li>手动释放静态对象和单例对象引用的对象</li>
<li>观察者解注册</li>
</ol>
<h2 id="内存大小占用"><a href="#内存大小占用" class="headerlink" title="内存大小占用"></a>内存大小占用</h2><ol>
<li>资源压缩</li>
<li>释放策略：例如应用退到后台，可以释放一些屏幕外的资源、对象或者View</li>
<li>数据结构和缓存优化</li>
<li>代码和包体积优化</li>
</ol>
<h2 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h2><ol>
<li>线程优化<ol>
<li>使用线程池</li>
<li>静态代码质量检查，禁止<code>new Thread</code></li>
<li>ASM修改字节码，将<code>new Thread</code>改为线程池调用，或者自定义Thread类，重写start方法交给线程池</li>
</ol>
</li>
<li>线程监控：hook线程方法<code>pthread_create、pthread_detach、pthread_join、pthread_exit</code>，记录线程生命周期和堆栈，异常上报</li>
</ol>
<h1 id="包体积优化"><a href="#包体积优化" class="headerlink" title="包体积优化"></a>包体积优化</h1><ol>
<li>ProGuard压缩和混淆，去除无用资源</li>
<li>图片压缩，使用webp、svg等</li>
<li>so优化</li>
<li>动态下发</li>
<li>去除无用三方依赖库，或自行封装：有的时候三方库会包含很多用不到的功能</li>
<li>使用Bundle打包，结合splitApk</li>
</ol>
<h1 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h1><ol>
<li>图片：ImageCache，Glide、Picasso等框架自带缓存</li>
<li>线程缓存和复用：合适的线程池参数</li>
<li>View缓存：RecyclerView替代ListView，减少inflate和findViewById次数</li>
<li>I/O缓存：使用Buffered I/O类替代普通I/O类，适用于网络和文件I/O</li>
<li>消息缓存：使用obtainMessage获取Message对象，减少Message创建开销</li>
</ol>
<h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><p>代码优化（Clean Code）：之后单独开一篇Clean Code和编码规范</p>
<ol>
<li>不要提前创建变量，用到的时候再创建</li>
<li>不常用的对象使用完之后主动释放</li>
<li>代码可读性：<ol>
<li>利用设计模式消除回调地狱</li>
</ol>
</li>
</ol>
<p>交互设计优化：通过交互设计来提升用户体验。</p>
<ol>
<li>一些确实耗时的操作，合理利用进度条、加载圈提示用户。</li>
<li>页面不要放太多东西，一次性加载耗时，可以结合抽屉栏、菜单、子页面等</li>
</ol>
<p>算法优化：使用合适的数据结构和算法，例如SparseArray替代HaspMap、ArrayMap。提高插入和查询效率</p>
<p>数据库和存储优化：合理的建表和使用索引</p>
<p>网络优化：网络请求慢也是影响用户体验的因素</p>
<ol>
<li>合并请求</li>
<li>传输数据优化</li>
<li>多节点部署、负载均衡</li>
</ol>
<p>耗电优化</p>
<p>编译优化：</p>
<ol>
<li>使用合适版本的AGP</li>
<li>自定义Task和Plugin，提高开发效率</li>
</ol>
<p>崩溃优化：捕获崩溃异常上报，友好提示</p>
<p>线上监控</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料</p>
<ul>
<li><a href="https://developer.android.com/studio/profile">AndroidStudio指南-分析应用性能</a></li>
<li><a href="https://developer.android.com/topic/performance">Android指南-性能与功耗</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能分析大全-方法篇</title>
    <url>/2021/01/04/android-2021-01-04-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E6%96%B9%E6%B3%95%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>性能分析分为很多领域，关系比较难理清，比如卡顿分析和内存、CPU、布局都有关系，对应的优化也是从这几方面入手。导致文章结构比较难组织，这里就罗列一下各种分析方法。</p>
<p>总体方法：</p>
<ol>
<li>查看基本信息：应用和系统整体CPU、内存等情况</li>
<li>合理假设、缩小范围验证</li>
<li>捕获具体信息：例如堆分配、方法调用栈、方法耗时等</li>
<li>分析详细信息：找到具体影响因素</li>
<li>解决、优化：<strong>没有完美的方案，需要找到平衡点，以提升用户体验为最终目的</strong>，例如空间换时间、时间换空间<ol>
<li>在不影响用户体验情况下进行优化，例如LMK会根据进程优先级决定杀死顺序，ANR会根据前后台设置超时时间</li>
<li>对于不影响用户体验的地方可以降低优先级</li>
</ol>
</li>
</ol>
<p>性能分析不准确？</p>
<ul>
<li>关闭<code>Instance Run</code>，避免影响性能</li>
<li>一般情况下只能对debuggable应用进行分析，而debuggable应用未经优化，导致性能分析不准确。Android 10（API 29）可以在应用清单文件中添加<code>&lt;profileable android:shell=&quot;true&quot;/&gt;</code>，标记为profileable应用，对性能影响较小。可分析应用功能有限，只具备部分CPU和内存分析功能。</li>
<li>频繁的GC会影响性能</li>
<li>分析工具运行的时候会对App运行效率有一定影响，因此应该对比相对性能。</li>
</ul>
<h1 id="CPU分析"><a href="#CPU分析" class="headerlink" title="CPU分析"></a>CPU分析</h1><img src="/2021/01/04/android-2021-01-04-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E6%96%B9%E6%B3%95%E7%AF%87/CPU分析大纲.png" style="zoom:100%;">

<h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><p>方法和函数跟踪：</p>
<ol>
<li>生成<code>.trace</code>跟踪文件：5.0以上可以设置采样间隔，避免影响性能。<ol>
<li>手动开始/停止跟踪：DDMS或者CPU Profiler</li>
<li>代码中调用<code>Debug.startMethodTracing</code>和<code>Debug.stopMethodTracing</code>开始/结束跟踪</li>
</ol>
</li>
<li>查看和分析<code>.trace</code>文件：<ol>
<li>DDMS中的TraceView工具</li>
<li>AS中的CPU Profiler</li>
</ol>
</li>
</ol>
<p>系统跟踪：</p>
<ol>
<li>生成Systrace或Perfetto文件<ol>
<li>使用CPU Profiler，选择CPU记录配置为系统跟踪</li>
<li>Systrace命令行工具：在PC上运行</li>
<li>Perfetto命令行工具：在设备端运行，Android 10以上</li>
<li>System Tracing App生成：Android 9以上</li>
</ol>
</li>
<li>查看和分析：<ol>
<li><a href="https://ui.perfetto.dev/">可视化界面-Perfetto UI</a>中查看</li>
<li>直接打开HTML文件</li>
</ol>
</li>
</ol>
<h2 id="使用Debug类生成Trace文件"><a href="#使用Debug类生成Trace文件" class="headerlink" title="使用Debug类生成Trace文件"></a>使用Debug类生成Trace文件</h2><p>参考<a href="https://developer.android.com/studio/profile/generate-trace-logs?hl=zh-cn">通过应用插桩生成跟踪日志</a></p>
<p>对于间隔时间较短，或难以手动启动/停止记录的场景。可以使用Debug类进行跟踪，生成<code>.trace</code>文件导入CPU Profiler中查看。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启跟踪，可以指定文件名称</span></span><br><span class="line">Debug.startMethodTracing(path)</span><br><span class="line"><span class="comment">//停止跟踪</span></span><br><span class="line">Debug.stopMethodTracing()</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>生成文件存储在<code>getExternalFilesDir()</code>路径下<code>/sdcard/Android/data/$packagename/files</code>。</li>
<li>启用剖析功能后，应用的运行速度会减慢，因此应该对比相对时间，而不是绝对时间。</li>
<li>存在8M的缓冲空间限制，对于持续较长时间的记录，需要使用CPU Profiler</li>
<li>Android 5.0（API 级别 21）以上，新增<code>Debug.startMethodTracingSampling(String tracePath, int bufferSize, int intervalUs)</code>方法，可以基于采样的方法跟踪，可以设置采样间隔，减少对性能的影响。</li>
<li>未指定新的文件名称，调用多次跟踪方法，旧文件会被覆盖。可以动态的重命名文件，如下</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dateFormat: DateFormat = SimpleDateFormat(<span class="string">&quot;dd_MM_yyyy_hh_mm_ss&quot;</span>, Locale.getDefault())</span><br><span class="line"><span class="keyword">val</span> logDate: String = dateFormat.format(Date())</span><br><span class="line">Debug.startMethodTracing(<span class="string">&quot;sample-<span class="variable">$logDate</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h1><img src="/2021/01/04/android-2021-01-04-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E6%96%B9%E6%B3%95%E7%AF%87/内存分析大纲.png" style="zoom:100%;">

<p>USS&lt;PSS&lt;RSS&lt;VSS：</p>
<ul>
<li>独占内存大小 (USS，Unique Set Size)：应用使用的非共享页面大小（不包括共享页面）</li>
<li>按比例分摊的内存大小 (PSS，Proportional Set Size)：应用使用的非共享页面的内存+共享页面的均匀分摊大小（例如，如果三个进程共享 3MB，则每个进程的 PSS 为 1MB）。</li>
<li>常驻内存大小 (RSS，Resident Set Size)：应用使用的非共享页面+共享页面大小</li>
<li>虚拟内存大小（VSS，Virtual Set Size）：应用使用的非共享页面+共享页面+分配但未使用的内存大小</li>
</ul>
<blockquote>
<p>比较有用的是USS和PSS</p>
<p>PSS需要确定共享的页面和共享页面的进程数量，因此计算较慢。PSS加起来即所有进程占用的实际内存。</p>
</blockquote>
<p>共享内存：</p>
<ol>
<li>Zygote启动并加载通用Framework代码和资源，新进程只加载和运行应用代码</li>
<li>大部分静态数据可被其他进程共享：例如Dalvik代码（预加载的odex文件）、应用资源、so库</li>
<li>Android明确分配的共享内存区域，例如窗口Surface和屏幕合成器之间共享的内存</li>
</ol>
<h2 id="查看内存分配"><a href="#查看内存分配" class="headerlink" title="查看内存分配"></a>查看内存分配</h2><ol>
<li>生成hprof文件：<ol>
<li>手动点击dump按钮</li>
<li>命令行：<code>am dumpheap &lt;pid&gt; &lt;file&gt;</code></li>
<li>代码中调用<code>Debug.dumpHprofData (String fileName)</code></li>
</ol>
</li>
<li>查看内存分配<ol>
<li>Java内存分配：<ol>
<li>Memory Profiler</li>
<li>MAT工具</li>
<li>DDMS：Heap、Allocation Tracker</li>
<li>Perfetto的Java Heap Profiler：Android11及以上设备</li>
</ol>
</li>
<li>Native内存分配：Android10及以上设备<ol>
<li>使用Perfetto的heapprofd工具</li>
<li>Memory Profiler：基于Perfetto的heapprofd实现</li>
</ol>
</li>
<li>JNI全局引用：Memory Profiler</li>
</ol>
</li>
</ol>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>内存泄漏：指本该回收的对象，由于被生命周期更长的对象引用，导致GC无法回收这块内存（GC可达，被GC Root对象引用）。内存泄漏不会有直接的异常或崩溃，但是持续的泄漏最终会导致内存溢出。</p>
<blockquote>
<p>就像水龙头漏水，漏的多了会导致池子变满溢出</p>
</blockquote>
<p>检查方法：运行代码，执行操作（例如旋转设备、切换应用），尝试强制GC，检查内存和对象数是否会回到稳定值。</p>
<p>常见内存泄漏场景：</p>
<ul>
<li>Activity、Context、View、Drawable等对象被引用，导致Activity或Context无法回收</li>
<li>非静态内部类，默认持有外部类引用。例如Handler、Thread和Runnable、AysncTask、TimerTask未结束，导致Activity无法被回收</li>
<li>单例或static对象引用其他对象</li>
<li>观察者模式未解注册</li>
<li>Android特殊组件：<ul>
<li>数据库Cursor未销毁</li>
<li>数据库、网络Socket、文件连接未close</li>
<li>自定义控件TypedArray未recycle</li>
<li>Bitmap未recycle</li>
</ul>
</li>
</ul>
<p>类型：</p>
<ul>
<li>常发性内存泄漏：每次执行都会泄漏。</li>
<li>一次性内存泄漏：多次执行只泄漏一次，例如单例持有Context，每次打开新的页面都替换新的Context，原来的Context就可以被释放掉</li>
</ul>
<h2 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h2><p>内存抖动：频繁创建对象，触发GC。例如在循环中、或者<code>onDraw</code>、<code>onBindViewHolder</code>等频繁调用的方法中创建对象</p>
<p>分析：CPU Profiler或者Systrace检查是否频繁发生GC。观察内存曲线是否抖动。</p>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>OOM（Out of memory，内存溢出）：JVM没有足够的内存来为对象分配空间，GC也已经没有空间可回收，此时会抛出<code>java.lang.OutOfMemoryError</code></p>
<p>原因：</p>
<ol>
<li>JVM分配空间太少</li>
<li>应用内存占用太多</li>
<li>应用内存使用完了没释放（内存泄漏）</li>
<li>线程创建太多</li>
<li>文件打开太多</li>
</ol>
<p>类型：</p>
<ol>
<li><code>java.lang.OutOfMemoryError: Java heap space</code>：Java堆内存溢出</li>
<li><code>java.lang.OutOfMemoryError: PermGen space</code>：永久代溢出，即方法区。包括Class信息、静态变量、常量等过多</li>
<li><code>java.lang.OutOfMemoryError: pthread_create</code>：线程创建失败</li>
<li><code>java.lang.StackOverflowError</code>：虚拟机栈溢出，一般是由于深度递归和死循环造成。栈满时再入栈叫”上溢”，栈空时再退栈叫”下溢”</li>
</ol>
<blockquote>
<p>对应JVM内存模型，除了程序计数器之外，Java虚拟机栈、Native方法栈、Java堆、方法区都可能发生内存溢出</p>
</blockquote>
<h2 id="APP内存限制"><a href="#APP内存限制" class="headerlink" title="APP内存限制"></a>APP内存限制</h2><p>一般是系统配置的，通过<code>getprop</code>或者<code>cat /system/build.prop</code>命令可以查看，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[dalvik.vm.heapgrowthlimit]: [160m] # 默认情况下APP可以使用的Heap最大值</span><br><span class="line">[dalvik.vm.heapmaxfree]: [4m] # 单次Heap调整的最大值</span><br><span class="line">[dalvik.vm.heapminfree]: [512k] # 单次Heap调整的最小值</span><br><span class="line">[dalvik.vm.heapsize]: [224m] # APP清单文件中指定了largeHeap属性，则以此项为最大值</span><br><span class="line">[dalvik.vm.heapstartsize]: [4m] # APP启动时分配的初始大小</span><br><span class="line">[dalvik.vm.heaptargetutilization]: [0.75] # 理想的堆内存利用率，已使用Heap/总Heap。GC之后会根据该值调整Heap大小</span><br></pre></td></tr></table></figure>

<p>应用可以通过<code>ActivityManager</code>的<code>getMemoryClass</code>方法查询：返回整数，单位为M</p>
<h2 id="LMK机制"><a href="#LMK机制" class="headerlink" title="LMK机制"></a>LMK机制</h2><p>内存不足前会调用<code>onTrimMemory()</code>方法通知应用主动释放内存，否则Android系统的LMK机制（Low Memory Kill），会根据进程<code>oom_adj_score</code>值杀死进程。</p>
<ul>
<li><code>cat /proc/进程号/oom_adj</code>：查看当前进程adj值</li>
<li><code>cat /proc/进程号/oom_score_adj</code>：查看真正有效的adj值</li>
</ul>
<p>按进程重要程度分为以下级别，参考<a href="https://developer.android.com/topic/performance/memory-management">开发者文档-进程间的内存分配</a></p>
<ul>
<li>系统原生进程：init、kswapd、netd、logd、adbd等</li>
<li>系统进程：系统服务system_server</li>
<li>持久性进程：设备核心服务，例如电话、WLAN</li>
<li>前台进程：用户正在交互所需要的进程<ul>
<li>这个进程拥有正在交互的Activity（前台Activity）</li>
<li>这个进程的Service与正在交互的Activity绑定</li>
<li>这个进程运行了前台服务（<code>startForegroundService</code>和<code>startForeground(id,notification)</code>）</li>
<li>正在执行生命周期的Service</li>
<li>正在执行onReceive的广播</li>
</ul>
</li>
<li>可见进程：不和用户交互，但处于可见状态，用户可感知<ul>
<li>Activity不处于前台，但仍可见（处于Pause状态）。例如前台activity启动一个对话框。</li>
<li>进程的服务和可见Activity绑定</li>
</ul>
</li>
<li>服务进程：运行了不属于上述两类的Service。通过<code>startService() </code>启动的进程。例如后台播放音乐、后台下载</li>
<li>Launcher应用：桌面、主屏幕</li>
<li>上一个应用</li>
<li>后台进程：Activity不可见（处于Stop状态），多个后台进程被保存在一个LRU列表</li>
<li>空进程：不包含活动组件，用于缓存，缩短下次在该进程启动组件的时间。例如Activity Back退出，进程不会立马被杀。</li>
</ul>
<p>更多细节参考<a href="http://gityuan.com/2018/05/19/android-process-adj/">解读Android进程优先级ADJ算法</a></p>
<h2 id="Kswapd"><a href="#Kswapd" class="headerlink" title="Kswapd"></a>Kswapd</h2><p>kernel swap daemon，作为一个守护进程会一直监控系统内存的使用，剩余内存达到低点(阈值)时触发回收操作，剩余内存达到高点(阈值)时停止回收操作。回收策略：</p>
<ol>
<li>删除缓存的内存：缓存本是用来以空间换时间的，现在空间不足了，就释放掉。</li>
<li>压缩内存中的数据：这些数据删除就丢失了，于是压缩后放在内存中的特定区域，节省了空间。</li>
</ol>
<h1 id="卡顿分析"><a href="#卡顿分析" class="headerlink" title="卡顿分析"></a>卡顿分析</h1><p>卡顿通常是因为主线程存在耗时方法调用，因此同样可以使用Cpu分析方法，使用系统跟踪，找到超出16ms的帧，分析具体方法耗时。</p>
<h2 id="GPU渲染速度"><a href="#GPU渲染速度" class="headerlink" title="GPU渲染速度"></a>GPU渲染速度</h2><p>查看GPU绘制信息：<code>dumpsys gfxinfo &lt;packageName</code>&gt;`</p>
<p>打开GPU呈现模式，会显示柱状条和16ms水平线：</p>
<ul>
<li>方法一：开发者选项&gt;监控&gt;GPU呈现模式分析</li>
<li>方法二：<code>setprop debug.hwui.profile [true/visual_bars/false]</code></li>
</ul>
<img src="/2021/01/04/android-2021-01-04-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E6%96%B9%E6%B3%95%E7%AF%87/GPU渲染模式.png" alt="GPU渲染" style="zoom:67%;">

<img src="/2021/01/04/android-2021-01-04-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E6%96%B9%E6%B3%95%E7%AF%87/GPU渲染.png" alt="GPU渲染" style="zoom:67%;">

<h2 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h2><p>打开过度绘制调试：原色（0次，没有过度绘制）–&gt;蓝色（1次）–&gt;绿色（2次）–&gt;粉色（3次）–&gt;红色（3次以上）</p>
<ul>
<li>方法一：开发者选项&gt;调试GPU过度绘制</li>
<li>方法二：<code>setprop debug.hwui.overdraw [false/show/show_deuteranomaly]</code> </li>
</ul>
<h2 id="捕获Binder调用"><a href="#捕获Binder调用" class="headerlink" title="捕获Binder调用"></a>捕获Binder调用</h2><p>频繁的进行Binder调用会影响性能。</p>
<p>捕获Binder调用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开始捕获</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> am trace-ipc start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行操作：滚动、动画...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出Binder调用堆栈</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> am trace-ipc stop --dump-file /data/<span class="built_in">local</span>/tmp/ipc-trace.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="检测主线程耗时"><a href="#检测主线程耗时" class="headerlink" title="检测主线程耗时"></a>检测主线程耗时</h2><h3 id="Looper循环中添加打印"><a href="#Looper循环中添加打印" class="headerlink" title="Looper循环中添加打印"></a>Looper循环中添加打印</h3><p>如下，loop中不断取出message处理。只要通过<code>Looper.getMainLooper().setMessageLogging()</code>设置打印类即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Looper.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">      <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">      <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">      &#125;</span><br><span class="line">      msg.target.dispatchMessage(msg);</span><br><span class="line">      <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用Choregorapher"><a href="#利用Choregorapher" class="headerlink" title="利用Choregorapher"></a>利用Choregorapher</h3><p>Android系统每16ms发送一次VSYNC信号，触发UI绘制，并提供了相应的回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出日志</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h1><ol>
<li>冷启动：后台无进程</li>
<li>热启动：后台有进程，Activity不需要重建，如home键回首页</li>
<li>温启动：后台有进程，但Activity需要重建或恢复状态，如back键退出Activity，内存不足回收Activity</li>
</ol>
<p>查看启动时间：</p>
<ol>
<li><code>am start -W -n package/activity</code></li>
<li>启动应用后查看logcat中Displayed打印，低版本在<code>ActivityManager</code>中打印，高版本在<code>ActivityTaskManager</code>打印</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -W</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> am start -W com.afauria.sample</span></span><br><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] pkg=com.afauria.sample &#125;</span><br><span class="line">Status: ok</span><br><span class="line">Activity: com.afauria.sample/.MainActivity</span><br><span class="line">ThisTime: 517</span><br><span class="line">TotalTime: 517</span><br><span class="line">WaitTime: 672</span><br><span class="line">Complete</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> logcat</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> logcat -d |grep ActivityManager</span></span><br><span class="line">03-15 15:01:07.418  3508  7142 I ActivityManager: START u0 &#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 pkg=com.afauria.sample cmp=com.afauria.sample/.MainActivity&#125; from uid 0</span><br><span class="line">03-15 15:01:07.569  3508  3539 I ActivityManager: Start proc 9980:com.afauria.sample/1000 for activity com.afauria.sample/.MainActivity</span><br><span class="line">03-15 15:01:08.088  3508  3547 I ActivityManager: Displayed com.afauria.sample/.MainActivity: +517ms</span><br></pre></td></tr></table></figure>

<p>分析：结合CPU分析方法，找到耗时操作。</p>
<p>解决：减少Application和Activity的onCreate中的工作</p>
<h1 id="能耗分析"><a href="#能耗分析" class="headerlink" title="能耗分析"></a>能耗分析</h1><p><code>Energy Profiler</code>，后面用过了再补充</p>
<p>方法：</p>
<ol>
<li><p>重置电池数据收集：<code>adb shell dumpsys batterystats --reset</code></p>
</li>
<li><p>断开USB线：充电状态下不会使用电池电量</p>
</li>
<li><p>执行操作</p>
</li>
<li><p>连接手机</p>
</li>
<li><p>输出电池使用情况：<code>adb shell dumpsys batterystats &lt;package_name&gt;</code>，可以看到屏幕耗电和进程cpu耗电</p>
<img src="/2021/01/04/android-2021-01-04-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E6%96%B9%E6%B3%95%E7%AF%87/电池使用情况.png" alt="电池使用情况" style="zoom:80%;"></li>
<li><p>生成报告：</p>
<ol>
<li>7.0及以上设备：<code>adb bugreport &gt; [path/]bugreport.zip</code></li>
<li>6.0及以下设备：<code>adb bugreport &gt; [path/]bugreport.txt</code></li>
</ol>
</li>
<li><p>使用<code>Battery Historian</code>分析报告</p>
</li>
</ol>
<h1 id="网络流量分析"><a href="#网络流量分析" class="headerlink" title="网络流量分析"></a>网络流量分析</h1><p><code>Network Profiler</code></p>
<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>开启严格模式，查看Log输出信息，分析I/O、网络等异常情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Application</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">             .detectDiskReads()</span><br><span class="line">             .detectDiskWrites()</span><br><span class="line">             .detectNetwork()   <span class="comment">// or .detectAll() for all detectable problems</span></span><br><span class="line">             .penaltyLog()</span><br><span class="line">             .build());</span><br><span class="line">     StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</span><br><span class="line">             .detectLeakedSqlLiteObjects()</span><br><span class="line">             .detectLeakedClosableObjects()</span><br><span class="line">             .penaltyLog()</span><br><span class="line">             .penaltyDeath()</span><br><span class="line">             .build());</span><br><span class="line">     <span class="keyword">super</span>.onCreate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="性能分析相关命令"><a href="#性能分析相关命令" class="headerlink" title="性能分析相关命令"></a>性能分析相关命令</h1><p>介绍下上面没有提到的命令：</p>
<ul>
<li>内存：<ul>
<li><code>dumpsys meminfo [package_name]</code>：查看某一时刻应用内存信息。</li>
<li><code>dumpsys procstats</code>：查看进程内存、CPU信息，可以查看一段时间的内存信息</li>
<li><code>procrank</code>：查看所有进程内存使用</li>
<li><code>showmap -a &lt;pid&gt;</code>：查看进程内存信息和对应的地址区域</li>
<li><code>cat /proc/meminfo</code>：查看设备内存</li>
<li><code>free</code>：查看可用内存</li>
<li><code>am dumpheap &lt;pid&gt; &lt;file&gt;</code>：捕获堆内存，生成hprof文件</li>
</ul>
</li>
<li><code>dumpsys cpuinfo</code>：查看cpu信息</li>
<li><code>top</code>：查看<strong>各个进程</strong>信息，内存和CPU使用情况</li>
<li><code>vmstat</code>：查看<strong>系统整体</strong>内存和CPU使用情况</li>
<li><code>df -h</code>：查看设备存储空间</li>
<li><code>tcpdump</code>：网络抓包，结合Wire Shark分析</li>
</ul>
<h2 id="dumpsys-prostats"><a href="#dumpsys-prostats" class="headerlink" title="dumpsys prostats"></a>dumpsys prostats</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">应用运行时间百分比 (minPSS-avgPSS-maxPSS/minUSS-avgUSS-maxUSS/minRSS-avgRSS-maxRSS over 样本数)</span></span><br><span class="line">AGGREGATED OVER LAST 3 HOURS:</span><br><span class="line">  * com.android.systemui / u0a37 / v28:</span><br><span class="line">           TOTAL: 100% (15MB-16MB-17MB/7.7MB-8.7MB-9.4MB/7.7MB-9.6MB-84MB over 178)</span><br><span class="line">      Persistent: 100% (15MB-16MB-17MB/7.7MB-8.7MB-9.4MB/7.7MB-9.6MB-84MB over 178)</span><br><span class="line">  ....</span><br><span class="line">  * com.android.gallery3d / u0a62 / v40030:</span><br><span class="line">           TOTAL: 0.01%</span><br><span class="line">        Receiver: 0.01%</span><br><span class="line">        (Cached): 54% (6.4MB-6.5MB-6.9MB/4.4MB-4.4MB-4.4MB/4.4MB-26MB-68MB over 6)</span><br></pre></td></tr></table></figure>

<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><code>top</code>：查看<strong>各个进程信息</strong>，内存和CPU使用情况</p>
<ul>
<li><code>-m &lt;num&gt;</code>：显示多少个进程</li>
<li><code>-n &lt;num&gt;</code>：刷新次数</li>
<li><code>-d &lt;num&gt;</code>：刷新间隔</li>
<li><code>-s &lt;col&gt;</code>：按列排序，如cpu、vss、rss、thr等</li>
<li><code>-t</code>：显示线程信息</li>
</ul>
<p>top一般用于查看进程信息，vmstat一般用于查看系统整体信息</p>
<h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>Linux命令（Virtual Memory Statistics），查看<strong>系统整体</strong>CPU和内存使用率，虚拟内存交换情况，IO读写情况</p>
<p>使用方式：<code>vmstat [Delay] [Count]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vmstat</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa</span><br><span class="line"> 2  0 173136  81416  14100 228904    0    0     1     0    0 1096  5  7 88  0</span><br></pre></td></tr></table></figure>

<ul>
<li>procs进程<ul>
<li>r： 等待执行的任务数。超过CPU个数，则会出现CPU瓶颈</li>
<li>B：等待IO的进程数量</li>
</ul>
</li>
<li>memory内存<ul>
<li>swpd：正在使用的虚拟内存大小，单位KB</li>
<li>free：空闲内存大小</li>
<li>buff：已用的Buffer大小，对块设备读写进行缓冲</li>
<li>cache：已用的cache大小，文件系统的cache</li>
<li>inact：非活跃内存大小，即可回收的内存。使用-a选项显示</li>
<li>active：活跃的内存大小。使用-a选项显示</li>
</ul>
</li>
<li>Swap：内存交换<ul>
<li>si：每秒从交换区写入内存的大小，单位KB/s</li>
<li>so：每秒从内存写入交换区的大小，单位KB/s</li>
</ul>
</li>
<li>IO<ul>
<li>bi：每秒读取磁盘的块数，单位block，块大小一般为1024bytes</li>
<li>bo：每秒写入磁盘的块数，单位block</li>
</ul>
</li>
<li>System：值越大，sy就会越大<ul>
<li>in：每秒中断数</li>
<li>cs：每秒上下文切换数</li>
</ul>
</li>
<li>CPU：<ul>
<li>us（User time）：用户进程执行消耗CPU时间</li>
<li>sy（System time）：系统进程消耗CPU时间</li>
<li>id：空闲时间（包括IO等待时间），一般us+sy+id=100，us+sy参考值为80%，大于80%可能存在CPU不足</li>
<li>wa：等待IO时间</li>
</ul>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于优化，文中只提到了一部分，更多优化思路请参考下一篇文章</p>
<p>ANR是卡顿的极端情况，单独写了一篇文章介绍。</p>
<p>LMK是系统内存管理的一种机制，后续可能会单独写一篇文章介绍</p>
<p>参考资料：</p>
<ul>
<li><a href="https://developer.android.com/studio/profile">AndroidStudio指南-分析应用性能</a></li>
<li><a href="https://developer.android.com/topic/performance">Android指南-性能与功耗</a></li>
<li><a href="https://developer.android.google.cn/topic/performance/tracing">Android指南-系统跟踪</a></li>
<li><a href="https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering#profile_rendering">开发者文档-GPU渲染分析</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能分析大全-工具篇</title>
    <url>/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习Android性能分析会涉及到一大堆工具。本来想将工具介绍放到性能分析过程中的，但是有的工具包含多个功能、存在功能重叠、或者被废弃了，穿插着讲会比较混乱。因此单独将工具使用拎出来，介绍工具的基本使用、不同工具间的关系、演进。</p>
<h2 id="工具演进"><a href="#工具演进" class="headerlink" title="工具演进"></a>工具演进</h2><p><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%BC%94%E8%BF%9B.png" alt="AndroidDeviceMonitor打开"></p>
<h2 id="工具作用"><a href="#工具作用" class="headerlink" title="工具作用"></a>工具作用</h2><p>按照作用对工具进行下分类。区分下调试工具和性能分析工具</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/Android性能分析工具分类.png" alt="AndroidDeviceMonitor打开" style="zoom:80%;">

<h1 id="Android-Device-Monitor"><a href="#Android-Device-Monitor" class="headerlink" title="Android Device Monitor"></a>Android Device Monitor</h1><p><strong>大部分工具已弃用，被AS工具取代了，参考<a href="https://developer.android.com/studio/profile/monitor">AndroidDeviceMonitor迁移</a></strong></p>
<p>包含在Android SDK中，囊括调试和分析多个工具</p>
<ul>
<li>DDMS：包含设备文件管理，Logcat、线程信息、堆信息、网络统计等功能</li>
<li>TraceView：分析<code>.trace</code>文件（已弃用，使用AS的CPU Profiler）</li>
<li>systrace：收集特定Trace信息</li>
<li>Tracer for OpenGL ES：分析GPU信息</li>
<li>Hierarchy Viewer：布局查看</li>
<li>Pixel Perfect</li>
<li>Network Traffic tool：查看网络传输</li>
</ul>
<h2 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h2><ol>
<li>通过<code>&lt;android-sdk&gt;/tools/monitor</code>命令打开。</li>
<li>旧版本AS可以通过<code>Tools--&gt;Android--&gt;DeviceMonitor</code>打开。（Android Studio3.1中废弃，Android Studio3.2中移除。）</li>
</ol>
<p><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/AndroidDeviceMonitor%E6%89%93%E5%BC%80.png" alt="AndroidDeviceMonitor打开"></p>
<p>界面如下：</p>
<p><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/AndroidDeviceMonitor%E7%95%8C%E9%9D%A2.png" alt="Android Device Monitor"></p>
<h2 id="常用按钮介绍"><a href="#常用按钮介绍" class="headerlink" title="常用按钮介绍"></a>常用按钮介绍</h2><p><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/AndroidDeviceMonitor%E5%B7%A5%E5%85%B7%E6%A0%8F.png" alt="AndroidDeviceMonitor工具栏"></p>
<p>从左到右依次介绍：</p>
<ol>
<li>Debug：开启调试，需要有源代码</li>
<li>Update Heap：更新堆使用情况，选中时右侧面板显示堆栈信息</li>
<li>Dump hprof file：生成堆使用情况hprof文件（Heap Profile）</li>
<li>Cause GC：触发垃圾回收</li>
<li>Update Thread：更新线程运行状态，选中时右侧面板显示线程运行状态</li>
<li>Start/Stop Method Profiling：开启或结束方法跟踪，采集数据，并自动使用TraceView显示图形化界面，可以导出<code>.trace</code>文件</li>
<li>Stop：结束进程</li>
<li>Screen Capture：截屏</li>
<li>Dump View Hierarchy for UI Automator：Dump布局信息</li>
<li>Capture system wide trace using Android systrace：打开Systrace工具</li>
</ol>
<h2 id="DDMS（Dalvik-Debug-Monitor-Server）"><a href="#DDMS（Dalvik-Debug-Monitor-Server）" class="headerlink" title="DDMS（Dalvik Debug Monitor Server）"></a>DDMS（Dalvik Debug Monitor Server）</h2><p>包含窗口和多个工具（调试和分析）：</p>
<ul>
<li>Device：用于查看连接的设备</li>
<li>File Explorer：浏览设备文件</li>
<li>Logcat：查看日志</li>
<li>Emulator Control：仿真控制、模拟器控制，如模拟电话、短信、位置、通知等</li>
<li>System Information：查看系统信息，CPU和内存使用情况等</li>
<li>Thread：查看所有线程信息</li>
<li>Heap：用于查看进程堆使用情况，例如Heap Size、Allocated、Free、Used、Objects等</li>
<li>Allocation Tracker：查看对象内存分配的具体情况</li>
<li>Network Traffic tool：监测网络使用情况</li>
</ul>
<h2 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h2><p>用于方法跟踪和查看，打开<code>.trace</code>文件分析具体方法调用耗时、CPU占用情况。Trace文件生成方式：</p>
<ol>
<li>DDMS或者CPU Profiler中手动点击Start/Stop Method Profiling</li>
<li>代码中调用<code>Debug.startMethodTracing</code>和<code>Debug.stopMethodTracing</code>方法</li>
</ol>
<p>TraceView界面：</p>
<p><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/TraceView%E7%95%8C%E9%9D%A2.png" alt="TraceView界面"></p>
<p>TraceView时间轴窗格：每个线程的活动信息</p>
<p><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/TraceView%E6%97%B6%E9%97%B4%E8%BD%B4%E7%AA%97%E6%A0%BC.png" alt="TraceView时间轴窗格"></p>
<p>TraceView分析窗格：方法耗时和CPU使用信息</p>
<p><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/TraceView%E5%88%86%E6%9E%90%E7%AA%97%E6%A0%BC.png" alt="TraceView分析窗格"></p>
<blockquote>
<ul>
<li>Incl Cpu Time：占用CPU时间，包括调用的方法</li>
<li>Excl Cpu Time：占用CPU时间，不包括调用的方法</li>
<li>Incl Real Time：方法执行真实时间，包括调用的方法</li>
<li>Excl Cpu Time：方法执行真实时间，不包括调用的方法</li>
<li>Calls+Recur Calls/Total：方法调用和递归次数占总次数的百分比</li>
<li>Cpu Time/Call：Cpu占用平均时间</li>
<li>Real Time/Call：平均执行时间</li>
</ul>
</blockquote>
<h2 id="dmtracedump"><a href="#dmtracedump" class="headerlink" title="dmtracedump"></a>dmtracedump</h2><p>SDK工具：<code>Android/sdk/platform-tools/dmtracedump</code>，将<code>.trace</code>文件生成图形化的方法调用堆栈图</p>
<p><code>dmtracedump [-ho] [-s sortable] [-d trace-file-name] [-g outfile] trace-file-name</code></p>
<p><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/dmtracedump.png"></p>
<h2 id="Systrace工具"><a href="#Systrace工具" class="headerlink" title="Systrace工具"></a>Systrace工具</h2><p>Systrace用于系统跟踪。基于Linux Kenerl的ftrace实现。在系统关键流程中插桩（如ActivityThread），通过category指定启用的Tag（高版本支持更多的Tag）。</p>
<blockquote>
<p>Java层的通过<code>android.os.Trace</code>类完成，native层通过<code>ATrace</code>宏完成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Trace</span> </span>&#123;</span><br><span class="line">    <span class="comment">//系统使用</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceBegin</span><span class="params">(<span class="keyword">long</span> traceTag, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isTagEnabled(traceTag)) &#123;</span><br><span class="line">            nativeTraceBegin(traceTag, methodName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceEnd</span><span class="params">(<span class="keyword">long</span> traceTag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isTagEnabled(traceTag)) &#123;</span><br><span class="line">            nativeTraceEnd(traceTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//APP使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beginSection</span><span class="params">(<span class="meta">@NonNull</span> String sectionName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isTagEnabled(TRACE_TAG_APP)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sectionName.length() &gt; MAX_SECTION_NAME_LEN) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;sectionName is too long&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            nativeTraceBegin(TRACE_TAG_APP, sectionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isTagEnabled(TRACE_TAG_APP)) &#123;</span><br><span class="line">            nativeTraceEnd(TRACE_TAG_APP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要收集应用Trace，跟踪的时候需要指定<code>-a</code>选项</strong></p>
<p>应用可以自定义插桩，参考<a href="https://developer.android.com/topic/performance/tracing/custom-events">开发者文档-定义自定义事件</a></p>
<ul>
<li>Java或Kotlin调用：<code>Trace.beginSection()</code>、<code>Trace.endSection()</code></li>
<li>Native调用：引入头文件<code>#include &lt;android/trace.h&gt;</code>，调用<code>ATrace_beginSection()</code>、<code>ATrace_endSection()</code></li>
</ul>
<p>注：</p>
<ol>
<li>begin和end调用一一对应</li>
<li>begin和end必须在同一个线程</li>
<li>systrace要求app是debuggable的，但是debug版本apk和release有差距，会导致结果不准确。可以打包release版本，通过反射调用<code>Trace.setAppTracingAllowed(true)</code>方法开启</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; trace = Class.forName(&quot;android.os.Trace&quot;);</span><br><span class="line">Method setAppTracingAllowed = trace.getDeclaredMethod(&quot;setAppTracingAllowed&quot;, boolean.class);</span><br><span class="line">setAppTracingAllowed.invoke(null, true);</span><br></pre></td></tr></table></figure>

<h3 id="图形界面使用"><a href="#图形界面使用" class="headerlink" title="图形界面使用"></a>图形界面使用</h3><p>DDMS中打开Systrace工具</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/DDMS-Systrace打开.png" style="zoom:67%;">

<p>选择输出路径、跟踪时长、Buffer大小、Tag等</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/DDMS-Systrace.png" style="zoom:67%;">

<h3 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 例如</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Android/sdk/platform-tools/systrace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./systrace.py --time=10 -o mynewtrace.html <span class="built_in">sched</span> gfx view wm binder_driver hal dalvik input res</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Systrace使用说明：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systrace.py [options] [category1 [category2 ...]]</span></span><br><span class="line"></span><br><span class="line">1. option为选项：可用`systrace.py -h`查看</span><br><span class="line">   1. `-t N`或者`--time=N`：指定跟踪时长</span><br><span class="line">   2. `-b N`或者`--buf-size=N`：指定跟踪缓冲区大小</span><br><span class="line">   3. `-a &lt;package-name&gt;`或者`--app=&lt;package-name&gt;`：开启指定包名应用中自定义插桩的Trace</span><br><span class="line">   4. `-l`或者`--list-categories`：查看设备支持的category</span><br><span class="line">   5. `-o`：输出文件，默认输出`trace.html`</span><br><span class="line">   6. `-j`：生成json文件</span><br><span class="line">2. category为要捕获的信息：可用`systrace.py -l`查看</span><br><span class="line">   1. `gfx`：Graphics信息，分析卡顿</span><br><span class="line">   2. `input`：输入事件</span><br><span class="line">   3. `sched`：cpu调度、线程信息</span><br><span class="line">   4. `view`：View绘制</span><br><span class="line">   5. `am`：ActivityManager调用信息，分析启动过程</span><br><span class="line">   6. `dalvik`：虚拟机信息，分析GC</span><br><span class="line">   7. `binder_driver`：分析Binder IPC</span><br><span class="line">   8. `core_services`：SystemServer信息</span><br></pre></td></tr></table></figure>

<h3 id="分析报告"><a href="#分析报告" class="headerlink" title="分析报告"></a>分析报告</h3><p><a href="https://developer.android.google.cn/topic/performance/tracing/navigate-report">分析报告</a>：可以使用Perfetto UI查看，选择”Open with legacy UI”。</p>
<p>如下图，绿色圆圈是正常的帧，红色和黄色表示存在卡顿。（无法看到具体调用栈，可以结合TraceView或CPU Profiler分析）</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/Systrace卡顿帧.png" style="zoom:70%;">

<p><strong>TraceView和systrace区别：</strong></p>
<ul>
<li>TraceView：捕获某个时间段内所有方法调用再全部分析，对性能影响较大（一个人犯罪了，把全国人民抓起来审问），高版本可以设置采样间隔。</li>
<li>systrace：更加精细的控制，对性能影响较小，在系统关键流程中插桩，收集特定范围内的信息，可以选择记录指定的TAG。</li>
</ul>
<h1 id="Android-Studio工具"><a href="#Android-Studio工具" class="headerlink" title="Android Studio工具"></a>Android Studio工具</h1><p>包括多个工具，部分功能是集成Android SDK中的工具</p>
<ul>
<li>Logcat</li>
<li>Android Emulator：模拟器。低版本是打开SDK的模拟器，高版本可以直接在AS中运行模拟器</li>
<li>Debug Window：断点调试</li>
<li>Device File Explorer：设备文件管理</li>
<li>ADB</li>
<li>Layout Inspector：布局查看</li>
<li>性能分析：AS 3.0以下使用Android Monitor，AS 3.0及以上使用Android Profiler</li>
<li>…</li>
</ul>
<h2 id="Android-Monitor"><a href="#Android-Monitor" class="headerlink" title="Android Monitor"></a>Android Monitor</h2><p>Android Studio3.0以下，包含Logcat、Memory、Network、CPU、GPU</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/AndroidMonitor界面.png" style="zoom: 67%;">

<h2 id="Android-Profiler"><a href="#Android-Profiler" class="headerlink" title="Android Profiler"></a>Android Profiler</h2><p>Android Studio3.0及以上，包含CPU（可以进行卡顿检测）、Memory、Network、Energy能耗分析器</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/AndroidProfiler界面.png" alt="AndroidProfiler界面" style="zoom: 40%;">

<p>可以单独启动Profiler，而不运行Android Studio：<code>&lt;studio-installation-folder&gt;/Contents/bin/profiler.sh</code></p>
<h3 id="高级性能分析"><a href="#高级性能分析" class="headerlink" title="高级性能分析"></a>高级性能分析</h3><p>低版本设备（Android 7.1（API 25）及以下）不支持部分高级功能，Profiler中会显示：”Advanced profiling is unavailable for the selected process”。例如：</p>
<ol>
<li>不支持事件时间轴</li>
<li>Memory Profiler中不支持显示GC事件</li>
<li>Memory Profiler中不支持实时显示已分配对象数量</li>
<li>Network Profiler中不支持已传输文件的详细信息</li>
<li>…</li>
</ol>
<p>低版本设备要使用高级功能，需要修改配置：</p>
<ol>
<li>打开Run &gt; Edit Configurations</li>
<li>选择应用Module</li>
<li>选择Profiling，打开”Enable additional support for older devices (API level &lt; 26)”</li>
<li>再次构建运行APP</li>
</ol>
<p>原理：在编译时往应用内插桩，会降低编译速度。</p>
<h2 id="CPU-Profiler"><a href="#CPU-Profiler" class="headerlink" title="CPU Profiler"></a>CPU Profiler</h2><p>检查CPU使用率和线程活动，记录和查看方法调用轨迹。包括Java方法（Method Trace）、C/C++方法（Function Trace），系统方法（System Trace）。</p>
<h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/CPU Profiler.png" style="zoom:67%;">

<ol>
<li>事件时间轴：显示Activity生命周期状态和用户交互事件等。（高级功能，低版本设备不支持）</li>
<li>CPU时间轴：实时显示应用CPU使用率（百分比）和当前应用线程总数，以及其他进程CPU使用率</li>
<li>线程活动时间轴：列出应用所有线程和活动。<ol>
<li>绿色：线程处于活跃状态或正准备使用CPU（就绪）。</li>
<li>黄色：线程处于活跃状态，正在等待I/O操作（磁盘或网络）。</li>
<li>灰色：线程休眠，并且没有消耗CPU。例如访问不可用资源。</li>
</ol>
</li>
</ol>
<p>采样方式：</p>
<ol>
<li>对Java方法采样：间隔一段时间捕获应用调用堆栈，比较捕获的数据集，推导应用Java方法执行时间和资源使用情况。<ol>
<li>如果一个方法在间隔期间执行完毕，则可能不会被记录。对于这种生命周期较短的方法，应使用插桩跟踪</li>
</ol>
</li>
<li>跟踪Java方法：对每个Java方法调用开始和结束时记录时间戳。<ol>
<li>记录每个方法，会影响运行时性能，进而影响分析数据。另外也会造成生成文件过大。</li>
</ol>
</li>
<li>对C/C++函数采样：捕获Native方法采样数据。</li>
<li>跟踪系统调用：基于systrace，记录应用和系统方法调用情况。</li>
<li>自定义配置</li>
</ol>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li>点击Record开始跟踪</li>
<li>应用执行操作</li>
<li>点击Stop停止跟踪</li>
<li>自动打开分析窗格，也可以导出<code>.trace</code>跟踪文件</li>
</ol>
<h3 id="分析窗格"><a href="#分析窗格" class="headerlink" title="分析窗格"></a>分析窗格</h3><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/CPU Profiler分析窗格.png" style="zoom:67%;">

<ul>
<li>Top Down：展开方法的被调用方<ul>
<li>Self：方法本身执行时间</li>
<li>Children：子方法执行时间</li>
<li>Total：方法执行总时间</li>
</ul>
</li>
<li>Bottom Up：展开方法的调用方</li>
<li>Call Chart：调用图。横轴是时间，纵轴是调用栈<ul>
<li>橙色：系统方法</li>
<li>绿色：应用自身方法</li>
<li>蓝色：三方API方法（包括Java API）</li>
</ul>
</li>
<li>Flame Chart：火焰图。将相同的调用栈汇总为较长的横条，横轴不代表时间轴，而是每个方法执行的相对时间<ul>
<li>橙色：系统方法</li>
<li>黄色：三方API方法</li>
<li>米黄色：应用自身方法</li>
</ul>
</li>
</ul>
<p>系统调用跟踪分析窗格，Display部分会显示系统图形流水线信息</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/CPU Profiler卡顿分析.png" style="zoom:70%;">

<ul>
<li>Frames：主线程和RenderThread时间，<strong>超出16ms会显示红色</strong></li>
<li>SurfaceFlinger：SurfaceFinger处理帧缓冲区的时间，负责将缓冲区内容送到显示器</li>
<li>VSYNC：与显示流水线保持同步的信号</li>
<li>BufferQueue：显示缓冲队列有多少帧在等待SurfaceFlinger使用。值为2表示处于三重缓冲状态。</li>
</ul>
<h2 id="Memory-Profiler"><a href="#Memory-Profiler" class="headerlink" title="Memory Profiler"></a>Memory Profiler</h2><h3 id="主界面-1"><a href="#主界面-1" class="headerlink" title="主界面"></a>主界面</h3><img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/Memory Profiler.png" style="zoom:67%;">

<blockquote>
<p>事件时间轴和实时已分配对象属于高级性能分析功能，低版本设备不支持。</p>
</blockquote>
<p>Allocation Tracking采样方式：</p>
<ul>
<li>Full：捕获内存中的所有对象分配。低版本AS中（Android Studio 3.2及以下）的默认行为。影响运行速度。</li>
<li>Sampled：定期对内存中的对象分配情况进行采样。默认选项，在进行性能剖析时对应用性能的影响较小。在短时间内分配大量对象的应用仍可能会表现出明显的速度减慢。</li>
<li>Off：停止跟踪应用的内存分配。</li>
</ul>
<p>内存计算方式：</p>
<ul>
<li>Java：Java或Kotlin对象大小</li>
<li>Native：C或C++对象大小</li>
<li>Graphics：图形BufferQueue内存大小</li>
<li>Stack：原生堆栈和Java堆栈大小，与线程数有关</li>
<li>Code：代码和资源（如Dex字节码、so库等）内存大小</li>
<li>Allocated：分配的Java/Kotlin对象数。不包含Native对象。</li>
</ul>
<h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li>查看内存使用量时间轴。</li>
<li>高版本（Android 8.0及以上）默认持续跟踪内存分配。低版本（Android 8.0以下）需要点击Record memory allocations按钮开始记录和停止记录。</li>
<li>执行操作</li>
<li>点击强制GC按钮进行垃圾回收</li>
<li>点击dump按钮捕获堆内存状态，生成hprof文件</li>
<li>查看内存具体分配情况，或者导出hprof文件</li>
</ol>
<h3 id="分析窗格-1"><a href="#分析窗格-1" class="headerlink" title="分析窗格"></a>分析窗格</h3><ol>
<li>Class Name：类分配情况</li>
<li>Instance：实例分配情况</li>
<li>Instance Detail：实例的引用链和实例的成员变量</li>
</ol>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/Memory Profiler堆信息.png" style="zoom:67%;">

<ul>
<li>Allocations：分配的对象数</li>
<li>Depth：GC Root到对象实例的最短跳数</li>
<li>Native Size：对象在Native内存中的大小</li>
<li>Shallow Size：对象本身的大小</li>
<li>Retained Size：对象被释放掉后真正能够减少的大小，包括递归引用的对象。如果有多个对象引用同一个对象，则不会被计算进来。</li>
</ul>
<h2 id="Energy-Profiler"><a href="#Energy-Profiler" class="headerlink" title="Energy Profiler"></a>Energy Profiler</h2><p>比较少用到</p>
<h2 id="Network-Profiler"><a href="#Network-Profiler" class="headerlink" title="Network Profiler"></a>Network Profiler</h2><p>比较少用到</p>
<h1 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h1><h2 id="Perfetto命令行工具"><a href="#Perfetto命令行工具" class="headerlink" title="Perfetto命令行工具"></a>Perfetto命令行工具</h2><ul>
<li><a href="https://perfetto.dev/docs/">官方文档</a></li>
<li><a href="https://developer.android.google.cn/studio/command-line/perfetto">使用介绍</a></li>
<li><a href="https://ui.perfetto.dev/">可视化界面-Perfetto UI</a></li>
</ul>
<p><strong>Android10引入的新一代分析工具，用于替代systrace工具</strong>。大文件打开比systrace快，能长时间跟踪，systrace记录短时间设备活动。</p>
<ol>
<li>ftrace：收集内核Trace信息</li>
<li>atrace：收集用户态Trace信息</li>
<li>Java Heap Profiler：收集Java内存分配信息，Android11及以上</li>
<li>heapprofd：收集Native内存分配信息，Android10以上</li>
</ol>
<p>Perfetto UI界面如下，很容易找到超出16ms的块，再进一步放大检查调用栈</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/Perfetto卡顿帧.png" style="zoom:70%;">

<p>Perfetto可以兼容显示Systrace界面：选择”Legacy UI”打开</p>
<h2 id="System-Tracing-App"><a href="#System-Tracing-App" class="headerlink" title="System Tracing App"></a>System Tracing App</h2><p>Android 9.0以上包含一个Sytem Tracing的系统应用，用于跟踪设备活动，生成Trace文件。可以直接在设备进行记录，再获取跟踪文件，无需通过adb连接到电脑。参考<a href="https://developer.android.google.cn/topic/performance/tracing/on-device">System Tracing App介绍</a></p>
<p>步骤如下：</p>
<ol>
<li><p>打开System Tracing应用：【开发者选项&gt;System Tracing】</p>
<img src="/2021/01/01/android-2021-01-01-Android%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E7%AF%87/System Tracing App.png" style="zoom:50%;"></li>
<li><p>开始记录：有两种方式</p>
<ol>
<li>打开”Record Trace”开关</li>
<li>打开”Show Quick Settings Tile”开关，将图标添加到快捷设置面板中，点击快捷图标开启”记录系统Trace”。</li>
</ol>
</li>
<li><p>应用执行操作</p>
</li>
<li><p>停止记录，会保存Trace文件</p>
<ol>
<li>Android10及以上版本使用<code>.perfetto-trace</code>后缀保存（Perfetto格式，可以转换成Systrace格式，参考<a href="https://perfetto.dev/docs/quickstart/traceconv">Trace conversion</a>）</li>
<li>Android9以上版本使用<code>.ctrace</code>后缀保存（Systrace格式）</li>
</ol>
</li>
<li><p>共享跟踪记录</p>
<ol>
<li>使用adb：<code>adb pull /data/local/trace/ .</code></li>
<li>使用Intent，通过电子邮件或其他应用共享给应用开发者</li>
</ol>
</li>
<li><p>Perfetto UI中打开Trace文件分析</p>
</li>
</ol>
<h2 id="AGI（Android-GPU-Inspector）"><a href="#AGI（Android-GPU-Inspector）" class="headerlink" title="AGI（Android GPU Inspector）"></a>AGI（Android GPU Inspector）</h2><p>图形分析器，包括Trace跟踪，CPU、GPU、内存、电池使用、Vulkan API调用等功能。参考<a href="https://developer.android.com/agi">Android GPU 检查器 (AGI)</a></p>
<h2 id="MAT（Memory-Analyzer-Tool）"><a href="#MAT（Memory-Analyzer-Tool）" class="headerlink" title="MAT（Memory Analyzer Tool）"></a>MAT（Memory Analyzer Tool）</h2><p>Java堆分析工具，和Eclipse一起使用。用于分析hprof文件。也有独立运行的MAT。参考<a href="https://www.jianshu.com/p/d8e247b1e7b2">MAT使用入门</a></p>
<h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>Android内存泄漏检测工具，单独写一篇文章介绍和分析源码。</p>
<h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p>方法一：参考<a href="https://www.cnblogs.com/sgtb/p/3708566.html">Android端抓包方法</a></p>
<ol>
<li>tcpdump抓包（需root）：<code>tcpdump -p -vv -s 0 -w /mnt/sdcard/capture.pcap</code></li>
<li>Wire Shark中分析。</li>
</ol>
<p>方法二：参考<a href="https://www.cnblogs.com/shoshana-kong/p/14161898.html">使用Fiddler实现手机抓包</a></p>
<ol>
<li>电脑安装Fiddler</li>
<li>启动Fiddler代理服务</li>
<li>手机设置网络代理为电脑IP地址，端口默认为8888</li>
<li>手机端请求网络，请求会经过PC代理转发</li>
<li>Fiddler分析网络包</li>
</ol>
<h1 id="性能分析脚本"><a href="#性能分析脚本" class="headerlink" title="性能分析脚本"></a>性能分析脚本</h1><p>见<a href="https://github.com/Afauria/PerformanceCheck">GitHub-PerformanceCheck</a></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ul>
<li><a href="https://developer.android.com/studio/profile">AndroidStudio指南-分析应用性能</a></li>
<li><a href="https://developer.android.com/topic/performance">Android指南-性能与功耗</a></li>
<li><a href="https://developer.android.google.cn/topic/performance/tracing">Android指南-系统跟踪</a></li>
<li><a href="https://developer.android.com/agi">Android GPU 检查器 (AGI)</a></li>
<li><a href="https://www.jianshu.com/p/d8e247b1e7b2">MAT使用入门</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>FCM推送</title>
    <url>/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<h1 id="FCM（Firebase-Cloud-Message）推送"><a href="#FCM（Firebase-Cloud-Message）推送" class="headerlink" title="FCM（Firebase Cloud Message）推送"></a>FCM（Firebase Cloud Message）推送</h1><h2 id="Firebase介绍"><a href="#Firebase介绍" class="headerlink" title="Firebase介绍"></a>Firebase介绍</h2><p>Firebase是一家实时后端数据库公司，提供多种产品帮助开发者快速构建App功能。2014年被Google收购。</p>
<ul>
<li>IaaS（Infrastructure as a Service）基础设施即服务：提供基础设施。如阿里云</li>
<li>PaaS（Platform as a Service）平台即服务：提供软件开发能力的平台，如涂鸦开发者平台</li>
<li>SaaS（Software as a Service）软件即服务：提供软件开发，俗称软件外包</li>
<li>BaaS（Backend as a Service）后端即服务：提供后台云服务、云存储，简化移动应用开发，如Firebase、七牛云、友盟等</li>
</ul>
<p>支持的功能：有免费和付费</p>
<ul>
<li><a href="https://firebase.google.com/docs">Firebase开发文档</a></li>
<li><a href="https://console.firebase.google.com/project/smarthome-8684b/features?hl=zh_cn">Firebase产品和功能</a></li>
<li><a href="https://firebase.google.com/docs/android/setup#available-libraries">Firebase依赖库</a></li>
</ul>
<p><img src="/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/Firebase-Function.png" alt="Firebase产品和功能"></p>
<p>相关概念：<a href="https://firebase.google.com/docs/projects/learn-more">Firebase说明</a>、<a href="https://firebase.google.com/docs/android/learn-more">Android和Firebase更多说明</a></p>
<ul>
<li>Firebase产品：Firebase提供的功能或服务</li>
<li>Firebase项目：一个项目中可以有多个应用（iOS、Android、Web等），同一项目中的资源共享</li>
<li>Firebase应用：不同平台应用，同一平台不同包名应用</li>
<li>Google Cloud：Firebase项目实际是Google Cloud项目，具有Firebase特定配置和服务。GCM-&gt;FCM</li>
<li>Firebase控制台：管理Firebase项目、应用、产品等</li>
<li>谷歌三件套，功能边界<ul>
<li>Google Play服务框架：Android的后台服务，提供常用的Google API调用，如Google登录服务、Google地图服务等</li>
<li>Google Play商店：Google应用商店，依赖Google Play服务</li>
<li>Google Play游戏服务：提供手机游戏开发的API，不安装的话可能无法正常运行Google Play商店的游戏</li>
</ul>
</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/diagram-FCM.png" alt="架构"></p>
<p><img src="/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/push_flow.jpeg"></p>
<p><img src="/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/push_flow.png"></p>
<h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><table>
<thead>
<tr>
<th></th>
<th>通知消息</th>
<th>数据消息（透传消息）</th>
<th>通知+数据</th>
</tr>
</thead>
<tbody><tr>
<td>接收方式</td>
<td>由SDK处理</td>
<td>由应用自行处理</td>
<td></td>
</tr>
<tr>
<td>数据格式</td>
<td>通知title、body</td>
<td>自定义键值对</td>
<td>通知内容+数据内容</td>
</tr>
<tr>
<td>发送方式</td>
<td>控制台发送、服务器发送</td>
<td>服务器发送</td>
<td>控制台发送、服务器发送</td>
</tr>
</tbody></table>
<p>客户端接收消息</p>
<table>
<thead>
<tr>
<th align="left">应用状态</th>
<th align="left">通知</th>
<th align="left">数据</th>
<th align="left">通知+数据</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前台</td>
<td align="left"><code>onMessageReceived</code></td>
<td align="left"><code>onMessageReceived</code></td>
<td align="left"><code>onMessageReceived</code></td>
</tr>
<tr>
<td align="left">后台</td>
<td align="left">系统任务栏显示</td>
<td align="left"><code>onMessageReceived</code></td>
<td align="left">通知：系统任务栏显示，数据：通知栏跳转intent的extras属性。</td>
</tr>
</tbody></table>
<h2 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h2><p><strong>要系统带GMS，国内手机厂商一般做了阉割</strong></p>
<p><a href="//todo">实操Demo</a></p>
<h3 id="手动添加Firebase"><a href="#手动添加Firebase" class="headerlink" title="手动添加Firebase"></a>手动添加Firebase</h3><ol>
<li><p>控制台创建Firebase项目</p>
</li>
<li><p>Firebase项目添加应用，填入应用包名</p>
</li>
<li><p>下载<code>google-services.json</code>文件，添加到application模块中</p>
</li>
<li><p>Gradle添加google服务插件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//项目build.gradle</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    google()  <span class="comment">// Google&#x27;s Maven repository</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath <span class="string">&#x27;com.google.gms:google-services:4.3.4&#x27;</span>  <span class="comment">// Google Services plugin</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    google()  <span class="comment">// Google&#x27;s Maven repository</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模块引入插件（<code>app/build.gradle</code>）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.google.gms.google-services&#x27;</span>  <span class="comment">// Google Services plugin</span></span><br></pre></td></tr></table></figure></li>
<li><p>模块添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用BoM，可以通过仅指定一个版本（BoM的版本）来管理所有Firebase库版本。</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Import the BoM for the Firebase platform</span></span><br><span class="line">    implementation platform(<span class="string">&#x27;com.google.firebase:firebase-bom:26.2.0&#x27;</span>)</span><br><span class="line">    implementation <span class="string">&#x27;com.google.firebase:firebase-messaging-ktx&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.firebase:firebase-analytics-ktx&#x27;</span><span class="comment">//analytic可以移除，用于演示BoM作用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.不使用BoM</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.google.firebase:firebase-messaging-ktx:21.0.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.firebase:firebase-analytics-ktx:18.0.0&#x27;</span><span class="comment">//analytic可以移除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个Service继承<code>FirebaseMessagingService</code>，Manifest注册服务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.MyFirebaseMessagingService&quot;</span><br><span class="line">    android:exported=&quot;false&quot;&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.google.firebase.MESSAGING_EVENT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取令牌：</p>
<ul>
<li>主动获取：<code>FirebaseMessaging.getInstance().getToken()</code></li>
<li>Token刷新回调：onNewToken，应用卸载安装等会触发token刷新</li>
</ul>
</li>
<li><p>模拟发送下行消息（下发给客户端，上行消息：客户端发给服务端）：可以指定应用、指定主题、指定设备组、指定设备token等将消息发送给特定用户或群体</p>
<ul>
<li>控制台发送</li>
<li>REST API调用</li>
<li>后台应用不同语言接入服务端SDK，调用SDK方法</li>
</ul>
</li>
</ol>
<h3 id="使用Android-Studio-Firebase-Assistant添加"><a href="#使用Android-Studio-Firebase-Assistant添加" class="headerlink" title="使用Android Studio Firebase Assistant添加"></a>使用Android Studio Firebase Assistant添加</h3><p>FIrebase Assistant是一个Android Studio插件，可创建并关联到Firebase项目，自动添加配置</p>
<p>使用方式：<code>AndroidStudio-&gt;Tools-&gt;Firebase</code>打开Assistant工具，按照工具流程添加</p>
<p>存在问题：导入库版本不一定是最新的，可能和Android Studio版本有关。低版本库getToken方式不一样，需要手动更新版本。</p>
<h2 id="获取Firebase服务授权"><a href="#获取Firebase服务授权" class="headerlink" title="获取Firebase服务授权"></a>获取Firebase服务授权</h2><p>服务器向Firebase服务发送请求需要获取授权。<a href="https://firebase.google.com/docs/cloud-messaging/auth-server">有三种方式</a></p>
<ul>
<li>Google 应用默认凭据（ADC，Google Cloud Application Default Credentials）：在Google服务器环境运行，可以直接使用默认凭据</li>
<li>服务帐号 JSON 文件：在非Google服务器环境运行，需要下载服务账号JSON文件。<ol>
<li>配置到服务器环境变量中。</li>
<li>通过代码读取Json文件路径，可能存在凭据泄漏风险，推荐方式一</li>
</ol>
</li>
<li>源自服务帐号的短期有效的 OAuth 2.0 访问令牌：根据服务账号JSON文件，生成临时访问令牌，添加到发送请求中。如果使用Admin SDK，SDK内部会自行处理，不需要手动生成。</li>
</ul>
<p>生成访问令牌：</p>
<ul>
<li>下载服务账号json文件</li>
<li>下载脚本，修改脚本</li>
<li>脚本和json文件放在同一目录，进入目录执行脚本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip install oauth2client</span></span><br><span class="line"><span class="keyword">from</span> oauth2client.service_account <span class="keyword">import</span> ServiceAccountCredentials</span><br><span class="line"></span><br><span class="line">PROJECT_ID = <span class="string">&#x27;smarthome-8684b&#x27;</span></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://fcm.googleapis.com&#x27;</span></span><br><span class="line">FCM_ENDPOINT = <span class="string">&#x27;v1/projects/&#x27;</span> + PROJECT_ID + <span class="string">&#x27;/messages:send&#x27;</span></span><br><span class="line">FCM_URL = BASE_URL + <span class="string">&#x27;/&#x27;</span> + FCM_ENDPOINT</span><br><span class="line">SCOPES = [<span class="string">&#x27;https://www.googleapis.com/auth/firebase.messaging&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [START retrieve_access_token]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_access_token</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Retrieve a valid access token that can be used to authorize requests.</span></span><br><span class="line"><span class="string">    :return: Access token.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    credentials = ServiceAccountCredentials.from_json_keyfile_name(</span><br><span class="line">        <span class="string">&#x27;service-account.json&#x27;</span>, SCOPES)</span><br><span class="line">    access_token_info = credentials.get_access_token()</span><br><span class="line">    <span class="built_in">print</span> access_token_info.access_token</span><br><span class="line">    <span class="keyword">return</span> access_token_info.access_token</span><br><span class="line"><span class="comment"># [END retrieve_access_token]</span></span><br><span class="line"></span><br><span class="line">_get_access_token()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="REST-API调用模拟发送消息"><a href="#REST-API调用模拟发送消息" class="headerlink" title="REST API调用模拟发送消息"></a>REST API调用模拟发送消息</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Postman请求</span></span><br><span class="line">POST https://fcm.googleapis.com/v1/projects/myproject-b5ae1/messages:send HTTP/1.1</span><br><span class="line"></span><br><span class="line">Content-Type: application/json</span><br><span class="line">Authorization: Bearer ya29.ElqKBGN2Ri_Uz...HnS_uNreA</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;message&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>:<span class="string">&quot;bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;notification&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>:<span class="string">&quot;This is an FCM notification message!&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;FCM Message&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">     		<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span></span><br><span class="line">   		&#125;</span><br><span class="line">    <span class="comment">//针对特定平台</span></span><br><span class="line">  	<span class="string">&quot;android&quot;</span>:&#123;</span><br><span class="line">       <span class="attr">&quot;notification&quot;</span>:&#123;</span><br><span class="line">         <span class="attr">&quot;icon&quot;</span>:<span class="string">&quot;stock_ticker_update&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;color&quot;</span>:<span class="string">&quot;#7e55c3&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;Authorization: Bearer ya29.ElqKBGN2Ri_Uz...HnS_uNreA&quot; -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line">&quot;message&quot;:&#123;</span><br><span class="line">   &quot;notification&quot;:&#123;</span><br><span class="line">     &quot;title&quot;:&quot;FCM Message&quot;,</span><br><span class="line">     &quot;body&quot;:&quot;This is an FCM Message&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;token&quot;:&quot;bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...&quot;</span><br><span class="line">&#125;&#125;&#x27; https://fcm.googleapis.com/v1/projects/myproject-b5ae1/messages:send</span><br></pre></td></tr></table></figure>

<h2 id="Firebase-SDK初始化方式"><a href="#Firebase-SDK初始化方式" class="headerlink" title="Firebase SDK初始化方式"></a>Firebase SDK初始化方式</h2><p><a href="https://firebase.googleblog.com/2016/12/how-does-firebase-initialize-on-android.html">Firebase初始化原理</a></p>
<p>多进程初始化问题：（Demo演示）Application调用Firebase</p>
<p>原因：Firebase通过ContentProvider初始化SDk，由于ContentProvider只在主进程运行，因此子进程如果调用Firebase方法，会报没有初始化SDK异常。</p>
<blockquote>
<p>解决方案1：自定义ContentProvider，指定子进程，初始化Firebase</p>
</blockquote>
<blockquote>
<p>解决方案2：子进程如果不需要Firebase服务的时候，不要在Application中调用Firebase方法。</p>
<ul>
<li>判断当前进程名为主进程名才调用Firebase方法</li>
<li>在主进程Activity中调用Firebase方法。—&gt;Activity可能被创建多次<ul>
<li>添加flag判断是否已经调用过Firebase方法</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="TV上遇到的问题"><a href="#TV上遇到的问题" class="headerlink" title="TV上遇到的问题"></a>TV上遇到的问题</h2><h3 id="TV没有通知栏，后台无法收到通知消息、通知-数据消息"><a href="#TV没有通知栏，后台无法收到通知消息、通知-数据消息" class="headerlink" title="TV没有通知栏，后台无法收到通知消息、通知+数据消息"></a>TV没有通知栏，后台无法收到通知消息、通知+数据消息</h3><p>通知流程：</p>
<pre class="mermaid">graph TB

onStartCommand-->processIntent
processIntent-->handleIntentOnMainThread
handleIntentOnMainThread-->handleNotificationOpen{是否是打开通知栏Action}
handleNotificationOpen--是-->跳转Activity
handleNotificationOpen--否-->handleIntent
handleIntent-->action{Intent类型}
action--token刷新-->onNewToken
action--消息接收-->handleMessageIntent
handleMessageIntent-->alreadyReceivedMessage{是否接收过该消息}
alreadyReceivedMessage--是-->END((结束))
alreadyReceivedMessage--否-->passMessageIntentToSdk
passMessageIntentToSdk-->dispatchMessage
dispatchMessage-->判断是否是通知消息
判断是否是通知消息--是-->return
判断是否是通知消息--否-->onMessageReceived</pre>

<ul>
<li><a href="https://firebase.google.com/docs/libraries/">查看源码</a>，发现判断条件在bundle参数中，可以修改Bundle参数。</li>
<li>onStartCommand、onStart等声明为final，无法重写。</li>
<li>handleIntent和handleIntentOnMainThread都可重写，保险写到handleIntentOnMainThread。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleIntentOnMainThread</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">	Log.e(TAG, <span class="string">&quot;handleIntentOnMainThread before&quot;</span> + intent?.extras)</span><br><span class="line">	<span class="comment">//问题1: intent.extras拿到的是拷贝过的Bundle</span></span><br><span class="line">  	<span class="comment">//需要直接修改intent的extras</span></span><br><span class="line">	<span class="keyword">val</span> key = Constants.MessageNotificationKeys.ENABLE_NOTIFICATION</span><br><span class="line">	<span class="keyword">val</span> oldKey = Constants.MessageNotificationKeys.ENABLE_NOTIFICATION.replace(</span><br><span class="line">		Constants.MessageNotificationKeys.NOTIFICATION_PREFIX,</span><br><span class="line">    	Constants.MessageNotificationKeys.NOTIFICATION_PREFIX_OLD</span><br><span class="line">	)</span><br><span class="line">	intent?.removeExtra(key)</span><br><span class="line">	intent?.removeExtra(oldKey)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.handleIntentOnMainThread(intent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMessageReceived</span><span class="params">(remoteMessage: <span class="type">RemoteMessage</span>)</span></span> &#123;</span><br><span class="line">	Log.d(TAG, <span class="string">&quot;onMessageReceived, From: &quot;</span> + remoteMessage.from + remoteMessage.messageType)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (remoteMessage.<span class="keyword">data</span>.isNotEmpty()) &#123;</span><br><span class="line">		Log.d(TAG, <span class="string">&quot;onMessageReceived, Message data payload: &quot;</span> + remoteMessage.<span class="keyword">data</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//问题2: remoteMessage.notification为空，notification使用懒加载</span></span><br><span class="line">  <span class="comment">//需要重新包装回来.</span></span><br><span class="line">  <span class="comment">//1.重新把remove的key put进去再访问</span></span><br><span class="line">  <span class="comment">//2.手动构造notification。构造方法私有</span></span><br><span class="line">  <span class="comment">//3.不构造notification，只拿想要的值：title和body</span></span><br><span class="line">	<span class="keyword">val</span> intent = remoteMessage.toIntent()</span><br><span class="line">	<span class="keyword">val</span> key = Constants.MessageNotificationKeys.ENABLE_NOTIFICATION</span><br><span class="line">	intent.putExtra(key, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">	RemoteMessage(intent.extras).notification?.let &#123;</span><br><span class="line">		Log.d(TAG, <span class="string">&quot;onMessageReceived, Message Notification Body: &quot;</span> + remoteMessage.notification!!.body)</span><br><span class="line">    Handler(Looper.getMainLooper()).post &#123;</span><br><span class="line">            Toast(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">                view = LayoutInflater.from(<span class="keyword">this</span><span class="symbol">@FCMTestService</span>)</span><br><span class="line">                    .inflate(R.layout.layout_notification, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line">                setGravity(Gravity.END or Gravity.BOTTOM, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">                duration = Toast.LENGTH_LONG</span><br><span class="line">            &#125;.show()</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li>模拟器有时候收不到通知，可以随便打开一下google应用，触发gms。怀疑是模拟器save state导致</li>
<li>am force-stop 退出的应用，不会收到notification</li>
<li>kill杀掉的进程，可以收到notification</li>
<li>后台弹窗问题：使用Toast，并且target sdk version小于26（弹窗问题小结）</li>
</ul>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>gitbook介绍：<a href="https://chrisniael.gitbooks.io/gitbook-documentation/content/index.html">GitBook文档</a>、<a href="http://www.chengweiyang.cn/gitbook/basic-usage/README.html">GitBook简明教程</a>、mermaid插件</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Firebase</tag>
        <tag>推送</tag>
      </tags>
  </entry>
  <entry>
    <title>《爱丽丝漫游奇境记》【转】</title>
    <url>/2020/11/20/reader-2020-11-20-%E7%88%B1%E4%B8%BD%E4%B8%9D%E6%BC%AB%E6%B8%B8%E5%A5%87%E5%A2%83%E8%AE%B0%E3%80%90%E8%BD%AC%E3%80%91/</url>
    <content><![CDATA[<h1 id="爱丽丝漫游奇境记【转】"><a href="#爱丽丝漫游奇境记【转】" class="headerlink" title="爱丽丝漫游奇境记【转】"></a>爱丽丝漫游奇境记【转】</h1><p>红桃皇后其实是个长得头特别大，人特别丑，完全得不到老爸老妈优秀遗传的长女，天天忍受长得漂亮得尽人心的做作妹妹，得不到人爱的可怜姑娘。 　　<br>　　她乖戾的性格下，其实就只是一个可爱傻女孩善良率直的心。<br>　　说她善良。你看爱丽丝说她因为长太高大被人当成怪人的时候，马上引来她的同情。别人不欢迎你，我欢迎。她身边的宠臣,一个两个不是这个鼻子长歪了,就是那个肚子特别大。<br>　　她就是同情和她自身一样，因为某样东西特别大（头），而遭到他人歧视的人。<br>　　她统治了wonderland，也没有将她做作妹妹怎样。<br>　　她亲爱的美丽妹妹还是有座开满鲜花的美丽宫殿以及一群忠心的白色骑士。<br>　　而她妹妹重获政权之后，却要把她流放到一个没有人烟的地方，而且不允许任何人和她说话。这对害怕孤独的红桃皇后来说，比杀了她更致命。 　　<br>　　可怕比可爱更强。<br>　　可以的情况下，谁想变成可怕的那个？<br>　　人人都喜欢不是更好吗？<br>　　可是万一你像红桃皇后那样顶着一个会被嘲笑，不具好感的头怎么办？ 　　<br>　　所以我觉得红桃皇后才真正像一个皇后，而白皇后充其量是个无能公主而已。<br>　　她坚强有魄力。<br>　　她心里的无助和害怕也只讲给骑士听而已。当然遗憾的是，这是个无情的迎合的家伙。<br>　　红桃皇后对外有多么坚强啊，以至于那么地讨人厌。<br>　　请看白皇后，遇到困难，只是指望一个外来者爱丽丝帮她砍掉恶龙。<br>　　明明自己有能力而不行动，以一个誓言为借口。<br>　　谁又想去杀生？<br>　　爱丽丝也已说过，自己坚决不杀生。<br>　　捂着鼻子取药材。<br>　　明明自己调药的时候，拿着死人油脂调得轻柔而快乐。<br>　　这样装模作样而伪善皇后，我一点都不喜欢。<br>　　相比之下，红桃皇后，嘟着嘴巴嚷嚷说，砍到他的头。真实而可爱多了。 　　<br>　　有天生的美丽，和优雅善良的举止少精弱精 ，自然更讨人喜欢。妹妹是这样获得国土大部分人的支持的。<br>　　而红桃皇后呢?<br>　　后面我发现效忠她的都是些满脸凶相的可怕怪兽之后,就想,也是,同类人才能理解同类人的寂寞。<br>　　其实这种人才特别容易为对向他们和善的人感动，甚至赴汤蹈火。<br>　　你看那只掌管钥匙的恶兽，只是因为爱丽丝还给了他眼睛。<br>　　也就甘心成为了她的坐骑。 　　<br>　　这些看似的恶人，其实就是缺乏爱的孩子而已。<br>　　内心异常的善良。<br>　　最怕别人欺骗她，背叛她，所以只好以一脸凶恶来保护自己。 　　<br>　　不过，童话是童话，红桃皇后扮演恶人，自然要输的。 </p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>小说</title>
    <url>/2019/09/01/reader-2019-09-01-Novel/</url>
    <content><![CDATA[<h2 id="雪中悍刀行"><a href="#雪中悍刀行" class="headerlink" title="雪中悍刀行"></a>雪中悍刀行</h2><ul>
<li>这一日，武当年轻掌教骑鹤至江南，与徐脂虎骑鹤远离江湖。仙人骑鹤下江南，才入江湖，便出江湖——武当年轻掌教洪洗象</li>
<li>江南好，最好是红衣。北凉苦，最苦是白衣</li>
<li>折剑断臂弃江湖，我以手足换手足</li>
<li>一杯酒，敬温华，折剑断臂木剑侠。</li>
<li>“不练剑了”——温华，温不胜</li>
<li>一剑仙人跪，两袖青蛇来</li>
<li>天不生我李淳罡，剑道万古如长夜。（天不生仲尼，万古如长夜）</li>
<li>大雪坪剑来</li>
<li>小僧如果真的可以成佛，今日起却也不想成佛了</li>
<li>风紧、扯呼。来，给少爷上酒呐</li>
<li>徐婴，你怎么可以如此好看，以至于我在神武城外，在借出春秋剑之前那一刻就想啊，跟你死在一起也不错。</li>
<li>若不回头、谁替你救苦救难。如能转念，何须我大慈大悲（采石山）</li>
<li>试问天上仙人，谁敢来此人间</li>
<li>古人说：世上没有不散的宴席。可还有古人说：人生何处不相逢</li>
<li>什么天下第一，还不是揉着腰出去的</li>
<li>徐骁嫡长子徐凤年在此求死</li>
<li>容我徐凤年今日只做一回徐凤年</li>
<li>我愿大秦无风，北凉不战。大秦，风起</li>
<li>这技术活，本世子没法赏啊</li>
<li>定要教你满城尽挂北凉刀</li>
<li>儒以文乱法，侠以武犯禁——韩非子</li>
<li>世上纵有千场雪，无奈再无悍刀行</li>
<li>读书人多是负心人</li>
<li>君只见，北凉铁骑甲天下，却不见北凉人家，家家皆缟素</li>
<li>战后细数，墓碑三十二万啊。世人皆知北凉铁骑战无双，不知北凉十家九户无儿郎</li>
<li>北凉军30万，人人皆向北而死</li>
<li>吃了多少苦，这个不能说，说了别人也只当你猪油蒙心不知足，是在跟饥汉说荤菜油腻。所以遇人只能说享了多大的福。</li>
<li>飞剑一日不养，百日功夫俱废，三日不养，飞剑彻底失去灵气，与废铜烂铁无异，再无希望飞剑取头颅</li>
<li>年轻人离家十年不算久，上了年纪的人，那就是出门一步即远行。</li>
<li>读书人比常人有着更多的感触，读书识字越多，认得历史越多，心思就难免越重，才学越高，往往分寸感越弱，不喜欢拿捏火候，准确说来，是不屑，懒得与人与事去虚与委蛇。看人和做事，就容易非黑即白，也就是你所谓的意气用事了。所以历史上那些才高八斗的文豪，往往做官不大，这种奇怪现象，不光光是眼高手低四个字就可以全部解释的，好在这对他们来说也没有关系，帝王将相终是一抔土，唯有饮者诗者留其名，借酒浇愁写名篇，岂不快哉。千百年后，自然比那些帝王将相和达官显贵更容易让人记住。</li>
<li>积善之家，必有余庆。积恶之家，必有余殃</li>
<li>如一棵西北黄沙最常见地胡杨木，生而不死有千年，死而不倒再千年，倒而不朽又千年</li>
<li>文章本天成，妙手偶得之</li>
<li>紫微斗数，八卦六爻，尚可。面相手相，奇门遁甲，还行。——赵长陵</li>
<li>自皈依佛，不受一切轮回苦。自皈依法，得享十方三世福。自皈依僧，不堕往生诸恶道……</li>
<li>青草明年生，大雁去又回。春风今年吹，公子归不归？青石板青草绿，青石桥上青衣郎，哼着金陵调。谁家女儿低头笑？黄叶今年落，一岁又一岁。秋风明年起，娘子在不在？黄河流黄花黄，黄河城里黄花娘，扑着黄碟翘，谁家儿郎刀在鞘？</li>
<li>情深不寿，慧极必伤</li>
<li>君只见，君只见听潮湖万鲤跳龙门。独不见清凉山，有名石碑不计数。君只见，君只见葫芦口头颅筑京观。独不见高墙下，死人骸骨相撑住。君只见，君只见凉州北策马啸西风。独不见边关南，朗朗书声出破庐。君只见，君只见三十万铁骑甲天下，独不见北凉人，家家户户皆缟素。</li>
<li>东西南北，南北东西，只愿相随无别离。今生来世，来世今生，谁能聚首再相逢</li>
<li>我褚禄山有洁癖，每天都要换一身华贵衣衫，喜豪奢，每天都要换乘骏马，嗜美食，每天都要厨子做出新花样，什么都换，唯独不换主子，褚禄山恨不得所有受恩于徐家的白眼狼，都知道一个简单的道理，人生两苦，想要却不得，拥有却失去，只要殿下让褚禄山掌权一日，褚禄山就一日见不得有人站着说话不腰疼。</li>
<li>那朝堂清流嘴里的话可要比屠夫手里的刀要利害，现在没多少人是文盲了，但人人都是那清流。</li>
<li>人生当苦无妨，良人当归即好</li>
</ul>
<h2 id="剑来"><a href="#剑来" class="headerlink" title="剑来"></a>剑来</h2><ul>
<li>寺庙不在僧人在，僧人不在佛经在，佛经不在佛组在，佛组不在佛法在</li>
<li>一心二意，不三不四，人五人六，乱七八糟，八九不离十，是个怂蛋</li>
<li>我听说不修行的寻常读书人，学问不小，就是都不太吃得住痛，有句话怎么说来着？家里没刀后院没水井，上吊死相太难看，廊柱太硬水太凉</li>
<li>让好人觉得此人是好人，让与之为敌之人，无论好坏，不管各自立场，都在内心深处，愿意认可此人是好人。这还不是最可怕的。更可怕的，是此人当真是好人。</li>
<li>有心为善，虽善不赏，无心为恶，虽恶不罚。</li>
</ul>
<h2 id="大奉打更人"><a href="#大奉打更人" class="headerlink" title="大奉打更人"></a>大奉打更人</h2><ul>
<li>原文：我许七安，从未在教坊司花过银子<ul>
<li>二叔：大郎，请问人生中最快乐的事是什么？</li>
<li>大郎抓了一只七星瓢虫，放到面粉里裹一圈后送给二叔。</li>
<li>二叔：大郎，你的意思是人虽微小如虫，在凡尘中摸爬滚打一生，但也必能遇到快乐之事</li>
<li>大郎：不对，白嫖</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统常用路径</title>
    <url>/2019/04/04/android-2019-04-04-Android%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>可以通过<code>find . -name &lt;文件名&gt;</code>在系统中查找文件，大部分文件夹需要root才能访问</p>
<h1 id="Android应用路径"><a href="#Android应用路径" class="headerlink" title="Android应用路径"></a>Android应用路径</h1><h2 id="内部存储和外部存储"><a href="#内部存储和外部存储" class="headerlink" title="内部存储和外部存储"></a>内部存储和外部存储</h2><ul>
<li>内部存储（Internal storage）：<code>/data/</code>路径下，需要root之后才能查看</li>
<li>外部存储（External storage）：<code>/storage/</code>路径下，需要申请读写权限。包括机身存储和外部SD卡。<ul>
<li>机身存储：<code>/storage/emulated/0/</code></li>
<li>SD卡存储：<code>/storage/SD卡/</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>以前的手机都要插SD卡，机身存储就是内部存储，SD卡就是外部存储。</p>
<p>现在的手机基本都扩充了机身存储，不需要插SD卡，因此把机身存储从概念上划分为内部存储和外部存储。</p>
</blockquote>
<p><img src="/2019/04/04/android-2019-04-04-Android%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84/Android%E8%AE%BE%E5%A4%87%E5%AD%98%E5%82%A8.png"></p>
<p><strong>Android的内部存储和外部存储只是外存的两个分区。</strong></p>
<ul>
<li>ROM（Read-Only Memory，只读存储器）：断电后数据还在。也叫外存。</li>
<li>RAM（Random Access Memory，随机存取存储器）：断电之后数据丢失。也叫主存、内存。</li>
</ul>
<p>外部存储可能有多个，如何获取SD卡路径？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File[] files;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    files = getExternalFilesDirs(Environment.MEDIA_MOUNTED);</span><br><span class="line">    <span class="keyword">for</span>(File file: files)&#123;</span><br><span class="line">        Log.e(TAG, file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外部存储公共目录"><a href="#外部存储公共目录" class="headerlink" title="外部存储公共目录"></a>外部存储公共目录</h2><p>根据type返回不同路径：<code>Environment.getExternalStoragePublicDirectory(type);</code></p>
<ul>
<li><code>Environment.DIRECTORY_DCIM：/storage/emulated/0/DCIM</code></li>
<li><code>DIRECTORY_MUSIC：/storage/emulated/0/Music</code></li>
<li><code>DIRECTORY_PODCASTS：/storage/emulated/0/Podcasts</code></li>
<li><code>DIRECTORY_RINGTONES：/storage/emulated/0/Ringtones</code></li>
<li><code>DIRECTORY_ALARMS：/storage/emulated/0/Alarms</code></li>
<li><code>DIRECTORY_NOTIFICATIONS：/storage/emulated/0/Notifications</code></li>
<li><code>DIRECTORY_PICTURES：/storage/emulated/0/Pictures</code></li>
<li><code>DIRECTORY_MOVIES：/storage/emulated/0/Movies</code></li>
<li><code>DIRECTORY_DOWNLOADS：/storage/emulated/0/Downloads</code></li>
<li><code>DIRECTORY_DOCUMENTS：/storage/emulated/0/Documents</code></li>
</ul>
<h2 id="APP私有目录"><a href="#APP私有目录" class="headerlink" title="APP私有目录"></a>APP私有目录</h2><p>APP私有目录（专属文件）：只有应用本身可访问，其他应用不可访问，应用卸载时会自动删除，也可以手动清除应用数据。</p>
<p>APP在内部存储和外部存储都有对应的私有目录：内部存储更安全，但是存储空间有限，建议大文件使用外部存储。</p>
<ul>
<li><code>/data/data/包名/</code>：内部存储APP私有目录<ul>
<li><code>/data/data/包名/cache</code>：临时缓存信息，存储空间不足时会自动被清除，<code>context.getCacheDir()</code></li>
<li><code>/data/data/包名/files</code>：文件信息，<code>context.getFilesDir()</code></li>
<li><code>/data/data/包名/databases</code>：数据库信息</li>
<li><code>/data/data/包名/shared_prefss</code>：SharedPreferences信息</li>
</ul>
</li>
<li><code>/storage/emulated/0/Android/data/包名/</code>：外部存储APP私有目录<ul>
<li><code>/storage/emulated/0/Android/包名/cache</code>：临时缓存信息，存储空间不足时会自动被清除，<code>context.getExternalCacheDir()</code></li>
<li><code>/storage/emulated/0/Android/包名/files</code>：文件信息，<code>context.getExternalFilesDir()</code></li>
<li><code>/storage/emulated/0/Android/包名/databases</code>：数据库信息</li>
<li><code>/storage/emulated/0/Android/包名/shared_prefss</code>：SharedPreferences信息</li>
</ul>
</li>
</ul>
<h2 id="其他路径"><a href="#其他路径" class="headerlink" title="其他路径"></a>其他路径</h2><ul>
<li><code>/data/app/包名</code>：普通应用安装路径，存放apk和解压文件，<code>context.getPackageCodePath()</code>、<code>context.getPackageResourcePath()</code></li>
<li><code>/system/app/包名</code>：系统应用安装路径，比<code>/data/app</code>权限更高，需要root之后才能卸载</li>
<li><code>/data/dalvik-cache</code>：存储dex优化的缓存文件，提升应用效率</li>
<li><code>/mnt/sdcard</code>、<code>/storage/sdcard0</code>、<code>/sdcard</code>、<code>/storage/emulated/0</code>、<code>/storage/emulated/legacy</code>：通过挂载和链接指向同一个路径，为了兼容不同Android版本路径名称。</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>绝对路径</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>context.getCacheDir()</code></td>
<td><code>/data/data/包名/cache</code></td>
<td>内部存储APP私有路径</td>
</tr>
<tr>
<td><code>context.getFilesDir()</code></td>
<td><code>/data/data/包名/files</code></td>
<td>内部存储APP私有路径</td>
</tr>
<tr>
<td><code>context.getExternalCacheDir()</code></td>
<td><code>/storage/emulated/0/Android/data/包名/cache</code></td>
<td>外部存储APP私有路径</td>
</tr>
<tr>
<td><code>context.getExternalFilesDir()</code></td>
<td><code>/storage/emulated/0/Android/data/包名/files</code></td>
<td>外部存储APP私有路径</td>
</tr>
<tr>
<td><code>Environment.getExternalStorageDirectory()</code></td>
<td><code>/storage/emulated/0</code></td>
<td>外部存储根目录</td>
</tr>
<tr>
<td><code>Environment.getDataDirectory()</code></td>
<td><code>/data</code></td>
<td>内部存储根目录</td>
</tr>
<tr>
<td><code>Environment.getRootDirectory()</code></td>
<td><code>/system</code></td>
<td>系统路径</td>
</tr>
<tr>
<td><code>Environment.getDownloadCacheDirectory() </code></td>
<td><code>/cache</code></td>
<td>公共缓存路径</td>
</tr>
<tr>
<td><code>context.getObbDir()</code></td>
<td><code>/storage/0/Android/obb/包名</code></td>
<td>OBB（Opaque Binary Blob），一般用于安卓游戏，</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Context获取的路径一般都和APP有关，卸载APP会清除。Environment获取的路径和APP无关。</li>
<li>内部存储更安全，但是存储空间有限。建议大文件使用外部存储。</li>
<li>APP在内部存储和外部存储都有对应的私有目录</li>
</ul>
<h1 id="常用系统路径"><a href="#常用系统路径" class="headerlink" title="常用系统路径"></a>常用系统路径</h1><ol>
<li>Settings provider属性：<code>/data/system/users/0/settings_global.xml</code></li>
<li><code>/system/etc/sysconfig/hiddenapi-package-whitelist.xml</code>：高版本无法调用hidden api，添加白名单</li>
<li>appops权限路径：<code>/data/system/appops.xml</code></li>
<li>所有应用权限：<code>/data/system/packages.xml</code></li>
<li>运行时权限：<code>/data/system/users/0/runtime-permissions.xml</code></li>
<li><code>/system/etc/permissions</code>、<code>/vendor/etc/permissions</code></li>
<li><code>/system/etc/default_permissions/default-permissions.xml</code>、<code>/system/etc/default_permissions/open app-permissions.xml</code></li>
<li>uri访问权限：<code>/data/system/urigrants.xml</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uri-grants</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uri-grant</span> <span class="attr">sourceUserId</span>=<span class="string">&quot;0&quot;</span> <span class="attr">targetUserId</span>=<span class="string">&quot;0&quot;</span> <span class="attr">sourcePkg</span>=<span class="string">&quot;com.afauria.media&quot;</span> <span class="attr">targetPkg</span>=<span class="string">&quot;com.android.htmlviewer&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;content://com.afauria.media.fileProvider&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;true&quot;</span> <span class="attr">modeFlags</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uri-grants</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="异常文件"><a href="#异常文件" class="headerlink" title="异常文件"></a>异常文件</h1><ul>
<li>墓碑文件：<code>/data/tombstones</code></li>
<li>anr文件：<code>/data/anr</code></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发工具和命令手册</title>
    <url>/2019/03/01/android-2019-03-01-Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="ADB（Android-Debug-Bridge）安卓调试工具"><a href="#ADB（Android-Debug-Bridge）安卓调试工具" class="headerlink" title="ADB（Android Debug Bridge）安卓调试工具"></a>ADB（Android Debug Bridge）安卓调试工具</h1><p>ADB是连接Android手机与PC端的桥梁，通过adb可以管理、操作模拟器和设备，如安装软件、查看设备软硬件参数、系统升级等</p>
<h2 id="Mac配置环境变量"><a href="#Mac配置环境变量" class="headerlink" title="Mac配置环境变量"></a>Mac配置环境变量</h2><ol>
<li>修改<code>~/.bash_profile</code>文件如下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/name/Library/Android/sdk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/tools`</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/platform-tools</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行<code>source .bash_profile</code>生效，如果使用了<code>zsh</code>，在<code>~/.zshrc</code>文件末尾添加<code>source ~/.bash_profile</code></li>
</ol>
<h2 id="常用adb命令"><a href="#常用adb命令" class="headerlink" title="常用adb命令"></a>常用adb命令</h2><ul>
<li><code>adb connect &lt;手机ip[:端口号]&gt;</code>：连接adb，默认端口号为5555</li>
<li><code>adb disconnect</code>：断开连接</li>
<li><code>adb devices</code>：查看连接的设备</li>
<li><code>adb [command] --help</code>：查看某个命令的帮助</li>
<li><code>adb install 电脑路径/xxx.apk</code>：安装apk到手机。-r覆盖安装，-t安装测试包，-d忽略版本大小</li>
<li><code>adb pull 手机存储路径 电脑路径</code>：从手机拷贝到电脑</li>
<li><code>adb push 电脑路径 手机存储路径</code>：从电脑拷贝到手机</li>
<li><code>adb shell</code>：进入Android终端。<code>-s</code>：如果连接了多个设备，使用-s指定设备</li>
<li><code>adb root</code>：开启root，大部分系统无法直接root</li>
<li><code>adb remount</code>：挂载目录，设置为可读写（需先root），或者进入终端输入<code>mount -o remount,rw [路径]</code></li>
<li>开启无线adb（需先root）：连接串口或USB，进入终端输入<ul>
<li><code>stop adbd</code></li>
<li><code>setprop service.adb.tcp.port 5555</code></li>
<li><code>start adbd</code></li>
</ul>
</li>
<li><code>adb kill-server</code>：杀死adb服务</li>
<li><code>adb start-server</code>：启动adb服务</li>
</ul>
<h2 id="无线连接ADB"><a href="#无线连接ADB" class="headerlink" title="无线连接ADB"></a>无线连接ADB</h2><p>参考<a href="https://developer.android.com/studio/command-line/adb">官方文档</a></p>
<p>Android11及更高版本：开发者选项中打开无线调试</p>
<p>Android10及以下：</p>
<ol>
<li>使用USB连接</li>
<li>输入<code>adb tcpip 5555</code></li>
<li>拔掉USB</li>
<li>输入<code>adb connect &lt;ip地址&gt;:5555</code></li>
</ol>
<h2 id="输出设备日志"><a href="#输出设备日志" class="headerlink" title="输出设备日志"></a>输出设备日志</h2><ul>
<li><code>adb logcat &gt; logcat.log</code>：输出日志到logcat.log文件夹，如果没有则新建</li>
<li><code>adb logcat &gt; &quot;%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%时%time:~3,2%分%time:~6,2%.log&quot;</code>：以日期时间命名文件</li>
<li><code>logcat -d -f &lt;文件名&gt;</code>：输出日志，-d表示将缓存日志全部输出</li>
<li><code>dmesg</code>：查看linux kernel开机日志</li>
</ul>
<p>adb logcat [选项] [过滤项]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选项</span><br><span class="line">&quot;-s&quot;: 设置输出日志的标签, 只显示该标签的日志;</span><br><span class="line">&quot;-f&quot;: 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;</span><br><span class="line">&quot;-r&quot;: 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;</span><br><span class="line">&quot;-n&quot;: 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;</span><br><span class="line">&quot;-v&quot;: 设置日志的输出格式, 注意只能设置一项;</span><br><span class="line">&quot;-c&quot;: 清空所有的日志缓存信息;</span><br><span class="line">&quot;-d&quot;: 将缓存的日志输出到屏幕上, 并且不会阻塞;</span><br><span class="line">&quot;-t&quot;: 输出最近的几行日志, 输出完退出, 不阻塞;</span><br><span class="line">&quot;-g&quot;: 查看日志缓冲区信息;</span><br><span class="line">&quot;-b&quot;: 加载一个日志缓冲区, 默认是 main, 下面详解;</span><br><span class="line">&quot;-B&quot;: 以二进制形式输出日志;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">过滤项格式 : &lt;tag&gt;[:priority] , 标签：日志等级, 默认的日志过滤项是&quot;*:I&quot;;如&quot;*:E&quot;表示过滤Error以上。</span><br><span class="line">-- V : Verbose (明细);</span><br><span class="line">-- D : Debug (调试);</span><br><span class="line">-- I : Info (信息);</span><br><span class="line">-- W : Warn (警告);</span><br><span class="line">-- E : Error (错误);</span><br><span class="line">-- F: Fatal (严重错误);</span><br><span class="line">-- S : Silent(Super all output) (最高的优先级, 可能不会记载东西);</span><br></pre></td></tr></table></figure>

<h1 id="常用android调试命令手册"><a href="#常用android调试命令手册" class="headerlink" title="常用android调试命令手册"></a>常用android调试命令手册</h1><p>可以结合<code>grep</code>命令过滤关键信息。</p>
<blockquote>
<p><code>grep [options] PATTERN FILE</code>：<code>grep -inR enable_global_input *</code></p>
<ul>
<li>-i：忽略大小写</li>
<li>-n：输出匹配的行号</li>
<li>-R：递归遍历文件夹</li>
<li>-E：可以输入多个：<code>grep -E &quot;word1|word2|word3&quot; file.txt </code></li>
</ul>
</blockquote>
<p><strong><code>dumpsys、pm、am、wm</code>等命令本质也是通过执行代码运行的，可以在framework中搜索到相关代码，了解原理</strong></p>
<h2 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h2><ul>
<li><code>dumpsys activity</code>：输出Android组件信息，可以加上a[ctivities]、b[roadcasts]、s[ervices]、prov[iders]等过滤特定信息</li>
<li><code>dumpsys window windows</code>：获取窗口信息，结合<code>grep mFocus</code>获取当前窗口</li>
<li><code>dumpsys package &lt;packagename&gt;</code>：输出应用包信息，结合<code>grep version</code>查看应用版本，结合<code>grep path</code>查看应用路径</li>
<li><code>dumpsys meminfo</code>：查看内存信息</li>
<li><code>dumpsys cpuinfo</code>：查看cpu信息</li>
</ul>
<h2 id="pm"><a href="#pm" class="headerlink" title="pm"></a>pm</h2><ul>
<li><p><code>pm list package -f </code>：输出所有已安装apk</p>
<ul>
<li>-f：输出安装路径</li>
<li>-3：过滤出第三方应用</li>
<li>-s：过滤出系统应用</li>
<li>-d：过滤disable应用</li>
<li>-U：显示应用uid</li>
<li>–uid UID：过滤指定uid应用</li>
<li>–user USER_ID：过滤指定userid应用</li>
</ul>
</li>
<li><p><code>pm install/uninstall &lt;apk文件&gt;</code>：安装应用，-r覆盖安装，-t安装测试包，-d忽略版本大小</p>
</li>
<li><p><code>pm path [package_name]</code>：查看应用安装路径</p>
</li>
<li><p><code>pm dump &lt;packagename&gt;</code>：查看应用信息</p>
</li>
<li><p><code>pm clear</code>：清除应用缓存数据</p>
</li>
<li><p><code>pm enable/disable &lt;包名/组件名&gt;</code>：启用/禁用组件，设置为disable之后组件无法运行。如开机向导应用，运行完毕之后禁用，下次开机就会直接进入桌面</p>
</li>
<li><p><code>pm list permissions [group]</code>：输出已知权限</p>
<ul>
<li><code>-d</code>：仅列出危险权限</li>
<li><code>-g</code>：按组进行整理</li>
</ul>
</li>
<li><p><code>pm list features</code>：输出系统支持的功能</p>
</li>
<li><p><code>pm list libraries</code>：输出系统支持的所有库</p>
</li>
<li><p><code>pm list users</code>：输出系统中的所有用户</p>
</li>
</ul>
<h2 id="am"><a href="#am" class="headerlink" title="am"></a>am</h2><ul>
<li><code>am start</code>、<code>am startservice</code>、<code>am broadcast</code>：启动组件<ul>
<li>-p：包名</li>
<li>-n：包名/Manifest注册组件名。</li>
<li>-a：action启动</li>
<li>-c：category</li>
<li>-d：data，uri启动</li>
</ul>
</li>
<li><code>am force-stop &lt;包名&gt;</code>：退出应用</li>
</ul>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><ul>
<li><code>input</code>：输入事件<ul>
<li><code>input keyevent &lt;keycode&gt;</code>：输入按键事件</li>
<li><code>input text xxx</code>：输入文本</li>
<li><code>input tap &lt;x&gt; &lt;y&gt;</code>：输入点击事件</li>
<li><code>input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;</code>：输入滑动事件</li>
<li>…</li>
</ul>
</li>
<li><code>getevent</code>：获取按键键值</li>
<li><code>sendevent &lt;device：设备&gt; &lt;type：事件类型&gt; &lt;scanCode：linux键值&gt; &lt;value：键值&gt;</code>：发送按键事件<ul>
<li>scanCode是linux层的键值和android keycode不一样。红外按键是从底层驱动传入，转换为Linux层scanCode，再转换为Android的KeyCode。</li>
<li>1为按下，0为松开</li>
<li>如<code>sendevent /dev/input/event0 1 658 1 &amp;&amp; sendevent /dev/input/event0 0 0 0 &amp;&amp; sendevent /dev/input/event0 1 658 0 &amp;&amp; sendevent /dev/input/event0 0 0 0</code></li>
</ul>
</li>
</ul>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><ul>
<li><code>dumpsys meminfo</code>：查看内存信息</li>
<li><code>dumpsys procstats</code>：查看进程内存、CPU信息</li>
<li><code>dumpsys cpuinfo</code>：查看cpu信息</li>
<li><code>dumpsys batterystats &lt;package_name&gt;</code>：查看应用能耗</li>
<li><code>cat /proc/meminfo</code>：查看设备内存</li>
<li><code>free</code>：查看可用内存</li>
<li><code>procrank</code>：查看所有进程内存使用</li>
<li><code>showmap -a &lt;pid&gt;</code>：查看进程内存信息和对应的地址区域</li>
<li><code>df -h</code>：查看设备存储空间</li>
<li><code>cat /proc/进程号/oom_adj</code>：查看当前进程adj值</li>
<li><code>cat /proc/进程号/oom_score_adj</code>：查看真正有效的adj值</li>
<li><code>vmstat [Delay] [Count]</code>：查看CPU和内存使用率，虚拟内存交换情况，IO读写情况</li>
<li><code>top</code>：查看进程信息，内存和CPU使用情况<ul>
<li><code>-m &lt;num&gt;</code>：显示多少个进程</li>
<li><code>-n &lt;num&gt;</code>：刷新次数</li>
<li><code>-d &lt;num&gt;</code>：刷新间隔</li>
<li><code>-s &lt;col&gt;</code>：按列排序，如cpu、vss、rss、thr等</li>
<li><code>-t</code>：显示线程信息</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><code>kill -9 $(pidof com.afauria.sample)</code>：kill某个应用进程，避免每次ps查看进程号</li>
<li><code>uiautomator dump [file]</code>：输出layout结构层级</li>
<li><code>logcat -d -f &lt;文件名&gt;</code>：输出日志，-d表示将缓存日志全部输出</li>
<li><code>dmesg</code>：查看内核日志</li>
<li><code>cat /sys/class/net/wlan0/address</code>：查看mac地址</li>
<li><code>svc wifi enable/disable</code>：开启/关闭wifi</li>
<li><code>getprop</code>、<code>setprop</code>：查看、设置系统属性，结合grep过滤可以查看系统信息，如内存大小、版本等</li>
<li><code>settings get/put &lt;namespace：system/global/secure&gt; &lt;key&gt; [value]</code>：查看Settings Provider属性<ul>
<li><code>settings get system date_format</code>、<code>settings put system date_format dd-MM-yyyy</code>：设置日期格式</li>
<li><code>settings put global http_proxy 127.0.0.1:8888</code>：设置代理，用于fiddle抓包</li>
<li><code>settings put global adb_enabled 0</code>：关闭USB调试</li>
</ul>
</li>
<li><code>wm size [如1920x1080]</code>、<code>wm density [如240]</code>：查看和设置设备分辨率和dpi</li>
<li><code>reboot</code>：重启设备</li>
<li><code>screencap 1.png</code>：截屏</li>
<li><code>screenrecord 1.mp4</code>：录屏</li>
<li><code>cmd overlay list</code>：查看overlay apk</li>
<li><code>tcpdump -p -vv -s 0 -w /mnt/sdcard/capture.pcap</code>：抓包，使用wireshark分析。系统需要root</li>
<li><code>busybox vi &lt;file&gt;</code>：busybox集成了linux常用工具和命令，短小精悍，适合嵌入式平台。系统不支持vi等命令时可以使用busybox。</li>
<li><code>find ./ -name runtime-permissions.xml</code>：查找文件</li>
<li><code>ifconfig</code>：查看ip地址和mac地址</li>
<li><code>pwd</code>：输出当前路径</li>
<li><code>ping</code>：尝试连接ip或域名</li>
<li><code>chmod [权限数字] [路径]</code>：修改文件权限，777表示任何用户可读可写</li>
<li><code>md5 [文件]</code>：获取文件md5值</li>
</ul>
<h1 id="终端登录工具"><a href="#终端登录工具" class="headerlink" title="终端登录工具"></a>终端登录工具</h1><ol>
<li>adb shell</li>
<li>windows上使用MobaXterm：支持SSH、FTP、串口、VNC等</li>
<li>mac上使用串口：通过<code>screen &lt;串口名称，如tty.usbserial-gggggggg1&gt; &lt;波特率，如115200&gt;</code>连接</li>
</ol>
<blockquote>
<p>tty（Teletypes，或者teletypewriters）：终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。</p>
<p>tty也是一个Unix命令，用来给出当前终端设备的名称。</p>
<p>在Linux系统的设备特殊文件目录/dev/下，TTY设备包括虚拟控制台，串口以及伪终端设备</p>
<p>/dev/tty代表当前tty设备，在当前的终端中输入 echo “hello” &gt; /dev/tty ，都会直接显示在当前的终端中。</p>
</blockquote>
<h1 id="Prop属性"><a href="#Prop属性" class="headerlink" title="Prop属性"></a>Prop属性</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>系统开机后会从以下系统文件中读取默认的属性，并写入共享内存中。按顺序读取，后面的会覆盖前面的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bionic/libc/include/sys/_system_properties.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_PATH_RAMDISK_DEFAULT  <span class="meta-string">&quot;/default.prop&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_PATH_SYSTEM_BUILD     <span class="meta-string">&quot;/system/build.prop&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_PATH_SYSTEM_DEFAULT   <span class="meta-string">&quot;/system/default.prop&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_PATH_LOCAL_OVERRIDE   <span class="meta-string">&quot;/data/local.prop&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system/core/init/property_service.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">    load_properties_from_file(PROP_PATH_SYSTEM_BUILD);</span><br><span class="line">    load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ALLOW_LOCAL_PROP_OVERRIDE</span></span><br><span class="line">    load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ALLOW_LOCAL_PROP_OVERRIDE */</span></span></span><br><span class="line">    <span class="comment">/* Read persistent properties after all default values have been loaded. */</span></span><br><span class="line">    load_persistent_properties();</span><br><span class="line">    update_legacy_atvc_properties();</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h2><ol>
<li>setprop、getprop命令</li>
<li>修改prop系统文件：需要root</li>
<li>Java调用，有权限限制</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java API</span></span><br><span class="line"><span class="keyword">import</span> android.os.SystemProperties;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key, String def)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String val)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>ro.开头的属性只读</li>
<li>persist.开头的属性名永久保存。其他属性（debug.、service.开头）开机之后清除：<ol>
<li>设置persist属性的时候会写入<code>/data/property/persistent_properties</code>文件中</li>
<li>加载属性的时候会从该文件读取</li>
</ol>
</li>
<li>直接编辑prop文件修改属性，会永久保存</li>
<li>属性名最大长度是32，属性值最大长度是92</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bionic/libc/include/sys/system_properties.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_NAME_MAX   32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_VALUE_MAX  92</span></span><br></pre></td></tr></table></figure>

<h1 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h1><h2 id="Windows运行Android模拟器"><a href="#Windows运行Android模拟器" class="headerlink" title="Windows运行Android模拟器"></a>Windows运行Android模拟器</h2><h3 id="Intel-CPU"><a href="#Intel-CPU" class="headerlink" title="Intel CPU"></a>Intel CPU</h3><p>Intel CPU使用HAXM（Hardware Accelerated Execution Manager）技术，使用基于 Intel(R) Virtualization Technology (VT) 的硬件加速，实现 Android 模拟器加速。</p>
<p>需要在BIOS中开启硬件支持VT，并且Android sdk需要安装Intel x86 Emulator Accelerator（HAXM）扩展。</p>
<h3 id="AMD-CPU"><a href="#AMD-CPU" class="headerlink" title="AMD CPU"></a>AMD CPU</h3><p>AMD通过Android Studio运行模拟器会报错，如”提示CPU不支持”，或者”建议使用x86模拟器”。在BIOS中开启虚拟化也没用。</p>
<p>解决办法：</p>
<ul>
<li>使用GenyMotion模拟器，并且在Android Studio上安装GenyMotion插件。<ul>
<li>问题：GenyMotion使用Virtual Box虚拟化技术，而我的电脑运行了Docker，Docker在Windows上使用的是Hyper-V虚拟化技术，两个一起开会出问题。</li>
</ul>
</li>
<li>官方在Android Emulator 27.3.1上给出了解决方案，结合了Win10的Hyper-V技术。<ul>
<li>Win10系统</li>
<li>在Android sdk中安装Android Emulator 27.3.1以上的版本</li>
<li>安装x86的镜像，x86_64（打开很慢）和armeabi-v7a（更慢）</li>
<li>在控制面板-&gt;程序-&gt;启用或关闭Windows功能中，打开<strong>Windows虚拟机监控程序平台（Windows Hypervisor Platform）</strong></li>
<li>重启电脑</li>
</ul>
</li>
</ul>
<h3 id="打开Hyper-V技术"><a href="#打开Hyper-V技术" class="headerlink" title="打开Hyper-V技术"></a>打开Hyper-V技术</h3><p>打开【Windows程序和功能-&gt;启用或关闭Windows功能-&gt;选中Hyper-V】</p>
<p><img src="/2019/03/01/android-2019-03-01-Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Win10%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.png" alt="Win10开启虚拟化技术"> </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果是IntelCPU还是建议使用HAXM，支持硬件加速。</li>
<li>如果是AMD CPU建议使用Win10的Hyper-V技术</li>
<li>建议使用x86模拟器，速度能快很多倍</li>
</ul>
<p>参考<a href="https://android-developers.googleblog.com/2018/07/android-emulator-amd-processor-hyper-v.html">Android模拟器安装</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android常见异常及解决方案</title>
    <url>/2019/02/27/android-2019-02-27-AndroidError/</url>
    <content><![CDATA[<p>关于Java异常，可以参考<a href="/KnowledgeTree/">知识体系</a></p>
<h1 id="常见编译错误"><a href="#常见编译错误" class="headerlink" title="常见编译错误"></a>常见编译错误</h1><h2 id="内存不足，无法启动虚拟机"><a href="#内存不足，无法启动虚拟机" class="headerlink" title="内存不足，无法启动虚拟机"></a>内存不足，无法启动虚拟机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of VM</span><br><span class="line">Could not reserve enough space <span class="keyword">for</span> 1572864KB object heap</span><br></pre></td></tr></table></figure>

<p><img src="/2019/02/27/android-2019-02-27-AndroidError/error01.png" alt="内存不足"></p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>修改<code>gradle.properties</code>文件，将虚拟机内存改小</li>
<li>关掉部分无用的进程，腾出空间</li>
</ol>
</blockquote>
<p>附上查看系统内存方法：</p>
<blockquote>
<ol>
<li>打开任务管理器-&gt;性能-&gt;内存。或者任务管理器-&gt;性能-&gt;资源监视器-&gt;内存</li>
<li>使用命令行</li>
</ol>
</blockquote>
<p>补充：Java工程可能也会遇到类似的错误，也可以通过设置虚拟机参数解决</p>
<p>Java虚拟机监控命令/工具：</p>
<ul>
<li><a href="https://www.cnblogs.com/lemon-pomelo/p/9285840.html">Java虚拟机–常用Java命令(一)</a></li>
<li><a href="https://www.cnblogs.com/xmzJava/p/8524949.html">Java虚拟机监控命令</a></li>
</ul>
<p>Android查看内存、CPU、电量等信息：</p>
<ul>
<li><a href="https://www.cnblogs.com/flyingcode/p/6113368.html">Android 通过adb shell命令查看内存，CPU，启动时间，电量等信息</a></li>
</ul>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p><code>java.lang.OutOfMemoryError: Metaspace</code></p>
<blockquote>
<p>有可能是电脑内存不足，</p>
<ol>
<li>重启Android Studio</li>
<li>查看内存，杀进程（活动监视器，或者命令行）</li>
<li>重新开机</li>
</ol>
</blockquote>
<h2 id="sdk版本不正确"><a href="#sdk版本不正确" class="headerlink" title="sdk版本不正确"></a>sdk版本不正确</h2><p><img src="/2019/02/27/android-2019-02-27-AndroidError/error02.png" alt="sdk版本"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &#x27;:girls:compileReleaseRenderscript&#x27;.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> llvm-rs-cc is missing</span></span><br></pre></td></tr></table></figure>

<p>解决方案：修改<code>build.gradle</code>中的版本号为下载过的sdk版本</p>
<h1 id="常见运行异常"><a href="#常见运行异常" class="headerlink" title="常见运行异常"></a>常见运行异常</h1><h2 id="Dialog-amp-AlertDialog，WindowManager不能正确使用"><a href="#Dialog-amp-AlertDialog，WindowManager不能正确使用" class="headerlink" title="Dialog&amp;AlertDialog，WindowManager不能正确使用"></a>Dialog&amp;AlertDialog，WindowManager不能正确使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">20715 android.view.WindowManager<span class="variable">$BadTokenException</span></span></span><br><span class="line">Unable to add window -- token android.os.BinderProxy@caaa709 is not valid; is your activity running?</span><br></pre></td></tr></table></figure>

<p>分析：该异常表示不能添加窗口，通常是所要依附的view已经不存在导致的。</p>
<p>常见场景：</p>
<blockquote>
<ol>
<li>上一个页面没有destroy的时候，之前的Activity已经接收到了广播。如果此时之前的Activity进行UI层面的操作处理，就会造成crash。UI层面的刷新，一定要注意时机，建议使用set_result来代替广播的形式进行刷新操作，避免使用广播的方式，代码不直观且容易出错。</li>
<li>Dialog在Actitivty退出后弹出。在Dialog调用show方法进行显示时，必须要有一个Activity作为窗口的载体，如果Activity被销毁，那么导致Dialog的窗口载体找不到。建议在Dialog调用show方法之前先判断Activity是否已经被销毁。</li>
<li>Service&amp;Application弹出对话框或WindowManager添加view时，没有设置window type为TYPE_SYSTEM_ALERT。需要在调用dialog.show()方法前添加dialog.getWindow().SetType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT)。</li>
<li>6.0的系统上, (非定制 rom 行为)若没有给予悬浮窗权限, 会弹出该问题, 可以通过Settings.canDrawOverlays来判断是否有该权限.</li>
<li>某些不稳定的MIUI系统bug引起的权限问题，系统把Toast也当成了系统级弹窗，android6.0的系统Dialog弹窗需要用户手动授权，若果app没有加入SYSTEM_ALERT_WINDOW权限就会报这个错。需要加入给app加系统Dialog弹窗权限，并动态申请权限，不满足第一条会出现没权限闪退，不满足第二条会出现没有Toast的情况。</li>
</ol>
</blockquote>
<h2 id="Context启动Activity"><a href="#Context启动Activity" class="headerlink" title="Context启动Activity"></a>Context启动Activity</h2><p>在 Android P 中，无法通过非 Activity 的 Context（如 Service）启动 Activity，除非在 Intent 中添加 FLAG_ACTIVITY_NEW_TASK，否则该 Activity 不会启动，并抛异常。</p>
<p>解决方案：启动 Activity 的地方判断Context是否<code>instanceof Activity</code></p>
<h2 id="参数不匹配"><a href="#参数不匹配" class="headerlink" title="参数不匹配"></a>参数不匹配</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">50220 java.lang.IllegalArgumentException</span></span><br><span class="line">Unknown color</span><br></pre></td></tr></table></figure>

<p>传入了不正确的参数导致。</p>
<p>常见场景：</p>
<blockquote>
<ol>
<li>Activity、Service状态异常；</li>
<li>非法URL；</li>
<li>UI线程操作。</li>
<li>Fragment中嵌套了子Fragment，Fragment被销毁，而内部Fragment未被销毁，所以导致再次加载时重复，在onDestroyView() 中将内部Fragment销毁即可</li>
<li>在请求网络的回调中使用了Glide.into(view),view已经被销毁会导致该错误</li>
</ol>
</blockquote>
<h2 id="空指针异常（NPE）"><a href="#空指针异常（NPE）" class="headerlink" title="空指针异常（NPE）"></a>空指针异常（NPE）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">2002 java.lang.NullPointerException</span></span><br><span class="line">SimpleDraweeView was not initialized!</span><br></pre></td></tr></table></figure>

<p>空指针最为常见，也最容易规避，使用的时候一定要进行<code>null check</code>或者<code>try-catch</code>，采取不信任原则。</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>方法形参要判空后才使用；</li>
<li>全局变量容易被系统回收或者更改，使用全局变量前建议判空；</li>
<li>第三方接口的调用，对返回值进行判空。</li>
<li>请注意线程安全</li>
</ol>
</blockquote>
<h2 id="数组存储异常"><a href="#数组存储异常" class="headerlink" title="数组存储异常"></a>数组存储异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">28916 java.lang.ArrayStoreException</span></span><br><span class="line">source[0] of type com.google.android.gms.internal.zzcek cannot be stored in destination array of type com.google.android.gms.common.api.internal.BasePendingResult[]</span><br></pre></td></tr></table></figure>

<p>当向数组中存放非数组声明类型对象时抛出</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>进行类型判断</li>
<li>重新声明数组类型</li>
</ol>
</blockquote>
<h2 id="Bitmap异常"><a href="#Bitmap异常" class="headerlink" title="Bitmap异常"></a>Bitmap异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">4230 java.lang.RuntimeException</span></span><br><span class="line">Canvas: trying to use a recycled bitmap android.graphics.Bitmap@1d515bf2</span><br><span class="line"></span><br><span class="line">android.graphics.Canvas.throwIfCannotDraw(Canvas.java:1282)</span><br></pre></td></tr></table></figure>

<p>画布尝试去使用一个已回收的位图对象，建议解除一切与Bitmap的绑定。通常由于bitmap比较占用内存，为避免oom习惯使用bitmap.recycle()来回收，当再次使用这个被回收的bitmap时就会产生发生异常。</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>在使用前先判断bitmap是否被回收；</li>
<li>在不确定图片是否还有其他引用时，不要调用recycle()。</li>
</ol>
</blockquote>
<p>RuntimeException（运行时异常），是所有Java虚拟机正常操作期间可以被抛出的异常的父类。通常需要关注cause by以下部分的堆栈。</p>
<h2 id="找不到指定方法"><a href="#找不到指定方法" class="headerlink" title="找不到指定方法"></a>找不到指定方法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">13623 java.lang.NoSuchMethodError</span></span><br><span class="line">no non-static method &quot;Lcom/**/**/**;.&lt;init&gt;(Ljava/lang/String;Ljava/l</span><br></pre></td></tr></table></figure>

<p>该异常表示找不到指定方法。主要是由于Android系统和Rom厂商定制化导致的碎片化问题，很难根治，建议做好机型适配，解决top机型问题：</p>
<blockquote>
<ol>
<li>如果是机型相关问题，则看下是否添加了该崩溃机型cpu架构的so库；</li>
<li>如果是系统API方法，使用时要注意API Level，如果设置的target version过高，调用低于设置版本的API方法将会报错。</li>
<li>setBackground方法在API &gt;= 16才生效</li>
</ol>
</blockquote>
<h2 id="安全异常、权限异常"><a href="#安全异常、权限异常" class="headerlink" title="安全异常、权限异常"></a>安全异常、权限异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">4523 java.lang.SecurityException</span></span><br><span class="line">Client must have ACCESS_FINE_LOCATION permission to request PRIORITY_HIGH_ACCURACY locations.</span><br><span class="line"></span><br><span class="line">com.google.android.gms.internal.zzeu.zzb(Unknown Source:10)</span><br></pre></td></tr></table></figure>

<p>权限异常或者称为安全异常，由安全管理器抛出，用于指示违反安全情况的异常，通常由于没有获取对应的权限。</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>android6.0以下需要在manifest中声明相应的权限；</li>
<li>android6.0及以上，在使用时需要动态申请权限。</li>
</ol>
</blockquote>
<h2 id="不支持的操作"><a href="#不支持的操作" class="headerlink" title="不支持的操作"></a>不支持的操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">11210 java.lang.UnsupportedOperationException</span></span><br><span class="line">Failed to resolve attribute at index 13: TypedValue&#123;t=0x2/d=0x7f040210 a=3&#125;</span><br></pre></td></tr></table></figure>

<p>常见场景：xml中</p>
<blockquote>
<ol>
<li>Android 4.x及以下的设备使用Android 5.0 以后MaterialDesign设计引入的colorPrimary等属性造成的异常；</li>
<li>有些基于Android原生系统再次开发的系统、Rom不支持Start、End，简易更改为Left、Right（例如，layout_alignParentStart和layout_alignParentEnd属性）；<br>总体来说就是，该属性在某些奇葩设备下不兼容，尽量使用兼容的属性。</li>
<li>还有一种情况是build目录下的文件没有清除干净，导致失败的。</li>
</ol>
</blockquote>
<h2 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#17553 java.lang.OutOfMemoryError</span><br><span class="line">pthread_create (1040KB stack) failed: Out of memory</span><br><span class="line">com.facebook.imagepipeline.core.PriorityThreadFactory1.run(PriorityThreadFactory.java:<span class="number">43</span>)</span><br></pre></td></tr></table></figure>

<p>该异常表示内存不足导致线程创建失败。pthread_create默认创建的线程是非detached的。如果使用不当，确实会造成内存泄漏。</p>
<p>预防方案：</p>
<blockquote>
<ol>
<li>创建detached的线程；</li>
<li>线程的start_routine结束之前detached；</li>
<li>主线程中使用pthread_join。</li>
</ol>
</blockquote>
<h2 id="迭代器异常"><a href="#迭代器异常" class="headerlink" title="迭代器异常"></a>迭代器异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">7707 java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>

<p>该异常表示迭代器迭代过程中，迭代的对象发生了改变，如数据项增加或删除。由于迭代对象不是线程安全，在迭代的过程中，会检查modCount是否和初始modCount即expectedModCount一致，如果不一致，则认为数据有变化，迭代终止并抛出异常。</p>
<p>常见场景：两个线程同时对集合进行操作，线程1对集合进行遍历，而线程2对集合进行增加、删除操作。</p>
<p>解决方案：多线程访问时要增加同步锁，或者建议使用线程安全的集合：</p>
<blockquote>
<ol>
<li>使用ConcurrentHashMap替换HashMap，CopyOnWriteArrayList替换ArrayList；</li>
<li>或者使用使用Vector替换ArrayList，Vector是线程安全的。Vector的缺点：大量数据操作时，由于线程安全，性能比ArrayList低.</li>
</ol>
</blockquote>
<h2 id="通知异常"><a href="#通知异常" class="headerlink" title="通知异常"></a>通知异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android.app.RemoteServiceException</span><br><span class="line">Context.startForegroundService() did not then call Service.startForeground()</span><br><span class="line"></span><br><span class="line">android.app.ActivityThreadH.handleMessage(ActivityThread.java:1768)</span><br></pre></td></tr></table></figure>

<p>该异常表示从Package发布通知时存在异常，主要出现在通知栏更新。</p>
<p>使用通知需要注意以下几点：</p>
<blockquote>
<ol>
<li>每次更新时都需要实例化Notification；</li>
<li>设置Notification的ContentView之后记得设置ContentIntent；</li>
<li>如果使用了RemoteViews时，需要保证包名的正确性；</li>
<li>注意各个系统版本对于Notification使用方法的差异性。</li>
</ol>
</blockquote>
<h2 id="Native方法没找到"><a href="#Native方法没找到" class="headerlink" title="Native方法没找到"></a>Native方法没找到</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError</span><br><span class="line">Native method not found: com.tutk.IOTC.AVAPIs.avInitialize:(I)I</span><br></pre></td></tr></table></figure>

<p>该异常表示native方法没有找到。报这个错误通常是so库加载失败，或者找不到准备执行的JNI方法，可能是因为method的signature或命名有误，建议使用javah命令行来生成JNI头文件来避免这个问题。</p>
<h2 id="状态异常"><a href="#状态异常" class="headerlink" title="状态异常"></a>状态异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">37812 java.lang.IllegalStateException</span></span><br></pre></td></tr></table></figure>

<p>常见类型</p>
<blockquote>
<p><code>IllegalStateException: Can not perform this action after onSaveInstanceState：</code></p>
<p>onSaveInstanceState方法是在该Activity即将被销毁前调用，来保存Activity数据的，如果在保存完状态后<br>再给它添加Fragment就会出错。解决办法就是把commit（）方法替换成 commitAllowingStateLoss()</p>
</blockquote>
<blockquote>
<p> <code>java.lang.IllegalStateException：Cannot   forward   a   response   that   is   already   committed  IllegalStateException：response already commited  IllegalStateException：getOutputStream() has already been called for this request</code></p>
<p><a href="http://my.oschina.net/guhai2004/blog/187041">参考java.lang.IllegalStateException异常产生的原因及解决办法</a></p>
<p>该异常表示，当前对客户端的响应已经结束，不能在响应已经结束（或说消亡）后再向客户端（实际上是缓冲区）输出任何内容。</p>
<p>具体分析：首先解释下flush()，我们知道在使用读写流的时候数据先被读入内存这个缓冲区中， 然后再写入文件，但是当数据读完时不代表数据已经写入文件完毕，因为可能还有一部分仍未写入文件而留在内存中，这时调用flush()方法就会把缓冲区的数据强行清空输出，因此flush()的作用就是保证缓存清空输出。response是服务端对客户端请求的一个响应，其中封装了响应头、状态码、内容等，服务端在把response提交到客户端之前，会向缓冲区内写入响应头和状态码，然后将所有内容flush。这就标志着该次响应已经committed(提交)。对于当前页面中已经committed(提交)的response，就不能再使用这个response向缓冲区写任何东西（注：同一个页面中的response.XXX()是同一个response的不同方法，只要其中一个已经导致了committed，那么其它类似方式的调用都会导致 IllegalStateException异常）。</p>
<p>注：能够导致响应已经committed的操作包括：forward, redirect, flushBuffer。</p>
</blockquote>
<blockquote>
<p><code>java.lang.IllegalStateException: Illegal State: Row/Object is no longer valid to operate on. Was it deleted?</code><a href="https://github.com/realm/realm-java/issues/1206">参考realm</a></p>
<p>realmObject对象在其他线程已被删除，在这个线程中使用的时候抛出的异常。</p>
</blockquote>
<blockquote>
<p><code>java.lang.IllegalStateException Can&#39;t change tag of fragment d&#123;e183845 #0 d&#123;e183845&#125;&#125;: was d&#123;e183845&#125; now d&#123;e183845 #0 d&#123;e183845&#125;&#125;</code></p>
<p>显示fragment的代码中使用了：fragment.show(getSupportFragmentManager, fragment.toString());<br>而这里是因为两次toString()结果不同，导致不同的tag指向的是同一个fragment。<br>获取fragment的tag的正确方法应该是使用其提供的fragment.getTag()方法。</p>
</blockquote>
<blockquote>
<p><code>java.lang.IllegalStateException Expected BEGIN_ARRAY but was BEGIN_OBJECT at line 1 column 37 path .data</code></p>
<p>该异常是由于服务器错误返回的JSON字符串和服务器正常下时返回的JSON字符串结构不同,导致利用Gson解析的时候报了一个异常:本该去解析集合却强制去解析对象所致.</p>
<p>解决方案：在使用Gson解析JSON时try cash一下,不报错按照正常逻辑继续解析,报异常则处理为请求失败逻辑即可.</p>
</blockquote>
<h2 id="Fresco图片加载"><a href="#Fresco图片加载" class="headerlink" title="Fresco图片加载"></a>Fresco图片加载</h2><p>使用FrescoManager 的时候默认使用的是可轻易被回收的bitmap，如果不在当前页面使用可能会被回收报错。如果报这个错，可以使用FrescoManager.load(String url, ImageView view, boolean canBeRecycled), 传入false，或者直接使用Fresco的SimpleDraweeView,这个是官方推荐的做法。</p>
<h1 id="版本适配问题"><a href="#版本适配问题" class="headerlink" title="版本适配问题"></a>版本适配问题</h1><h2 id="Android-P使用http明文传输"><a href="#Android-P使用http明文传输" class="headerlink" title="Android P使用http明文传输"></a>Android P使用http明文传输</h2><p>报错：<code>java.io.IOException: Cleartext HTTP traffic to  not permitted</code></p>
<p>解决方案：</p>
<ol>
<li>APP改用https请求</li>
<li>targetSdkVersion 降到27以下</li>
<li>更改网络安全配置</li>
</ol>
<p>方式一：</p>
<p>manifest文件中<code>&lt;application&gt;</code>标签添加：<code>android:usesCleartextTraffic=&quot;true&quot;</code></p>
<p>方式二：</p>
<ol>
<li>创建<code>res/xml/network_security_config.xml</code>文件，配置如下</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改manifest文件，引入配置</li>
</ol>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">	android:networkSecurityConfig=&quot;@xml/network_security_config&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker for windows+Jenkins+gradle配置</title>
    <url>/2019/01/14/tool-2019-1-14-Docker-Jenkins/</url>
    <content><![CDATA[<h1 id="docker运行jenkins"><a href="#docker运行jenkins" class="headerlink" title="docker运行jenkins"></a>docker运行jenkins</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里使用的docker是windows版的，路径和linux或mac不一样，坑也更多一点。主要就是因为容器的特性，搞明白了之后大部分的问题都可以解决了，具体总结为下面两个原因：</p>
<ul>
<li><strong>使用docker配置jenkins路径有很大的不同，原因是容器内无法访问主机目录，因此需要将主机目录挂载到容器中，Jenkins配置都要使用容器中的目录</strong>，</li>
<li><strong>容器内的各种环境也是隔离的，相当于一个独立的系统（类似Win10内置的Linux子系统功能）。也就是说需要的环境都得在容器内再安装一遍。也可以使用挂载，将主机的安装路径挂载到容器中，然后容器中再像Linux一样配置环境变量，这样的好处是和主机版本一致，而且不会增加容器大小。</strong><ul>
<li>如java、python、gradle、android sdk等环境</li>
</ul>
</li>
</ul>
<p>还有一点要注意的：</p>
<p><strong>docker容器删掉之后下次再运行，所有的数据都会清空，再创建一个新的容器。因此需要持久化数据</strong>：方法和上面一样，将主机上的目录挂载到docker容器中，对容器目录的读写操作即是对主机的读写，删除容器不会删除主机上的数据，重新创建容器的时候只需要再次挂载主机目录。</p>
<p>我的主机存储路径是这样的（根据需要自行替换）：</p>
<ul>
<li><code>E:\ASproject</code>：存放android项目</li>
<li><code>D:\Docker\Volume\Jenkins</code>：用于持久化容器</li>
<li><code>D:\android-sdk-windows</code>：存放安卓sdk</li>
</ul>
<h2 id="docker安装jenkins"><a href="#docker安装jenkins" class="headerlink" title="docker安装jenkins"></a>docker安装jenkins</h2><ul>
<li><code>docker search jenkins</code>：在docker hub查找jenkins镜像</li>
</ul>
<p>搜到的第一个jenkins镜像（Official Jenkins Docker iage）版本太老了，会有很多问题，这里使用jenkins/jenkins镜像。</p>
<ul>
<li><code>docker pull jenkins/jenkins</code>：拉取镜像</li>
<li><code>docker run -d -p 8082:8080 -p 50000:50000 --name myjenkins -v /d/Docker/Volume/Jenkins:/var/jenkins_home -v /e/ASproject:/var/as_project -v /d/android-sdk-windows:/var/android_sdk jenkins/jenkins:lts</code>：运行jenkins，<ul>
<li><code>-v 主机目录:容器目录</code>：主机目录挂载到容器目录</li>
<li><code>-p 主机端口:容器端口</code>：容器端口映射到主机端口</li>
<li><code>-d</code>：后台运行</li>
<li><code>--name</code>：容器命名，这里命名为<code>myjenkins</code>，可自行替换，后面用到的也替换</li>
</ul>
</li>
<li>浏览器访问<code>localhost:8082</code>：能够访问即成功了</li>
</ul>
<p>挂载目录解释：</p>
<p>Jenkins的很多配置需要设置路径（如jdk、gradle、android sdk、项目workspace等），而容器内无法访问主机的目录，使用主机目录会配置失败，因此需要将主机目录挂载到容器中</p>
<p><code>-v /d/Docker/Volume/Jenkins:/var/jenkins_home</code>：将主机<code>D:\Docker\Volume\Jenkins</code>挂载到容器的<code>/var/jenkins_home</code>，即访问<code>/var/jenkins_home</code>就是访问主机<code>D:\Docker\Volume\Jenkins</code>。这样做是为了容器持久化，否则删除容器之后所有的配置都会消失。重新运行容器之后只要再次挂载这个目录就能恢复配置。</p>
<p><code>-v /e/ASproject:/var/as_project</code>：这样做是为了把项目工作区挂载到容器中，不然访问不到安卓的项目，也可以把项目复制到刚才挂载的<code>D:\Docker\Volume\Jenkins</code>这个目录下，让容器能够访问到，不推荐这么做，因为会改变原先项目的路径，而且太大了，所以单独挂载到容器的一个新的目录作为工作区，原先项目路径也不用改变。</p>
<p><code>-v /d/android-sdk-windows:/var/android_sdk</code>：同样的道理，把本机的sdk挂载到容器的新目录中，不用在容器中再装一次sdk</p>
<h2 id="Jenkins初始化"><a href="#Jenkins初始化" class="headerlink" title="Jenkins初始化"></a>Jenkins初始化</h2><h3 id="第一次进入需要初始密码"><a href="#第一次进入需要初始密码" class="headerlink" title="第一次进入需要初始密码"></a>第一次进入需要初始密码</h3><ul>
<li><p>可以直接访问刚才挂载的主机目录：<code>D:\Docker\Volume\Jenkins\secrets\initialAdminPassword</code></p>
</li>
<li><p>或者使用命令行</p>
<ul>
<li><code>docker exec -it myjenkins /bin/bash</code>进入容器。</li>
<li><code>cd var/jenkins_home/secrets</code>进入目录</li>
<li><code>cat initialAdminPassword</code>：查看密码，复制到浏览器</li>
</ul>
</li>
<li><p>设置了用户密码之后这个文件就没了</p>
</li>
</ul>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>上一步输入密码之后提示安装插件，使用推荐安装，或者自行选择插件</p>
<p>失败了没关系，进去之后可以到系统管理–插件管理中再安装</p>
<h3 id="设置用户名、密码"><a href="#设置用户名、密码" class="headerlink" title="设置用户名、密码"></a>设置用户名、密码</h3><h2 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h2><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>进入系统管理–系统设置，如下，这里使用刚才挂载的容器内的路径，不能直接用<code>D:\android-sdk-windows</code></p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins01.png" alt="Jenkins环境变量配置"></p>
<p>注：这个版本的Jenkins镜像好像自带了java环境，因此不用再配置java环境变量，也不用将主机jdk目录挂载到容器内</p>
<h3 id="全局工具配置"><a href="#全局工具配置" class="headerlink" title="全局工具配置"></a>全局工具配置</h3><p>配置gradle路径，将安装的gradle整个拷贝到<code>D:\Docker\Volume\Jenkins</code>中，对应容器中的<code>/var/jenkins_home</code>（当然也可以按照上面的挂载方法，将主机安装的gradle挂载到容器新的目录）,这里配置如下</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins02.png" alt="Jenkins环境变量配置"></p>
<p>注：</p>
<ul>
<li>android studio安装的gradle一般是在<code>C:\Users\XXX\.gradle\wrapper\dists\gradle-4.6-all\bcst21l2brirad8k2ben1letg\gradle-4.6</code>，将这个文件夹复制到容器能够访问到的主机目录即可</li>
<li>jdk不需要配置，这个版本的jenkins镜像自带了java环境</li>
</ul>
<h2 id="任务配置"><a href="#任务配置" class="headerlink" title="任务配置"></a>任务配置</h2><p>任务就是每次执行任务的模板，可以查看执行日志，第几次执行等</p>
<p>创建任务、填写名字、描述、这些较简单，跳过，这里只讲关键的配置</p>
<h3 id="工作区配置"><a href="#工作区配置" class="headerlink" title="工作区配置"></a>工作区配置</h3><p>点击advanced展开配置</p>
<p>刚才我们使用<code>-v /e/ASproject:/var/as_project</code>，把主机的android项目目录挂载到了容器的中，因此可以通过容器路径访问主机上的TestProject项目，因此配置如下</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins03.png" alt="Jenkins环境变量配置"></p>
<h3 id="Build配置"><a href="#Build配置" class="headerlink" title="Build配置"></a>Build配置</h3><p>会在上面配置的工作区上执行脚本，有多种脚本可以执行，如gradle，shell等。可以写一些简单的脚本进行测试，比如打印java版本，查看当前目录文件等。gradle脚本选择刚才在全局工具配置中的名称</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins04.png" alt="Jenkins环境变量配置"></p>
<p>点开左边的构建历史，查看某次构建，如下</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins05.png" alt="Jenkins环境变量配置"></p>
<p>注：我们的docker内部是使用linux环境的（也可以切换成windows的），因此能够选择<code>执行shell</code>，而不能选择<code>执行Windows批处理命令</code></p>
<h3 id="代码远程仓库配置"><a href="#代码远程仓库配置" class="headerlink" title="代码远程仓库配置"></a>代码远程仓库配置</h3><p>留坑</p>
<p>配置ssh访问github：使用docker exec命令进入容器，然后参考linux配置，参考文章：<a href="https://blog.csdn.net/m0_38139979/article/details/82820972">Linux   ssh访问Github相关配置</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="python环境安装"><a href="#python环境安装" class="headerlink" title="python环境安装"></a>python环境安装</h3><p>Job配置的时候可以配置python脚本，也可以配置shell，通过shell命令来执行python脚本。如 <code>python /var/jenkins_home/scripts/***.py</code>。</p>
<p><strong>注：脚本路径要用容器内路径，不能用主机上的路径</strong></p>
<p>docker版的jenkins自带了python2的环境，但是没有pip，因此需要再安装pip：</p>
<ul>
<li>使用<code>docker exec -it &lt;容器名/容器id&gt; /bin/bash</code>进入容器内，然后就当Linux环境进行安装就可以了</li>
</ul>
<p>参考<a href="https://www.cnblogs.com/technologylife/p/5870576.html"><a href="https://www.cnblogs.com/technologylife/p/5870576.html">Linux 下安装pip</a></a>，输入以下命令（安装的是python2的pip）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://bootstrap.pypa.io/get-pip.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python get-pip.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip -V　　<span class="comment">#查看pip版本</span></span></span><br></pre></td></tr></table></figure>

<p><strong>不过这样安装有个问题，就是删除容器之后下次需要再次安装模块</strong>：解决思路应该是把主机上的python安装目录整个挂载到容器中，然后再<code>run</code>的时候通过<code>--env</code>设置环境变量，替换掉jenkins自带的python。<strong>没试过，应该可行。有知道的大佬可以联系我</strong></p>
<p>保存一下需要安装的模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install gitpython</span><br></pre></td></tr></table></figure>



<h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h2 id="docker-for-windows重启电脑"><a href="#docker-for-windows重启电脑" class="headerlink" title="docker for windows重启电脑"></a>docker for windows重启电脑</h2><p>每次电脑重启，容器显示在运行，但是已经不能用了，执行restart重启容器会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error response from daemon: Cannot restart container myjenkins: </span><br><span class="line">driver failed programming external connectivity on endpoint myjenkins </span><br><span class="line">(0e1a94a2783d0ff6acc8a8580652692a27bd5dea24bfa2d45d329bb5764bfaa0): </span><br><span class="line">Error starting userland proxy: mkdir /port/tcp:0.0.0.0:8082:tcp:172.26.0.2:8080: input/output error</span><br></pre></td></tr></table></figure>

<p>解决：不知道什么原因，将docker服务整个重启即可</p>
<h2 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h2><p>将gradle复制到jenkins容器映射目录（即主机的<code>d:\Docker\Volume\Jenkins</code>），在系统管理–全局工具配置-Gradle中的<code>GRALDE_HOME</code>使用路径<code>/var/jenkins_home/gradle-4.6</code>。gradle-wrapper不知道怎么弄，没成功过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//gradle路径不正确</span><br><span class="line">Started by user unknown or anonymous</span><br><span class="line">Building in workspace E:\ASproject\FireSecure</span><br><span class="line">[Gradle] - Launching build.</span><br><span class="line">[Gradle] - [ERROR] Can&#x27;t retrieve the Gradle executable.</span><br><span class="line">Build step &#x27;Invoke Gradle script&#x27; marked build as failure</span><br><span class="line">Finished: FAILURE</span><br></pre></td></tr></table></figure>

<h2 id="java环境配置"><a href="#java环境配置" class="headerlink" title="java环境配置"></a>java环境配置</h2><p>docker里面有个java环境（docker-java-home），不知道是装docker就有的，还是装jenkins才弄上去的，<br>（猜测应该是jenkins自带的，我看了一下其他容器（nginx）没有java环境。nexus也有一个java环境，路径和jenkins不一样，不过版本一模一样，让我有点怀疑）<br>（网上说需要在系统管理–系统设置里设置Jenkins的JAVA_HOME环境变量，docker版的好像不需要，默认设置了docker-java-home）</p>
<h2 id="java-version（注意：不是–）"><a href="#java-version（注意：不是–）" class="headerlink" title="java -version（注意：不是–）"></a>java -version（注意：不是–）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br><span class="line">Build step &#x27;Execute shell&#x27; marked build as failure</span><br></pre></td></tr></table></figure>

<h2 id="docker内的容器找不到主机路径，需要Volume挂载"><a href="#docker内的容器找不到主机路径，需要Volume挂载" class="headerlink" title="docker内的容器找不到主机路径，需要Volume挂载"></a>docker内的容器找不到主机路径，需要Volume挂载</h2><p><strong>这个是最常见的，可能会以各种各样的形式出现</strong></p>
<h3 id="容器访问主机上的工程"><a href="#容器访问主机上的工程" class="headerlink" title="容器访问主机上的工程"></a>容器访问主机上的工程</h3><p>默认workspace在容器内的var/jenkins_home路径，上面我们已经通过<code>-v /d/Docker/Volume/Jenkins:/var/jenkins_home</code> 把主机的<code>d:\Docker\Volume\Jenkins</code>挂载到该目录下面了，访问<code>var/jenkins_home</code>就是访问<code>d:\Docker\Volume\Jenkins</code>。</p>
<p>也就是说需要将Android工程都复制到<code>d:\Docker\Volume\Jenkins</code>里面，然后通过<code>/var/jenkins_home</code>去访问具体的项目。</p>
<p>这样做的坏处显而易见，主机上的文件和docker容器文件混在一起，结构不清晰（强迫症受不了，目录和命名都要清清楚楚），要删除也不方便（我们要做的是随时可拆卸）。</p>
<p>解决办法很简单，还是挂载，将工程目录挂载到容器中一个新的目录下，单独存放工程。在run的时候使用<code>-v /e/ASproject:/var/as_project</code>挂载一个新的目录，<code>e:\ASproject</code>是放我的android项目，然后挂载到容器内的<code>/var/as_project</code>，访问<code>/var/as_project</code>就是访问<code>e:\ASproject</code>。</p>
<p>如果有java工程或者前端工程的话，可以按这种方式再挂载一个新的目录，然后在job里面需要配置Custom Workspace</p>
<h3 id="容器内Android-Sdk路径"><a href="#容器内Android-Sdk路径" class="headerlink" title="容器内Android Sdk路径"></a>容器内Android Sdk路径</h3><p>同理，Android项目的local.properties文件中用来指定sdk路径，一般是主机sdk路径。</p>
<p>这里也要修改成容器内的路径，否则执行编译的时候会找不到sdk路径，本地开发的时候再调成主机sdk路径。如图</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins09.png" alt="Android Sdk路径"></p>
<p><strong>注：这里还有一个坑</strong></p>
<p>执行gradle的upload命令时一直报<code>llvm-rs-cc is missing</code>，在主机上运行没问题，容器中执行就报这个错。找了很久，发现是sdk的build_tools出了问题。</p>
<p>原因：主机是windows环境，下载的是windows版本的sdk，容器内是linux环境，通过上面的方法挂载主机的sdk，在容器中使用会出错。</p>
<p>解决办法：下载linux版本的android sdk，sdk比较大，有些文件是通用的，可以不用重复下载（build-tools刚好是不通用的，因此报了上面的错误）</p>
<p>具体方法可以看这篇文章：<a href="https://www.kafan.cn/edu/84098914.html">windows和linux下androidSDK</a></p>
<p>顺便学下linux下安装android sdk：<a href="https://blog.csdn.net/u011974797/article/details/78973012">Linux – 安装配置Android SDK</a></p>
<h2 id="Force-GRADLE-USER-HOME-to-use-workspace"><a href="#Force-GRADLE-USER-HOME-to-use-workspace" class="headerlink" title="Force GRADLE_USER_HOME to use workspace"></a>Force GRADLE_USER_HOME to use workspace</h2><p>这个选项是把gradle缓存之类的（就是平时用户目录下的.gradle/下的东西）都放到workspace里，网上说勾上，但这里我不建议勾选，不勾选他会下到<code>/root</code>目录下，所有项目共用（和平时一样）。</p>
<h2 id="job左边的workspace里面有一个清扫工作空间，看到一篇文章说"><a href="#job左边的workspace里面有一个清扫工作空间，看到一篇文章说" class="headerlink" title="job左边的workspace里面有一个清扫工作空间，看到一篇文章说"></a>job左边的workspace里面有一个清扫工作空间，看到一篇文章说</h2><p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins08.png" alt="Jenkins成功图"></p>
<p><strong>这里提醒一下，删除job不会删除项目，但是点击了清理工作空间，整个项目都会被删掉（慎用！！！！！）</strong></p>
<h2 id="docker中使用vim，有的容器有（nexus），有的容器没有（nginx、jenkins）"><a href="#docker中使用vim，有的容器有（nexus），有的容器没有（nginx、jenkins）" class="headerlink" title="docker中使用vim，有的容器有（nexus），有的容器没有（nginx、jenkins）"></a>docker中使用vim，有的容器有（nexus），有的容器没有（nginx、jenkins）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">更新来源</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash">安装vim</span></span><br><span class="line">apt-get install -y vim</span><br></pre></td></tr></table></figure>

<h2 id="执行compileDebug-stacktrace-出错，改为gradlew-compileDebugJavaWithJavac-stacktrace"><a href="#执行compileDebug-stacktrace-出错，改为gradlew-compileDebugJavaWithJavac-stacktrace" class="headerlink" title="执行compileDebug --stacktrace 出错，改为gradlew compileDebugJavaWithJavac --stacktrace"></a>执行<code>compileDebug --stacktrace </code>出错，改为<code>gradlew compileDebugJavaWithJavac --stacktrace</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.gradle.execution.TaskSelectionException: Task ‘compileDebug’ is ambiguous in root project ‘NJCitizenCardApp’. Candidates are: ‘compileDebugAidl’, ‘compileDebugAndroidTestAidl’, ‘compileDebugAndroidTestJavaWithJavac’, ‘compileDebugAndroidTestNdk’, ‘compileDebugAndroidTestRend</span><br><span class="line">erscript’, ‘compileDebugAndroidTestShaders’, ‘compileDebugAndroidTestSources’, ‘compileDebugJavaWithJavac’, ‘compileDebugNdk’, ‘compileDebugRenderscript’, ‘compileDebugShaders’, ‘compileDebugSources’, ‘compileDebugUnitTestJavaWithJavac’, ‘compileDebugUnitTestSources’.</span><br><span class="line">at org.gradle.execution.TaskSelector.getSelection(TaskSelector.java:116)</span><br><span class="line">at org.gradle.execution.TaskSelector.getSelection(TaskSelector.java:81)</span><br><span class="line">at org.gradle.execution.commandline.CommandLineTaskParser.parseTasks(CommandLineTaskParser.java:42)</span><br><span class="line">at org.gradle.execution.TaskNameResolvingBuildConfigurationAction.configure(TaskNameResolvingBuildConfigurationAction.java:44)</span><br><span class="line">at org.gradle.execution.DefaultBuildConfigurationActionExecuter.configure(DefaultBuildConfigurationActionExecuter.java:48)</span><br></pre></td></tr></table></figure>

<h2 id="执行build命令的时候出现这个"><a href="#执行build命令的时候出现这个" class="headerlink" title="执行build命令的时候出现这个"></a>执行<code>build</code>命令的时候出现这个</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: llvm-rs-cc is missing </span><br><span class="line">at com.android.builder.core.AndroidBuilder.compileAllRenderscriptFiles(AndroidBuilder.java:1194) </span><br><span class="line">at com.android.build.gradle.tasks.RenderscriptCompile.taskAction(RenderscriptCompile.java:</span><br></pre></td></tr></table></figure>

<p>我这里是因为buildToolsVersion（没加）、compileSdkVersion（27）和targetSdkVersion（27）不一致引起的，把buildToolsVersion加上这个问题就消失了。</p>
<p>然而最后正常之后，又提示：（也就是说白加了，问题不出在这里）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING: The specified Android SDK Build Tools version (27.0.3) is ignored, as it is below the minimum supported version (28.0.3) for Android Gradle Plugin 3.2.1.</span><br><span class="line">Android SDK Build Tools 28.0.3 will be used.</span><br><span class="line">To suppress this warning, remove &quot;buildToolsVersion &#39;27.0.3&#39;&quot; from your build.gradle file, as each version of the Android Gradle Plugin now has a default version of the build tools.</span><br></pre></td></tr></table></figure>

<h2 id="共用缓存报错（Jenkins执行任务，本地使用IDE也在执行）"><a href="#共用缓存报错（Jenkins执行任务，本地使用IDE也在执行）" class="headerlink" title="共用缓存报错（Jenkins执行任务，本地使用IDE也在执行）"></a>共用缓存报错（Jenkins执行任务，本地使用IDE也在执行）</h2><p> 这是因为在跑job的时候，手贱在android studio里面也点了一下。最后搜到是共用缓存被锁住的问题<a href="https://stackoverflow.com/questions/53186389/gradle-build-on-gitlab-ci-could-not-create-service-of-type-scriptpluginfactory">参考</a>，再跑一下就好了（不。是换了个错误）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Could not create service of type ScriptPluginFactory using BuildScopeServices.createScriptPluginFactory().</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Could not create service of <span class="built_in">type</span> FileHasher using BuildSessionScopeServices.createFileSnapshotter().</span></span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Exception is:</span><br><span class="line">org.gradle.internal.service.ServiceCreationException: Could not create service of type ScriptPluginFactory using BuildScopeServices.createScriptPluginFactory().</span><br><span class="line">	at org.gradle.internal.service.DefaultServiceRegistry$FactoryMethodService.invokeMethod(DefaultServiceRegistry.java:857)</span><br><span class="line">	at org.gradle.internal.service.DefaultServiceRegistry$FactoryService.create(DefaultServiceRegistry.java:808)</span><br><span class="line">	</span><br><span class="line">	........ more</span><br><span class="line">	</span><br><span class="line">Caused by: org.gradle.api.UncheckedIOException: java.io.IOException: Input/output error</span><br><span class="line">	at org.gradle.internal.UncheckedException.throwAsUncheckedException(UncheckedException.java:57)</span><br><span class="line">	at org.gradle.internal.UncheckedException.throwAsUncheckedException(UncheckedException.java:40)</span><br><span class="line">	at org.gradle.cache.internal.DefaultFileLockManager.lock(DefaultFileLockManager.java:103)</span><br><span class="line">	at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.incrementLockCount(LockOnDemandCrossProcessCacheAccess.java:105)</span><br><span class="line">	at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.acquireFileLock(LockOnDemandCrossProcessCacheAccess.java:161)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.onStartWork(DefaultCacheAccess.java:368)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:213)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:203)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.newCache(DefaultCacheAccess.java:298)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.newCache(DefaultCacheAccess.java:57)</span><br><span class="line">	at org.gradle.cache.internal.DefaultPersistentDirectoryStore.createCache(DefaultPersistentDirectoryStore.java:148)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.createCache(DefaultCacheFactory.java:177)</span><br><span class="line">	at org.gradle.api.internal.changedetection.state.CrossBuildFileHashCache.createCache(CrossBuildFileHashCache.java:51)</span><br><span class="line">	at org.gradle.api.internal.changedetection.state.CachingFileHasher.&lt;init&gt;(CachingFileHasher.java:44)</span><br><span class="line">	at org.gradle.internal.service.scopes.BuildSessionScopeServices.createFileSnapshotter(BuildSessionScopeServices.java:198)</span><br><span class="line">	at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)</span><br><span class="line">	at org.gradle.internal.service.ReflectionBasedServiceMethod.invoke(ReflectionBasedServiceMethod.java:35)</span><br><span class="line">	at org.gradle.internal.service.DefaultServiceRegistry$FactoryMethodService.invokeMethod(DefaultServiceRegistry.java:855)</span><br><span class="line">	... 82 more</span><br><span class="line">Caused by: java.io.IOException: Input/output error</span><br><span class="line">	at org.gradle.cache.internal.filelock.LockStateAccess.readState(LockStateAccess.java:69)</span><br><span class="line">	at org.gradle.cache.internal.filelock.LockStateAccess.ensureLockState(LockStateAccess.java:46)</span><br><span class="line">	at org.gradle.cache.internal.filelock.LockFileAccess.ensureLockState(LockFileAccess.java:59)</span><br><span class="line">	at org.gradle.cache.internal.DefaultFileLockManager$DefaultFileLock.lock(DefaultFileLockManager.java:293)</span><br><span class="line">	at org.gradle.cache.internal.DefaultFileLockManager$DefaultFileLock.&lt;init&gt;(DefaultFileLockManager.java:154)</span><br><span class="line">	at org.gradle.cache.internal.DefaultFileLockManager.lock(DefaultFileLockManager.java:100)</span><br><span class="line">	... 97 more</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Docker容器内无法访问主机网络"><a href="#Docker容器内无法访问主机网络" class="headerlink" title="Docker容器内无法访问主机网络"></a>Docker容器内无法访问主机网络</h2><p>背景：执行Jenkins打包aar到maven仓库的时候，提示无法连接到Nexus服务。</p>
<p>原因：Docker容器内无法访问主机网络</p>
<p>我运行了Docker的Nexus容器，主机使用<code>localhost:8081</code>访问Nexus服务，Docker的Jenkins容器无法访问<code>localhost</code>地址。（可以使用<code>exec</code>命令进入容器内，在容器中使用curl或者telnet工具尝试访问端口）</p>
<p>解决办法：</p>
<ul>
<li>使用主机IP访问<ul>
<li>在容器内使用<code>ip addr</code>命令查看ip地址</li>
<li>在容器外使用<code>ipconfig</code>命令查看ip地址</li>
</ul>
</li>
<li>运行容器的时候可以配置容器网络：默认有三种网络：host、bridge、none，可以使用<code>docker network ls</code>命令查看，可以使用<code>docker network create</code>命令自行创建网络。使用<code>docker run --network 网络名</code>命令配置容器网络<ul>
<li>容器使用宿主机网络：使用<code>docker run --network host</code>命令。（有坑：这种模式只适用于Linux主机，不适合windows和mac）</li>
<li>容器以桥接模式连接到宿主机：使用<code>docker run --network bridge</code>命令（不设置的话使用默认的bridge网络）</li>
</ul>
</li>
</ul>
<p>参考<a href="https://www.jb51.net/article/149173.htm">Docker容器访问宿主机网络的方法</a></p>
<p>这里碰到了一个问题，我对网络不太了解，不过经过测试之后得出来了一些结论，有知道的可以联系我。</p>
<p>我主机总共监听了3个端口：</p>
<ul>
<li>使用docker运行了Nexus容器，映射到主机的8081端口，原端口也是8081</li>
<li>使用docker运行了Jenkins容器，映射到主机的8082端口，原端口是8080</li>
<li>主机上运行了springboot的服务，监听8083端口</li>
</ul>
<p>这里不设置桥接网络，即用默认的Bridge网络，使用<code>docker inspect &lt;容器名&gt;</code>可以查看到Networks的配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//截取其中网关和ip地址</span></span><br><span class="line"><span class="comment">//Jenkins配置如下</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看Nexus的配置，这个ip是按容器创建顺序自动分配的</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进入Jenkins容器中使用curl测试下能否访问地址和端口，测试结果如下</p>
<ul>
<li>在主机浏览器上使用<code>localhost</code>都能访问这三个端口，没问题。</li>
<li>主机上访问172.17.0.1:8081，超时，但不是被拒绝了</li>
<li>Jenkins容器内访问：</li>
</ul>
<table>
<thead>
<tr>
<th>主机:端口</th>
<th>Jenkins</th>
</tr>
</thead>
<tbody><tr>
<td>localhost</td>
<td>三个端口都访问不到</td>
</tr>
<tr>
<td>172.17.0.1:8081（网关+Nexus映射端口）</td>
<td>可以</td>
</tr>
<tr>
<td>172.17.0.1:8082（网关+Jenkins映射端口）</td>
<td>可以</td>
</tr>
<tr>
<td>172.17.0.1:8083（网关+主机服务端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.2:8081（NexusIP+Nexus原/映射端口）</td>
<td>可以</td>
</tr>
<tr>
<td>172.17.0.2:8082（NexusIP+Jenkins映射端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.2:8083（NexusIP+主机服务端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.3:8081（JenkinsIP+Nexus映原/映射端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.3:8082（JenkinsIP+Jenkins映射端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.3:8083（JenkinsIP+主机服务端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>主机动态ip:8081</td>
<td>可以</td>
</tr>
<tr>
<td>主机动态ip:8082</td>
<td>可以</td>
</tr>
<tr>
<td>主机动态ip:8083</td>
<td>可以</td>
</tr>
<tr>
<td>主机动态ip:8080</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.1:8080（网关+Jenkins原端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.3:8080（JenkinsIP+Jenkins原端口）</td>
<td>可以</td>
</tr>
</tbody></table>
<p>得出结论如下（对网络不太了解，凭自己感觉得出来结论，有错误的地方可以联系我）：</p>
<ul>
<li>docker使用bridge网络，即是一个虚拟的网关：172.17.0.1，或者叫子网？（可以使用<code>docker network create</code>命令自行创建网络），容器在这个子网下创建，会分配到一个虚拟的ip地址</li>
<li>在子网内的容器互相访问可以使用<code>网关+容器映射端口</code>，或者使用<code>容器的ip+该容器的原端口号</code><ul>
<li>这里的原端口指的是没有映射过的端口，如Jenkins是8080，Nexus是8081</li>
<li>Nexus可以使用172.17.0.3:8080访问Jenkins，使用8082则不可以</li>
</ul>
</li>
<li>主机访问容器，直接访问<code>主机IP+容器映射端口</code>。理论上应该是可以通过网关（172.17.0.1）访问到容器内部的，这里只是提示超时了，不知道应该怎么设置。</li>
</ul>
<p>按我的理解就是docker给每个容器分配了一个虚拟的网关和虚拟的ip地址。把每个容器看作一台机器，同一个网关下的容器看作一个子网下的机器。（真实的网络我不了解，但是应该能够得出和虚拟的一样的结论）</p>
<ul>
<li>容器映射出去的端口到网关那里，因此可以通过<code>网关+容器映射端口</code>访问到容器。同样也映射到了主机那里，可以通过<code>主机ip+容器映射端口</code>访问</li>
<li>知道容器ip的情况下，可以直接访问容器监听的端口，即<code>容器ip+容器原端口</code>（和主机服务类似，也可以通过localhost访问自己的端口），不能使用映射出去的端口了</li>
<li>但是容器要访问外部（主机）的话就只有通过主机ip访问（不过这个ip是动态在变的，每次都要换，也可以通过域名，或者设置固定ip）</li>
</ul>
<p>win10固定ip设置：</p>
<ul>
<li>命令行<code>ipconfig/all</code>查看IPv4、子网掩码、网关、首选DNS、备用DNS。（或者网络和Internet-&gt;状态-&gt;查看网络属性）</li>
<li>找到IP设置-&gt;IPv4，选择手动，一个个填上去就好了。</li>
<li>就不放图了</li>
</ul>
<h3 id="docker容器内无法访问公网"><a href="#docker容器内无法访问公网" class="headerlink" title="docker容器内无法访问公网"></a>docker容器内无法访问公网</h3><p>Temporary failure in name resolution</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br><span class="line"><span class="meta">#</span><span class="bash">报错</span></span><br><span class="line">ping: www.baidu.com: Temporary failure in name resolution</span><br><span class="line"><span class="meta">#</span><span class="bash">或者：ping: www.bing.com: Name or service not known</span></span><br></pre></td></tr></table></figure>

<p>原因：DNS设置有问题</p>
<p>解决办法：windows下打开docker设置，如下图，选择固定DNS（具体原因不太懂，自己尝试了这样改就OK了）</p>
<p><img src="/images/Docker/docker07.png" alt="docker容器访问公网"></p>
<h2 id="python编码错误"><a href="#python编码错误" class="headerlink" title="python编码错误"></a>python编码错误</h2><h3 id="编码错误1"><a href="#编码错误1" class="headerlink" title="编码错误1"></a>编码错误1</h3><p>背景：http请求返回值中含有中文，在容器内使用命令行运行没报错，使用jenkins job运行就报编码错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 84-87: ordinal not in range(128)</span><br></pre></td></tr></table></figure>

<p>原因：python默认编码是ascii。</p>
<p>解决办法：</p>
<p>（1）加上这三句，设置编码。（本文件有效）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>（2）设置python默认编码（全局python环境）,#在Python的Lib\site-packages文件夹下新建一个sitecustomize.py文件，内容为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>（3）使用命令行运行不会报错。。。</p>
<h3 id="编码错误2"><a href="#编码错误2" class="headerlink" title="编码错误2"></a>编码错误2</h3><p>还有一种情况，python文件中出现中文，包括中文注释，运行的时候也会报错（而且使用命令行也会报错）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character &#x27;\xe5&#x27; in file E:/CiProject/jenkins_workspace/ci_scripts/util/http_util.py on line 11, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details</span><br></pre></td></tr></table></figure>

<p>原因：python文件默认是以ascii保存的</p>
<p>解决办法：需要声明文件编码格式，在文件头加上声明，下面几种方式都可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=&lt;encoding name&gt;</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: &lt;encoding name&gt; -*-</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># vim: set fileencoding=&lt;encoding name&gt; :</span></span><br></pre></td></tr></table></figure>

<h2 id="其他Android错误"><a href="#其他Android错误" class="headerlink" title="其他Android错误"></a>其他Android错误</h2><p>运行Gradle脚本可能会出现各种各样的Android或者Gradle错误，只能一个个排查了，比如遇到内存不足，sdk版本不对等</p>
<h2 id="docker容器时区和宿主机不一致"><a href="#docker容器时区和宿主机不一致" class="headerlink" title="docker容器时区和宿主机不一致"></a>docker容器时区和宿主机不一致</h2><ul>
<li>docker容器内时区为UTC：国际协调时间，即0时区</li>
<li>宿主机时区为CST：中国标准时间，即东八区</li>
</ul>
<p>解决办法：</p>
<ol>
<li><p>启动容器的时候通过挂载共享主机的localtime：<code>docker run --name &lt;name&gt; -v /etc/localtime:/etc/localtime</code></p>
</li>
<li><p>将主机的配置文件拷贝到容器中：<code>docker cp /etc/localtime:【容器ID或者NAME】/etc/localtime</code></p>
</li>
<li><p>使用<code>docker exec -it &lt;容器名/id&gt; /bin/bash</code>进去容器内部进行修改。（当作一个linux系统即可）</p>
</li>
<li><p>创建自定义的Dockerfile，如下。保存后使用docker build生成镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM redis</span><br><span class="line">FROM tomcat</span><br><span class="line">ENV CATALINA_HOME /usr/local/tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash">设置时区</span></span><br><span class="line">RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">  &amp;&amp; echo &#x27;Asia/Shanghai&#x27; &gt;/etc/timezone \</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>对于Windows版的docker，时区配置不知道在哪，上面的方法不知道有没有用，因为暂时不影响，所以没尝试</strong></p>
<h2 id="使用shell执行gradlew命令"><a href="#使用shell执行gradlew命令" class="headerlink" title="使用shell执行gradlew命令"></a>使用shell执行gradlew命令</h2><ul>
<li>使用gradle命令：在容器内下载gradle，并且在<strong>容器内部（不是宿主机）</strong>配置环境变量。（或者直接挂载主机的gradle路径）</li>
<li>使用gradlew命令：gradlew对gradle进行了封装，并且会自动下载对应版本的gradlew。</li>
</ul>
<p><strong>使用gradlew注意：</strong></p>
<ul>
<li><p>修改Android工程的.gitignore，下面三行去掉</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/gradle/</span><br><span class="line">/gradlew</span><br><span class="line">/gradlew.bat</span><br></pre></td></tr></table></figure></li>
<li><p>脚本需要使用<code>./gradlew ***</code>执行，而不是<code>gradlew</code>，因为容器是linux环境，和宿主机（windows）不同</p>
</li>
<li><p>会自动下载相应版本到用户目录的<code>.gradle</code>文件夹下</p>
</li>
</ul>
<h2 id="切换task为assembleDebug终于成功打出apk了，折腾了一晚上天快亮了，"><a href="#切换task为assembleDebug终于成功打出apk了，折腾了一晚上天快亮了，" class="headerlink" title="切换task为assembleDebug终于成功打出apk了，折腾了一晚上天快亮了，"></a>切换task为<code>assembleDebug</code>终于成功打出apk了，折腾了一晚上天快亮了，</h2><p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins14.png" alt="Jenkins成功图"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative学习</title>
    <url>/2019/01/01/android-2019-01-01-ReactNative/</url>
    <content><![CDATA[<h1 id="RN介绍"><a href="#RN介绍" class="headerlink" title="RN介绍"></a>RN介绍</h1><p>Learn once, Write anywhere.z</p>
<ol>
<li>前端技术栈</li>
<li>支持动态化</li>
<li>支持热重载</li>
<li>需要开发Native组件</li>
<li>通过JavaScript Core映射成原生控件渲染</li>
</ol>
<h2 id="和传统前端的区别"><a href="#和传统前端的区别" class="headerlink" title="和传统前端的区别"></a>和传统前端的区别</h2><table>
<thead>
<tr>
<th></th>
<th>传统前端</th>
<th>RN</th>
</tr>
</thead>
<tbody><tr>
<td>标签</td>
<td>小写（div、img）</td>
<td>首字母大写（View、Image）</td>
</tr>
<tr>
<td>文字</td>
<td>所有双标签都可以包裹文字</td>
<td>需要使用<code>&lt;Text&gt;&lt;/Text&gt;</code>包裹</td>
</tr>
<tr>
<td>背景</td>
<td>style支持background</td>
<td>需要使用<code>&lt;ImageBackground&gt;</code></td>
</tr>
<tr>
<td>结构</td>
<td>支持CSS样式</td>
<td>一切皆JS</td>
</tr>
<tr>
<td>加载</td>
<td>根据代码顺序自上而下加载</td>
<td>根据生命周期加载</td>
</tr>
<tr>
<td>页面跳转</td>
<td><code>&lt;a&gt;</code>标签或者<code>window.location.href</code></td>
<td>路由框架<code>react-navigation</code>、<code>navigator</code>等</td>
</tr>
<tr>
<td>全局变量</td>
<td>浏览器Window对象</td>
<td>global对象</td>
</tr>
</tbody></table>
<h2 id="RN生命周期"><a href="#RN生命周期" class="headerlink" title="RN生命周期"></a>RN生命周期</h2><ul>
<li><code>constructor</code>：组件被创建之前初始化数据</li>
<li><code>componentWillMount</code>：组件已创建但是未被渲染，可以在这里面请求数据</li>
<li><code>render</code>：组件渲染，组件结构都写在这里</li>
<li><code>componentDidMount</code>：组件已渲染完,可以在这里请求数据并使用setState改变数据来触发视图自动更新</li>
<li><code>componentWillReceiveProps</code>：如果组件收到新的属性（props），就会调用此函数,并使用setState改变数据来触发视图自动更新</li>
<li><code>shouldComponentUpdate</code>：当组件接收到新的属性和状态改变的话，都会触发调用 shouldComponentUpdate来判断组件是否应该更新</li>
<li><code>componentWillUpdate</code>：如果组件状态或者属性改变，并且 <code>shouldComponentUpdate(...)</code> 返回为 true，就会开始准更新组件，并调用<code>componentWillUpdate()</code></li>
<li><code>componentDidUpdate</code>：调用了<code>render()</code>更新完成界面之后，会调用<code>componentDidUpdate()</code>来得到通知</li>
<li><code>componentWillUnmount</code>：当组件要被从界面上移除的时候，就会调用此函数，一般在这里取消定时器，remove监听事件</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="React-Native-Error-Cannot-find-module-‘asap-raw’"><a href="#React-Native-Error-Cannot-find-module-‘asap-raw’" class="headerlink" title="React Native:Error: Cannot find module ‘asap/raw’"></a>React Native:Error: Cannot find module ‘asap/raw’</h2><p>安装<code>react-native-navigation</code>后出错</p>
<p>解决办法：重新安装依赖，执行<code>npm install</code></p>
<h2 id="setting-gradle路径问题"><a href="#setting-gradle路径问题" class="headerlink" title="setting.gradle路径问题"></a>setting.gradle路径问题</h2><p>使用react-navigation：</p>
<ul>
<li><code>yarn add react-navigation</code></li>
<li><code>yarn add react-native-gesture-handler</code></li>
<li><code>react-native link react-native-gesture-handler</code>（会修改setting.gradle，引入<code>react-native-gesture-handler</code>作为project module）</li>
</ul>
<p>问题：路径使用<code>\</code>分割，不正确，应该修改为<code>/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Settings file &#x27;E:\AndroidStudioProjects\Demo\android\settings.gradle&#x27; line: 3</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Could not compile settings file &#x27;E:\AndroidStudioProjects\Demo\android\settings.gradle&#x27;.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> startup failed:</span></span><br><span class="line">  settings file &#x27;E:\AndroidStudioProjects\Demo\android\settings.gradle&#x27;: 3: unexpected char: &#x27;\&#x27; @ line 3, column 133.</span><br><span class="line">     s\react-native-gesture-handler\android&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="VsCode格式化代码"><a href="#VsCode格式化代码" class="headerlink" title="VsCode格式化代码"></a>VsCode格式化代码</h2><p>VsCode格式化ReactNative代码的时候，标签尖括号会换行</p>
<p>解决办法：如果是js文件，下面不要选择JavaScript，而是JavaScript React，如图</p>
<p><img src="/2019/01/01/android-2019-01-01-ReactNative/vscode_format.png" alt="VsCode格式化ReactNative代码"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmder——Windows下好用的命令行工具</title>
    <url>/2018/12/14/tool-2018-12-14-Cmder/</url>
    <content><![CDATA[<h2 id="Cmder"><a href="#Cmder" class="headerlink" title="Cmder"></a>Cmder</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Cmder是windows下的命令行工具，支持大部分Linux命令，使用方便，可以替代原来的cmd，并且界面美观简洁，相比PowerShell、cmd不忍直视。</p>
<p>先上效果图</p>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder.png"></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>直接去<a href="http://cmder.net/">官网</a>下载，解压即可</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li><p>配置环境变量</p>
<p>把解压后的目录加到系统环境变量，然后使用<code>win +R</code>，输入<code>cmder</code>，即可快捷打开cmder</p>
</li>
<li><p>加入右键菜单（类似git bash）：打开命令行工具输入<code>cmder /register all</code></p>
<p>如果遇到拒绝访问，如下，可以通过”右键，以管理员方式运行”</p>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder01.png"></p>
</li>
<li><p>添加语言环境，否则会出现中文乱码</p>
<p>在Settings -&gt;Startup -&gt; Environment中添加一行：<code>set LC_ALL=zh_CN.UTF-8</code>，注意后面的分号</p>
</li>
</ol>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder02.png"></p>
<ol start="4">
<li><p>修改命令提示符号</p>
<p>cmder默认提示符号是λ，可以改成$：打开cmder安装目录下的\vendor\clink.lua文件，搜索<code>$&#123;lamb&#125;</code>改成想要的符号，如下</p>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder03.png"></p>
</li>
<li><p>设置命令别名</p>
<p>cmder原生不支持如<strong>ll</strong> 等命令，可以通过设置别名来实现</p>
<p>打开cmder安装目录下的\config\user-aliases.cmd文件，加入下面设置，也可以自定义</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l&#x3D;ls --show-control-chars -F --color $*</span><br><span class="line">la&#x3D;ls -aF --show-control-chars -F --color $*</span><br><span class="line">ll&#x3D;ls -alF --show-control-chars -F --color $*</span><br></pre></td></tr></table></figure>

<p>​    使用<code>&amp;</code>连接执行多条命令，<code>$1、$2、$*</code>表示命令后面添加的参数。</p>
<p>可以通过命令别名设置快速进入常用文件夹，如<code>project = e: &amp; cd MyProject\$*</code>，输入<code>project</code>则切换到e盘，并进入<code>MyProject</code>目录，输入<code>project subproject\hhh</code>则表示进入<code>e:\MyProject\subproject\hhh</code></p>
<ol>
<li><p>指定命令执行环境</p>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder04.png"></p>
</li>
<li><p>快捷键</p>
<p><code>Ctrl+U</code>：清除当前行</p>
<p><code>Ctrl+L</code>：清屏</p>
<p><code>Ctrl+T</code>：新建标签页</p>
<p><code>Ctrl+W</code>：关闭标签页</p>
<p><code>鼠标右键</code>：粘贴</p>
<p><code>Ctrl+鼠标滚轮</code>：放大缩小字体</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/mynamepg/article/details/81233120">推荐一款超好用的工具cmder</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js或ts语法笔记</title>
    <url>/2018/12/12/webdev-2018-12-12-SyntaxSugarNote/</url>
    <content><![CDATA[<h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><ul>
<li><p><code>==</code>和<code>===</code></p>
<ul>
<li>==会自动转换类型比较</li>
<li>===严格比较，类型需要相同</li>
<li>!=和!==同理</li>
</ul>
</li>
<li><p><code>success?.() </code>相当于<code>success &amp;&amp; success()</code>，判断不为空再执行</p>
</li>
<li><p>(+”1”)把字符串转换成整数</p>
</li>
</ul>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>prototype 属性允许您向对象添加属性和方法</p>
<p><strong>注意：</strong> Prototype 是全局属性，适用于所有的Javascript对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">employee</span>(<span class="params">name,jobtitle,born</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name=name;</span><br><span class="line">	<span class="built_in">this</span>.jobtitle=jobtitle;</span><br><span class="line">	<span class="built_in">this</span>.born=born;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fred=<span class="keyword">new</span> employee(<span class="string">&quot;Fred Flintstone&quot;</span>,<span class="string">&quot;Caveman&quot;</span>,<span class="number">1970</span>);</span><br><span class="line">employee.prototype.salary=<span class="literal">null</span>;</span><br><span class="line">fred.salary=<span class="number">20000</span>;</span><br><span class="line"><span class="built_in">document</span>.write(fred.salary);</span><br></pre></td></tr></table></figure>

<p>给employee函数添加了salary属性，可以.出来</p>
<h2 id="argument"><a href="#argument" class="headerlink" title="argument"></a>argument</h2><p>在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function howManyArgs() &#123;</span><br><span class="line">  alert(arguments.length);</span><br><span class="line">&#125;</span><br><span class="line">howManyArgs(&quot;string&quot;, 45);    &#x2F;&#x2F;2</span><br><span class="line">howManyArgs();    &#x2F;&#x2F;0</span><br><span class="line">howManyArgs(12);    &#x2F;&#x2F;1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：与其他程序设计语言不同，ECMAScript 不会验证传递给函数的参数个数是否等于函数定义的参数个数。开发者定义的函数都可以接受任意个数的参数（根据 Netscape 的文档，最多可接受 255 个），而不会引发任何错误。任何遗漏的参数都会以 undefined 传递给函数，多余的函数将忽略。</p>
<h2 id="pipeline写法"><a href="#pipeline写法" class="headerlink" title="pipeline写法"></a>pipeline写法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data </span><br><span class="line">|&gt; fnx</span><br><span class="line">|&gt; fny</span><br><span class="line">|&gt; fnz</span><br></pre></td></tr></table></figure>

<p>相当于fnz(fny(fnx(data)))，pipeline写法</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> func=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;&#125;</span><br><span class="line"> <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connect（a,b）=func（c）</p>
<p>connect(mapStateToProps,mapDispatchToProps)(MainPage)</p>
<p>实际上是这样func(c)(MainPage);</p>
<p>MainPage是赋值给里面的c，而不是对应a，b</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Lint工具和自定义Lint规则</title>
    <url>/2018/12/04/android-2018-12-04-LintTools/</url>
    <content><![CDATA[<h1 id="Lint介绍"><a href="#Lint介绍" class="headerlink" title="Lint介绍"></a>Lint介绍</h1><h2 id="Lint简介"><a href="#Lint简介" class="headerlink" title="Lint简介"></a>Lint简介</h2><p>静态代码质量检查（分析、扫描）工具</p>
<p>Android Lint 是 SDK Tools 16（ADT 16）开始引入的一个代码扫描工具（在sdk目录/tools/bin下可以找到lint工具），通过对代码进行静态分析，可以检查代码规范问题和质量问题，并提出一些改进建议。可以规范团队代码风格，提高代码质量，指导开发者正确使用sdk等。</p>
<p>原生lint规则已经很全面了，不过有时候在团队开发中我们得根据需求定制自己的lint规则</p>
<p>举例：</p>
<ul>
<li>提醒使用自己的log工具，不用原生的log</li>
<li>提醒try-catch代码块后记得加finally</li>
<li>提醒资源文件，资源id命名规范，加模块名前缀</li>
<li>……</li>
</ul>
<h2 id="lint原理"><a href="#lint原理" class="headerlink" title="lint原理"></a>lint原理</h2><p>lint规则是在AST（抽象语法树，类似dom树）上进行解析。可以将项目里的一切视为对象，如目录、文件，java类、方法，xml元素、属性、值等，针对这些对象进行分析处理，并上报问题。</p>
<ul>
<li>推荐一个Android Studio的插件：PsiViewer，可以查看语法树</li>
</ul>
<h2 id="有几种使用方式"><a href="#有几种使用方式" class="headerlink" title="有几种使用方式"></a>有几种使用方式</h2><ul>
<li>使用lint命令行执行</li>
<li>使用android studio提供的可视化工具</li>
<li>结合gradle命令，如<code>./gradlew lint</code> （推荐）</li>
</ul>
<h2 id="Lint过程"><a href="#Lint过程" class="headerlink" title="Lint过程"></a>Lint过程</h2><p><img src="/2018/12/04/android-2018-12-04-LintTools/lint_process.png" alt="lint过程"></p>
<h1 id="Android-Lint使用"><a href="#Android-Lint使用" class="headerlink" title="Android Lint使用"></a>Android Lint使用</h1><h2 id="使用Android-Studio提供的工具运行lint"><a href="#使用Android-Studio提供的工具运行lint" class="headerlink" title="使用Android Studio提供的工具运行lint"></a>使用Android Studio提供的工具运行lint</h2><ul>
<li>在Android Studio菜单栏Analyze&gt;Inspect code，选择要扫描的范围（也可以在右键菜单中打开）<br><img src="/2018/12/04/android-2018-12-04-LintTools/android_inspect01.png" alt="android studio lint"></li>
<li>配置检查规则：<br><img src="/2018/12/04/android-2018-12-04-LintTools/android_inspect02.png" alt="android studio lint"></li>
<li>检查结果示例<br><img src="/2018/12/04/android-2018-12-04-LintTools/android_inspect03.png" alt="android studio lint"></li>
</ul>
<p>除此之外，还可以通过配置lint.xml文件进行配置，参考<a href="https://developer.android.google.cn/studio/write/lint">开发者文档</a></p>
<h2 id="推荐使用gradle命令运行lint"><a href="#推荐使用gradle命令运行lint" class="headerlink" title="推荐使用gradle命令运行lint"></a>推荐使用gradle命令运行lint</h2><ul>
<li>可以导出html、xml文件到模块下的build/reports目录下，使用浏览器打开，查看lint结果</li>
</ul>
<p><code>./gradlew -p 模块名 lint</code>或<code>./gradlew 模块名:lint</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="lint-xml配置"><a href="#lint-xml配置" class="headerlink" title="lint.xml配置"></a>lint.xml配置</h3><ul>
<li>官方文档说要放到项目根目录，试了一下不行，需要放到相应的module目录下</li>
<li>更新lint.xml配置有时候应用可能不及时，需要sync一下或者重启Android Studio</li>
<li>鼠标移到问题代码处，点开more，可以看到issue id</li>
</ul>
<p>举例</p>
<ul>
<li>配置规则<br><img src="/2018/12/04/android-2018-12-04-LintTools/lint_config.png" alt="配置规则"></li>
<li>前后对比<ul>
<li>编辑器里的提示对比<br><img src="/2018/12/04/android-2018-12-04-LintTools/lint_config01.png" alt="配置前后对比"></li>
<li>导出结果对比<br><img src="/2018/12/04/android-2018-12-04-LintTools/lint_config02.png" alt="配置前后对比"></li>
</ul>
</li>
</ul>
<h3 id="Java代码配置"><a href="#Java代码配置" class="headerlink" title="Java代码配置"></a>Java代码配置</h3><p>添加 <code>@SuppressLint</code> 注解，禁止Lint 检查某个 Java 类或方法。<br>如：<code>@SuppressLint(&quot;all&quot;)</code> ，禁止检查所有lint问题</p>
<h3 id="xml文件配置"><a href="#xml文件配置" class="headerlink" title="xml文件配置"></a>xml文件配置</h3><ul>
<li>添加命名空间：<code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></li>
<li>添加属性：配置禁止检查无用资源lint，该属性会继承到子元素：<code>tools:ignore=&quot;UnusedResources&quot;</code></li>
</ul>
<h3 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h3><p>在构建时执行</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123; </span><br><span class="line"> lintOptions &#123;</span><br><span class="line">    <span class="comment">// true--关闭lint报告的分析进度</span></span><br><span class="line">    quiet <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--错误发生后停止gradle构建</span></span><br><span class="line">    abortOnError <span class="literal">false</span></span><br><span class="line">    <span class="comment">// true--只报告error</span></span><br><span class="line">    ignoreWarnings <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--忽略有错误的文件的全/绝对路径(默认是true)</span></span><br><span class="line">    absolutePaths <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--检查所有问题点，包含其他默认关闭项</span></span><br><span class="line">    checkAllWarnings <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--所有warning当做error</span></span><br><span class="line">    warningsAsErrors <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 关闭指定问题检查</span></span><br><span class="line">    disable <span class="string">&#x27;TypographyFractions&#x27;</span>, <span class="string">&#x27;TypographyQuotes&#x27;</span></span><br><span class="line">    <span class="comment">// 打开指定问题检查</span></span><br><span class="line">    enable <span class="string">&#x27;RtlHardcoded&#x27;</span>, <span class="string">&#x27;RtlCompat&#x27;</span>, <span class="string">&#x27;RtlEnabled&#x27;</span></span><br><span class="line">    <span class="comment">// 仅检查指定问题 check &#x27;NewApi&#x27;, &#x27;InlinedApi&#x27;</span></span><br><span class="line">    <span class="comment">// true--error输出文件不包含源码行号</span></span><br><span class="line">    noLines <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--显示错误的所有发生位置，不截取</span></span><br><span class="line">    showAll <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 回退lint设置(默认规则)</span></span><br><span class="line">    lintConfig file(<span class="string">&quot;default-lint.xml&quot;</span>)</span><br><span class="line">    <span class="comment">// true--生成txt格式报告(默认false)</span></span><br><span class="line">    textReport <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 重定向输出；可以是文件或&#x27;stdout&#x27;</span></span><br><span class="line">    textOutput <span class="string">&#x27;stdout&#x27;</span></span><br><span class="line">    <span class="comment">// true--生成XML格式报告</span></span><br><span class="line">    xmlReport <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 指定xml报告文档(默认lint-results.xml)</span></span><br><span class="line">    xmlOutput file(<span class="string">&quot;lint-report.xml&quot;</span>)</span><br><span class="line">    <span class="comment">// true--生成HTML报告(带问题解释，源码位置，等)</span></span><br><span class="line">    htmlReport <span class="literal">true</span></span><br><span class="line">    <span class="comment">// html报告可选路径(构建器默认是lint-results.html )</span></span><br><span class="line">    htmlOutput file(<span class="string">&quot;lint-report.html&quot;</span>)</span><br><span class="line">    <span class="comment">// true--所有正式版构建执行规则生成崩溃的lint检查，如果有崩溃问题将停止构建</span></span><br><span class="line">    checkReleaseBuilds <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 在发布版本编译时检查(即使不包含lint目标)，指定问题的规则生成崩溃</span></span><br><span class="line">    fatal <span class="string">&#x27;NewApi&#x27;</span>, <span class="string">&#x27;InlineApi&#x27;</span></span><br><span class="line">    <span class="comment">// 指定问题的规则生成错误</span></span><br><span class="line">    error <span class="string">&#x27;Wakelock&#x27;</span>, <span class="string">&#x27;TextViewEdits&#x27;</span></span><br><span class="line">    <span class="comment">// 指定问题的规则生成警告</span></span><br><span class="line">    warning <span class="string">&#x27;ResourceAsColor&#x27;</span></span><br><span class="line">    <span class="comment">// 忽略指定问题的规则(同关闭检查)</span></span><br><span class="line">    ignore <span class="string">&#x27;TypographyQuotes&#x27;</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义Lint流程"><a href="#自定义Lint流程" class="headerlink" title="自定义Lint流程"></a>自定义Lint流程</h1><h2 id="自定义lint规则"><a href="#自定义lint规则" class="headerlink" title="自定义lint规则"></a>自定义lint规则</h2><ul>
<li><p>根目录<code>build.gradle</code>中添加gradle插件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">classpath <span class="string">&quot;com.android.tools.build:gradle:$gradlePluginVersion&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>新建一个模块，如checks，用于编写自定义lint规则</p>
</li>
<li><p>修改build.gradle如下<br><img src="/2018/12/04/android-2018-12-04-LintTools/custom_lint01.png" alt="自定义lint规则gradle配置"></p>
<p>– 添加java plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;java-library&#39;</span><br></pre></td></tr></table></figure>

<p>– 添加依赖，版本号根据需要填</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &quot;com.android.tools.lint:lint-api:$lintVersion&quot; &#x2F;&#x2F;Lint Api</span><br><span class="line">compile &quot;com.android.tools.lint:lint-checks:$lintVersion&quot; &#x2F;&#x2F;android lint原生规则</span><br><span class="line">testCompile &quot;com.android.tools.lint:lint:$lintVersion&quot; &#x2F;&#x2F;用于运行Lint检查</span><br></pre></td></tr></table></figure>

<p>– 配置jar打包，Lint-Registry是透露给lint工具的注册类的方法，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes(&quot;Lint-Registry&quot;: &quot;com.my.smart.lint.checks.MyIssueRegistry&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写自定义Lint规则，下面介绍</p>
</li>
<li><p>编译生成jar，路径为<code>/checks/build/libs/checks.jar</code></p>
</li>
</ul>
<h2 id="应用lint规则"><a href="#应用lint规则" class="headerlink" title="应用lint规则"></a>应用lint规则</h2><p>有以下几种方式</p>
<ol>
<li>将jar放到~/.android/lint/下，对所有本地项目生效。  </li>
<li>将jar放到模块libs目录，使用lintChecks方式引入<br><img src="/2018/12/04/android-2018-12-04-LintTools/lintchecks.png" alt="lintChecks解释"></li>
<li>将jar打包成aar，使用implementation引入（推荐）</li>
</ol>
<p>使用第三种方式引入</p>
<ul>
<li><p>新建一个library模块，用于打包aar </p>
</li>
<li><p>在library的dependencies中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lintChecks project(&#39;:checks&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>打包上传到maven</p>
</li>
</ul>
<h2 id="编写lint规则"><a href="#编写lint规则" class="headerlink" title="编写lint规则"></a>编写lint规则</h2><p>可以通过看<a href="https://android.googlesource.com/platform/tools/base/+/master/lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks">已有的Lint规则源码</a>，<a href="https://www.javadoc.io/doc/com.android.tools.lint/lint-api/25.3.0">LintApi文档</a>来学习</p>
<p>主要使用<code>lint-api</code>提供的接口进行开发</p>
<h3 id="常用api如下"><a href="#常用api如下" class="headerlink" title="常用api如下"></a>常用api如下</h3><ul>
<li>Issue：表示一个Lint规则。例如调用 Toast.makeText() 方法后，没有调用 Toast.show() 方法将其显示。</li>
<li>IssueRegistry：用于注册要检查的Issue列表。自定义Lint需要生成一个jar文件，其Manifest指向IssueRegistry类。</li>
<li>Detector：用于检测并报告代码中的Issue。每个Issue包含一个Detector。</li>
<li>Scope：声明Detector要扫描的代码范围，例如Java源文件、XML资源文件、Gradle文件等。每个Issue可包含多个Scope。</li>
<li>Scanner：用于扫描并发现代码中的Issue。每个Detector可以实现一到多个Scanner。<ul>
<li>JavaScanner（最早） / JavaPsiScanner / UastScanner（最新、推荐）：扫描Java源文件</li>
<li>XmlScanner：扫描XML文件</li>
<li>ClassScanner：扫描class文件</li>
<li>BinaryResourceScanner：扫描二进制资源文件</li>
<li>ResourceFolderScanner：扫描资源文件夹</li>
<li>GradleScanner：扫描Gradle脚本</li>
<li>OtherFileScanner：扫描其他类型文件</li>
<li>……</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>AST（Abstract Syntax Tree，抽象语法树）</li>
<li>PSI（Program Structure Interface）：是一个框架，用于访问抽象语法树，<code>com.intellij.psi</code></li>
<li>UAST（Unified AST）：是一个框架，用于访问抽象语法树，<code>org.jetbrains.uast</code></li>
</ul>
</blockquote>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>检查控件id命名前缀，如ImageView以iv_开头，Button以btn开头</p>
<ol>
<li>实现Detector</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 继承ResourceXmlDetector，该类实现了XmlScanner，表示检查xml文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfauriaResIdDetector</span> <span class="keyword">extends</span> <span class="title">ResourceXmlDetector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Implementation IMPLEMENTATION_RES_ONLY = <span class="keyword">new</span> Implementation(</span><br><span class="line">            AfauriaResIdDetector.class,</span><br><span class="line">            Scope.RESOURCE_FILE_SCOPE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 定义Issue，包括id，描述，解释，分类，优先级，严重级别，作用域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Issue RES_ID_ISSUE = Issue.create(</span><br><span class="line">            <span class="string">&quot;AfauriaResId&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Id命名不规范&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Id 命名以控件缩写为前缀&quot;</span>,</span><br><span class="line">            Category.SECURITY,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            Severity.ERROR,</span><br><span class="line">            IMPLEMENTATION_RES_ONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 过滤文件夹</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appliesTo</span><span class="params">(ResourceFolderType folderType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResourceFolderType.LAYOUT == folderType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 过滤tag</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">getApplicableElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        elements.add(LINEAR_LAYOUT);</span><br><span class="line">        elements.add(RELATIVE_LAYOUT);</span><br><span class="line">        elements.add(FRAME_LAYOUT);</span><br><span class="line">        elements.add(CONSTRAINT_LAYOUT);</span><br><span class="line">        elements.add(LIST_VIEW);</span><br><span class="line">        elements.add(SCROLL_VIEW);</span><br><span class="line">        elements.add(TEXT_VIEW);</span><br><span class="line">        elements.add(IMAGE_VIEW);</span><br><span class="line">        elements.add(CHECK_BOX);</span><br><span class="line">        elements.add(RADIO_BUTTON);</span><br><span class="line">        elements.add(EDIT_TEXT);</span><br><span class="line">        elements.add(RECYCLER_VIEW);</span><br><span class="line">        elements.add(BUTTON);</span><br><span class="line"><span class="comment">//        elements.add(PROGRESS_BAR);</span></span><br><span class="line"><span class="comment">//        elements.add(FQCN_DATE_PICKER);</span></span><br><span class="line"><span class="comment">//        elements.add(FQCN_TIME_PICKER);</span></span><br><span class="line"><span class="comment">//        elements.add(RADIO_GROUP);</span></span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 过滤属性，这里有坑，下面解释</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public Collection&lt;String&gt; getApplicableAttributes() &#123;</span></span><br><span class="line"><span class="comment">//        return Collections.singletonList(&quot;id&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//6. 已经定位到对象，对其进行解析，若不符合规则，则报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitElement</span><span class="params">(XmlContext context, Element element)</span> </span>&#123;</span><br><span class="line">        checkIdAttr(context,element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIdAttr</span><span class="params">(XmlContext context, Element element)</span></span>&#123;</span><br><span class="line">    <span class="comment">//7. 对象解析</span></span><br><span class="line">        Attr attributeNode = element.getAttributeNode(<span class="string">&quot;android:id&quot;</span>);</span><br><span class="line">        String tag = element.getTagName();</span><br><span class="line">        System.out.println(<span class="string">&quot;ResId Tag Name：&quot;</span> + tag);</span><br><span class="line">        <span class="keyword">if</span> (tag.equals(BUTTON)) &#123;</span><br><span class="line">            tag = <span class="string">&quot;btn&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tag = tag.replaceAll(<span class="string">&quot;[a-z\\d.]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            tag = tag.toLowerCase();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;ResId Tag Prefix：&quot;</span> + tag);</span><br><span class="line">        <span class="keyword">if</span> (attributeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String value = attributeNode.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!value.startsWith(ANDROID_ID_PREFIX)</span><br><span class="line">                    &amp;&amp; !value.startsWith(ANDROID_NEW_ID_PREFIX)</span><br><span class="line">                    &amp;&amp; !value.startsWith(NEW_ID_PREFIX + tag)) &#123;</span><br><span class="line">                <span class="comment">//8. 报告错误，参数：Issue，Node（对象节点），Location（报错位置），Message（提示信息），LintFix（解决方案）</span></span><br><span class="line">                context.report(RES_ID_ISSUE,</span><br><span class="line">                        attributeNode,</span><br><span class="line">                        context.getLocation(attributeNode),</span><br><span class="line">                        String.format(<span class="string">&quot; id 命名以 %s_ 开头&quot;</span>, tag));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：</p>
<p><code>getApplicableElements</code>和<code>visitElement</code>，<code>getApplicableAttributes </code>和<code>visitAttribute</code>是成对使用的，一开始以为是链式的，先过滤元素，再过滤元素属性，最后只要实现visitAttribute。结果发现visitElement也会被调用。实现了返回反而会多执行visit方法。</p>
<ol start="2">
<li>注册规则</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfauriaIssueRegistry</span> <span class="keyword">extends</span> <span class="title">IssueRegistry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Issue&gt; <span class="title">getIssues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">                AfauriaResIdDetector.RES_ID_ISSUE</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><code>Issue</code>:Lint规则<ul>
<li><code>Id</code>: 规则标识，唯一</li>
<li><code>Description</code>: 规则描述</li>
<li><code>Explanation</code>: 规则说明，解决方案</li>
<li><code>Severity</code>: 规则严重程度，由高到低<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFORMATIONAL</li>
<li>IGNORE</li>
</ul>
</li>
<li><code>Priority</code>: 规则优先级，1-10，10最高</li>
<li><code>Category</code>: 规则分类（部分），可自定义<ul>
<li>Lint</li>
<li>Correctness (子分类 Messages):正确性</li>
<li>Security：安全性</li>
<li>Performance:性能</li>
<li>Usability (子分类 Typography, Icons):易用性</li>
<li>A11Y (Accessibility):无障碍</li>
<li>I18N (Internationalization，子分类 Rtl)：国际化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>由于缓存或者其他原因，有时候需要重启Android Studio才能应用自定义lint规则</li>
<li>推荐使用gradle命令执行lint</li>
<li>除了手动运行Lint外，大部分问题在编写代码时Android Studio就会给出提醒</li>
<li>自定义的规则使用Android Studio的Inspect检查不出来，不过在代码编写的时候会有提示，需要将规则放到<code>~/.android/lint/</code>目录下才会生效，建议用gradle命令运行导出Issue</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/u010360371/article/details/50189171">android lint check的学习和自定义以及lint语法</a></li>
<li><a href="https://www.jianshu.com/p/cbd9a643a6b7">使用Lint</a></li>
<li><a href="https://www.jianshu.com/p/a0f28fbef73f">Android Studio 工具：Lint 代码扫描工具（含自定义lint）</a></li>
<li><a href="https://blog.csdn.net/ouyang_peng/article/details/80374867">【我的Android进阶之旅】Android自定义Lint实践</a></li>
<li><a href="http://www.cnblogs.com/oneapm/p/5221072.html">自定义 Lint 规则简介</a></li>
<li><a href="https://www.colabug.com/2109876.html">Android Lint：自定义Lint调试与开发</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓混淆</title>
    <url>/2018/11/24/android-2018-11-24-Android%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ProGuard是一个压缩、优化和混淆Java<a href="https://baike.so.com/doc/6261423-6474843.html">字节码</a>文件的开源工具，它可以删除无用的类、字段、方法和属性。可以删除没用的注释，最大限度地优化字节码文件。它还可以使用<a href="https://baike.so.com/doc/1649095-1743070.html">简短</a>的无意义的名称来重命名已经存在的类、字段、方法和属性。常常用于Android开发用于混淆最终的项目，增加项目被反编译的难度。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>压缩: 移除无效的类、属性、方法等</li>
<li>优化: 优化字节码，并删除未使用的结构</li>
<li>混淆: 将类名、属性名、方法名混淆为难以读懂的字母，比如a,b,c</li>
</ul>
<h2 id="混淆注意事项"><a href="#混淆注意事项" class="headerlink" title="混淆注意事项"></a>混淆注意事项</h2><h3 id="不能混淆"><a href="#不能混淆" class="headerlink" title="不能混淆"></a>不能混淆</h3><ul>
<li>在AndroidManifest中配置的类，比如四大组件</li>
<li>JNI调用的方法</li>
<li>用了反射的类</li>
<li>WebView中JavaScript调用的方法</li>
<li>Layout文件引用到的自定义View</li>
<li>一些引入的第三方库（一般都会有混淆说明的）</li>
<li>Parcelable 的子类和 Creator 静态成员变量不混淆，否则会产生 Android.os.BadParcelableException 异常</li>
<li>使用了枚举要保证枚举不被混淆 </li>
</ul>
<blockquote>
<p>因为混淆之后，类名会变成a,b,c这，通过包名+类名就找不到该类了，会出现ClassNotFoundException异常。</p>
</blockquote>
<h3 id="保留java-bean"><a href="#保留java-bean" class="headerlink" title="保留java bean"></a>保留java bean</h3><p>使用了 Gson 之类的工具要使 JavaBean 类即实体类不被混淆，混淆后属性名改变，变成了没有意思的名称，json转换就会出错</p>
<h3 id="注解不能混淆"><a href="#注解不能混淆" class="headerlink" title="注解不能混淆"></a>注解不能混淆</h3><p>注解在Android平台中使用的越来越多,常用的有ButterKnife和Otto。很多场景下注解被用作在运行时反射确定一些元素的特征.</p>
<p>为了保证注解正常工作,我们不应该对注解进行混淆.Android工程默认的混淆配置已经包含了下面保留注解的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br></pre></td></tr></table></figure>

<h3 id="Crash信息处理"><a href="#Crash信息处理" class="headerlink" title="Crash信息处理"></a>Crash信息处理</h3><p>代码混淆的时候记得加上在混淆文件里面记得加上这句： </p>
<p>keep住源文件以及行号 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepattributes SourceFile,LineNumberTable</span><br></pre></td></tr></table></figure>

<h2 id="ProGuard用法和选项"><a href="#ProGuard用法和选项" class="headerlink" title="ProGuard用法和选项"></a>ProGuard用法和选项</h2><h3 id="保留选项："><a href="#保留选项：" class="headerlink" title="保留选项："></a>保留选项：</h3><p><strong>注意选项的命名规律：-keep* 用于防止目标被移除或者重命名、-keep*names则仅仅用于防止重命名。</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-keep</td>
<td>-keep [,modifier,…] class_spec 作为入口点保留的类、类成员。对于库，所有公共成员都需要保留</td>
</tr>
<tr>
<td>-keepclassmembers</td>
<td>-keepclassmembers [,modifier,…] class_spec  指定要保留的类成员，如果它们所属的类被保留的话</td>
</tr>
<tr>
<td>-keepclasseswithmembers</td>
<td>-keepclasseswithmembers [,modifier,…] class_spec 指定需要保留的类，如果其成员符合条件</td>
</tr>
<tr>
<td>-keepnames class_spec</td>
<td>等价于-keep,allowshrinking class_spec 指定其名称需要保留的类和类成员，如果在压缩阶段这些类没有被删除的话。该选项仅用于混淆阶段</td>
</tr>
<tr>
<td>-keepclassmembernames</td>
<td>-keepclassmembernames class_spec 指定名称要保留的类成员，如果在压缩阶段这些类没有被删除的话。该选项仅用于混淆阶段</td>
</tr>
<tr>
<td>-keepclasseswithmembernames</td>
<td>-keepclasseswithmembernames class_spec 指定要保留的类和类成员，如果所有指定的类成员在经历了压缩阶段还存在</td>
</tr>
<tr>
<td>-printseeds [filename]</td>
<td>打印所有匹配-keep的类和类成员，默认打印到标准输出</td>
</tr>
</tbody></table>
<p>-keep选项支持添加限定符，格式为： -keep,限定符 ，限定符包括：</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>includedescriptorclasses</td>
<td>方法、字段的类型描述符中的任何类，跟随被keep的方法/字段一并保留，通常用于保留Native方法的名字时，防止Native方法参数的名字被修改，以保证和Native库兼容</td>
</tr>
<tr>
<td>allowshrinking</td>
<td>指定是否入口点可以被压缩</td>
</tr>
<tr>
<td>allowoptimization</td>
<td>指定是否入口点可以被优化</td>
</tr>
<tr>
<td>allowobfuscation</td>
<td>指定是否入口点可以被混淆</td>
</tr>
</tbody></table>
<p>压缩选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-dontoptimize</td>
<td>不进行优化。默认情况下优化启用，所有方法都在字节码级别进行优化</td>
</tr>
<tr>
<td>-optimizations opt_filter</td>
<td>在更细粒度上控制进行哪些优化</td>
</tr>
<tr>
<td>-optimizationpasses n</td>
<td>优化的步骤数，默认1步，如果发现没有可优化的，后续步骤自动省略</td>
</tr>
<tr>
<td>-assumenosideeffects class_spec</td>
<td>指定不具有副作用（不改变任何状态信息）的方法规格，如果这些方法的返回值没有被使用，那么这样的调用会清除</td>
</tr>
<tr>
<td>-allowaccessmodification</td>
<td>是否允许放宽类、类成员的访问限定符。这可能有利于优化，例如对getter()进行内联，需要相应字段成为public的</td>
</tr>
<tr>
<td>-mergeinterfacesaggressively</td>
<td>允许接口合并，甚至在实现类没有实现所有接口方法的情况下</td>
</tr>
</tbody></table>
<p>混淆选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-dontobfuscate</td>
<td>是否进行混淆，默认是。除了匹配-keep系列选项的类、类成员的名字将被随机的改为短名。为了方便调试而保留的内部属性，例如源代码名称、变量名、行号，都将被移除</td>
</tr>
<tr>
<td>-printmapping [filename]</td>
<td>打印混淆前后类名、类成员名的对照</td>
</tr>
<tr>
<td>-applymapping filename</td>
<td>指定一个先前生成的混淆名对照表，本次依照该对照继续混淆，不在表中的成员生成新的名字</td>
</tr>
<tr>
<td>-obfuscationdictionary filename</td>
<td>指定存放有效混淆后变量名的文件</td>
</tr>
<tr>
<td>-overloadaggressively</td>
<td>混淆时支持激进的重载，允许多个字段、方法使用重复的名字，只要参数和返回值不同</td>
</tr>
<tr>
<td>-useuniqueclassmembernames</td>
<td>让不同名的类成员具有不同的混淆后的名称，让同名的类成员混淆后的名称依旧相同</td>
</tr>
<tr>
<td>-dontusemixedcaseclassnames</td>
<td>混淆后，不使用混合大小写的类名</td>
</tr>
<tr>
<td>-keeppackagenames [pkg_filter]</td>
<td>指定不混淆的包的过滤器，过滤器支持* **和前导的!</td>
</tr>
<tr>
<td>-flattenpackagehierarchy [pkg_name]</td>
<td>对所有被重命名的包进行重新打包，如果不指定参数值，则打包到根目录</td>
</tr>
<tr>
<td>-repackageclasses [pkg_name]</td>
<td>对所有被重命名的类进行重新打包，如果不指定参数值，则打包到根目录</td>
</tr>
<tr>
<td>-keepattributes [attr_filter]</td>
<td>指定需要保留的所有可选属性，参数值是逗号分隔的，所有JVM或ProGuard支持的属性值。支持使用? * ** !。在处理库的时候，至少应该保留Exceptions, InnerClasses, Signature属性，如果程序依赖于注解，则应该保留</td>
</tr>
<tr>
<td>-keepparameternames</td>
<td>保留方法参数的名称和类型。该选项实质上保留了一个修剪（trim）后的LocalVariableTable、LocalVariableTypeTable这两个调试属性，在处理库时可能使用。注意，方法局部变量的名称依旧会混淆</td>
</tr>
<tr>
<td>-renamesourcefileattribute [string]</td>
<td>设置SourceFile、SourceDir 属性为指定的常量值</td>
</tr>
<tr>
<td>-adaptclassstrings [class_filter]</td>
<td>代表了类名的字符串常量值，是否也被混淆（与目标类的名字保持一致）。如果不指定参数值，所有代表类名的字符串常量都被混淆</td>
</tr>
<tr>
<td>-adaptresourcefilenames [file_filter]</td>
<td>是否重命名资源文件，如果其文件名反映了一个被混淆的类的名字</td>
</tr>
<tr>
<td>-adaptresourcefilecontents [file_filter]</td>
<td>是否修改资源文件中的类名，如果对应的类的名字已经被混淆。ProGuard使用平台默认字符集读取文件，如果需要改变这一行为，需要设置LANG环境变量或者JVM系统属性file.encoding</td>
</tr>
</tbody></table>
<p>预校验选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-dontpreverify</td>
<td>指定不进行字节码预校验，对于Java6+默认开启</td>
</tr>
<tr>
<td>-microedition</td>
<td>只是目标类文件将在JME平台上运行</td>
</tr>
</tbody></table>
<p>一般选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-verbose</td>
<td>在处理时打印冗长的信息</td>
</tr>
<tr>
<td>-dontnote [class_filter]</td>
<td>不打印配置选项中，与正则式匹配的类相关的错误或者疏忽</td>
</tr>
<tr>
<td>-dontwarn [class_filter]</td>
<td>不打印配置选项中，与正则式匹配的类相关的重要错误，例如unresolved references</td>
</tr>
<tr>
<td>-ignorewarnings</td>
<td>忽略所有警告，强制进行处理。这可能很危险</td>
</tr>
<tr>
<td>-printconfiguration [filename]</td>
<td>打印解析后的配置信息到目标文件</td>
</tr>
<tr>
<td>-dump [filename]</td>
<td>打印处理后的类文件的内部结构</td>
</tr>
</tbody></table>
<p>通配符匹配规则</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配单个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配类名中的任何部分，但不包含额外的包名</td>
</tr>
<tr>
<td>**</td>
<td>匹配类名中的任何部分，并且可以包含额外的包名</td>
</tr>
<tr>
<td>%</td>
<td>匹配任何基础类型的类型名</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意类型名 ,包含基础类型/非基础类型</td>
</tr>
<tr>
<td>…</td>
<td>匹配任意数量、任意类型的参数</td>
</tr>
<tr>
<td><init></init></td>
<td>匹配任何构造器</td>
</tr>
<tr>
<td><fields></fields></td>
<td>匹配任何字段名</td>
</tr>
<tr>
<td><methods></methods></td>
<td>匹配任何方法</td>
</tr>
<tr>
<td>*(当用在类内部时)</td>
<td>匹配任何字段和方法</td>
</tr>
<tr>
<td>$</td>
<td>指内部类</td>
</tr>
</tbody></table>
<h2 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则"></a>一些规则</h2><h3 id="两个常用的混淆命令，"><a href="#两个常用的混淆命令，" class="headerlink" title="两个常用的混淆命令，"></a>两个常用的混淆命令，</h3><p>注意一颗星表示只是保持该包下的类名，而子包下的类名还是会被混淆；两颗星表示把本包和所含子包下的类名都保持；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">hadcn</span>.<span class="title">test</span>.** </span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">class</span> <span class="title">cn</span>.<span class="title">hadcn</span>.<span class="title">test</span>.*</span></span><br></pre></td></tr></table></figure>

<p>用以上方法保持类后，你会发现类名虽然未混淆，但里面的具体方法和变量命名还是变了，这时如果既想保持类名，又想保持里面的内容不被混淆，我们就需要以下方法了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">bean</span>.** </span>&#123; *; &#125;</span><br></pre></td></tr></table></figure>

<p>在此基础上，我们也可以使用Java的基本规则来保护特定类不被混淆，比如我们可以用extend，implement等这些Java规则。如下例子就避免所有继承Activity的类被混淆</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保留我们使用的四大组件，自定义的Application等等这些类不被混淆</span></span><br><span class="line"><span class="comment"># 因为这些子类都有可能被外部调用</span></span><br><span class="line">-keep public class * extends android.app.Activity</span><br><span class="line">-keep public class * extends android.app.Appliction</span><br><span class="line">-keep public class * extends android.app.Service</span><br><span class="line">-keep public class * extends android.content.BroadcastReceiver</span><br><span class="line">-keep public class * extends android.content.ContentProvider</span><br><span class="line">-keep public class * extends android.app.backup.BackupAgentHelper</span><br><span class="line">-keep public class * extends android.preference.Preference</span><br><span class="line">-keep public class * extends android.view.View</span><br><span class="line">-keep public class com.android.vending.licensing.ILicensingService</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 混淆后，不使用混合大小写的类名</span></span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定需要保留的所有可选属性</span></span><br><span class="line"><span class="comment"># 更多 参考。https://www.guardsquare.com/en/proguard/manual/attributes</span></span><br><span class="line">-keepattributes Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,LocalVariable*Table,*Annotation*,Synthetic,EnclosingMethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包到根目录</span></span><br><span class="line">-repackageclasses <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许放宽类、类成员的访问限定符。</span></span><br><span class="line">-allowaccessmodification</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印解析后的配置信息到目标文件</span></span><br><span class="line">-printconfiguration proguard_test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化的步骤数</span></span><br><span class="line">-optimizationpasses 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在处理时打印冗长的信息</span></span><br><span class="line">-verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不跳过依赖库中的非public类，4.5+默认值</span></span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不跳过包可见的依赖库类成员（字段、方法）</span></span><br><span class="line">-dontskipnonpubliclibraryclassmembers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留native方法的规格，以便能与native库链接</span></span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># keep setters in Views so that animations can still work</span></span><br><span class="line">-keepclassmembers public class * extends android.view.View &#123;</span><br><span class="line">   void <span class="built_in">set</span>*(***);</span><br><span class="line">   *** get*();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># We want to keep methods in Activity that could be used in the XML attribute onClick</span></span><br><span class="line">-keepclassmembers class * extends android.app.Activity &#123;</span><br><span class="line">   public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations</span></span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    public static **[] values();</span><br><span class="line">    public static ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除输出的日志</span></span><br><span class="line"></span><br><span class="line">-assumenosideeffects class com.tuya.smart.android.common.utils.L &#123;</span><br><span class="line"></span><br><span class="line">public static *** d(...);</span><br><span class="line"></span><br><span class="line">public static *** v(...);</span><br><span class="line"></span><br><span class="line">public static *** i(...);</span><br><span class="line"></span><br><span class="line">public static *** e(...);</span><br><span class="line"></span><br><span class="line">public static *** w(...);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留Parcelable序列化类不被混淆</span></span><br><span class="line">-keepclassmembers class * implements android.os.Parcelable &#123;</span><br><span class="line">  public static final android.os.Parcelable<span class="variable">$Creator</span> CREATOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-keepattributes Exceptions,InnerClasses,...  </span><br><span class="line">-keep class [packagename].A&#123;*;&#125;  </span><br><span class="line">-keep class [packagename].A$* &#123;*;&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 A$* 表示所有A的内部类都保留下来，也可以如下使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-keepattributes Exceptions,InnerClasses,...  </span><br><span class="line">-keep class com.xxx.A&#123; *; &#125;  </span><br><span class="line">-keep class com.xxx.A<span class="variable">$B</span> &#123; *; &#125;  </span><br><span class="line">-keep class com.xxx.A<span class="variable">$C</span> &#123; *; &#125;  </span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-cn">压缩代码和资源</a></li>
<li><a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html">ProGuard</a></li>
<li><a href="https://www.guardsquare.com/en/proguard/manual/usage#classspecification">ProGuard manual</a></li>
<li><a href="https://blog.gmem.cc/proguard-study-note">ProGuard学习笔记</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook使用笔记</title>
    <url>/2018/11/18/note-2018-11-18-MacBook%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="macOS-软件下载"><a href="#macOS-软件下载" class="headerlink" title="macOS 软件下载"></a>macOS 软件下载</h1><ul>
<li><a href="https://www.macbl.com/">马可菠萝</a></li>
<li><a href="https://mac.orsoon.com/">未来 Mac 下载</a></li>
<li><a href="https://www.rjsos.com/mac">玩机手册</a></li>
<li><a href="https://www.waitsun.com/topics/os">麦氪派</a></li>
<li><a href="https://www.inpandora.com/">潘多拉盒子</a></li>
<li><a href="https://macapp.org.cn/">MacApp分享频道</a></li>
</ul>
<h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统架构</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> arch</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看应用架构</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lipo -archs `<span class="built_in">which</span> vim`</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> uname -a</span></span><br></pre></td></tr></table></figure>

<h1 id="brew安装和卸载"><a href="#brew安装和卸载" class="headerlink" title="brew安装和卸载"></a>brew安装和卸载</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> brew安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> brew卸载</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall.sh)</span>&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>从安装脚本可以看出，Intel芯片（x86_64架构）安装在<code>/usr/local/</code>，M1芯片（arm64架构）安装在<code>/opt/homebrew</code></p>
<img src="/2018/11/18/note-2018-11-18-MacBook%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/brew安装脚本.png" style="zoom:50%;">

<p>卸载脚本：如果是M1芯片，会同时卸载新旧路径的brew</p>
<img src="/2018/11/18/note-2018-11-18-MacBook%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/brew卸载脚本2.png" style="zoom:50%;">

<p>M1芯片如果只想卸载旧路径的brew，可以下载<code>uninstall.sh</code>脚本，去掉条件判断，再执行脚本，只卸载<code>/usr/local</code>下的brew。</p>
<img src="/2018/11/18/note-2018-11-18-MacBook%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/brew卸载脚本.png" style="zoom:50%;">

<h1 id="ruby卸载和安装"><a href="#ruby卸载和安装" class="headerlink" title="ruby卸载和安装"></a>ruby卸载和安装</h1><ol>
<li>Mac内置了一个Ruby，位于<code>/usr/bin/ruby</code>，版本较老，不可卸载</li>
<li>通过<code>brew install ruby</code>安装的ruby，位于<code>/opt/homebrew/Cellar/ruby</code></li>
</ol>
<p>默认使用内置的Ruby，如果想使用brew安装的Ruby，需要在<code>.zshrc</code>中配置环境变量</p>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="环境变量不生效"><a href="#环境变量不生效" class="headerlink" title="环境变量不生效"></a>环境变量不生效</h2><p>在<code>~/.bash_profile</code>中配好环境变量后每次重启终端需要执行<code>source ~/.bash_profile</code>才生效</p>
<p>原因：使用zsh插件，加载的是<code>~/.zshrc</code>文件，<code>~/.zshrc</code>中没有定义环境变量</p>
<blockquote>
<p>在<code>~/.zshrc</code>文件后加上<code>source ~/.bash_profile</code></p>
</blockquote>
<h2 id="Mac空间不足，升级系统失败"><a href="#Mac空间不足，升级系统失败" class="headerlink" title="Mac空间不足，升级系统失败"></a>Mac空间不足，升级系统失败</h2><p>Mac电脑空间不足，导致升级系统失败，且无法用U盘升回旧版本。没有用<code>Time Machine</code>备份系统</p>
<p>（搞了半天，差点以为回不来了，公司的IT都说要抹盘了。）</p>
<blockquote>
<ol>
<li>开机按住<code>Option</code>或<code>Command+R</code>进入恢复模式</li>
<li>打开终端（发现可以打开终端，一般来说已经可以为所欲为）</li>
<li>进入磁盘路径：输入<code>cd /Volume/xxx</code>（一般是<code>/Volume/Machine HD-数据/User</code>，如果有空格需要转义）</li>
<li>用<code>rm</code>命令删除不需要的文件，再进行升级</li>
<li>如果需要拷贝重要文件出来<ol>
<li>可以插上U盘，<code>cp 电脑路径 /Volume/U盘名称/路径</code></li>
<li>可以将电脑和另一个电脑连上同一个局域网，用<code>scp</code>命令拷贝文件。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="迁移数据到新电脑"><a href="#迁移数据到新电脑" class="headerlink" title="迁移数据到新电脑"></a>迁移数据到新电脑</h2><h3 id="vim异常"><a href="#vim异常" class="headerlink" title="vim异常"></a>vim异常</h3><p>使用vim提示如下异常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error detected while processing /Users/Afauria/.vim/bundle/tlib_vim/plugin/02tlib.vim:</span><br><span class="line">line   77: E1208: -complete used without allowing argumentsPress ENTER or type command to continue</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原因：旧版本vim问题，在高版本系统上出错</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决方法：更新vim插件</span></span><br><span class="line">cd /Users/Afauria/.vim/bundle/tlib_vim/plugin/</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h3 id="python脚本异常"><a href="#python脚本异常" class="headerlink" title="python脚本异常"></a>python脚本异常</h3><p>使用cd命令进入路径提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env: python: No such file or directory</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原因：新版本系统上内置python3，去掉了python2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决方法：将python链接到python3的路径</span></span><br><span class="line">ln -s /opt/homebrew/bin/python3 /opt/homebrew/bin/python</span><br></pre></td></tr></table></figure>

<h3 id="存储空间显示异常"><a href="#存储空间显示异常" class="headerlink" title="存储空间显示异常"></a>存储空间显示异常</h3><p>迁移数据后【关于本机-&gt;储存空间管理】中【文稿】和【应用程序】不显示内容，但是空间占用是正常的。</p>
<blockquote>
<p>更新了一下系统版本之后自动修复了</p>
</blockquote>
<h3 id="mysql数据库异常"><a href="#mysql数据库异常" class="headerlink" title="mysql数据库异常"></a>mysql数据库异常</h3><p>连接数据库提示<code>ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39;</code></p>
<p>解决：重启mysql服务<code>brew services restart mysql</code></p>
<h3 id="brew架构不正确"><a href="#brew架构不正确" class="headerlink" title="brew架构不正确"></a>brew架构不正确</h3><p>数据从Intel架构迁移到M1架构，使用brew提示：<code>Error: Cannot install in Homebrew on ARM processor in Intel default prefix (/usr/local)!</code></p>
<p>原因：Intel芯片brew位于<code>/usr/local/</code>，M1芯片brew位于<code>/opt/homebrew</code></p>
<p>解决方法：执行<code>echo &#39;eval $(/opt/homebrew/bin/brew shellenv)&#39; &gt;&gt; /Users/Afauria/.zprofile</code>，重新配置环境变量。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker笔记</title>
    <url>/2018/11/04/tool-2018-11-04-Docker/</url>
    <content><![CDATA[<h1 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h1><h2 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h2><p><img src="/2018/11/04/tool-2018-11-04-Docker/docker01.png" alt="docker架构图"></p>
<h2 id="docker概念"><a href="#docker概念" class="headerlink" title="docker概念"></a>docker概念</h2><table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>镜像(Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板。</td>
</tr>
<tr>
<td>容器(Container)</td>
<td>容器是独立运行的一个或一组应用。</td>
</tr>
<tr>
<td>客户端(Client)</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker API 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td>主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td>镜像仓库(Repository)</td>
<td>用来存储具体的镜像，可以理解为代码控制中的代码仓库。通过tag区分版本号</td>
</tr>
<tr>
<td>注册服务器（Registry）</td>
<td>用于管理镜像仓库，起到的是服务器的作用。默认是官方的Docker Hub，可以搭建私有服务器</td>
</tr>
</tbody></table>
<p>镜像资源分为两类：</p>
<ul>
<li>官方提供的，名称不带前缀，如：<code>hello-world</code></li>
<li>docker用户创建并维护的,名称带用户名前缀，如：<code>username/hello-world</code></li>
</ul>
<p>镜像名完整组成：<code>registryhost/username/repository:tag</code>即<code>服务主机/用户名/仓库名:版本号</code></p>
<ul>
<li>registryhost不填，则默认为DockerHub</li>
<li>username不填，则表示docker官方提供的镜像</li>
<li>tag不填，则默认为latest</li>
</ul>
<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.docker.com/get-started">官网</a>下载安装，按提示一步步完成，国内下载速度慢的话可以使用迅雷。</p>
<p><strong>注：windows下默认安装在C盘，镜像多的话可能会导致C盘越来越大，可以修改镜像存储路径，<a href="https://blog.csdn.net/stemq/article/details/53150939">参考博客</a></strong></p>
<ul>
<li>windows上安装的docker其实本质上还是借助与windows平台的hyper-v技术来创建一个linux虚拟机，你执行的所有命令其实都是在这个虚拟机里执行的，所以所有pull到本地的image都会在虚拟机的Virtual hard disks目录的文件中，这个文件就是虚拟硬盘文件。如果要想改变路径只需要在hyper-v管理器里设置就可以了。默认的安装路径是<code>C:\Users\Public\Documents\Hyper-V\Virtual hard disks</code>下。</li>
<li>将默认<code>C:\Users\Public\Documents\Hyper-V\Virtual hard disks\MobyLinuxVM.vhdx</code>的文件拷贝到想要改变的路径</li>
<li>控制面板-&gt;管理工具-&gt;Hyper-V管理器-&gt;右键设置-&gt;硬盘驱动器-&gt;虚拟硬盘输入为想要保存的路径</li>
</ul>
<p><img src="/2018/11/04/tool-2018-11-04-Docker/docker03.png" alt="docker修改镜像路径"></p>
<p><img src="/2018/11/04/tool-2018-11-04-Docker/docker04.png" alt="docker修改镜像路径"></p>
<ul>
<li>我试了一下发现重启之后又恢复成原来的路径，解决如下</li>
</ul>
<p><img src="/2018/11/04/tool-2018-11-04-Docker/docker05.png" alt="docker修改镜像路径"></p>
<p><img src="/2018/11/04/tool-2018-11-04-Docker/docker06.png" alt="docker修改镜像路径"></p>
<h2 id="镜像服务器设置"><a href="#镜像服务器设置" class="headerlink" title="镜像服务器设置"></a>镜像服务器设置</h2><p>Perferences… -&gt; Daemon -&gt; Registry mirrors配置</p>
<p>windows：在setting -&gt; Daemon -&gt; Registry mirrors中配置</p>
<p>镜像地址：</p>
<ul>
<li>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a>  </li>
<li>官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li>
<li>ustc的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li>
<li>daocloud：<a href="https://www.daocloud.io/mirror#accelerator-doc%EF%BC%88%E6%B3%A8%E5%86%8C%E5%90%8E%E4%BD%BF%E7%94%A8%EF%BC%89">https://www.daocloud.io/mirror#accelerator-doc（注册后使用）</a></li>
</ul>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>可视化工具：<a href="https://kitematic.com/">Kitematic</a></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>容器生命周期管理： <code>docker [run|start|stop| restart|kill|rm|pause|unpause]</code></li>
<li>容器操作运维：<code>docker [ps|inspect|top|attach|events|logs|wait|export|port]</code></li>
<li>容器rootfs命令： <code>docker [commit|cp|diff]</code></li>
<li>镜像仓库： <code>docker [login|pull|push|search]</code></li>
<li>本地镜像管理：<code>docker [images|rmi|tag|build|history|save|import]</code></li>
<li>其他命令：<code>docker [info|version]</code></li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>CONTAINER:：可以是容器名也可以是容器id<br>REPOSITORY：仓库名<br>REGISTRYHOST：服务主机地址<br>IMAGE：镜像名<br>TAG：版本号，不填则默认为latest</p>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul>
<li><code>docker</code>：查看docker帮助</li>
<li><code>docker &lt;COMMAND&gt; --help</code>：查看具体命令帮助</li>
<li><code>docker -v</code>，<code>docker --version</code>：查看docker版本</li>
<li><code>docker info</code>：查看docker系统信息</li>
<li><code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]</code>:获取容器/镜像的元数据。<br>常用OPTIONS：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :指定返回值的模板文件。</span><br><span class="line">-s :显示总的文件大小。</span><br><span class="line">--type :为指定类型返回JSON。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><ul>
<li><code>docker login -u 用户名 -p 密码</code>: 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</li>
<li><code>docker logout </code>: 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</li>
<li><code>docker search 镜像名</code>：从Docker Hub查找镜像</li>
<li><code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code>： 从镜像仓库中拉取或者更新指定镜像</li>
<li><code>docker push [OPTIONS] NAME[:TAG]</code>：将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><p><code>docker container ls</code>或<code>docker ps</code>：列出运行的容器，加-a或–all可列出所有容器</p>
<ul>
<li>COMMAND列表示容器启动时执行的命令，加<code>--no-trunc</code>选项显示完整命令</li>
</ul>
</li>
<li><p><code>docker create [OPTIONS]</code> 镜像名：创建新容器，但不启动</p>
</li>
<li><p><code>docker run [OPTIONS] 镜像名</code>：创建新容器并运行<br>会从本地查找镜像，若不存在，则从默认公共镜像源(DockerHub)下载<br>常用OPTIONS： </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-p: 端口映射，格式为：主机(宿主)端口:容器端口  </span><br><span class="line">-d: 后台运行容器，并返回容器ID，不加-d会显示日志</span><br><span class="line">--name：为容器指定名称</span><br><span class="line">······</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>docker start [OPTIONS] CONTAINER [CONTAINER...]</code>：启动一个或多个已经被停止的容器</p>
</li>
<li><p><code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code>：停止一个或多个运行中的容器</p>
</li>
<li><p><code>docker restart [OPTIONS] CONTAINER [CONTAINER...]</code>：重启一个或多个容器</p>
</li>
<li><p><code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code>：杀掉一个或多个运行中的容器</p>
</li>
<li><p><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code>：删除一个或多少容器</p>
</li>
<li><p><code>docker logs [OPTIONS] CONTAINER</code>：获取容器的日志</p>
</li>
<li><p><code>docker top [OPTIONS] CONTAINER [ps OPTIONS]</code>：查看容器中运行的进程信息，支持 ps 命令参数。</p>
</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul>
<li><code>docker images</code>：列出本地镜像</li>
<li><code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]</code>：获取容器/镜像的元数据<br>常用OPTIONS：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :指定返回值的模板文件。</span><br><span class="line">-s :显示总的文件大小。</span><br><span class="line">--type :为指定类型返回JSON。</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><code>docker build [OPTIONS] PATH | URL | -</code>：根据Dockerfile构建镜像<br>常用OPTIONS:：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- -t，--tag : 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br><span class="line">- -f : 指定Dockerfile路径</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code>：从容器创建一个新的镜像</p>
<p>常用OPTIONS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停。</span><br></pre></td></tr></table></figure></li>
<li><p><code>docker tag [OPTIONS] IMAGE[:TAG][REGISTRYHOST/][USERNAME/]NAME[:TAG]</code>：修改镜像的所属仓库</p>
</li>
<li><p><code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code>：删除一个或多个本地镜像</p>
<p>OPTIONS说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :强制删除；</span><br><span class="line">--no-prune :不移除该镜像的过程镜像，默认移除；</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="把镜像上传到Docker-Hub"><a href="#把镜像上传到Docker-Hub" class="headerlink" title="把镜像上传到Docker Hub"></a>把镜像上传到Docker Hub</h1><h2 id="注册docker账号"><a href="#注册docker账号" class="headerlink" title="注册docker账号"></a>注册docker账号</h2><p><a href="(https://hub.docker.com/)">DockerHub</a></p>
<ul>
<li>输入DockerId（即用户名，英文小写和数字），邮箱，密码</li>
<li>邮箱验证</li>
</ul>
<h2 id="在hub上创建仓库"><a href="#在hub上创建仓库" class="headerlink" title="在hub上创建仓库"></a>在hub上创建仓库</h2><p>Create Repository，起名，如hello-world，则路径为username/hello-word</p>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>搜索镜像：<code>docker search hello-world</code></p>
<p>拉取镜像：<code>docker pull hello-world</code></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>创建新容器并运行：<code>docker run --name my-hello-world -d hello-world</code></p>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><p><code>docker ps</code>，<code>docker container ls</code>：可以看到容器id，容器名称等信息。</p>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><h3 id="基于Dockerfile构建新镜像"><a href="#基于Dockerfile构建新镜像" class="headerlink" title="基于Dockerfile构建新镜像"></a>基于Dockerfile构建新镜像</h3><p>待补充//todo</p>
<h3 id="使用commit从容器创建镜像"><a href="#使用commit从容器创建镜像" class="headerlink" title="使用commit从容器创建镜像"></a>使用commit从容器创建镜像</h3><p><code>docker commit -p 容器id/容器名 my-hello-world:v1</code></p>
<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><p>查看本地镜像：<code>docker images</code></p>
<p>可以修改镜像的所属仓库：<br><code>docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</code></p>
<h2 id="登录docker账号"><a href="#登录docker账号" class="headerlink" title="登录docker账号"></a>登录docker账号</h2><p>输入<code>docker login</code>，接着输入用户名和密码<br>或者在docker图形界面登录</p>
<h2 id="本地镜像上传到镜像仓库"><a href="#本地镜像上传到镜像仓库" class="headerlink" title="本地镜像上传到镜像仓库"></a>本地镜像上传到镜像仓库</h2><p><code>docker push username/my-hello-world:v1</code>：上传成功后可以到hub上查看是否创建成功</p>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p>原先在windows上用的终端是Git Bash，在使用docker的jenkins容器时，需要<code>docker exec -it jenkins /bin/bash</code>，进入交互解释器，提示<code>the input device is not a TTY.  If you are using mintty, try prefixing the command with &#39;winpty&#39;</code></p>
<p>这是由于终端和linux不一样，网上有很多解决办法，说的有点多，弄了一会没弄好就没耐心了，正好我觉得Git Bash不太好用了，如复制粘贴快捷键（一点都不快捷，笔记本的键盘可能会好点）是<code>Ctrl+ins</code>和<code>Shift+ins</code>，且命令提示也不是很友好，于是趁此机会换了cmder命令行工具，顺便学习了一下，结果很满意，想看的可以移步<a href="/2018/12/14/tool-2018-12-14-Cmder/">这里</a>。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/wherein/p/6862911.html">Docker 如何把镜像上传到docker hub</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1593010515480468898&wfr=spider&for=pc">Docker新手入门之四：Docker镜像和仓库的基本使用</a></li>
<li><a href="http://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>青年的楷模 学习的榜样——读《习近平的七年知青岁月》【转】</title>
    <url>/2018/11/02/reader-2017-10-01-PartyArticleStudy/</url>
    <content><![CDATA[ <center>
     <font size="5">青年的楷模 学习的榜样——读《习近平的七年知青岁月》</font><br>
     <font size="4">团中央书记处常务书记 贺军科</font>
 </center>

<p>​    2013年五四青年节，习近平总书记在同各界优秀青年代表座谈时，讲了一段极有文采、极富人生哲理的话：“青年朋友们，人的一生只有一次青春。现在，青春是用来奋斗的；将来，青春是用来回忆的……青年时代，选择吃苦也就选择了收获，选择奉献也就选择了高尚。青年时期多经历一点摔打、挫折、考验，有利于走好一生的路。要历练宠辱不惊的心理素质，坚定百折不挠的进取意志，保持乐观向上的精神状态，变挫折为动力，用从挫折中吸取的教训启迪人生，使人生获得升华和超越。”</p>
<p>​    当时，我听到这段话，第一反应就是青年喜欢听、听得进，肯定会“火”。果不其然，总书记的讲话一经全文公开发表，这段话就在青年中引起强烈共鸣，激励着无数青年发出了“奋斗的青春最美丽”的铮铮誓言。现在，读了《习近平的七年知青岁月》（以下简称《岁月》），了解了总书记青年时期的点点滴滴，我们再来回味和咀嚼这段话，更有一种跨越历史、直击人心的触动与震撼，更能体会到总书记在讲这一番话时的语重心长、殷殷嘱托。我理解，总书记这段话是说给广大青年听的，同时每一个字又是对自己知青岁月的深沉感悟。在那段日子里，青年习近平在艰难困苦中经历摔打、挫折、考验，做到了宠辱不惊、百折不挠、乐观向上，真正实现了人生的升华和超越。透过七年知青岁月，我们更加深刻地感受到了总书记“五四”寄语背后那股震撼人心的力量，这就是“知行合一”所带来的极其强大的心灵感染力、理论说服力、实践穿透力。这种震撼，吸引着我、同样也吸引着广大青年走进总书记的七年知青岁月，感悟总书记的青春奋斗故事给我们带来的深刻启示。《岁月》一经出版发行，就在广大团干部和团员青年中自发形成了读《岁月》、话理想、谈奋斗的浓厚氛围，形成了向青年习近平学习、向习近平总书记看齐的高度自觉。这是人民群众的呼声，这是人民领袖的魅力。</p>
<p>　　一、习近平总书记的七年知青岁月是青年一代励志成才的生动教材</p>
<p>　　习近平总书记寄语青年：“人生的扣子从一开始就要扣好。”总书记的七年知青岁月就是对这句话的最好注脚。对于每一个人来讲，扣人生第一粒扣子时的外部环境是很不一样的。有人可以在亲人的帮助下扣，有人可以在阳光下、灯光下扣，而总书记当初是在黑暗中摸索，在“苦其心志、劳其筋骨、饿其体肤”的环境下，艰难而又准确地扣好这人生第一粒扣子的。惟其艰难，更显伟大，更能够给当代青年以丰富的教益与启迪。</p>
<p>　　青年一代向总书记学习，就是要坚定听党话、跟党走的理想信念。习近平总书记指出，广大团员青年坚定跟党走，就是初心。不忘这个初心，是我国广大青年的政治选择，也是我国广大青年的人生航向。总书记曾经说过：“人生的道路要靠自己来选择。如何选择一条正确的道路，关键是要有坚定的理想信念。否则，环境再好照样会走错路。”总书记青年时期先后写了8份入团申请书、10份入党申请书，即便是在个人处境极为艰难的条件下，始终没有对党产生过怀疑和动摇。这就为我们生动诠释了什么叫矢志不渝、什么叫理想坚定，为广大青年树立了坚守初心不动摇的学习楷模。党的十八大以来，习近平总书记反复强调理想信念是精神之钙；在谈到青年成长道路问题时，每次必讲理想，而且都是第一位的要求。广大青年要把总书记的要求和他青年时代的实践结合起来学习，把理想信念建立在对科学理论的理性认同上，建立在对历史规律的正确认识上，建立在对基本国情的准确把握上，真正牢固树立为实现中华民族伟大复兴中国梦而奋斗的远大理想，坚定跟党走中国特色社会主义道路的坚定信念。</p>
<p>　　青年一代向总书记学习，就是要永葆肯吃苦、不怕苦的奋斗精神。在七年知青岁月里，别人做事从“零”开始，青年习近平却要从“负数”开始，深深体味了最苦、最难的生活，并在苦难中完成了人生的一次升华。从“扁担把他的肩膀磨得一层一层掉皮、出血”到“肩膀上磨出了厚厚的茧子，就不怕扁担磨了”；从“躺在跳蚤堆里睡觉，一咬一挠，浑身发肿”到“对跳蚤的毒素产生抵抗力”；从一开始劳动“连婆姨都不如的每天五六个工分”到两年后“拿到壮劳力的10个工分，成了种地的好把式”。不管多累多苦，青年习近平总是一直拼命干，从来不“撒尖儿”，一步一步地过了跳蚤关、饮食关、劳动关、思想关这“四关”。每过一关都是一份磨砺，都有一份收获，不断积蓄着人生升华与超越的能量。这种苦难的磨砺，既是物质上、身体上的，更是精神上、心灵上的。总书记从不谙世事的“知青”到自称“是个普通农民”“是黄土地的儿子”，体现的是思想深处对农村和农民感情的深刻变化，证明已经完全融入了人民群众之中、深深扎根在中国的大地之中。“青年时代，选择吃苦也就选择了收获。”不同年代，吃苦的含义是不一样的。当代青年不会再有当初大规模上山下乡的那种历练，也很少会有吃不饱肚子的担忧，但是同样会碰到“苦”的环境、尝到“苦”的滋味。作为生活在新时期的青年一代，没有任何理由怨天尤人，必须像青年习近平那样，敢于吃苦、乐于吃苦、善于吃苦、不忘吃苦，在奋斗中创造属于自己的无悔青春。</p>
<p>　　青年一代向总书记学习，就是要养成爱读书、善读书的生活方式。酷爱读书，是《岁月》中几乎每一位受访者都谈到的对习近平总书记的深刻印象。青年习近平到陕北插队，只带了两个行李箱，里面装的全是书；“白天劳动、晚上看书”成为总书记知青岁月的生活常态，而且一直坚持，广泛涉猎了历史、政治、哲学、文学、外交、传统文化等领域的大量书籍，留下了“30里借书、30里讨书”的生动故事，用梁家河老乡的话说，“近平读书有‘书瘾’”，已经到了痴迷的程度。在当时那么差的学习条件下、不怕考试得零分的社会氛围中，青年习近平从来没有放弃读书和思考，这是难能可贵的。他不仅爱读书，而且善读书，“经常是几本书同时看，有所对比，有所分析”，“既知其然，又知其所以然”；注重从实践中求真知，指出“我们读了很多书，但书里有很多水分，只有和群众结合，才能把水分蒸发掉，得到真正的知识”。在总书记青年时代，书很少，很多时候是有什么书就读什么书；现在，书多了，想读什么书就有什么书，但我们的读书学习越来越快餐式、碎片化、浅层次。针对这一问题，总书记在多次讲话中强调，青年抓学习要“下一番心无旁骛、静谧自怡的功夫”，“特别是要克服浮躁之气，静下来多读经典，多知其所以然”，“努力做到又博又专、愈博愈专”。这些要求很有现实针对性，广大青年应当结合青年习近平读书学习的事例，养成爱读书、善读书的生活方式，真正在向书本学习、向实践学习中打牢自身成长的根基。</p>
<p>　　二、习近平总书记的七年知青岁月是年轻干部健康成长的看齐标杆</p>
<p>　　习近平总书记多次用“墩墩苗”来比喻年轻干部的成长，深刻指出：“干部多‘墩墩苗’没有什么坏处，把基础搞扎实了，后面的路才能走得更稳更远。”在七年知青岁月里，青年习近平担任过驻队社教干部、梁家河村党支部书记，在最基层、第一线为老百姓做一件件实事，赢得了群众的口碑，成为“大家都拥护”的村支书。总书记用躬身实践告诉新时期的年轻干部“为什么当干部、怎么当好干部”，为大家树起了看齐的标杆。</p>
<p>　　年轻干部向总书记看齐，就是要一心为民。《岁月》一书给我留下的一个深刻印象就是，习近平总书记“在走上社会之初就与最底层的中国农民同甘苦共患难，由此培养了他一生都割舍不断的深厚感情——从心底里热爱人民，把老百姓搁在心里”。对乞食老汉“解衣推食”、帮助老汉拉车、帮群众找猪、为救治受伤村民而急坏了……这些都是青年习近平为民情怀的自然流露。梁家河的村民们讲，总书记那时候“主要想的就不是自己的前途，而是怎么能做好村里的工作，怎么能让群众的生活好起来”。从政是一条充满不确定性的路，对待这种不确定性，总书记的选择是：“干得好，将来成就一番大事业，干得不好，就在下面给老百姓做些实事，也没什么”，“因为不管从政道路的前景如何，在基层为群众做实事的权利总是不会被剥夺的”。总书记用“在任何岗位上都能为群众做实事”来看淡不确定性，与某些干部用拉帮结派、投机钻营来抵消不确定性，是两种选择、两种境界，泾渭分明、高下立见，老百姓心中自有一杆秤。现在，习近平总书记反复强调“以人民为中心的发展思想”，从总书记的七年知青岁月中我们更深刻地读懂了它的根基与源头。新时期的年轻干部必须始终牢记全心全意为人民服务的宗旨，把人民放在心中最高的位置，坚定不移践行党的群众路线，始终与人民心心相印、与人民同甘共苦、与人民团结奋斗。</p>
<p>　　年轻干部向总书记看齐，就是要勤勉务实。梁家河的村民讲，“近平不搞形式主义，不搞那个年代时兴的学习、运动，而是立志办大事，要给群众做实实在在的事情。”村里缺地缺粮食，他就带领大家打淤地坝；村里缺水，他就带领大家挖深水井；为了方便村民缝补衣服、磨面磨粉、购买日用品和农具，他给村里办起了缝纫社、代销店、铁业社、磨坊。“只要是村民需要的，只要是他能想到的，他都去办，而且都办得轰轰烈烈。”青年习近平的务实还体现在村民都爱听他讲话。村民们都说，“近平开会和其他干部不一样，其他干部开会，讲话的时候老百姓在下边抽旱烟的、说闲话的、纳鞋底的，基本上没有人听。唯独习近平开会，讲话的时候大家都静悄悄地听”，“能把人听憨了！”原因就在于青年习近平“不说空话，不说大话”，讲得“特别实在”，说的都是老百姓想说的心里话。新时期的年轻干部要牢记总书记“空谈误国、实干兴邦”的教诲，一切从实际出发，真正选择人民群众急需的事情去干，选择打基础、利长远的事情去干，特别是要把那些已经决定了的好事实事，快干、干成、干好，真正让人民群众有实实在在的获得感。</p>
<p>　　年轻干部向总书记看齐，就是要敢于担当。“敢说、敢做、敢担当”，这是梁家河的乡亲们对青年习近平担任村党支部书记时领导风格的一致评价。当年，总书记做事“有决心、有毅力，轻易不说出口，只要说出口的话，只要认定了的事，他就坚持到底”。打坝、办沼气、办代销店、办铁业社，等等，没有哪件事情是半途而废的，无论遇到什么困难，他都能想办法克服。特别是在当时的政治和经济环境下，搞副业是有风险的，很容易被扣帽子。但是，只要群众需要、对集体有利，总书记就会在严谨把握政策的基础上，带领大家坚决地干。这就是一种担当。党的十八大以来，总书记带领全党直面问题和弊端，坚定不移推进全面从严治党，抓铁有痕、踏石留印，以钉钉子精神逐步深化，实现了党风、政风、社会风气的明显好转。这背后所体现的顽强意志品质和强烈责任担当，与总书记七年知青岁月中的奋斗是一脉相承的。当前，我们正处于全面决胜小康的关键时期，处于改革攻坚期、社会转型期、矛盾凸显期，更需要党员干部敢于担当。年轻干部必须牢记总书记提出的20字好干部标准，真正把责任扛在肩上，敢于较真、敢于碰硬、敢于直面矛盾，争当迎难而上、攻坚克难的勇士。</p>
<p>　　三、习近平总书记的七年知青岁月在当代青年内心赢得了强大真挚的情感认同</p>
<p>　　当今世界正处于百年不遇的大变局之中，我们比历史上任何时期都更接近实现中华民族伟大复兴的目标。越是这个关键历史时期，我们越需要一个坚强的领导核心。党的十八大以来，习近平总书记以马克思主义政治家的雄才大略、远见卓识、坚定信念，在进行具有许多新的历史特点的伟大斗争中运筹帷幄、勇于担当、率先垂范，赢得了包括广大青年在内的全党全军全国各族人民的衷心爱戴，在党的十八届六中全会上正式明确为党中央的核心、全党的核心。这是党之幸、国家之幸、民族之幸，是具有重大现实意义和深远历史意义的政治成果，我们必须备加珍惜、坚决捍卫。</p>
<p>　　对核心的绝对忠诚和坚定追随，最根本的在于发自内心的崇敬与爱戴，最深沉、最持久的源泉是心灵上的情感认同。1949年5月7日，周恩来同志在中华全国青年第一次代表大会上作报告，发出了“学习毛泽东”的号召，指出：“决不要把毛泽东看成一个偶然的、天生的、神秘的、无法学习的领袖……我们的领袖是从人民当中生长出来的，是跟中国人民血肉相联的，是跟中国的大地、中国的社会密切相关的。”现在，我们同样需要更加全面、更加深入、更加生动地理解和认识我们的领袖，“不仅看到他们在台上作大报告的样子，也知道一点儿他们的酸甜苦辣和内心世界”。《岁月》一书正是为人民群众特别是青年一代提供了这样一个难得的窗口。</p>
<p>　　习近平总书记是从人民当中生长出来的。在梁家河的七年时间里，总书记窑洞里的知青越来越少，但是来这里拉话、讨论事情、听说书的老乡越来越多。这是一幅没有刻意导演、但却十分具有象征意义的画面，定格了总书记密切联系群众、深深扎根群众的生动景象。</p>
<p>　　习近平总书记是跟中国人民血肉相联的。青年习近平离开梁家河时，村民们送了一程又一程，难舍难分。40年后，总书记再次来到梁家河，对乡亲们讲：“当年，我人走了，但我把心留在了这里。”简简单单的话语背后，饱含着与人民的深厚感情。</p>
<p>　　习近平总书记是跟中国的大地、中国的社会密切相关的。总书记曾经说过：“15岁来到黄土地时，我迷惘、彷徨；22岁离开黄土地时，我已经有着坚定的人生目标，充满自信。”在梁家河的7年岁月，总书记读懂了“生活”这部大书，读懂了“中国农村”这部大书，也读懂了“实际”这部大书。这是总书记与黄土地的不解之缘，从中国的大地、中国的社会中汲取到无穷的智慧和力量。</p>
<p>　　最近，我经常和各级团干部和各领域团员青年聊起读《岁月》一书的感受和体会。不少青年朋友讲：“五年来，习近平总书记带领党和国家干了许多得民心、顺民意的大事难事，我们感到总书记的形象在心目中越来越高大，由衷地信服和拥护总书记的核心地位；最近读了《习近平的七年知青岁月》，又感到总书记和我们离得越来越近、贴得越来越紧，发自内心地爱戴这样的人民领袖。”看完《岁月》一书，我们都能强烈地感受到，书中讲述的习近平总书记的每一个青春奋斗故事都很实在，都是普通人经过努力能够做到的，但是这么多故事背后的闪光点集中到一个人身上，就诞生了“伟大”。正是因为这种普通群众都能理解和认知的“伟大”，包括广大青年在内的人民群众才发自内心地感到习近平总书记既可敬、又可亲，既高大、又贴近，具有强烈的人格魅力。</p>
<p>　　理解这份“伟大”，还需要我们置身当时的历史条件和时代环境去体悟。当我们只是作为一个旁观者，回望过去时，历史已经定格，呈现出一种确定性；但是，在真实的历史正在行进时，充满了未知、充满了不确定性。我们现在回头看，习近平总书记在梁家河一待就是七年，很不容易；但更不容易的是，总书记当初在梁家河，不知道自己要待多久，很多时候看不到未来、也设计不了自己的未来。在那种情况下，总书记仍然坚守初心、坚持学习、坚持奋斗、坚持工作，支撑这份宝贵的坚守与坚持的，就是信仰的力量、为民的情怀、务实的作风、担当的精神。现在，我们进行伟大斗争、建设伟大工程、推进伟大事业、实现伟大梦想，正需要有这样一股力量、这样一份情怀、这样一种作风、这样一身担当的领袖来掌舵领航。</p>
<p>　　“每一代青年都有自己的际遇和机缘，都要在自己所处的时代条件下谋划人生、创造历史。”时代在变、环境在变，不变的是榜样的力量。习近平总书记七年知青岁月对青年一代成长成才的启示，具有跨越时空的永恒价值。当代青年要向习近平总书记学习，始终坚守初心、坚定理想，始终与人民相结合、和群众在一起，多一些摔打磨练、多几分淡定从容，不在坐享其成中虚度青春，要在不懈奋斗中创造未来，勇做走在时代前列的奋进者、开拓者、奉献者，努力在实现中国梦的生动实践中放飞青春梦想。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>名词和缩写解释笔记</title>
    <url>/2018/10/24/note-2018-10-24-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>网络用语可使用在线工具查询：<a href="https://lab.magiconch.com/nbnhhsh/?from=home">能不能好好说话</a></p>
<h1 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>cli</td>
<td>command-line interface</td>
<td>命令行界面</td>
<td>相对应的是GUI（图形界面接口）</td>
</tr>
<tr>
<td>CR</td>
<td>Carriage Return</td>
<td>回车</td>
<td>对应ASCII中转义字符\r</td>
</tr>
<tr>
<td>LF</td>
<td>Linefeed</td>
<td>换行</td>
<td>对应ASCII中转义字符\n</td>
</tr>
<tr>
<td>apt</td>
<td>Advanced Packaging Tool</td>
<td></td>
<td>Linux下的一款安装包管理工具</td>
</tr>
</tbody></table>
<h2 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2><p>位（bit）是计算机存储的最小单位，字节是计算机处理数据的最小单位，1字节=8位</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>bit</td>
<td></td>
<td>位</td>
<td>存放一位二进制数，即 0 或 1，最小的存储单位</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
<td>字节</td>
<td>1B=8bit</td>
</tr>
<tr>
<td>KB</td>
<td>Kilobyte</td>
<td>千字节</td>
<td>1KB=1024B</td>
</tr>
<tr>
<td>MB</td>
<td>Megabyte</td>
<td>兆字节</td>
<td>1MB=1024KB</td>
</tr>
<tr>
<td>GB</td>
<td>Gigabyte</td>
<td>吉字节</td>
<td>1GB=1024MB</td>
</tr>
<tr>
<td>TB</td>
<td>Trillionbyte</td>
<td>太字节</td>
<td>1TB=1024GB</td>
</tr>
<tr>
<td>PB</td>
<td>Petabyte</td>
<td>拍字节</td>
<td>1PB=1024GB</td>
</tr>
<tr>
<td>EB</td>
<td>Exabyte</td>
<td>艾字节</td>
<td>1EB=1024PB</td>
</tr>
<tr>
<td>ZB</td>
<td>Zettabyte</td>
<td>泽字节</td>
<td>1ZB=1024EB</td>
</tr>
<tr>
<td>YB</td>
<td>Yottabyte</td>
<td>尧字节</td>
<td>1YB=1024ZB</td>
</tr>
<tr>
<td>BB</td>
<td>Brontobyte</td>
<td>珀字节</td>
<td>1BB=1024YB</td>
</tr>
<tr>
<td>NB</td>
<td>NonaByte</td>
<td>诺字节</td>
<td>1NB=1024BB</td>
</tr>
<tr>
<td>DB</td>
<td>DoggaByte</td>
<td>刀字节</td>
<td>1DB=1024NB,计算机中最大的储存单位</td>
</tr>
</tbody></table>
<h2 id="吉利数字"><a href="#吉利数字" class="headerlink" title="吉利数字"></a>吉利数字</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>65536</td>
<td>2的16次方</td>
</tr>
<tr>
<td>65535</td>
<td>2的16次方-1:理论上计算机能达到的最大进程数</td>
</tr>
</tbody></table>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>TLS</td>
<td>Transport Layer Security</td>
<td>传输层安全</td>
<td></td>
</tr>
<tr>
<td>SSL</td>
<td>Secure Sockets Layer</td>
<td>安全套接层</td>
<td>tls的前身，最初由netscape开发，被IETF标准化并改名为tls</td>
</tr>
<tr>
<td>CA</td>
<td>Certificate Authority</td>
<td></td>
<td>证书颁发机构</td>
</tr>
<tr>
<td>CSR</td>
<td>Cerificate Signing Request</td>
<td></td>
<td>证书请求文件</td>
</tr>
<tr>
<td>crt</td>
<td>Certificate</td>
<td>证书文件</td>
<td>客户端认证的证书</td>
</tr>
<tr>
<td>ssid</td>
<td>Service Set Identifier</td>
<td>服务集标识</td>
<td>用来区分不同的网络。SSID就是一个局域网的名称,无线网络中SSID，是路由器发送的无线信号的名字SSID技术可以将一个无线局域网分为几个需要不同身份验证的子网络，每一个子网络都需要独立的身份验证，只有通过身份验证的用户才可以进入相应的子网络，防止未被授权的用户进入本网络。</td>
</tr>
<tr>
<td>DNS</td>
<td>Domain Name System</td>
<td>域名系统</td>
<td>特网上作为域名和<a href="https://baike.so.com/doc/4252723-4455111.html">IP地址</a>相互映射的一个<a href="https://baike.so.com/doc/6591740-6805519.html">分布式数据库</a>，能够使用户更方便的访问<a href="https://baike.so.com/doc/2011565-2128705.html">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a href="https://baike.so.com/doc/5331327-5566564.html">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析(或主机名解析)。DNS协议运行在<a href="https://baike.so.com/doc/5418284-5656447.html">UDP</a>协议之上，使用端口号53。通常 Internet 主机域名的一般结构为:主机名.三级域名.二级域名.顶级域名。</td>
</tr>
</tbody></table>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>VNC</td>
<td>Virtual Network Console</td>
<td>虚拟网络控制台</td>
<td></td>
</tr>
<tr>
<td>ELK</td>
<td>Elasticsearch+Logstash+Kibana</td>
<td>三个软件的缩写</td>
<td>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</td>
</tr>
</tbody></table>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>Transmission Control Protocol</td>
<td>传输控制协议</td>
<td>传输层协议，有连接，可靠，三次握手建立连接，四次挥手断开连接</td>
</tr>
<tr>
<td>UDP</td>
<td>User Datagram Protocol</td>
<td>用户数据报协议</td>
<td>传输层协议，无连接，不可靠</td>
</tr>
<tr>
<td>http</td>
<td>Hyper Text Transport Protocol</td>
<td>超文本传输协议</td>
<td></td>
</tr>
<tr>
<td>https</td>
<td></td>
<td>http+ssl</td>
<td></td>
</tr>
<tr>
<td>POP3</td>
<td>Post Office Protocol 3</td>
<td>邮局协议的第3个版本</td>
<td>规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。</td>
</tr>
<tr>
<td>SMTP</td>
<td>Simple Mail Transfer Protocol</td>
<td>简单邮件传输协议</td>
<td>控制邮件的中转方式，属于TCP/IP协议</td>
</tr>
<tr>
<td>IMAP</td>
<td>Internet Mail Access Protocol</td>
<td>交互式邮件存取协议</td>
<td>邮件访问标准协议之一，与POP的不同：开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。</td>
</tr>
<tr>
<td>RTP</td>
<td>Real-time Transport Protocol</td>
<td>实时传输协议</td>
<td>RTP数据协议</td>
</tr>
<tr>
<td>RTCP</td>
<td>Real-time Transport Control Protocol</td>
<td>实时传输控制协议</td>
<td>RTP控制协议，控制RTP传输</td>
</tr>
<tr>
<td>RTSP</td>
<td>Real Time Streaming Protocol，</td>
<td>实时流协议</td>
<td>可以发送暂停，播放，停止等请求</td>
</tr>
</tbody></table>
<h2 id="OJ术语"><a href="#OJ术语" class="headerlink" title="OJ术语"></a>OJ术语</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
</tr>
</thead>
<tbody><tr>
<td>OJ</td>
<td>Online Judge</td>
<td>在线判题系统</td>
</tr>
<tr>
<td>AC</td>
<td>Accepted</td>
<td>通过</td>
</tr>
<tr>
<td>WA</td>
<td>Wrong Answer</td>
<td>答案错误</td>
</tr>
<tr>
<td>TLE</td>
<td>Time Limit Exceed</td>
<td>超时</td>
</tr>
<tr>
<td>OLE</td>
<td>Output Limit Exceed</td>
<td>超过输出限制</td>
</tr>
<tr>
<td>MLE</td>
<td>Memory Limit Exceed</td>
<td>超内存</td>
</tr>
<tr>
<td>RE</td>
<td>Runtime Error</td>
<td>运行时错误</td>
</tr>
<tr>
<td>PE</td>
<td>Presentation Error</td>
<td>格式错误</td>
</tr>
<tr>
<td>CE</td>
<td>Compile Error</td>
<td>无法编译</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>IETF：国际互联网工程任务组（The Internet Engineering Task Force，简称 IETF）是一个公开性质的大型民间国际团体，汇集了与互联网架构和互联网顺利运作相关的网络设计者、运营者、投资人和研究人员，并欢迎所有对此行业感兴趣的人士参与。</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ECS</td>
<td>Elastic Compute Service</td>
<td>云服务器</td>
<td></td>
</tr>
<tr>
<td>MUA</td>
<td></td>
<td>邮件用户代理</td>
<td>它是一种应用程序，或者电子邮件客户端程序。通过 MUA 程序，我们可以发送邮件，也可以把接收到的邮件保存在客户端的邮箱中。这两种操作属于不同的两个进程。MUA通过POP（邮局协议）和STMP（简单邮件传输协议）从电子邮件服务器发送或接收消息。</td>
</tr>
<tr>
<td>MTA</td>
<td></td>
<td>邮件传送代理</td>
<td>是电子邮件服务器的两个独立进程，MUA向电子邮件服务器发送一个电子邮件，MTA会判断这个邮件的地址是否在本服务器上。如果是则通过MDA发送到目的邮箱MUA.如果不是MTA就把这个邮件传送到包含目的邮箱列表的电子邮件服务器。</td>
</tr>
<tr>
<td>MDA</td>
<td></td>
<td>邮件分发代理</td>
<td></td>
</tr>
<tr>
<td>dsl</td>
<td>Domain Specified Language</td>
<td>领域特定语言</td>
<td></td>
</tr>
<tr>
<td>Stub</td>
<td></td>
<td>桩</td>
<td>在某个地方插入一个Stub，用于占位，Stub中一般没有实际内容，运行时会替换成真正的对象。如ViewStub</td>
</tr>
<tr>
<td>Hook</td>
<td></td>
<td>钩子</td>
<td>对某个方法、流程进行拦截、处理。如Git Hook、生命周期Hook等</td>
</tr>
<tr>
<td>Fake</td>
<td></td>
<td>伪造</td>
<td>开发或测试的时候模拟数据源、模拟行为</td>
</tr>
<tr>
<td>Mock</td>
<td></td>
<td>模拟</td>
<td>单元测试模拟数据，如方法返回值、变量等</td>
</tr>
<tr>
<td>Foo</td>
<td></td>
<td></td>
<td>无实际意义，不知道给函数或变量起什么名字的时候可以叫foo。也被解释做Fuck Oriented Object、Fu的变体（fuck-up）</td>
</tr>
<tr>
<td>DRY</td>
<td>Don’t Repeat Yourself</td>
<td>干原则</td>
<td>指在程序设计以及计算中避免重复代码，将公共部分提取、抽象。</td>
</tr>
<tr>
<td>PayLoad</td>
<td></td>
<td>有效载荷、负载</td>
<td>对接收者有用的数据，接口返回的有用字段，信头和元数据等称为开销数据。<br>例如委托卡车运东西，货物的重量，车子重量，司机重量都属于载重，对于客户来说，只关心货物重量，因此货物重量是有效载重。</td>
</tr>
</tbody></table>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><h2 id="岗位"><a href="#岗位" class="headerlink" title="岗位"></a>岗位</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>Operator</td>
<td>运维、管理员</td>
<td>维护公司的服务器能够正常提供服务，细分的话包括系统部分，网络部分，应用程序部分，数据库部分等。现在市面上主要的OP有三种：网络游戏运维，网站运维，大型项目测试和生产环境运维。</td>
</tr>
<tr>
<td>PM</td>
<td>Product Manager</td>
<td>产品经理</td>
<td>负责市场调查并根据用户的需求，确定开发何种产品，选择何种技术、商业模式等，举凡产品从创意到上市，所有相关的研发、调研、生产、编预算、广告、促销活动等等，都由产品经理掌控</td>
</tr>
<tr>
<td>PJM</td>
<td>Project Manager</td>
<td>项目经理</td>
<td>对项目实行质量、安全、进度、成本管理的责任保证体系和全面提高项目管理水平设立的重要管理岗位。项目经理是为项目的成功策划和执行负总责的人。</td>
</tr>
<tr>
<td>RD</td>
<td>Research and Development Engineer</td>
<td>研发工程师</td>
<td></td>
</tr>
<tr>
<td>FE</td>
<td>Front-End Engineer、Front-End Development</td>
<td>前端工程师，前端开发</td>
<td></td>
</tr>
<tr>
<td>QA</td>
<td>Quality Assurance</td>
<td>质量保证</td>
<td>细分包括PQA（产品）、SQA（供应商 or 软件）、DQA（开发 or 设计）、TQA（全面 or 测试）。有时也指测试</td>
</tr>
<tr>
<td>QC</td>
<td>Quality Control</td>
<td>质量控制</td>
<td></td>
</tr>
<tr>
<td>QE</td>
<td>Quality Engineer</td>
<td>质量工程师</td>
<td></td>
</tr>
<tr>
<td>UED</td>
<td>User Experience Design</td>
<td>用户体验设计</td>
<td></td>
</tr>
<tr>
<td>UI设计</td>
<td>User Interface Design</td>
<td>用户界面设计</td>
<td>对软件的人机交互、操作逻辑、界面美观的整体设计</td>
</tr>
<tr>
<td>KA</td>
<td>Key Account</td>
<td>重要客户</td>
<td></td>
</tr>
<tr>
<td>OEM</td>
<td>Original Equipment Manufacturer</td>
<td>原始设备制造商</td>
<td>OEM生产：定点生产（代工），即委托他人生产</td>
</tr>
<tr>
<td>ODM</td>
<td>Original Design Manufacturer</td>
<td>原始设计商</td>
<td></td>
</tr>
<tr>
<td>BSP</td>
<td>Board Support Package</td>
<td>板级支持包</td>
<td>boot和驱动程序，指驱动开发人员</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>KBI</td>
<td>Key Behavior Index</td>
<td>关键行为指标</td>
<td>考察各部门及各级员工在一定时间、一定空间和一定职责范围内关键工作行为履行状况的量化指标，是对各部门和各级员工工作行为管理的集中体现。</td>
</tr>
<tr>
<td>KPI</td>
<td>Key Performance Indicators</td>
<td>关键绩效指标</td>
<td>又称主要绩效指标、重要绩效指标、绩效评核指标等，是指衡量一个管理工作成效最重要的指标，是一项数据化管理的工具，必须是客观、可衡量的绩效指标。这个名词往往用于财政、一般行政事务的衡量。是将公司、员工、事务在某时期表现量化与质化的一种指标。可协助将优化组织表现，并规划愿景。</td>
</tr>
<tr>
<td>OKR</td>
<td>Objectives and Key Result</td>
<td>目标与关键成果法</td>
<td>跟踪目标和完成情况的管理工具和方法</td>
</tr>
<tr>
<td>OAR</td>
<td>Objectives Action Review</td>
<td>目标行为回顾</td>
<td></td>
</tr>
<tr>
<td>gdpr</td>
<td>General Data Protection Regulation</td>
<td>通用数据保护条例</td>
<td></td>
</tr>
<tr>
<td>QCC</td>
<td>Quality Control Circle</td>
<td>品控圈</td>
<td></td>
</tr>
<tr>
<td>PDCA</td>
<td>Plan、Do、Check、Action</td>
<td></td>
<td>一种质量管理方法：选定课题-把握现状-制定目标-分析原因-制定对策-按对策实施-检查效果-巩固措施-总结改进</td>
</tr>
<tr>
<td>SOP</td>
<td>Standard Operation Procedure</td>
<td>标准作业程序</td>
<td></td>
</tr>
<tr>
<td>NRE</td>
<td>Non-Recurring Engineering</td>
<td>非循环工程</td>
<td>NRE费用即一次性工程费用</td>
</tr>
<tr>
<td>MP</td>
<td>Mass Product</td>
<td>量产阶段</td>
<td></td>
</tr>
<tr>
<td>WS</td>
<td>Working Sample</td>
<td>试验样品</td>
<td></td>
</tr>
<tr>
<td>ES</td>
<td>Engineering Sample</td>
<td>工程样品</td>
<td></td>
</tr>
<tr>
<td>CS</td>
<td>Commercial Sample</td>
<td>商业货样</td>
<td></td>
</tr>
</tbody></table>
<p>质量七工具</p>
<ul>
<li>控制图：目标-实际</li>
<li>柏拉图：缺陷数量-比例</li>
<li>流程图：发现流程缺陷</li>
<li>因果图(鱼骨图)：人机料法环测</li>
<li>检查表：</li>
<li>直方图：</li>
<li>散布图：用于表征两个变量之间是否有相关性</li>
</ul>
<h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>LGTM</td>
<td>Look good to me</td>
<td>我觉得可以</td>
<td>别人征求意见时觉得没问题，代码审核没有意见。可以回复LGTM</td>
</tr>
<tr>
<td>Loop More</td>
<td>Loop More</td>
<td></td>
<td>转发邮件添加更多联系人</td>
</tr>
<tr>
<td>CC</td>
<td>Carbon Copy</td>
<td>抄送</td>
<td></td>
</tr>
<tr>
<td>FYI</td>
<td>for your information</td>
<td>供你参考</td>
<td></td>
</tr>
<tr>
<td>TBD</td>
<td>to be determined</td>
<td>待定</td>
<td></td>
</tr>
<tr>
<td>OOO</td>
<td>out of office</td>
<td>不在办公室</td>
<td></td>
</tr>
<tr>
<td>IAM</td>
<td>in a meeting</td>
<td>在开会</td>
<td></td>
</tr>
<tr>
<td>WAH</td>
<td>work at home</td>
<td>在家办公</td>
<td></td>
</tr>
<tr>
<td>EOD</td>
<td>end of the day</td>
<td>下班前</td>
<td>催促别人下班前回复</td>
</tr>
<tr>
<td>COB</td>
<td>close of the business</td>
<td>下班前</td>
<td>催促别人下班前回复</td>
</tr>
<tr>
<td>ETA</td>
<td>Estimated Time of Arrival</td>
<td>预计到达时间</td>
<td></td>
</tr>
<tr>
<td>OTOH</td>
<td>On the Other Hand</td>
<td>另一方面</td>
<td></td>
</tr>
</tbody></table>
<p>Not sure if my last email：我不太确定您是否收到了我的上一封邮件，希望别人回复</p>
<p>To put it more simply…：简单来说…</p>
<p>Looking forward to …：期待你的回复，提前表达期待</p>
<p>Thanks in advance.：提前表达感谢</p>
<p>… I’d be most grateful.：提前表达感谢</p>
<p>邮件礼仪</p>
<ul>
<li>感谢开头感谢别人回复自己邮件，不用太客套，废话少说：Thanks for the quick reply/updated information.Thanks for getting back to me.</li>
<li>道歉邮件回的晚了，或者临时通知别人事情，要先道歉：Sorry for the late reply.Apologies for the late notice.</li>
<li>附件英语是attachment。但是如果你说please find the attachment会显得很没有水平。一般直接用动词attached或enclosed：Attached/Enclosed please find the report.I attached the report and please take a look.</li>
<li>收尾最后收尾一般都是询问别人意下如何。不要用please tell me…这种不地道的中式英语。可以这么说：Please let me know your thoughts.Looking forward to your insight.</li>
</ul>
<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>MRD</td>
<td>Market Requirements Document</td>
<td>市场需求文档</td>
<td>市场需求、功能需求 。如市场与竞争对手分析，通过哪些功能来实现商业目的，功能/非功能需求分哪几块，功能的优先级等等</td>
</tr>
<tr>
<td>PRD</td>
<td>Product Requirements Document</td>
<td>产品需求文档</td>
<td>需求分析</td>
</tr>
<tr>
<td>FSD</td>
<td>Functional Specifications Document</td>
<td>功能详细说明</td>
<td></td>
</tr>
<tr>
<td>PDR</td>
<td>Preliminary Design Review</td>
<td>初步设计评审</td>
<td></td>
</tr>
<tr>
<td>ToS</td>
<td>Terms of Service</td>
<td>服务条款</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>IaaS</td>
<td>Infrastructure as a Service</td>
<td>基础设施及服务</td>
<td>如阿里云。PaaS、SaaS、BaaS都是基于IaaS</td>
</tr>
<tr>
<td>PaaS</td>
<td>Platform as a Service</td>
<td>平台即服务</td>
<td>搭建平台，集成应用产品，整合起来提供服务，以SaaS模式提交给客户。属于SaaS的一种应用。简化应用部署流程</td>
</tr>
<tr>
<td>SaaS</td>
<td>Software as a Service</td>
<td>软件即服务</td>
<td>通过网络提供程序应用类服务</td>
</tr>
<tr>
<td>Baas</td>
<td>Backend as a Service</td>
<td>后端即服务</td>
<td>整合并提供特定领域的云后端服务，包括数据存储、推送、社交媒体整合等，用于快速开发移动应用，提供API或SDK。如聚合数据。简化应用开发流程、</td>
</tr>
</tbody></table>
<h2 id="运营"><a href="#运营" class="headerlink" title="运营"></a>运营</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>CPA</td>
<td>Cost To Action</td>
<td>根据用户行为付费的计费方式（如打开一次广告，注册一次账号，购买一次会员等）</td>
<td></td>
</tr>
<tr>
<td>CPS</td>
<td>Cost To Sales</td>
<td>以实际销售产品数量支付佣金的计费方式</td>
<td></td>
</tr>
<tr>
<td>ASO</td>
<td>App Store Optimization</td>
<td>应用商店优化</td>
<td></td>
</tr>
</tbody></table>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>OCS</td>
<td>Online Charge System</td>
<td>在线计费系统（订单管理系统）</td>
<td></td>
</tr>
<tr>
<td>CRM</td>
<td>Customer Relationship Management</td>
<td>客户关系管理</td>
<td></td>
</tr>
<tr>
<td>SQM</td>
<td>Sales Quota Management</td>
<td>销售目标管理系统</td>
<td></td>
</tr>
<tr>
<td>OA</td>
<td>Office Automation</td>
<td>办公自动化</td>
<td>综合系统。包括流程审批、协同工作、沟通工具、文档管理、论坛、计划管理、项目管理、任务管理、会议管理、系统集成、通讯录等应用</td>
</tr>
<tr>
<td>SSO</td>
<td></td>
<td>单点登录</td>
<td>在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。</td>
</tr>
<tr>
<td>BSS</td>
<td></td>
<td></td>
<td>基站子系统</td>
</tr>
</tbody></table>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>AOP</td>
<td>Aspect Oriented Programming</td>
<td>面向切面编程</td>
<td>针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</td>
</tr>
<tr>
<td>OOP</td>
<td>Object Oriented Programming</td>
<td>面向对象编程</td>
<td>针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。</td>
</tr>
<tr>
<td>OOD</td>
<td>Object-Oriented Design</td>
<td>面向对象设计</td>
<td></td>
</tr>
<tr>
<td>IoC</td>
<td>Inversion of Control</td>
<td>控制反转</td>
<td></td>
</tr>
<tr>
<td>DI</td>
<td>Dependency Injection</td>
<td>依赖注入</td>
<td></td>
</tr>
<tr>
<td>TDD</td>
<td>Test-Driven Development</td>
<td>测试驱动开发</td>
<td>先写单元测试，再实现功能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名词</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>编译型语言</td>
<td>使用编译器在程序运行之前编译，一次编写，处处编译，如C，C++</td>
</tr>
<tr>
<td>解释型语言</td>
<td>使用解释器在程序运行时解释，每次运行都要解释，java是解释型语言，将源码编译成.class（字节码文件），但是不是机器码，通过jvm对.class文件进行解释再执行</td>
</tr>
<tr>
<td>机器语言</td>
<td>机器可以执行的语言。高级语言都需要翻译成机器语言才可以被机器识别</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>一方库/包</td>
<td>本项目或者本工程中的类和方法、接口等</td>
</tr>
<tr>
<td>二方库/包</td>
<td>公司内部的依赖库，公司内部其他项目发布的jar包，如公司项目平台的核心依赖包</td>
</tr>
<tr>
<td>三方库/包</td>
<td>外部的开源库或开源项目贡献的jar， 比如apache、google、Ali等发布的依赖</td>
</tr>
<tr>
<td>A端</td>
<td>指开发、管理方</td>
</tr>
<tr>
<td>B端</td>
<td>Business： 企业用户商家</td>
</tr>
<tr>
<td>C端</td>
<td>Consumer： 个人用户、消费者</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RCT</td>
<td>React</td>
</tr>
<tr>
<td>i18n</td>
<td>（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。在资讯领域，国际化(i18n)指让产品（出版物，软件，硬件等）无需做大的改变就能够适应不同的语言和地区的需要。对程序来说，在不修改内部代码的情况下，能根据不同语言及地区显示相应的界面。 在全球化的时代，国际化尤为重要，因为产品的潜在用户可能来自世界的各个角落。通常与i18n相关的还有L10n（“本地化”的简称）。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>AOSP</td>
<td>Android Open-Source Project</td>
<td>Android 开放源代码项目</td>
<td></td>
</tr>
<tr>
<td>adt</td>
<td>Android Developer Tools</td>
<td>安卓开发者工具</td>
<td>为Eclipse IDE开发的插件，使用了sdk工具，用来开发Andorid应用</td>
</tr>
<tr>
<td>aapt</td>
<td>Android Asset Packaging Tool</td>
<td>安卓资源打包工具</td>
<td>将Android资源文件（res目录下）打包成R.java类(资源索引表)，以及.arsc资源文件（压缩资源文件）</td>
</tr>
<tr>
<td>apt</td>
<td>Annotation Processing Tool</td>
<td>注解处理器</td>
<td>在编译时扫描和处理注解</td>
</tr>
<tr>
<td>SDK</td>
<td>Software Development Kit</td>
<td>软件开发工具包</td>
<td>具备一定功能的应用软件的开发工具的集合。SDK包含了API的定义，API定义了对外的接口和规范，SDK还包含功能的具体实现和一些辅助功能。</td>
</tr>
<tr>
<td>API</td>
<td>Application Programming nterface</td>
<td>应用程序编程接口</td>
<td>SDK开发者提供给调用方使用的接口</td>
</tr>
<tr>
<td>SPI</td>
<td>Service Provider Interface</td>
<td>服务发现接口</td>
<td>调用方提供给外部实现的接口，要求实现方按照调用方的规范进行实现</td>
</tr>
<tr>
<td>FFI</td>
<td>Foregin Function Interface</td>
<td>语言交互接口，外部函数接口</td>
<td>用于两种不同的语言之间互相通信调用。如Java中的JNI</td>
</tr>
<tr>
<td>JNI</td>
<td>Java Native Interface</td>
<td>Java本地接口</td>
<td>用于Java与C/C++通信的接口</td>
</tr>
<tr>
<td>DLL</td>
<td>Dynamic Link Library</td>
<td>动态链接库</td>
<td>.dll文件不能直接执行，他们通常由 .exe 在执行时装入，内含有一些资源以及可执行代码等。</td>
</tr>
<tr>
<td>ABI</td>
<td>Application Binary Interface</td>
<td>应用程序二进制接口</td>
<td>描述应用程序和操作系统之间的底层接口，约定目标文件格式、数据类型、如何进行系统调用等</td>
</tr>
<tr>
<td>EABI</td>
<td>Embedded ABI</td>
<td>嵌入式ABI</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>两种不同语言之间互相调用一般有两种方案：</p>
<ol>
<li>将函数做成一个独立的服务：跨进程通信（IPC）或通过网络协议通信（RPC、RESTful）</li>
<li>通过FFI调用，将其它语言的接口内嵌到本语言中，调用效率更高</li>
</ol>
</blockquote>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>DBA</td>
<td>Database Administrator</td>
<td>数据库管理员</td>
<td>负责管理和维护数据库服务器的人。数据库管理员负责全面管理和控制数据库系统</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言</td>
<td>由SELECT子句，FROM子句，WHERE子句组成的查询块：SELECT &lt;字段名表&gt;FROM &lt;表或视图名&gt;WHERE&lt;查询条件&gt;</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manage Language</td>
<td>数据操纵语言</td>
<td>插入：INSERT，更新：UPDATE，删除：DELETE</td>
</tr>
<tr>
<td>DDL</td>
<td>Data Define Language</td>
<td>数据定义语言</td>
<td>用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：CREATE TABLE/VIEW/INDEX/SYN/CLUSTER ，DDL操作是隐性提交的！不能rollback</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言</td>
<td>用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视，授权：GRANT。回滚：ROLLBACK。提交：COMMIT</td>
</tr>
<tr>
<td>CRUD</td>
<td>Create、Retrieve、Update、Delete</td>
<td>增删改查</td>
<td></td>
</tr>
</tbody></table>
<p>注释：<br>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p>
<p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p>
<p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>HTML</td>
<td>HyperText Markup Language</td>
<td>超文本标记语言</td>
<td></td>
</tr>
<tr>
<td>CSS</td>
<td>Cascading Style Sheets</td>
<td>层叠样式表</td>
<td></td>
</tr>
<tr>
<td>SPA</td>
<td>Single Page Application</td>
<td>单页Web应用</td>
<td></td>
</tr>
<tr>
<td>SSR</td>
<td>Server Side Render</td>
<td>服务端渲染</td>
<td></td>
</tr>
<tr>
<td>CSRF</td>
<td>Cross-site request forgery</td>
<td>跨站请求伪造</td>
<td>也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</td>
</tr>
</tbody></table>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>XML</td>
<td>eXtensible Markup Language</td>
<td>可扩展标记语言</td>
<td></td>
</tr>
<tr>
<td>XSL</td>
<td>eXtensible Stylesheet Language</td>
<td>可扩展样式表语言</td>
<td>可描述如何来显示 XML 文档，包括三部分：XSLT、XPath、XSL-FO</td>
</tr>
<tr>
<td>XSLT</td>
<td>XSL Transformations</td>
<td></td>
<td>用于转换 XML 文档的语言，XSLT 使用 XPath 在 XML 文档中查找信息。</td>
</tr>
<tr>
<td>XPath</td>
<td></td>
<td></td>
<td>通过元素和属性在 XML 文档中导航的语言</td>
</tr>
<tr>
<td>XSL-FO</td>
<td></td>
<td></td>
<td>用于格式化 XML 文档的语言</td>
</tr>
</tbody></table>
<h2 id="XML和HTML"><a href="#XML和HTML" class="headerlink" title="XML和HTML"></a>XML和HTML</h2><table>
<thead>
<tr>
<th>XML</th>
<th>HTML</th>
</tr>
</thead>
<tbody><tr>
<td>被设计为具有自我描述性</td>
<td></td>
</tr>
<tr>
<td>旨在传输信息：被设计用于结构化、传输和存储数据，其焦点是数据的内容</td>
<td>旨在显示信息：被设计用来显示数据，其焦点是数据的外观</td>
</tr>
<tr>
<td>标签没有被预定义。需要自定义标签</td>
<td>有预定义标签，如<code>&lt;a&gt;、&lt;div&gt;</code>等</td>
</tr>
</tbody></table>
<h1 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ASR</td>
<td>Automatic Speech Recognition</td>
<td>自动语音识别技术</td>
<td></td>
</tr>
<tr>
<td>NLU</td>
<td>Natural Language Understanding</td>
<td>自然语言理解</td>
<td></td>
</tr>
<tr>
<td>NLP</td>
<td>Natural Language Processing</td>
<td>自然语言处理</td>
<td></td>
</tr>
<tr>
<td>TTS</td>
<td>Text-To-Speech</td>
<td>语音转文字</td>
<td>语音合成</td>
</tr>
<tr>
<td>ADC</td>
<td>Analog-to-Digital Converter</td>
<td>模拟数字转换器</td>
<td></td>
</tr>
<tr>
<td>ALSA</td>
<td>Advanced Linux Sound Architecture</td>
<td>高级Linux声音架构</td>
<td></td>
</tr>
<tr>
<td>AI</td>
<td>Artificial Intelligence</td>
<td>人工智能</td>
<td>包含机器学习</td>
</tr>
<tr>
<td>ML</td>
<td>Machine Learning</td>
<td>机器学习</td>
<td>包含深度学习</td>
</tr>
<tr>
<td>DL</td>
<td>Deep Learning</td>
<td>深度学习</td>
<td>搭建人工神经网络进行学习</td>
</tr>
</tbody></table>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="网络用语"><a href="#网络用语" class="headerlink" title="网络用语"></a>网络用语</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RTFM</td>
<td>Read The Fucking Manual</td>
<td>滚回去看说明手册</td>
<td></td>
</tr>
<tr>
<td>STFW</td>
<td>Search The Fucking Web</td>
<td>滚回去百度</td>
<td></td>
</tr>
<tr>
<td>ASL</td>
<td>Age、Sex、Location</td>
<td></td>
<td>相亲用</td>
</tr>
<tr>
<td>SUX</td>
<td>suck的第三人称单数</td>
<td>滥，差劲</td>
<td>that sux=sb</td>
</tr>
<tr>
<td>LMAO</td>
<td>laughing my ass off</td>
<td>笑死宝宝</td>
<td></td>
</tr>
<tr>
<td>FTW</td>
<td>for the win</td>
<td>棒棒哒</td>
<td></td>
</tr>
<tr>
<td>LOL</td>
<td>laughing out loud</td>
<td>大声笑</td>
<td></td>
</tr>
<tr>
<td>YOLO</td>
<td>you only live once</td>
<td>人生只有一次</td>
<td></td>
</tr>
<tr>
<td>FML</td>
<td>fuck my life</td>
<td>悲催的人生</td>
<td></td>
</tr>
<tr>
<td>TL;DR</td>
<td>too long; didn ’ t read</td>
<td>太长不看</td>
<td></td>
</tr>
<tr>
<td>TGIF</td>
<td>thank god it’s Friday</td>
<td>天啊，星期五了</td>
<td></td>
</tr>
<tr>
<td>LB</td>
<td>Like Back</td>
<td>互粉啊！互粉！</td>
<td></td>
</tr>
<tr>
<td>HMU</td>
<td>Hit Me Up</td>
<td>妹妹约么</td>
<td></td>
</tr>
<tr>
<td>BRB</td>
<td>Be right back</td>
<td>我一定会回来的。</td>
<td>同义：BBL=Be back late；BFN=bye bye for now</td>
</tr>
<tr>
<td>NSFL</td>
<td>Not Safe For Life</td>
<td>慎入</td>
<td>比如单生狗，慎入</td>
</tr>
<tr>
<td>MTFBWY</td>
<td>May The Force Be With You</td>
<td>愿原力与你同在</td>
<td>《星球大战》中的经典台词，有 Good luck 的意思。</td>
</tr>
<tr>
<td>TIL</td>
<td>Today I learnt</td>
<td>今天我学到了</td>
<td></td>
</tr>
</tbody></table>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RSS</td>
<td><a href="https://baike.baidu.com/item/Really/16030355">Really</a> Simple Syndication</td>
<td>简易信息聚合（聚合内容）</td>
<td>RSS是一种用于共享新闻和其他Web内容的数据交换规范，就是将订户订阅的内容传送给他们的通讯协同格式(Protocol)。是站点用来和其他站点之间共享内容的一种简易方式（也叫聚合内容），在Blog开始盛行的时候得到广泛的应用。 RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含了全文或是节录的文字，再加上发用者所订阅之网摘布数据和授权的元数据。网络摘要能够使发行者自动地发布他们的数据，同时也使读者能更够定期更新他们喜欢的网站或是聚合不同网站的网摘。<br>RSS摘要可以借由RSS阅读器、feed reader或是aggregator等网页或以桌面为架构的软件来阅读。标准的XML档式可允许信息在一次发布后通过不同的程序阅览。用户借由将网摘输入RSS阅读器或是用鼠标点取浏览器上指向订阅程序的RSS小图标之URI（非通常称为URL）来订阅网摘。RSS阅读器定期检阅是否有更新，然后下载给监看用户界面。<br>RSS可以是以下三个解释的其中一个：<br>Really Simple Syndication（真正简单的整合） RDF (Resource Deion Framework) Site Summary Rich Site Summary（丰富站点摘要）</td>
</tr>
<tr>
<td>Feed</td>
<td></td>
<td></td>
<td>Feed就是为满足以某种形式持续得到自己更新的需求而提供的格式标准的信息出口。就是信源。信息发布网站将网站全部或者部分信息整合到一个 RSS 文件中，这个文件就被称之为 feed 。信源中包含的数据都是标准的 XML 格式，不但能直接被其他站点调用，也能在其他的终端和服务中使用。<br>RSS订阅的过程中会用到的“Feed”，便是表示这是用来接收该信息来源更新的接口</td>
</tr>
</tbody></table>
<h2 id="建模-游戏"><a href="#建模-游戏" class="headerlink" title="建模/游戏"></a>建模/游戏</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
</tr>
</thead>
<tbody><tr>
<td>PBR</td>
<td>Physicallly-Based Rendering</td>
<td>基于物理的渲染方式</td>
</tr>
<tr>
<td>PBS</td>
<td>Physicallly-Based Shader</td>
<td>基于物理的着色方式</td>
</tr>
<tr>
<td>FC</td>
<td>Family Computer，Famicom</td>
<td>第一代红白机，1983年发售，1985年超级马里奥，1986年塞尔达传说</td>
</tr>
<tr>
<td>NES</td>
<td>Nintendo Entertainment System</td>
<td>欧美地区叫法，灰机</td>
</tr>
<tr>
<td>GB</td>
<td>Game Boy</td>
<td>1989年，俄罗斯方块</td>
</tr>
<tr>
<td>SFC</td>
<td>Super Famicom</td>
<td>1990年，第二代红白机</td>
</tr>
<tr>
<td>N64</td>
<td>Nintendo 64</td>
<td>任天堂64位机，1996年发售，宝可梦系列，第三代红白机</td>
</tr>
<tr>
<td>NGC</td>
<td>Nintendo GameCube</td>
<td>2001年，第四代红白机</td>
</tr>
<tr>
<td>GBA</td>
<td>Game Boy Advance</td>
<td>2001年，第二代GameBoy</td>
</tr>
<tr>
<td>NDS</td>
<td>Nintendo Dual screen</td>
<td>2004年，折叠双屏掌机</td>
</tr>
<tr>
<td>GBM</td>
<td>Game Boy MICRO</td>
<td>2005年，Game Boy小型机</td>
</tr>
<tr>
<td>Wii</td>
<td></td>
<td>2006年，首次引入体感</td>
</tr>
<tr>
<td>3DS</td>
<td>Nintendo 3DS</td>
<td>2010年，折叠双屏掌机，3D裸眼技术</td>
</tr>
<tr>
<td>NS</td>
<td>Nintendo Switch</td>
<td>2017年发售的游戏机</td>
</tr>
<tr>
<td>PSP</td>
<td>PlayStation Portable</td>
<td>索尼掌机</td>
</tr>
<tr>
<td>PS3</td>
<td>Play Station 3</td>
<td>索尼家用主机</td>
</tr>
<tr>
<td>IP</td>
<td>Intellectual Property</td>
<td>知识产权</td>
</tr>
<tr>
<td>Expansion Pack</td>
<td>资料片</td>
<td>游戏扩展版、补充内容。 在原有游戏基础上，增加一些新内容而开发出来的游戏扩展软件。 例如扩充新的故事情节、地图、角色、装备等。</td>
</tr>
<tr>
<td>DLC</td>
<td>Downloadable Content</td>
<td>追加可下载内容包。 下载的游戏附加内容 。</td>
</tr>
</tbody></table>
<blockquote>
<p>资料片和DLC本质没有区别，都是游戏本体发售后的追加内容。</p>
<p>有的人说DLC不能脱离本体运行，资料片可以脱离本体运行。（不过也有DLC也有能独立运行的，资料片也有非独立的。）</p>
<p>也有人说资料片是包含本体和扩展内容的单独的光盘，DLC是通过网络下载的”现代版”的资料片</p>
</blockquote>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SD卡</td>
<td>Secure Digital Memory Card</td>
<td>安全数字卡</td>
<td></td>
</tr>
<tr>
<td>TF卡</td>
<td>T-Flash、Trans Flash、MicroSD</td>
<td>微型SD卡</td>
<td>TF卡比SD卡小，TF卡插入适配器中可以转换为SD卡</td>
</tr>
<tr>
<td>ROM</td>
<td>Read-Only Memory</td>
<td>只读存储器</td>
<td>一般存储BIOS等不需要被修改的基本程序</td>
</tr>
<tr>
<td>RAM</td>
<td>Random Access Memory</td>
<td>随机存取存储器</td>
<td>也叫主存、运行内存，用于临时存储程序、数据和中间结果，断电之后丢失。如PC上的内存条</td>
</tr>
<tr>
<td>Flash</td>
<td>Flash Memory</td>
<td>闪存</td>
<td>非易失性，断电之后还能保存数据。并且可以直接运行程序，不需要读到RAM中。一般用于嵌入式产品，如U盘、数码相机、MP3等</td>
</tr>
<tr>
<td>eMMC</td>
<td>Embedded Multi Media Card</td>
<td></td>
<td>集成了一个控制器，即Flash+主控IC，主要针对手机或平板电脑等内嵌式存储器。提供标准接口管理Flash，使得手机厂商能够专注开发其他部分</td>
</tr>
<tr>
<td>Cache</td>
<td></td>
<td>高速缓冲存储器</td>
<td>位于CPU和内存之间，存储CPU临时数据，比RAM速度更快</td>
</tr>
<tr>
<td>SSD</td>
<td>Solid State Disk</td>
<td>固态硬盘</td>
<td>读写速度比SATA块，读写次数少于硬盘，价格更高</td>
</tr>
<tr>
<td>SATA</td>
<td>Serial Advanced Technology Attachment</td>
<td>机械硬盘</td>
<td></td>
</tr>
<tr>
<td>SRAM</td>
<td>Static RAM</td>
<td>静态随机存储器</td>
<td></td>
</tr>
<tr>
<td>DRAM</td>
<td>Dynamic RAM</td>
<td>动态随机存储器</td>
<td></td>
</tr>
<tr>
<td>SDRAM</td>
<td>Synchronous Dynamic RAM</td>
<td>同步动态随机存储器</td>
<td></td>
</tr>
<tr>
<td>SDR SDRAM</td>
<td>Single Data Rate SDRAM</td>
<td>单信道同步动态随机存储器</td>
<td>数据预取宽度为1bit</td>
</tr>
<tr>
<td>DDR1 SDRAM</td>
<td>Double Data Rate SDRAM</td>
<td>双信道同步动态随机存储器</td>
<td>数据预取宽度为2bit，即每次存取2bit为1组的数据</td>
</tr>
<tr>
<td>DDR2 SDRAM</td>
<td>Double Data Rate Two SDRAM</td>
<td>双信道两次同步动态随机存储器</td>
<td>数据预取宽度为4bit</td>
</tr>
<tr>
<td>DDR3 SDRAM</td>
<td>Double Data Rate Three SDRAM</td>
<td>双信道三次同步动态随机存储器</td>
<td>数据预取宽度为8bit</td>
</tr>
<tr>
<td>PROM</td>
<td>Programmable ROM</td>
<td>可编程只读存储器</td>
<td></td>
</tr>
<tr>
<td>EPROM</td>
<td>Erasable Programmable ROM</td>
<td>可擦除可编程只读存储器</td>
<td></td>
</tr>
<tr>
<td>OTPROM</td>
<td>One Time Programmable ROM</td>
<td>一次编程只读存储器</td>
<td></td>
</tr>
<tr>
<td>EEPROM</td>
<td>Electrically Erasable Programmable ROM</td>
<td>电子式可擦除可编程只读存储器</td>
<td></td>
</tr>
</tbody></table>
<h2 id="TV"><a href="#TV" class="headerlink" title="TV"></a>TV</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>CEC</td>
<td>Consumer Electronics Control</td>
<td>消费类电子控制</td>
<td>系统发送CEC信号给HDMI设备（例如碟机），从而进行控制</td>
</tr>
<tr>
<td>ARC</td>
<td>Audio Return Channel</td>
<td>音频回传通道</td>
<td>电视将声音通过HDMI线回传给外置的音频设备（例如功放、音响）</td>
</tr>
</tbody></table>
<blockquote>
<p>传统TV只接收HDMI输入的画面信号，作为显示器使用。HDMI CEC和HDMI ARC，TV可以输出信号（回传）给外部设备，不需要多余的线材</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题配置手册</title>
    <url>/2018/10/20/blog-2018-10-20-NexTConfig/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>博客效果如图：</p>
<p><img src="/2018/10/20/blog-2018-10-20-NexTConfig/%E5%8D%9A%E5%AE%A2%E6%95%88%E6%9E%9C.png" alt="博客效果"></p>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>列举部分功能，没有介绍到的可以参考主题配置文件中的注释。</p>
<h2 id="添加README-md文件"><a href="#添加README-md文件" class="headerlink" title="添加README.md文件"></a>添加README.md文件</h2><p>在Hexo目录下的source根目录下添加一个README.md文件，修改站点配置文件<code>_config.yml</code>，将skip_render参数的值设置为<code>skip_render: README.md</code>，跳过渲染该文件</p>
<h2 id="更换Schema"><a href="#更换Schema" class="headerlink" title="更换Schema"></a>更换Schema</h2><p>NexT内置了四套主题，这里叫Scheme（用一送四很划算），修改主题配置文件的scheme字段：Muse、Mist、Pisces、Gemini</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>修改avatar字段，设置头像链接地址，如：</p>
<ol>
<li>使用完整的互联网URI：<code>avatar: http://example.com/avatar.png</code></li>
<li>使用相对路径，放置到 <code>source/images/</code>路径下：<code>avatar: /images/avatar.png</code></li>
</ol>
<h2 id="设置菜单项"><a href="#设置菜单项" class="headerlink" title="设置菜单项"></a>设置菜单项</h2><p>修改主题配置文件的menu字段</p>
<p>格式为<code>菜单项名称（会匹配翻译）: 链接 || Font Awesome图标</code></p>
<p><strong>注：旧版本<code>路径 ||</code>中间有空格，升级Hexo之后跳转404，url链接多了个<code>%20</code>，表示空格，需要删除</strong></p>
<p>示例配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/||</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">/schedule/||</span> <span class="string">calendar</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml||</span> <span class="string">sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/|| heartbeat</span></span><br></pre></td></tr></table></figure>

<p>菜单项的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 <code>languages/&#123;language&#125;.yml</code> 。</p>
<p>例如修改简体中文配置文件：<code>languages/zh-Hans.yml</code>，或者添加自定义的字段other：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">公益404</span></span><br><span class="line">  <span class="attr">other:</span> <span class="string">其他</span></span><br></pre></td></tr></table></figure>

<h2 id="生成分类、标签和关于页面"><a href="#生成分类、标签和关于页面" class="headerlink" title="生成分类、标签和关于页面"></a>生成分类、标签和关于页面</h2><p>首先修改主题配置文件的menu菜单项，将tags和categories的注释去掉</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p><code>hexo new page tags</code>：在<code>站点/source/</code>目录下会生成新的文件夹tags，在该文件夹下会有一个index.md文件，头信息修改如下，不需要加正文内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-04-04</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>同理，将tags换成categories即可</p>
<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>同理，自行编辑文章内容，不需要加type</p>
<h2 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h2><p>修改主题配置文件 <code>themes/next/_config.yml</code>，不同动态背景，值为true应用：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Only fit scheme Pisces</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="修改文章底部标签图标"><a href="#修改文章底部标签图标" class="headerlink" title="修改文章底部标签图标"></a>修改文章底部标签图标</h2><p>默认文章底部的标签带#号，改为图标</p>
<p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=”tag”&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h2 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h2><p>在<a href="http://www.easyicon.net/">EasyIcon</a>中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span> </span><br><span class="line">	<span class="attr">small:</span> <span class="string">/images/favicon.ico</span></span><br><span class="line">	<span class="attr">medion:</span> <span class="string">/images/favicon.ico</span></span><br><span class="line">	<span class="comment">#apple_touch_icon: /images/apple-touch-icon-next.png</span></span><br><span class="line">	<span class="comment">#safari_pinned_tab: /images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<h2 id="去掉NexT自带的文章目录序号"><a href="#去掉NexT自带的文章目录序号" class="headerlink" title="去掉NexT自带的文章目录序号"></a>去掉NexT自带的文章目录序号</h2><p>NexT会为文章自动加上目录序号，如果自己的文章里面已经加了序号，不需要自动加的话，则修改主题配置文件</p>
<p><img src="/2018/10/20/blog-2018-10-20-NexTConfig/%E9%85%8D%E7%BD%AE%E5%8E%BB%E6%8E%89%E7%9B%AE%E5%BD%95%E5%BA%8F%E5%8F%B7.png" alt="去掉文章目录序号"></p>
<h1 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h1><h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search，原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。</p>
<p>安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改站点配置文件：</p>
<blockquote>
<p>search:<br>path: search.xml<br>field: post<br>format: html<br>limit: 10000</p>
</blockquote>
<p>修改NexT主题配置文件：</p>
<blockquote>
<p>local_search:<br>​    enable: true</p>
</blockquote>
<p>【踩坑】：启用搜索功能之后，使用<code>hexo serve</code>运行正常，点击按钮弹出搜索框，发布到GitPage，搜索框直接显示到搜索按钮旁边了。</p>
<blockquote>
<p>打开浏览器开发者工具，找到html元素，查看本地和GitPage页面差异，发现两者<code>main.css</code>样式不同，GitPage上搜素框css样式丢失</p>
<p>解决：<code>hexo clean</code>清除之前的编译结果，<code>hexo g -d</code>重新部署</p>
</blockquote>
<h2 id="添加站点地图sitemap"><a href="#添加站点地图sitemap" class="headerlink" title="添加站点地图sitemap"></a>添加站点地图sitemap</h2><p>为了让博文被google或百度检索，需要使用hexo的sitemap功能。</p>
<ol>
<li>安装插件，自动生成站点地图：<code>sitemap.xml、baidusitemap.xml</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>hexo g -d</code>生成并发布博客之后，可以通过<code>博客地址/sitemap.xml</code>、<code>博客地址/baidusitemap.xml</code>访问站点地图文件</li>
</ol>
<h3 id="Google检索"><a href="#Google检索" class="headerlink" title="Google检索"></a>Google检索</h3><ol>
<li>登录<a href="https://search.google.com/search-console/about">Google Search Console</a></li>
<li>点击立即使用，输入域名或<code>xxx.github.io</code>验证资源。</li>
<li>选择HTML标记验证，如下图</li>
</ol>
<img src="/2018/10/20/blog-2018-10-20-NexTConfig/Google Search验证资源.jpg" style="zoom:33%;">

<ol start="4">
<li>如果使用NexT主题，可以直接修改<strong>主题配置文件</strong>，<code>google_site_verification: xxx</code>，填入<code>content</code>中的内容。（原理是自动帮我们在生成的静态html文件head中添加<code>&lt;meta&gt;</code>）</li>
<li><code>hexo g -d</code>重新生成并发布博客</li>
<li>回到Google Search Console，点击验证</li>
<li>添加站点地图文件<code>sitemap.xml</code>，如下图。过一段时间会在<strong>概述</strong>中显示被索引的情况</li>
</ol>
<img src="/2018/10/20/blog-2018-10-20-NexTConfig/添加Google站点地图.png" style="zoom: 67%;">

<h3 id="百度检索"><a href="#百度检索" class="headerlink" title="百度检索"></a>百度检索</h3><ol>
<li>登录【<a href="https://ziyuan.baidu.com/site/index#/">百度资源管理平台-用户中心-站点管理</a>】</li>
<li>点击添加网站，输入博客地址</li>
<li>选择HTMl标签验证</li>
<li>如果使用NexT主题，可以直接修改<strong>主题配置文件</strong>，<code>baidu_site_verification: xxx</code>，填入<code>content</code>中的内容。</li>
<li><code>hexo g -d</code>重新生成并发布博客</li>
<li>回到百度资源页面完成验证</li>
<li>添加站点地图文件<code>baidusitemap.xml</code>，如下图。过一段时间可以查看索引数据</li>
</ol>
<img src="/2018/10/20/blog-2018-10-20-NexTConfig/添加百度站点地图.png" style="zoom: 67%;">

<h2 id="添加博客字数统计"><a href="#添加博客字数统计" class="headerlink" title="添加博客字数统计"></a>添加博客字数统计</h2><ol>
<li>安装插件：<code>npm i hexo-symbols-count-time --save</code></li>
<li>修改站点配置文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment"># 文章字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>   <span class="comment"># 站点总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>  <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>   <span class="comment"># 排除代码字数统计</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>   <span class="comment"># 平均单词长度</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>   <span class="comment"># 平均每分钟阅读单词数</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span> <span class="comment"># 时长单位</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改主题配置文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">false</span>   <span class="comment"># 是否另起一行</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>【踩坑】：配置之后发现文章字数始终为空，打印<code>post.length</code>为<code>undefined</code>。最终发现因为先安装了<code>hexo-wordcount</code>，卸载之后需要执行<code>hexo clean</code>清除缓存</p>
<h2 id="添加站点访问统计"><a href="#添加站点访问统计" class="headerlink" title="添加站点访问统计"></a>添加站点访问统计</h2><p>修改主题配置文件，页脚会出现访问量。<strong>会和<code>Live2d</code>冲突。可以使用valine的visitor进行字数统计，见下文添加评论系统</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><p><strong>注：Next新版本不再内置Valine</strong></p>
<p>使用Valine（基于LeanCloud云服务）作为评论系统。（也可以用Disqus、Gitalk、<a href="https://livere.com/">Livere</a>、<a href="http://changyan.kuaizhan.com/">畅言</a>等）</p>
<blockquote>
<p>看别人用Gitalk也挺不错的，还可以将评论发到issue，及时收到通知。缺点是需要登录GitHub账号，可能会劝退一拨人</p>
</blockquote>
<p>由于<code>busuanzi</code>统计站点访问量会和<code>Live2d</code>插件冲突，因此使用Valine visitor进行访问统计。（会和<code>leancloud_visitors</code>冲突，打开一个就行）</p>
<p>步骤如下：</p>
<ol>
<li>注册<a href="https://www.leancloud.cn/">LeanCloud</a>账号，实名认证</li>
<li>进入控制台，创建应用</li>
<li>在【设置-应用凭证】中找到appId和appKey</li>
<li>【设置-安全中心】可以配置Web安全域名，避免别人拿到appId和appKey之后使用</li>
<li>在LeanCloud控制台【数据存储-结构化数据】中创建Class，起名为Counter，如下图。（Comment为评论记录，Counter为访问记录）</li>
</ol>
<p><img src="/2018/10/20/blog-2018-10-20-NexTConfig/LeanCloud%E5%88%9B%E5%BB%BAClass.png"></p>
<ol start="7">
<li>修改主题配置文件，如下</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">&quot;第3步中的appId&quot;</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">&quot;第3步中的appKey&quot;</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">&quot;欢迎交流讨论&quot;</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 文章阅读统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 文章评论</span></span><br></pre></td></tr></table></figure>

<h2 id="配置Live2d卡通人物"><a href="#配置Live2d卡通人物" class="headerlink" title="配置Live2d卡通人物"></a>配置Live2d卡通人物</h2><ol>
<li>安装<code>npm install --save hexo-helper-live2d</code>，具体配置见官网说明<a href="https://github.com/EYHN/hexo-helper-live2d">hexo-helper-live2d</a></li>
<li>安装动画model，如<code>npm install live2d-widget-model-koharu</code>，可以到<a href="https://github.com/xiazeyu/live2d-widget-models">live2d-widget-models</a>挑选自己喜欢的model，效果见<a href="https://huaji8.top/post/live2d-plugin-2.0/">hexo live2d插件 2.0 !</a></li>
<li>将下述配置拷贝到根目录<code>_config.yml</code>中，不能拷到主题配置中，否则不生效。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-koharu</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">250</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">500</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure>

<h2 id="右上角配置Fork-me-on-GitHub入口"><a href="#右上角配置Fork-me-on-GitHub入口" class="headerlink" title="右上角配置Fork me on GitHub入口"></a>右上角配置Fork me on GitHub入口</h2><p>方法1：</p>
<ol>
<li>到<a href="http://tholman.com/github-corners/">GitHub Corners</a>或者<a href="https://github.blog/2008-12-19-github-ribbons/">GitHub Ribbons</a>选择喜欢的图标，copy相应的代码</li>
<li>将代码粘贴到<code>themes/next/layout/_layout.swig</code>文件中(放在<code>body</code>的内即可)</li>
<li>修改<code>href</code>链接为想要跳转的地址，如GitHub主页</li>
</ol>
<p>方法2：修改主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">	<span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/Afauria</span></span><br></pre></td></tr></table></figure>

<h2 id="添加每日一言-今日诗词"><a href="#添加每日一言-今日诗词" class="headerlink" title="添加每日一言/今日诗词"></a>添加每日一言/今日诗词</h2><ol>
<li>在<strong>layout或者md文档</strong>中添加下面代码。我是将今日诗词添加到了<strong>关于页面</strong>，将每日一言添加到了侧边栏：<code>/themes/next/layout/_partials/sidebar/site_overview.swig</code>中</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--今日诗词--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-border poem-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-border poem-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-title&quot;</span>&gt;</span>念两句诗<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;poem&quot;</span>&gt;</span>挑选中...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>&gt;</span></span><br><span class="line"><span class="javascript">    jinrishici.load(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">      poem.innerHTML = result.data.content</span><br><span class="line"><span class="javascript">      info.innerHTML = <span class="string">&#x27;【&#x27;</span> + result.data.origin.dynasty + <span class="string">&#x27;】&#x27;</span> + result.data.origin.author + <span class="string">&#x27;《&#x27;</span> + result.data.origin.title + <span class="string">&#x27;》&#x27;</span></span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--每日一言--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-side&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hitokoto&quot;</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hitokotofrom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>&gt;</span></span><br><span class="line"><span class="javascript">  fetch(<span class="string">&#x27;https://v1.hitokoto.cn&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span></span><br><span class="line"><span class="javascript">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line">       	hitokoto.innerHTML = data.hitokoto</span><br><span class="line"><span class="javascript">    	<span class="keyword">if</span>(data.from_who != <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">      	  hitokotofrom.innerHTML =<span class="string">&#x27;——&#x27;</span> + data.from_who + <span class="string">&#x27; 《&#x27;</span> + data.from + <span class="string">&#x27;》&#x27;</span></span></span><br><span class="line"><span class="javascript">      	&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">	  hitokotofrom.innerHTML =<span class="string">&#x27;——《&#x27;</span> + data.from + <span class="string">&#x27;》&#x27;</span> </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    .catch(<span class="built_in">console</span>.error) </span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>/themes/next/source/css</code>中添加下面的css样式，也可自行修改样式</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.poem-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">730px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#797979</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: none;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">80px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-wrap</span> <span class="selector-class">.poem-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Lato&#x27;</span>, <span class="string">&quot;PingFang SC&quot;</span>, <span class="string">&quot;Microsoft YaHei&quot;</span>, sans-serif;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">letter-spacing</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#797979</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-wrap</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#797979</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-wrap</span> <span class="selector-tag">p</span><span class="selector-id">#poem</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-wrap</span> <span class="selector-tag">p</span><span class="selector-id">#info</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-border</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">27%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#797979</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-right</span> &#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-left</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">685px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.poem-border</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">18%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.poem-wrap</span> &#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">        <span class="attribute">border-top</span>: <span class="number">2px</span> solid <span class="number">#797979</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.poem-wrap</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">6px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.poem-border</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-side</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">5%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-side</span> <span class="selector-tag">div</span><span class="selector-id">#hitokoto</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-side</span> <span class="selector-tag">div</span><span class="selector-id">#hitokotofrom</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加文章置顶功能"><a href="#添加文章置顶功能" class="headerlink" title="添加文章置顶功能"></a>添加文章置顶功能</h2><ol>
<li>安装插件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在需要置顶的文章头部中添加<code>top: true</code></li>
<li>配置置顶图标：修改<code>next/layout/_macro/post.swig</code>文件，在<code>&lt;div class=&quot;post-meta&quot;&gt;</code>中添加下面代码</li>
</ol>
<blockquote>
<p>新版本改到了<code>next/layout/_partials/post/post-meta.njk</code>中</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-meta&quot;</span>&gt;</span></span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;far fa-thumb-tack&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#7D26CD&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">  <span class="comment">&lt;!--省略..--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>置顶图标无法显示？</p>
<blockquote>
<p>由于<code>next</code>主题使用的<code>fontawesome</code>图标只有<code>all.min.css</code>，不包含<code>fa-thumb-tack</code>（图钉）图标。需要手动下载<code>fontawesome</code>图标，替换<code>next/source/lib/font-awesome</code>下的文件夹。</p>
<p>这里就不引入了，换成<code>fa-fire</code>（火）或者<code>fa-bolt</code>（闪电）图标，能看懂就行</p>
</blockquote>
<h2 id="修改归档页面文章数量"><a href="#修改归档页面文章数量" class="headerlink" title="修改归档页面文章数量"></a>修改归档页面文章数量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-generator-index</span><br><span class="line">npm install --save hexo-generator-archive</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改站点配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首页配置</span></span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 归档页面配置</span></span><br><span class="line">archive_generator:</span><br><span class="line">  per_page: 30</span><br><span class="line">  order_by: -date</span><br></pre></td></tr></table></figure>

<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="NexT升级"><a href="#NexT升级" class="headerlink" title="NexT升级"></a>NexT升级</h2><p>Hexo升级之后使用NexT会出现一些错误，原来NexT版本为5.1.4，需要升级为V7+。</p>
<p>本文配置基于V5，升级之后部分配置需要相应修改。</p>
<p><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">参考升级说明</a></p>
<h2 id="toArray报错"><a href="#toArray报错" class="headerlink" title="toArray报错"></a>toArray报错</h2><p><code>hexo g</code>生成报错，不影响使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR Template render error: (e:\GitPageBlog\AkiyamaBlog\themes\next\layout\post.swig)</span><br><span class="line">Error: Unable to call `post[&quot;categories&quot;][&quot;toArray&quot;]`, which is undefined or falsey</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改<code>themes/next/layout/_macro/post.swig</code>文件，去掉<code>post.categories.toArray()</code>和<code>post.tags.toArray()</code>中的<code>toArray()</code></p>
</blockquote>
<p><strong>注：回来补充，不能去掉toArray()，否则文章开头的分类和标签无法显示……估计和node版本有关系</strong></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ol>
<li><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>和<a href="https://theme-next.js.org/docs/getting-started/">NexT官方文档</a></li>
<li><a href="http://www.mdslq.cn/archives/40609c5b.html#%E6%B7%BB%E5%8A%A0READMEmd%E6%96%87%E4%BB%B6">Hexo博客Next主题个性设置集锦</a></li>
<li><a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html">Hexo+NexT 主题配置备忘</a></li>
<li><a href="https://blog.csdn.net/qq_40265501/article/details/80030627">hexo博客添加搜索功能</a></li>
<li><a href="https://blog.csdn.net/qq_44036990/article/details/105088198">hexo(next)——每日一言、今日诗词</a></li>
<li><a href="https://blog.csdn.net/qq_42889280/article/details/103087433">Hexo博客+Next主题深度优化与定制</a></li>
<li><a href="https://eericzeng.github.io/2019/07/14/hexo%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9sitemap%E7%9A%84%E4%BD%BF%E7%94%A8/">hexo博客站点sitemap的使用</a></li>
</ol>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo手册</title>
    <url>/2018/10/18/blog-2018-10-18-Hexo%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>。新手时期写的水文，熟悉之后就觉得没什么用了，有问题可以翻官方最新的文档，自己写的可能已经过时。当然自己抄一遍之后记忆会更加深刻。</p>
<h1 id="Hexo目录"><a href="#Hexo目录" class="headerlink" title="Hexo目录"></a>Hexo目录</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml 	# 站点配置文件</span><br><span class="line">├── package.json	# npm配置</span><br><span class="line">├── scaffolds		# 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span><br><span class="line">├── source			# 子文件夹相当于一个个页面(page)，每个页面对应一个布局文件，可以修改主题里的配置文件改变样式</span><br><span class="line">|   ├── _drafts		# 草稿页面：存放所有草稿</span><br><span class="line">|   ├── _posts		# 文章页面：存放所有文章，所有文章都是同一个布局</span><br><span class="line">|   ├── about		# 关于页面</span><br><span class="line">|   ├── categories	# 分类页面</span><br><span class="line">|   ├── tags		# 标签页面</span><br><span class="line">|   └──………………</span><br><span class="line">└── themes			# 主题</span><br></pre></td></tr></table></figure>

<h1 id="Hexo一些基本概念"><a href="#Hexo一些基本概念" class="headerlink" title="Hexo一些基本概念"></a>Hexo一些基本概念</h1><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>前页（扉页、版权页、目次等），位于文章最上方<code>---</code>分隔的区域，做一些变量声明和配置。也可以用json格式，使用<code>;;;</code>分隔</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>layout</code></td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td><code>title</code></td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td><code>date</code></td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td><code>updated</code></td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td><code>comments</code></td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>标签（不适用于分页），无顺序</td>
<td></td>
</tr>
<tr>
<td><code>categories</code></td>
<td>分类（不适用于分页），有顺序</td>
<td></td>
</tr>
<tr>
<td><code>permalink</code></td>
<td>覆盖文章网址</td>
<td></td>
</tr>
</tbody></table>
<h2 id="模板（Scaffold）"><a href="#模板（Scaffold）" class="headerlink" title="模板（Scaffold）"></a>模板（Scaffold）</h2><p>模板决定了网站内容的呈现方式，可以根据模板生成初始化文章</p>
<table>
<thead>
<tr>
<th>模板</th>
<th>用途</th>
<th>回调</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>首页</td>
<td>post</td>
</tr>
<tr>
<td>post</td>
<td>文章</td>
<td>index</td>
</tr>
<tr>
<td>page</td>
<td>分页</td>
<td>index</td>
</tr>
<tr>
<td>archive</td>
<td>归档</td>
<td>index</td>
</tr>
<tr>
<td>category</td>
<td>分类归档</td>
<td>archive</td>
</tr>
<tr>
<td>tag</td>
<td>标签归档</td>
<td>archive</td>
</tr>
</tbody></table>
<h2 id="局部模版（Partial）"><a href="#局部模版（Partial）" class="headerlink" title="局部模版（Partial）"></a>局部模版（Partial）</h2><p>可以在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利</p>
<h2 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h2><p>如果页面结构类似，例如两个模板都有页首（Header）和页脚（Footer），您可考虑通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>site</code></td>
<td><a href="https://hexo.io/zh-cn/docs/variables#%E7%BD%91%E7%AB%99%E5%8F%98%E9%87%8F">网站变量</a></td>
</tr>
<tr>
<td><code>page</code></td>
<td>针对该页面的内容以及 front-matter 所设定的变量。</td>
</tr>
<tr>
<td><code>config</code></td>
<td>网站配置</td>
</tr>
<tr>
<td><code>theme</code></td>
<td>主题配置。继承自网站配置。</td>
</tr>
<tr>
<td><code>_</code> (单下划线)</td>
<td><a href="http://lodash.com/">Lodash</a> 函数库</td>
</tr>
<tr>
<td><code>path</code></td>
<td>当前页面的路径（不含根路径）</td>
</tr>
<tr>
<td><code>url</code></td>
<td>当前页面的完整网址</td>
</tr>
<tr>
<td><code>env</code></td>
<td>环境变量</td>
</tr>
</tbody></table>
<h3 id="网站变量"><a href="#网站变量" class="headerlink" title="网站变量"></a>网站变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>site.posts</code></td>
<td>所有文章</td>
</tr>
<tr>
<td><code>site.pages</code></td>
<td>所有分页</td>
</tr>
<tr>
<td><code>site.categories</code></td>
<td>所有分类</td>
</tr>
<tr>
<td><code>site.tags</code></td>
<td>所有标签</td>
</tr>
</tbody></table>
<h3 id="页面变量"><a href="#页面变量" class="headerlink" title="页面变量"></a>页面变量</h3><h4 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.title</code></td>
<td>页面标题</td>
</tr>
<tr>
<td><code>page.date</code></td>
<td>页面建立日期（<a href="http://momentjs.com/">Moment.js</a> 对象）</td>
</tr>
<tr>
<td><code>page.updated</code></td>
<td>页面更新日期（<a href="http://momentjs.com/">Moment.js</a> 对象）</td>
</tr>
<tr>
<td><code>page.comments</code></td>
<td>留言是否开启</td>
</tr>
<tr>
<td><code>page.layout</code></td>
<td>布局名称</td>
</tr>
<tr>
<td><code>page.content</code></td>
<td>页面的完整内容</td>
</tr>
<tr>
<td><code>page.excerpt</code></td>
<td>页面摘要</td>
</tr>
<tr>
<td><code>page.more</code></td>
<td>除了页面摘要的其余内容</td>
</tr>
<tr>
<td><code>page.source</code></td>
<td>页面原始路径</td>
</tr>
<tr>
<td><code>page.full_source</code></td>
<td>页面的完整原始路径</td>
</tr>
<tr>
<td><code>page.path</code></td>
<td>页面网址（不含根路径）。我们通常在主题中使用 <code>url_for(page.path)</code>。</td>
</tr>
<tr>
<td><code>page.permalink</code></td>
<td>页面的完整网址</td>
</tr>
<tr>
<td><code>page.prev</code></td>
<td>上一个页面。如果此为第一个页面则为 <code>null</code>。</td>
</tr>
<tr>
<td><code>page.next</code></td>
<td>下一个页面。如果此为最后一个页面则为 <code>null</code>。</td>
</tr>
<tr>
<td><code>page.raw</code></td>
<td>文章的原始内容</td>
</tr>
<tr>
<td><code>page.photos</code></td>
<td>文章的照片（用于相簿）</td>
</tr>
<tr>
<td><code>page.link</code></td>
<td>文章的外部链接（用于链接文章）</td>
</tr>
</tbody></table>
<h4 id="文章（post）：和-page-布局类似，但是添加了下列变量。"><a href="#文章（post）：和-page-布局类似，但是添加了下列变量。" class="headerlink" title="文章（post）：和 page 布局类似，但是添加了下列变量。"></a>文章（post）：和 <code>page</code> 布局类似，但是添加了下列变量。</h4><table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.published</code></td>
<td>如果该文章已发布则为True</td>
</tr>
<tr>
<td><code>page.categories</code></td>
<td>该文章的所有分类</td>
</tr>
<tr>
<td><code>page.tags</code></td>
<td>该文章的所有标签</td>
</tr>
</tbody></table>
<h4 id="首页（index）"><a href="#首页（index）" class="headerlink" title="首页（index）"></a>首页（index）</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.per_page</code></td>
<td>每页显示的文章数量</td>
</tr>
<tr>
<td><code>page.total</code></td>
<td>总文章数</td>
</tr>
<tr>
<td><code>page.current</code></td>
<td>目前页数</td>
</tr>
<tr>
<td><code>page.current_url</code></td>
<td>目前分页的网址</td>
</tr>
<tr>
<td><code>page.posts</code></td>
<td>本页文章</td>
</tr>
<tr>
<td><code>page.prev</code></td>
<td>上一页的页数。如果此页是第一页的话则为 <code>0</code>。</td>
</tr>
<tr>
<td><code>page.prev_link</code></td>
<td>上一页的网址。如果此页是第一页的话则为 <code>&#39;&#39;</code>。</td>
</tr>
<tr>
<td><code>page.next</code></td>
<td>下一页的页数。如果此页是最后一页的话则为 <code>0</code>。</td>
</tr>
<tr>
<td><code>page.next_link</code></td>
<td>下一页的网址。如果此页是最后一页的话则为 <code>&#39;&#39;</code>。</td>
</tr>
<tr>
<td><code>page.path</code></td>
<td>当前页面的路径（不含根目录）。我们通常在主题中使用 <code>url_for(page.path)</code>。</td>
</tr>
</tbody></table>
<h4 id="归档-archive-：与-index-布局相同，但新增以下变量。"><a href="#归档-archive-：与-index-布局相同，但新增以下变量。" class="headerlink" title="归档 (archive)：与 index 布局相同，但新增以下变量。"></a>归档 (archive)：与 <code>index</code> 布局相同，但新增以下变量。</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.archive</code></td>
<td>等于 <code>true</code></td>
</tr>
<tr>
<td><code>page.year</code></td>
<td>年份归档 (4位)</td>
</tr>
<tr>
<td><code>page.month</code></td>
<td>月份归档 (没有前导零的2位数)</td>
</tr>
</tbody></table>
<h4 id="分类-category-：与-index-布局相同，但新增以下变量。"><a href="#分类-category-：与-index-布局相同，但新增以下变量。" class="headerlink" title="分类 (category)：与 index 布局相同，但新增以下变量。"></a>分类 (category)：与 <code>index</code> 布局相同，但新增以下变量。</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.category</code></td>
<td>分类名称</td>
</tr>
</tbody></table>
<h4 id="标签-tag-：与-index-布局相同，但新增以下变量。"><a href="#标签-tag-：与-index-布局相同，但新增以下变量。" class="headerlink" title="标签 (tag)：与 index 布局相同，但新增以下变量。"></a>标签 (tag)：与 <code>index</code> 布局相同，但新增以下变量。</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.tag</code></td>
<td>标签名称</td>
</tr>
</tbody></table>
<h1 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>npm install -g hexo-cli</td>
<td>安装hexo插件</td>
</tr>
<tr>
<td>npm update -g hexo-cli</td>
<td>升级</td>
</tr>
<tr>
<td>npm install hexo-deployer-git –save</td>
<td>安装部署git插件</td>
</tr>
<tr>
<td>hexo –version、hexo -v</td>
<td>查看版本</td>
</tr>
<tr>
<td>hexo list <type></type></td>
<td>列出网站资料</td>
</tr>
</tbody></table>
<h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><table>
<thead>
<tr>
<th>简写</th>
<th>完整</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>hexo n “我的博客”</td>
<td>hexo new “我的博客”</td>
<td>新建文章</td>
</tr>
<tr>
<td>hexo p</td>
<td>hexo publish</td>
<td>发表草稿</td>
</tr>
<tr>
<td>hexo g</td>
<td>hexo generate</td>
<td>生成，</td>
</tr>
<tr>
<td>hexo s</td>
<td>hexo server</td>
<td>启动服务预览</td>
</tr>
<tr>
<td>hexo d</td>
<td>hexo deploy</td>
<td>将.deploy目录部署到GitHub</td>
</tr>
</tbody></table>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>hexo init [folder]</td>
<td>新建站点。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立站点。</td>
</tr>
<tr>
<td>hexo server</td>
<td>启动服务，监视文件变动并自动更新，无须重启服务器。默认地址：<a href="http://localhost:4000/">http://localhost:4000/</a></td>
</tr>
<tr>
<td>hexo server -s</td>
<td>静态模式，只使用静态文件</td>
</tr>
<tr>
<td>hexo server -p 5000</td>
<td>指定服务端口启动，默认4000</td>
</tr>
<tr>
<td>hexo server -i 192.168.1.1</td>
<td>自定义 IP，默认localhost</td>
</tr>
<tr>
<td>hexo server -l</td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
<tr>
<td>hexo clean</td>
<td>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</td>
</tr>
<tr>
<td>hexo g</td>
<td>生成静态网页至public目录</td>
</tr>
<tr>
<td>hexo g –watch</td>
<td>监视文件变动</td>
</tr>
<tr>
<td>hexo d</td>
<td>部署网站</td>
</tr>
</tbody></table>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p><code>hexo new [layout] &lt;title&gt;</code>：新建文章。如果指定设置 <code>layout</code> 的话，默认使用站点配置文件 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数（默认为post）代替。如果标题包含空格的话，使用引号括起来。</p>
<ul>
<li>hexo new post 文章名：新建文章，会在<code>source/_post/</code>目录下新建文件</li>
<li>hexo new draft 草稿名：新建草稿，会在<code>source/_draft/</code>目录下新建文件</li>
<li>hexo new page 页面名：新建页面，会生成<code>source/页面名/index.md</code>，如关于、分类、标签</li>
</ul>
<p>可以自定义模版，在<code>scaffolds</code>目录下新建或修改模版文件，<code>hexo new </code>会从<code>scaffolds</code>文件夹下找到对应的模版，生成文件。</p>
<h2 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h2><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>hexo –safe</td>
<td>在安全模式下，不会载入插件和脚本。安装新插件遭遇问题时，可以尝试以安全模式重新执行</td>
</tr>
<tr>
<td>hexo –debug</td>
<td>在终端中显示调试信息并记录到 <code>debug.log</code></td>
</tr>
<tr>
<td>hexo –silent</td>
<td>隐藏终端信息</td>
</tr>
<tr>
<td>hexo –config custom.yml</td>
<td>自定义配置文件的路径，执行后将不再使用 <code>_config.yml</code></td>
</tr>
<tr>
<td>hexo –draft</td>
<td>显示 <code>source/_drafts</code> 文件夹中的草稿文章</td>
</tr>
<tr>
<td>hexo –cwd /path/to/cwd</td>
<td>自定义当前工作目录（Current working directory）的路径。</td>
</tr>
</tbody></table>
<h1 id="Hexo配置参数说明"><a href="#Hexo配置参数说明" class="headerlink" title="Hexo配置参数说明"></a>Hexo配置参数说明</h1><p>站点配置文件：<code>站点根目录/_config.yml</code></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>网站标题</td>
</tr>
<tr>
<td>subtitle</td>
<td>副标题</td>
</tr>
<tr>
<td>description</td>
<td>描述、签名</td>
</tr>
<tr>
<td>keywords</td>
<td>博客关键字，利于SEO（搜索引擎优化）</td>
</tr>
<tr>
<td>author</td>
<td>作者、昵称</td>
</tr>
<tr>
<td>language</td>
<td>语言，如zh-Hans</td>
</tr>
<tr>
<td>timezone</td>
<td>时区</td>
</tr>
<tr>
<td>theme</td>
<td>主题</td>
</tr>
<tr>
<td>deploy</td>
<td>部署网站</td>
</tr>
<tr>
<td>permalink</td>
<td>永久链接</td>
</tr>
</tbody></table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span> </span><br><span class="line">    <span class="attr">type:</span> <span class="string">部署方式，如git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">仓库地址</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">分支名</span></span><br></pre></td></tr></table></figure>

<p>permalink配置示例：<br>使用<code>hexo new post &quot;文章&quot;</code>生成文章时会自动命名，并且生成静态文件时会生成相应的文件夹路径。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>:year/:month/:day/:title/</code></td>
<td>2013/07/14/hello-world</td>
</tr>
<tr>
<td><code>:year-:month-:day-:title.html</code></td>
<td>2013-07-14-hello-world.html</td>
</tr>
<tr>
<td><code>:category/:title</code></td>
<td>foo/bar/hello-world</td>
</tr>
</tbody></table>
<p>permalink变量<br>| 变量          | 描述                                                       |<br>| ————- | ———————————————————- |<br>| <code>:year</code>       | 文章的发表年份（4 位数）                                   |<br>| <code>:month</code>      | 文章的发表月份（2 位数）                                   |<br>| <code>:i_month</code>    | 文章的发表月份（去掉开头的零）                             |<br>| <code>:day</code>        | 文章的发表日期 (2 位数)                                    |<br>| <code>:i_day</code>      | 文章的发表日期（去掉开头的零）                             |<br>| <code>:title</code>      | 文件名称                                                   |<br>| <code>:post_title</code> | 文章标题                                                   |<br>| <code>:id</code>         | 文章 ID                                                    |<br>| <code>:category</code>   | 分类。如果文章没有分类，则是 <code>default_category</code> 配置信息。 |</p>
<h1 id="Hexo图片路径配置"><a href="#Hexo图片路径配置" class="headerlink" title="Hexo图片路径配置"></a>Hexo图片路径配置</h1><p>Hexo Markdown文章中使用图片需要将图片放到<code>source/images</code>文件夹下，通过<code>![](/images/图片名称)</code>引用。</p>
<p>这种方式在<strong>Typora中无法预览图片</strong></p>
<p>解决方案：</p>
<ol>
<li>修改_config.yml文件：<code>post_asset_folder: true</code><ol>
<li>使用<code>hexo new post 文章名称</code>时，会创建相同名称的文件夹</li>
<li>将要引用的图片放到该文件夹下</li>
</ol>
</li>
<li>安装插件：<code>npm install https://github.com/CodeFalling/hexo-asset-image</code></li>
<li>文章中引用图片路径：<code>![](文件夹名称/图片名称)</code></li>
</ol>
<h1 id="Hexo支持mermaid图表"><a href="#Hexo支持mermaid图表" class="headerlink" title="Hexo支持mermaid图表"></a>Hexo支持mermaid图表</h1><ol>
<li>安装插件：<code>npm install hexo-filter-mermaid-diagrams</code></li>
<li>旧版本配置步骤多一点</li>
<li>新版本直接在<strong>主题配置文件</strong>中启用mermaid即可</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># theme/next/_config.yml</span></span><br><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2018/10/17/blog-2018-10-17-Hexo/</url>
    <content><![CDATA[<h1 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h1><p>静态网页生成工具，可用于搭建博客。使用 Markdown（或其他渲染引擎）解析文章，有多种主题供选择。</p>
<p><a href="https://hexo.io/zh-cn/docs/">中文官方文档</a></p>
<h2 id="与Jekyll的区别？"><a href="#与Jekyll的区别？" class="headerlink" title="与Jekyll的区别？"></a>与Jekyll的区别？</h2><p>在 Github Page 里用 Jekyll 其实是上传一个工程文件 ，Github 自动生成静态文件，而 Hexo 是先生成好文件再部署的。</p>
<p>此外，Jekyll基于Ruby，Hexo基于Node</p>
<p>在 Hexo 中有两个重要的配置文件：</p>
<ol>
<li><strong>站点配置文件</strong>：<code>站点根目录/_config.yml</code>。主要包含 Hexo 本身的配置。</li>
<li><strong>主题配置文件</strong>：<code>站点根目录/themes/主题名称/_config.yml</code> ，主要用于配置主题相关的选项。</li>
</ol>
<h1 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p><a href="https://nodejs.org/en/">Node.js安装</a></p>
<p>安装后打开cmd，输入<code>node -v</code>、<code>npm -v</code>检查是否安装成功（环境变量自动配置好了）</p>
<blockquote>
<p>等于<code>node --version</code>、<code>npm --version</code></p>
</blockquote>
<p><a href="https://git-scm.com/">Git安装</a></p>
<p>在电脑上右键出现Git Bash Here、Git GUI Here即表示安装成功。</p>
<p>若配置了环境变量，可输入<code>git --version</code>检查是否安装成功</p>
<p>注意：一般情况在Git Bash中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择【use Git from the Windows Command Prompt】。</p>
<p>安装和配置SSH</p>
<h2 id="安装和运行"><a href="#安装和运行" class="headerlink" title="安装和运行"></a>安装和运行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo命令行工具</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否安装成功：hexo -v或者hexo --version</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo -v</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化hexo，或者创建空目录，执行hexo init</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> blog为站点根目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖包，即`package.json`中配置的库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地运行hexo：hexo s或者hexo server，默认端口为4000，也可通过`hexo server -p 端口号`指定端口号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://localhost:4000/">http://localhost:4000/</a> ，效果如下</p>
<p><img src="/2018/10/17/blog-2018-10-17-Hexo/Hexo%E9%A6%96%E9%A1%B5.png" alt="hexo成功图"></p>
<h1 id="Hexo主题切换"><a href="#Hexo主题切换" class="headerlink" title="Hexo主题切换"></a>Hexo主题切换</h1><p>Hexo提供了很多种<a href="https://hexo.io/themes/">主题</a>，挑选自己喜欢、功能稳定的。以<a href="https://theme-next.js.org/docs/getting-started/">NexT</a>为例：</p>
<ol>
<li>下载NexT主题，主题本质也是一个个Git工程，有两种安装方式。<ol>
<li>下载到<code>themes</code>文件夹中：<code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></li>
<li>npm安装，下载到<code>node_modules</code>中：<code>npm install hexo-theme-next</code>。</li>
</ol>
</li>
<li>启用NexT主题：打开<strong>站点配置文件</strong>，修改 theme 字段为 next。</li>
<li>运行验证：输入<code>hexo s</code>启动服务，浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> ，可以看到主题已经变更。</li>
</ol>
<p><img src="/2018/10/17/blog-2018-10-17-Hexo/Next%E4%B8%BB%E9%A2%98.png" alt="hexo成功图"></p>
<h2 id="主题配置文件目录说明"><a href="#主题配置文件目录说明" class="headerlink" title="主题配置文件目录说明"></a>主题配置文件目录说明</h2><ul>
<li><code>_config.yml</code>：主题的配置文件。修改时会自动更新，无需重启服务器。</li>
<li><code>languages</code>：语言文件夹，不同语言文件</li>
<li><code>layout</code>：布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式。</li>
<li><code>script</code>：脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件</li>
<li><code>source</code>：资源文件夹，存放 CSS、JavaScript、images 文件等资源。</li>
</ul>
<h2 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h2><p>如果懂css的话，可以修改theme中layout和source中的布局和css样式，定制主题。</p>
<p>使用npm下载主题较简单，但由于<code>node_modules</code>是临时文件夹，不便于自定义主题。因此建议自行clone维护。</p>
<p>本地修改样式之后，换个电脑之后记录会丢失，或者pull原作者新提交的代码的时候会出现冲突。</p>
<p>解决方法：fork原主题仓库，从自己的仓库clone，本地修改之后提交，定期从原主题仓库同步merge。</p>
<h1 id="部署到Github-Pages"><a href="#部署到Github-Pages" class="headerlink" title="部署到Github Pages"></a>部署到Github Pages</h1><p>GitHub Pages是免费的静态网页托管服务，使用Hexo可以生成静态站点文件，并上传到GitHub Pages上。默认使用<code>github.io</code>子域名。</p>
<h2 id="GitPage创建"><a href="#GitPage创建" class="headerlink" title="GitPage创建"></a>GitPage创建</h2><p>登录GitHub，创建一个新的仓库，仓库名称要和用户名一样，例如：<strong>Afauria.github.io</strong></p>
<p>创建完之后就可以通过 <code>https://afauria.github.io/</code> 来访问博客地址了</p>
<h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><p>使用<code>hexo generate</code>命令生成静态站点文件，简写为<code>hexo g</code></p>
<p>此命令会在站点根目录生成public文件夹，即最终推到GitHub的文件。</p>
<blockquote>
<p>与Jekyll不同，Jekyll是将工程推到Github，由GitPage生成静态文件，而这里是先生成静态文件再推到GitHub</p>
</blockquote>
<h2 id="安装deploy插件"><a href="#安装deploy插件" class="headerlink" title="安装deploy插件"></a>安装deploy插件</h2><p>由于public是临时目录，会被覆盖或者删除，手动维护Git比较麻烦。</p>
<p>因此需要安装插件，自动上传GitHub：<code>npm install hexo-deployer-git</code></p>
<p>配置GitHub仓库：打开根目录的 <code>_config.yml</code> 文件，找到deploy，修改如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span> </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:Afauria/Afauria.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h2 id="将静态文件推到GitHub上"><a href="#将静态文件推到GitHub上" class="headerlink" title="将静态文件推到GitHub上"></a>将静态文件推到GitHub上</h2><p>使用<code>hexo deploy</code>命令推到GitHub上，简写为<code>hexo d</code></p>
<p>上面两个命令可以合并为<code>hexo generate --deploy</code>或<code>hexo deploy --generate</code></p>
<p>当然也可以简写为<code>hexo g -d</code>或<code>hexo d -g</code></p>
<h2 id="访问博客地址"><a href="#访问博客地址" class="headerlink" title="访问博客地址"></a>访问博客地址</h2><p>访问刚才的博客地址 <code>https://afauria.github.io/</code> ，可以看到博客页面已经换成了Hexo页面。</p>
<h1 id="源文件版本管理"><a href="#源文件版本管理" class="headerlink" title="源文件版本管理"></a>源文件版本管理</h1><p>GitHub Pages只存储了生成的静态站点文件，源文件和主题仓库没有存档，没法在多台电脑间同步，因此需要创建Git仓库管理。</p>
<p><code>.gitignore</code>配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br><span class="line">package-lock.json</span><br></pre></td></tr></table></figure>

<p>由于themes下的主题也是一个git仓库，无法被add进来，因此需要单独管理。</p>
<p>主题仓库无法直接提交到远程，并且pull的时候会和作者冲突，可以使用fork，定期从原仓库同步修改。</p>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="两年后-，更新nodejs，hexo-g-d发布失败"><a href="#两年后-，更新nodejs，hexo-g-d发布失败" class="headerlink" title="两年后~，更新nodejs，hexo g -d发布失败"></a>两年后~，更新nodejs，hexo g -d发布失败</h2><p>错误如下</p>
<p><img src="/2018/10/17/blog-2018-10-17-Hexo/HexoDeployFailed.png" alt="Hexo发布失败"></p>
<p>解决方案：</p>
<ol>
<li><p>更新hexo命令行工具：<code>npm install -g hexo-cli</code></p>
</li>
<li><p>更新<code>package.json</code>中依赖组件的版本</p>
<ol>
<li>使用<code>npm update</code>更新所有依赖组件的版本</li>
<li>发现hexo从<code>^3.7.0</code>版本变到了<code>^3.9.0</code>，试了一下发布还是不行</li>
<li><code>package.json</code>中，版本号使用了^，只会更新小版本，不会更新大版本，因此还是版本号还是<code>3.x.x</code></li>
<li>从<a href="https://github.com/hexojs/hexo-starter">hexo工程模板</a>中拷贝最新的<code>package.json</code>，替换原来的版本</li>
<li>再执行<code>npm install</code>和<code>npm update</code>更新版本到<code>^5.3.0</code>，其他依赖也更新</li>
</ol>
</li>
<li><p>再执行<code>hexo g -d</code>，成功发布</p>
</li>
</ol>
<p><img src="/2018/10/17/blog-2018-10-17-Hexo/HexoDependenciesVersion.png" alt="Hexo依赖版本图"></p>
<p>注：更新后的hexo需要新版本node，否则会提示<code>TypeError: Object.fromEntries is not a function</code>。</p>
<p>由于我还在使用了gitbook-cli，该工具已经不再维护，只能通过旧版本node运行，无法共存。</p>
<p>解决方案：使用n管理node版本，使用hexo时切换到<code>n node/14.17.6</code>，使用gitbook-cli时切换到<code>n node/10.24.0</code></p>
<h2 id="升级之后菜单跳转404，url带-20"><a href="#升级之后菜单跳转404，url带-20" class="headerlink" title="升级之后菜单跳转404，url带%20"></a>升级之后菜单跳转404，url带%20</h2><p>next menu配置：旧版本<code>链接 ||</code>中间有空格，升级Hexo之后需要删除空格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/||</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">/schedule/||</span> <span class="string">calendar</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml||</span> <span class="string">sitemap</span></span><br></pre></td></tr></table></figure>

<h2 id="GitPage-构建失败"><a href="#GitPage-构建失败" class="headerlink" title="GitPage 构建失败"></a>GitPage 构建失败</h2><p>2021-5-16照常<code>hexo g -d</code>发布博客，结果收到GitHub错误邮件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The page build failed for the &#96;master&#96; branch with the following error:</span><br><span class="line"></span><br><span class="line">Unable to build page. Please try again later.</span><br><span class="line"></span><br><span class="line">For information on troubleshooting Jekyll see:</span><br><span class="line"></span><br><span class="line">  https:&#x2F;&#x2F;docs.github.com&#x2F;articles&#x2F;troubleshooting-jekyll-builds</span><br><span class="line"></span><br><span class="line">If you have any questions you can submit a request at https:&#x2F;&#x2F;support.github.com&#x2F;contact?repo_id&#x3D;367865705&amp;page_build_id&#x3D;253625473</span><br></pre></td></tr></table></figure>

<p>整了半天没解决，收了几十封错误邮件。尝试了很多方法无效：</p>
<ol>
<li><p>删除新上传的文件</p>
</li>
<li><p>排查错误字符</p>
</li>
<li><p>回退版本</p>
</li>
<li><p><code>hexo clean</code>、并删除<code>.deploy_git</code>文件夹</p>
</li>
<li><p>使用本地Jekyll编译运行正常</p>
</li>
<li><p>删除了远程Git仓库，新建GitPage</p>
</li>
<li><p>最后甚至准备转战Gitee发布，结果创建GitPage服务的时候提示服务不可用……</p>
<p><img src="/2018/10/17/blog-2018-10-17-Hexo/GiteePages.png" alt="GiteePages"></p>
</li>
</ol>
<p>本地构建运行<code>hexo serve</code>正常，使用jekyll编译也正常，说明文章格式没有错误。就是GitPage构建的时候失败了。</p>
<p>最后实在没办法，只能暂时放着，静下来整理博客，反正本地运行也可以看。</p>
<p>结果到晚上随手发布了一下，居然成功了、成功了……</p>
<p>只能说GitHub太坑，估计下午哪里瓦特了。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb基础概念笔记</title>
    <url>/2018/10/10/webdev-2018-10-10-JavaWebBasicNote/</url>
    <content><![CDATA[<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="java对象"><a href="#java对象" class="headerlink" title="java对象"></a>java对象</h2><p>POJO（Plain Ordinary Java Object，简单Java对象）</p>
<p>POJO在不同环境、场合下有不同意义：</p>
<ul>
<li>PO（Persistant Object，持久对象）：数据库表在java中映射的对象</li>
<li>BO（Business Object，业务对象）：业务层的Java对象</li>
<li>VO（View Object，视图对象）：表现层的Java对象</li>
<li>DTO（Data Transfer Object，数据传输对象）：在两个系统间传递数据，需要将POJO序列化，如RPC</li>
<li>JavaBean：遵循特定写法的java类，通常具有以下特征：<ul>
<li>属性私有</li>
<li>实现getter和setter</li>
<li>具有无参构造函数</li>
<li>实现序列化</li>
</ul>
</li>
<li>EJB(Enterprise JavaBean，企业级JavaBean)：一组JavaBean的集合，组合起来实现某块业务的功能</li>
</ul>
<h2 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h2><ul>
<li>Model层：模型层，mvc中的model</li>
<li>Dao层：（Data Access Object，数据访问对象），封装数据库操作（CRUD），常用框架：Mybatis，hibernate，spring-data-jpa等</li>
<li>Service层：业务层，封装业务逻辑，调用dao层进行处理，如跨表查询，判断等问题</li>
<li>Controller层：控制层，用于接收请求，分发到具体service，调用service层方法，返回数据，封装响应页面返回给前端</li>
<li>View层：视图层，如jsp、模板（template）（前后端分离之后，view层就到前端去了）</li>
</ul>
<h3 id="Entity、Model、Domain的区别"><a href="#Entity、Model、Domain的区别" class="headerlink" title="Entity、Model、Domain的区别"></a>Entity、Model、Domain的区别</h3><ul>
<li>Entity：实体，对应数据库表</li>
<li>Model：更接近业务，将entity进行处理</li>
<li>Domain：类似model，model主要是在mvc中提出来的概念，模块化的话称为domain更常见</li>
</ul>
<p>Model会对Entity进行处理：如数据库存储性别用（1，2），Entity里面存储的是int型，经过转换封装成Model，再传给前端，避免前端做判断</p>
<p>Entity和Model在数据库中就相当于表和视图的关系，表存储可能会有很多无用的字段，所以在表上建立视图，用于频繁读取。</p>
<h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>jpa（java persistent api，java持久化api）</p>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><ul>
<li>1开头的归类为临时响应，并需要客户端继续请求</li>
<li>2开头归类为请求成功</li>
<li>3开头归类为重定向</li>
<li>4开头归类为请求出错</li>
<li>5开头归类为服务器问题</li>
</ul>
<p>http常用的状态码及其对应的含义如下：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>客户应该继续发出请求</td>
</tr>
<tr>
<td>101</td>
<td>客户要求服务器根据请求转换HTTP协议版本</td>
</tr>
<tr>
<td>200</td>
<td>服务器响应正常。</td>
</tr>
<tr>
<td>201</td>
<td>提示知道新文件的URL</td>
</tr>
<tr>
<td>202</td>
<td>接受和处理、但处理未完成</td>
</tr>
<tr>
<td>203</td>
<td>返回信息不确定或不完整</td>
</tr>
<tr>
<td>204</td>
<td>请求收到，但返回信息为空</td>
</tr>
<tr>
<td>205</td>
<td>服务器完成了请求，用户代理必须复位当前已经浏览过的文件</td>
</tr>
<tr>
<td>206</td>
<td>服务器已经完成了部分用户的GET请求</td>
</tr>
<tr>
<td>300</td>
<td>请求的资源可在多处得到</td>
</tr>
<tr>
<td>301</td>
<td>删除请求数据</td>
</tr>
<tr>
<td>302</td>
<td>在其他地址发现了请求数据</td>
</tr>
<tr>
<td>303</td>
<td>建议客户访问其他URL或访问方式</td>
</tr>
<tr>
<td>304</td>
<td>该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。</td>
</tr>
<tr>
<td>305</td>
<td>请求的资源必须从服务器指定的地址得到</td>
</tr>
<tr>
<td>306</td>
<td>前一版本HTTP中使用的代码，现行版本中不再使用</td>
</tr>
<tr>
<td>307</td>
<td>申明请求的资源临时性删除</td>
</tr>
<tr>
<td>400</td>
<td>无法找到请求的资源。</td>
</tr>
<tr>
<td>401</td>
<td>访问资源的权限不够。</td>
</tr>
<tr>
<td>402</td>
<td>保留有效ChargeTo头响应</td>
</tr>
<tr>
<td>403</td>
<td>没有权限访问资源。</td>
</tr>
<tr>
<td>404</td>
<td>需要访问的资源不存在。</td>
</tr>
<tr>
<td>405</td>
<td>需要访问的资源被禁止。</td>
</tr>
<tr>
<td>406</td>
<td>根据用户发送的Accept头，请求资源不可访问</td>
</tr>
<tr>
<td>407</td>
<td>访问的资源需要代理身份验证。</td>
</tr>
<tr>
<td>408</td>
<td>客户端没有在用户指定的时间内完成请求</td>
</tr>
<tr>
<td>409</td>
<td>对当前资源状态，请求不能完成</td>
</tr>
<tr>
<td>410</td>
<td>服务器上不再有此资源且无进一步的参考地址</td>
</tr>
<tr>
<td>411</td>
<td>服务器拒绝用户定义的Content-Length属性请求</td>
</tr>
<tr>
<td>412</td>
<td>一个或多个请求头字段在当前请求中错误</td>
</tr>
<tr>
<td>413</td>
<td>请求的资源大于服务器允许的大小</td>
</tr>
<tr>
<td>414</td>
<td>请求的URL太长。</td>
</tr>
<tr>
<td>415</td>
<td>请求资源不支持请求项目格式</td>
</tr>
<tr>
<td>416</td>
<td>请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</td>
</tr>
<tr>
<td>417</td>
<td>服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</td>
</tr>
<tr>
<td>500</td>
<td>服务器内部错误。如代码执行异常</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持请求的函数</td>
</tr>
<tr>
<td>502</td>
<td>服务器暂时不可用，有时是为了防止发生系统过载</td>
</tr>
<tr>
<td>503</td>
<td>服务器过载或暂停维修</td>
</tr>
<tr>
<td>504</td>
<td>关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持或拒绝支请求头中指定的HTTP版本</td>
</tr>
</tbody></table>
<h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><h3 id="解释一：转发是服务器行为，重定向是客户端行为"><a href="#解释一：转发是服务器行为，重定向是客户端行为" class="headerlink" title="解释一：转发是服务器行为，重定向是客户端行为"></a>解释一：转发是服务器行为，重定向是客户端行为</h3><p>转发过程：客户浏览器发送http请求—-》web服务器接受此请求–》调用内部的一个方法在容器内部完成请求处理和转发动作—-》将目标资源发送给客户；<br>在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</p>
<p>重定向过程：客户浏览器发送http请求—-》web服务器接受后发送302状态码响应及对应新的location给客户浏览器–》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址—-》服务器根据此请求寻找资源并发送给客户。<br>在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。</p>
<h3 id="解释二：重定向，其实是两次request"><a href="#解释二：重定向，其实是两次request" class="headerlink" title="解释二：重定向，其实是两次request,"></a>解释二：重定向，其实是两次request,</h3><p>第一次，客户端request   A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中，传输的信息会被丢失。</p>
<p>请求转发是服务器内部把对一个request/response的处理权，移交给另外一个<br>对于客户端而言，它只知道自己最早请求的那个A，而不知道中间的B，甚至C、D。 传输的信息不会丢失。</p>
<h3 id="解释三：假设你去办理某个执照，"><a href="#解释三：假设你去办理某个执照，" class="headerlink" title="解释三：假设你去办理某个执照，"></a>解释三：假设你去办理某个执照，</h3><p>重定向：你先去了A局，A局的人说：“这个事情不归我们管，去B局”，然后，你就从A退了出来，自己乘车去了B局。 </p>
<p>转发：你先去了A局，A局看了以后，知道这个事情其实应该B局来管，但是他没有把你退回来，而是让你坐一会儿，自己到后面办公室联系了B的人，让他们办好后，送了过来。</p>
<p>注：</p>
<p>转发或重定向后需要return避免代码往下执行。</p>
<p>连续发两次forward，会报错：Cannot forward after response has been committed</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行笔记</title>
    <url>/2018/10/04/note-2018-10-04-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>mac和linux系统都是基于unix内核的类unix系统，因此两者命令基本一样，有细微差别</p>
<table>
<thead>
<tr>
<th>作用</th>
<th>Linux/Mac</th>
</tr>
</thead>
<tbody><tr>
<td>打开文件或文件夹</td>
<td>open [path]</td>
</tr>
<tr>
<td>列出当前目录文件</td>
<td>ls、ll -h</td>
</tr>
<tr>
<td>打印当前目录路径</td>
<td>pwd</td>
</tr>
<tr>
<td>拷贝文本</td>
<td>pbcopy（mac专有）</td>
</tr>
<tr>
<td>查看系统信息</td>
<td>sw_vers</td>
</tr>
<tr>
<td>计算器</td>
<td>bc</td>
</tr>
<tr>
<td>查看ip</td>
<td>ifconfig</td>
</tr>
<tr>
<td>匹配字符串</td>
<td>grep</td>
</tr>
<tr>
<td>创建文件夹</td>
<td>mkdir</td>
</tr>
<tr>
<td>创建文件</td>
<td>touch</td>
</tr>
<tr>
<td>查看应用安装路径</td>
<td>which</td>
</tr>
<tr>
<td>查看系统磁盘使用情况</td>
<td>df</td>
</tr>
<tr>
<td>查看目录或文件大小</td>
<td>du -sh 文件夹路径</td>
</tr>
</tbody></table>
<p>常用命令：</p>
<ul>
<li>查看IP地址：<code>ifconfig en0 | grep inet | awk &#39;$1==&quot;inet&quot; &#123;print $2&#125;</code></li>
<li><code>find . -name &#39;文件名&#39;</code>：在当前路径下查找文件，需要完整的文件名，或者使用通配符</li>
<li><code>grep [options] PATTERN FILE</code>：<code>grep -inR enable_global_input *</code><ul>
<li>-i：忽略大小写</li>
<li>-n：输出匹配的行号</li>
<li>-R：递归遍历文件夹</li>
<li>-E：可以输入多个：<code>grep -E &quot;word1|word2|word3&quot; file.txt </code></li>
</ul>
</li>
</ul>
<p>Linux查看系统版本：</p>
<ul>
<li><code>cat /proc/version</code>和<code>uname -a</code>查看内核版本</li>
<li><code>lsb_release -a</code>和<code>cat /etc/issue</code>：查看发行版本信息</li>
</ul>
<p><a href="https://blog.csdn.net/qq_36421001/article/details/123009582">Linux必学的60个命令</a></p>
<h1 id="Windows常用命令"><a href="#Windows常用命令" class="headerlink" title="Windows常用命令"></a>Windows常用命令</h1><p>windows命令行工具推荐cmder</p>
<p>windows和mac下命令有所区别，使用cmder的别名功能可以进行统一</p>
<p>常用命令</p>
<ul>
<li>打开文件或文件夹：<code>explorer [path]</code></li>
<li>查看系统信息：<code>winver</code></li>
<li>计算器：<code>calc</code></li>
<li>进入文件夹：<code>cd /d c:\Users\41001\Desktop</code>：<code>/d</code>表示直接进入该盘符</li>
</ul>
<h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p><code>alias</code>命令查看别名，mac电脑好像自带了许多别名，这里做个备份，虽然大部分用不上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">alias</span></span></span><br><span class="line">-=&#x27;cd -&#x27;</span><br><span class="line">...=../..</span><br><span class="line">....=../../..</span><br><span class="line">.....=../../../..</span><br><span class="line">......=../../../../..</span><br><span class="line">1=&#x27;cd -&#x27;</span><br><span class="line">2=&#x27;cd -2&#x27;</span><br><span class="line">3=&#x27;cd -3&#x27;</span><br><span class="line">4=&#x27;cd -4&#x27;</span><br><span class="line">5=&#x27;cd -5&#x27;</span><br><span class="line">6=&#x27;cd -6&#x27;</span><br><span class="line">7=&#x27;cd -7&#x27;</span><br><span class="line">8=&#x27;cd -8&#x27;</span><br><span class="line">9=&#x27;cd -9&#x27;</span><br><span class="line">_=sudo</span><br><span class="line">afind=&#x27;ack -il&#x27;</span><br><span class="line">d=&#x27;dirs -v | head -10&#x27;</span><br><span class="line">g=git</span><br><span class="line">ga=&#x27;git add&#x27;</span><br><span class="line">gaa=&#x27;git add --all&#x27;</span><br><span class="line">gap=&#x27;git apply&#x27;</span><br><span class="line">gapa=&#x27;git add --patch&#x27;</span><br><span class="line">gau=&#x27;git add --update&#x27;</span><br><span class="line">gav=&#x27;git add --verbose&#x27;</span><br><span class="line">gb=&#x27;git branch&#x27;</span><br><span class="line">gbD=&#x27;git branch -D&#x27;</span><br><span class="line">gba=&#x27;git branch -a&#x27;</span><br><span class="line">gbd=&#x27;git branch -d&#x27;</span><br><span class="line">gbda=&#x27;git branch --no-color --merged | command grep -vE &quot;^(\*|\s*(master|develop|dev)\s*$)&quot; | command xargs -n 1 git branch -d&#x27;</span><br><span class="line">gbl=&#x27;git blame -b -w&#x27;</span><br><span class="line">gbnm=&#x27;git branch --no-merged&#x27;</span><br><span class="line">gbr=&#x27;git branch --remote&#x27;</span><br><span class="line">gbs=&#x27;git bisect&#x27;</span><br><span class="line">gbsb=&#x27;git bisect bad&#x27;</span><br><span class="line">gbsg=&#x27;git bisect good&#x27;</span><br><span class="line">gbsr=&#x27;git bisect reset&#x27;</span><br><span class="line">gbss=&#x27;git bisect start&#x27;</span><br><span class="line">gc=&#x27;git commit -v&#x27;</span><br><span class="line">&#x27;gc!&#x27;=&#x27;git commit -v --amend&#x27;</span><br><span class="line">gca=&#x27;git commit -v -a&#x27;</span><br><span class="line">&#x27;gca!&#x27;=&#x27;git commit -v -a --amend&#x27;</span><br><span class="line">gcam=&#x27;git commit -a -m&#x27;</span><br><span class="line">&#x27;gcan!&#x27;=&#x27;git commit -v -a --no-edit --amend&#x27;</span><br><span class="line">&#x27;gcans!&#x27;=&#x27;git commit -v -a -s --no-edit --amend&#x27;</span><br><span class="line">gcb=&#x27;git checkout -b&#x27;</span><br><span class="line">gcd=&#x27;git checkout develop&#x27;</span><br><span class="line">gcf=&#x27;git config --list&#x27;</span><br><span class="line">gcl=&#x27;git clone --recurse-submodules&#x27;</span><br><span class="line">gclean=&#x27;git clean -id&#x27;</span><br><span class="line">gcm=&#x27;git checkout master&#x27;</span><br><span class="line">gcmsg=&#x27;git commit -m&#x27;</span><br><span class="line">&#x27;gcn!&#x27;=&#x27;git commit -v --no-edit --amend&#x27;</span><br><span class="line">gco=&#x27;git checkout&#x27;</span><br><span class="line">gcount=&#x27;git shortlog -sn&#x27;</span><br><span class="line">gcp=&#x27;git cherry-pick&#x27;</span><br><span class="line">gcpa=&#x27;git cherry-pick --abort&#x27;</span><br><span class="line">gcpc=&#x27;git cherry-pick --continue&#x27;</span><br><span class="line">gcs=&#x27;git commit -S&#x27;</span><br><span class="line">gcsm=&#x27;git commit -s -m&#x27;</span><br><span class="line">gd=&#x27;git diff&#x27;</span><br><span class="line">gdca=&#x27;git diff --cached&#x27;</span><br><span class="line">gdct=&#x27;git describe --tags `git rev-list --tags --max-count=1`&#x27;</span><br><span class="line">gdcw=&#x27;git diff --cached --word-diff&#x27;</span><br><span class="line">gds=&#x27;git diff --staged&#x27;</span><br><span class="line">gdt=&#x27;git diff-tree --no-commit-id --name-only -r&#x27;</span><br><span class="line">gdw=&#x27;git diff --word-diff&#x27;</span><br><span class="line">gf=&#x27;git fetch&#x27;</span><br><span class="line">gfa=&#x27;git fetch --all --prune&#x27;</span><br><span class="line">gfo=&#x27;git fetch origin&#x27;</span><br><span class="line">gg=&#x27;git gui citool&#x27;</span><br><span class="line">gga=&#x27;git gui citool --amend&#x27;</span><br><span class="line">ggpull=&#x27;git pull origin &quot;$(git_current_branch)&quot;&#x27;</span><br><span class="line">ggpur=ggu</span><br><span class="line">ggpush=&#x27;git push origin &quot;$(git_current_branch)&quot;&#x27;</span><br><span class="line">ggsup=&#x27;git branch --set-upstream-to=origin/$(git_current_branch)&#x27;</span><br><span class="line">ghh=&#x27;git help&#x27;</span><br><span class="line">gignore=&#x27;git update-index --assume-unchanged&#x27;</span><br><span class="line">gignored=&#x27;git ls-files -v | grep &quot;^[[:lower:]]&quot;&#x27;</span><br><span class="line">git-svn-dcommit-push=&#x27;git svn dcommit &amp;&amp; git push github master:svntrunk&#x27;</span><br><span class="line">gk=&#x27;\gitk --all --branches&#x27;</span><br><span class="line">gke=&#x27;\gitk --all $(git log -g --pretty=%h)&#x27;</span><br><span class="line">gl=&#x27;git pull&#x27;</span><br><span class="line">glg=&#x27;git log --stat&#x27;</span><br><span class="line">glgg=&#x27;git log --graph&#x27;</span><br><span class="line">glgga=&#x27;git log --graph --decorate --all&#x27;</span><br><span class="line">glgm=&#x27;git log --graph --max-count=10&#x27;</span><br><span class="line">glgp=&#x27;git log --stat -p&#x27;</span><br><span class="line">glo=&#x27;git log --oneline --decorate&#x27;</span><br><span class="line">globurl=&#x27;noglob urlglobber &#x27;</span><br><span class="line">glod=&#x27;git log --graph --pretty=&#x27;\&#x27;&#x27;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset&#x27;\&#x27;</span><br><span class="line">glods=&#x27;git log --graph --pretty=&#x27;\&#x27;&#x27;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset&#x27;\&#x27;&#x27; --date=short&#x27;</span><br><span class="line">glog=&#x27;git log --oneline --decorate --graph&#x27;</span><br><span class="line">gloga=&#x27;git log --oneline --decorate --graph --all&#x27;</span><br><span class="line">glol=&#x27;git log --graph --pretty=&#x27;\&#x27;&#x27;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;\&#x27;</span><br><span class="line">glola=&#x27;git log --graph --pretty=&#x27;\&#x27;&#x27;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;\&#x27;&#x27; --all&#x27;</span><br><span class="line">glols=&#x27;git log --graph --pretty=&#x27;\&#x27;&#x27;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;\&#x27;&#x27; --stat&#x27;</span><br><span class="line">glp=_git_log_prettily</span><br><span class="line">glum=&#x27;git pull upstream master&#x27;</span><br><span class="line">gm=&#x27;git merge&#x27;</span><br><span class="line">gma=&#x27;git merge --abort&#x27;</span><br><span class="line">gmom=&#x27;git merge origin/master&#x27;</span><br><span class="line">gmt=&#x27;git mergetool --no-prompt&#x27;</span><br><span class="line">gmtvim=&#x27;git mergetool --no-prompt --tool=vimdiff&#x27;</span><br><span class="line">gmum=&#x27;git merge upstream/master&#x27;</span><br><span class="line">gp=&#x27;git push&#x27;</span><br><span class="line">gpd=&#x27;git push --dry-run&#x27;</span><br><span class="line">gpf=&#x27;git push --force-with-lease&#x27;</span><br><span class="line">&#x27;gpf!&#x27;=&#x27;git push --force&#x27;</span><br><span class="line">gpoat=&#x27;git push origin --all &amp;&amp; git push origin --tags&#x27;</span><br><span class="line">gpristine=&#x27;git reset --hard &amp;&amp; git clean -dfx&#x27;</span><br><span class="line">gpsup=&#x27;git push --set-upstream origin $(git_current_branch)&#x27;</span><br><span class="line">gpu=&#x27;git push upstream&#x27;</span><br><span class="line">gpv=&#x27;git push -v&#x27;</span><br><span class="line">gr=&#x27;git remote&#x27;</span><br><span class="line">gra=&#x27;git remote add&#x27;</span><br><span class="line">grb=&#x27;git rebase&#x27;</span><br><span class="line">grba=&#x27;git rebase --abort&#x27;</span><br><span class="line">grbc=&#x27;git rebase --continue&#x27;</span><br><span class="line">grbd=&#x27;git rebase develop&#x27;</span><br><span class="line">grbi=&#x27;git rebase -i&#x27;</span><br><span class="line">grbm=&#x27;git rebase master&#x27;</span><br><span class="line">grbs=&#x27;git rebase --skip&#x27;</span><br><span class="line">grep=&#x27;grep  --color=auto --exclude-dir=&#123;.bzr,CVS,.git,.hg,.svn&#125;&#x27;</span><br><span class="line">grh=&#x27;git reset&#x27;</span><br><span class="line">grhh=&#x27;git reset --hard&#x27;</span><br><span class="line">grm=&#x27;git rm&#x27;</span><br><span class="line">grmc=&#x27;git rm --cached&#x27;</span><br><span class="line">grmv=&#x27;git remote rename&#x27;</span><br><span class="line">groh=&#x27;git reset origin/$(git_current_branch) --hard&#x27;</span><br><span class="line">grrm=&#x27;git remote remove&#x27;</span><br><span class="line">grset=&#x27;git remote set-url&#x27;</span><br><span class="line">grt=&#x27;cd &quot;$(git rev-parse --show-toplevel || echo .)&quot;&#x27;</span><br><span class="line">gru=&#x27;git reset --&#x27;</span><br><span class="line">grup=&#x27;git remote update&#x27;</span><br><span class="line">grv=&#x27;git remote -v&#x27;</span><br><span class="line">gsb=&#x27;git status -sb&#x27;</span><br><span class="line">gsd=&#x27;git svn dcommit&#x27;</span><br><span class="line">gsh=&#x27;git show&#x27;</span><br><span class="line">gsi=&#x27;git submodule init&#x27;</span><br><span class="line">gsps=&#x27;git show --pretty=short --show-signature&#x27;</span><br><span class="line">gsr=&#x27;git svn rebase&#x27;</span><br><span class="line">gss=&#x27;git status -s&#x27;</span><br><span class="line">gst=&#x27;git status&#x27;</span><br><span class="line">gsta=&#x27;git stash push&#x27;</span><br><span class="line">gstaa=&#x27;git stash apply&#x27;</span><br><span class="line">gstall=&#x27;git stash --all&#x27;</span><br><span class="line">gstc=&#x27;git stash clear&#x27;</span><br><span class="line">gstd=&#x27;git stash drop&#x27;</span><br><span class="line">gstl=&#x27;git stash list&#x27;</span><br><span class="line">gstp=&#x27;git stash pop&#x27;</span><br><span class="line">gsts=&#x27;git stash show --text&#x27;</span><br><span class="line">gsu=&#x27;git submodule update&#x27;</span><br><span class="line">gtl=&#x27;gtl()&#123; git tag --sort=-v:refname -n -l $&#123;1&#125;* &#125;; noglob gtl&#x27;</span><br><span class="line">gts=&#x27;git tag -s&#x27;</span><br><span class="line">gtv=&#x27;git tag | sort -V&#x27;</span><br><span class="line">gunignore=&#x27;git update-index --no-assume-unchanged&#x27;</span><br><span class="line">gunwip=&#x27;git log -n 1 | grep -q -c &quot;\-\-wip\-\-&quot; &amp;&amp; git reset HEAD~1&#x27;</span><br><span class="line">gup=&#x27;git pull --rebase&#x27;</span><br><span class="line">gupa=&#x27;git pull --rebase --autostash&#x27;</span><br><span class="line">gupav=&#x27;git pull --rebase --autostash -v&#x27;</span><br><span class="line">gupv=&#x27;git pull --rebase -v&#x27;</span><br><span class="line">gwch=&#x27;git whatchanged -p --abbrev-commit --pretty=medium&#x27;</span><br><span class="line">gwip=&#x27;git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify --no-gpg-sign -m &quot;--wip-- [skip ci]&quot;&#x27;</span><br><span class="line">history=omz_history</span><br><span class="line">jadx-gui=&#x27;cd /Users/Afauria/AndroidStudioProjects/jadx/build/jadx&amp;&amp;bin/jadx-gui lib/jadx-core-*.jar&#x27;</span><br><span class="line">l=&#x27;ls -lah&#x27;</span><br><span class="line">la=&#x27;ls -lAh&#x27;</span><br><span class="line">ll=&#x27;ls -lh&#x27;</span><br><span class="line">ls=&#x27;ls -G&#x27;</span><br><span class="line">lsa=&#x27;ls -lah&#x27;</span><br><span class="line">md=&#x27;mkdir -p&#x27;</span><br><span class="line">rd=rmdir</span><br><span class="line">run-help=man</span><br><span class="line">tips=&#x27;~/tip.sh&#x27;</span><br><span class="line">which-command=whence</span><br></pre></td></tr></table></figure>




<p>dart frontend_server.dart.snapshot –target=flutter –aot –tfa -Ddart.vm.profile=false -Ddart.vm.product=true –sdk-root /ssd2/zhangweiyue/flutter/common/flutter_patched_sdk –output-dill app.dill /ssd2/afauria/demo/lib/main.dart</p>
<p>/disk3/afauria/code/flutter_engine/engine_sdk/sdk/clang_x64/gen_snapshot –snapshot_kind=app-aot-elf –elf=libapp.so app.dill</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>快捷键笔记</title>
    <url>/2018/10/04/note-2018-10-04-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="命令行常用快捷键"><a href="#命令行常用快捷键" class="headerlink" title="命令行常用快捷键"></a>命令行常用快捷键</h1><p>光标移动：<br><code>ctrl+a</code>：移动到行首<br><code>ctrl+e</code>：移动到行尾<br><code>option+左右</code>：以单词为单位移动</p>
<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><p>光标移动：<br>b：前移一个单词词首<br>w：后移一个单词词首<br>e：后移一个单词词尾<br>nw、nb：n为数字，表示移动n个单词<br>0：移到行首<br>^：移到行首，不包括空格<br>$：移到行尾</p>
<p>vi文档内搜索：/搜索内容，n键跳到下一处位置</p>
<h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><p><code>command+f12（File Structure）</code>：打开类结构<br><code>ctrl+h（Type Hierarchy）</code>：打开类继承关系<br><code>ctrl+tab</code>：切换tab<br><code>option+左右</code>：单词移动</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记</title>
    <url>/2018/10/04/tool-2018-10-04-Git/</url>
    <content><![CDATA[<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><p>工作区</p>
<p>暂存区</p>
<p>版本库</p>
<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><p>//todo</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul>
<li><code>git diff --cached </code>：比较暂存区和版本库</li>
<li><code>git diff</code>：比较工作区和版本库</li>
<li><code>git patch/git am</code>：生成补丁、打补丁</li>
<li><code>git log 文件名</code>：查看某个文件的修改历史<ul>
<li>-3：查看最近三个提交</li>
<li>–stat：查看修改了哪些文件，不看文件细节</li>
</ul>
</li>
<li><code>git reset head</code>：取消暂存，使用别名<code>git unstage</code></li>
<li><code>git reset</code>：默认不修改文件，只修改Git记录。–hard同时修改文件，</li>
<li><code>git checkout &lt;file&gt;</code>:取消修改，回退到版本库</li>
<li><code>git revert &lt;commit-id&gt;</code>：撤销中间的某个版本，生成一个新的提交</li>
<li><code>git merge &lt;side2：合并到当前分支&gt;</code></li>
<li><code>git cherry-pick &lt;commit-id&gt;</code>：copy一个版本到当前分支，不出现交叉，不影响被copy的分支</li>
<li><code>git rebase side1 [side2:结构上side2在side1后面，side2省略的话，会将当前分支加到side1后面]</code>。第一个参数是基，第二个参数是要生成的补丁。side1省略的话相当于git rebase origin/head head。</li>
<li><code>git remote prune origin</code>。远程分支已删除，本地未同步。通过git remote show origin查看，根据提示使用git remote prune origin同步已删除的分支</li>
<li><code>git commit --amend</code>:修改最后一次提交信息</li>
<li>合并最后两个提交：<ul>
<li><code>git rebase -i 倒数第三个commit</code></li>
<li>pick第一个，squash第二个</li>
</ul>
</li>
<li>修改倒数第二次提交信息：<ul>
<li>git rebase -i head~2（倒数第三个commit）。</li>
<li>将相应commit的pick改为edit</li>
<li>退出编辑</li>
<li>git commit –amend 修改提交信息。</li>
<li>git rebase –continue：恢复提交</li>
</ul>
</li>
<li><code>git blame &lt;file&gt;</code>显示文件每一行修改版本和作者</li>
<li><code>git count-objects -vH</code>：查看仓库大小</li>
<li><code>git gc</code>：Git垃圾回收</li>
</ul>
<h1 id="clone和fork"><a href="#clone和fork" class="headerlink" title="clone和fork"></a>clone和fork</h1><p>clone：将远程代码仓库A克隆到本地，如果不是Contributor，则无法将自己的提交push到仓库A中</p>
<p>fork：是GitHub提供的功能，将远程代码仓库A复制一份到自己的GitHub远程仓库B中，提交之后push到B。如果希望原作者合入你的修改，可以创建pull request，意思是请求对方拉取你的修改，如果原作者同意的话，就会将你的提交更新到仓库A中。</p>
<p>fork之后如果原项目更新了，如何同步原项目的修改？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置upstream为原仓库连接，origin为自己fork的仓库连接</span></span><br><span class="line">git remote add upstream 原仓库地址</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取该连接的修改</span></span><br><span class="line">git fetch upstream</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并远程仓库的修改</span></span><br><span class="line">git merge upstream/master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送修改到fork后的仓库</span></span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li><code>.gitkeep</code>：git无法追踪空文件夹，当需要追踪空文件夹时，可以创建一个<code>.gitkeep</code>文件放在这些文件夹中</li>
<li><code>.gitignore</code>：配置git忽略哪些文件，可以使用路径通配符</li>
</ul>
<h1 id="Git-Flow工作流"><a href="#Git-Flow工作流" class="headerlink" title="Git-Flow工作流"></a>Git-Flow工作流</h1><p>//todo</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>一直在用Git，但是缺少总结，这里占个坑，有时间再补。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a>：Git可视化学习</li>
<li><a href="https://juejin.cn/post/6895246702614806542">Git各指令的本质，真是通俗易懂啊</a></li>
<li><a href="https://blog.islinjw.cn/2020/08/21/Git%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/">Git是怎么工作的</a></li>
<li><a href="https://git-scm.com/book/en/v2">Pro Git书籍</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程-廖雪峰</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android依赖配置</title>
    <url>/2018/08/04/android-2018-08-04-DependenciesNote/</url>
    <content><![CDATA[<h2 id="Gradle依赖配置"><a href="#Gradle依赖配置" class="headerlink" title="Gradle依赖配置"></a>Gradle依赖配置</h2><h3 id="implementation和api"><a href="#implementation和api" class="headerlink" title="implementation和api"></a>implementation和api</h3><p><code>implementation</code>：依赖隔离</p>
<p><code>api</code>：依赖传递，相当于原来的<code>compile</code></p>
<p>从3.4版本的gradle开始，compile已经被api与implementation取代</p>
<p>compileOnly：只在编译时引用，只能保证代码能编过，运行的时候会由于找不到类失败</p>
<h2 id="常用框架、依赖库配置"><a href="#常用框架、依赖库配置" class="headerlink" title="常用框架、依赖库配置"></a>常用框架、依赖库配置</h2><h3 id="ButterKnife配置和使用"><a href="#ButterKnife配置和使用" class="headerlink" title="ButterKnife配置和使用"></a>ButterKnife配置和使用</h3><ol>
<li>base module中添加依赖<code>api rootProject.ext.dependencies[&quot;butterknife&quot;]</code></li>
<li>library module添加注解处理器<code>annotationProcessor rootProject.ext.dependencies[&quot;butterknife-compiler&quot;]</code></li>
<li>library module添加butterknife插件：在模块的build.gradle顶部添加<code>apply plugin: &#39;com.jakewharton.butterknife&#39;</code></li>
<li>project module引用插件依赖：在工程的build.gradle–&gt;buildscript–&gt;dependencies中添加<code>classpath &quot;com.jakewharton:butterknife-gradle-plugin:8.4.0&quot;</code></li>
<li><code>@BindView(R.id.**)</code>改成<code>@BindView(R2.id.**)</code></li>
</ol>
<p>注意：</p>
<ul>
<li>缺少第3，4步会报<code>attribute value must be constant……</code>问题</li>
<li>缺少第2步会报空指针</li>
<li>不同butterknife版本和gradle版本配置会有所不同。有时候会出现问题，具体怎么解决的忘了，有空再补</li>
</ul>
<p>补充：</p>
<p><strong>APT</strong>(Annotation Processing Tool)即<strong>注解处理器</strong>，是一种处理注解的工具，确切的说它是javac的一个工具，它用来在<strong>编译时</strong>扫描和处理注解。注解处理器以<strong>Java代码</strong>(或者编译过的字节码)作为输入，生成**.java文件<strong>作为输出。<br> 简单来说就是在编译期，通过注解生成</strong>.java**文件。摘自<a href="ttps://www.jianshu.com/p/7af58e8e3e18">【Android】APT</a></p>
<h3 id="ARouter配置"><a href="#ARouter配置" class="headerlink" title="ARouter配置"></a>ARouter配置</h3><ol>
<li><p>base module中添加依赖api rootProject.ext.dependencies[“arouter”]</p>
</li>
<li><p>所有的module中添加</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">javaCompileOptions &#123;</span><br><span class="line">	annotationProcessorOptions &#123;</span><br><span class="line">		arguments = [<span class="attr">moduleName:</span> project.getName()]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>路由页面使用@Route注解@Route(path = “/homepage/HomePageActivity”)，路径前必须带/</p>
</li>
<li><p>跳转使用ARouter.getInstance().build(“/homepage/HomePageActivity”).navigation();</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Mina心跳检测实现</title>
    <url>/2018/07/24/network-2018-07-24-MinaHeartbeat/</url>
    <content><![CDATA[<p>上一篇文章讲了Mina的简单使用，这一篇将要讲讲怎么用Mina实现心跳检测。网上有很多相关的文章，但是我觉得比较难理解，自己折腾了好久才明白，所以想用我觉得容易理解的话总结一下。也给自己做个笔记。</p>
<h1 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h1><p>​    1.心跳机制有什么用？<br>在TCP的长连接中，有可能两端有很长一段时间没有数据往来，理论上连接应该是一直保持的。但实际情况中，如果中间节点出现故障，连接断开（如防火墙，或者断网等），这时候故障是难以知道的。</p>
<p>比如客户端因为某种情况断开了连接，服务端并不会收到消息，可能还傻傻的等待对方发送消息过来。反过来也一样。</p>
<p>所以发明了心跳机制来维持长连接，保活。</p>
<p>​    2.心跳机制是什么？</p>
<p>心跳机制原理很简单，就是客户端每隔一段时间发送一个“请求心跳包”到服务端，服务端收到“请求心跳包”之后回复一个心跳包，客户端接收到“回复心跳包”后判断连接正常。</p>
<p>如果客户端“在一定时间（即超时时间）”没有收到回复包则表示中间出错了，可以尝试重新连接或者做出相应的操作。</p>
<p>当然一般我们会设置一个变量，“多次判断”有没有收到回复包。比如3次没收到回复包，才判断连接出错。如果收到了回复包，则把变量重置为0。</p>
<p>由谁（客户端还是服务端）发起请求其实都一样，当然也可以两边都发，具体情况看需求和方便性。比如为了减轻服务端压力，由客户端发出请求较合适。</p>
<p><img src="/2018/07/24/network-2018-07-24-MinaHeartbeat/mina_heartbeat01.png" alt="mina心跳包01"></p>
<p>​    3.心跳包是什么？</p>
<p>心跳包其实就是双方规定的一个信息，可以是一个数字、一串字符、也可以是一个结构对象，只要接收方能够判断就行。</p>
<p>我把发出请求的心跳包叫做心跳请求包，把回复的心跳包叫做心跳回复包。</p>
<p>心跳包之所以叫心跳包是因为：他像心跳一样每隔一定时间发送一次，以此告诉对方，自己还活着。</p>
<h1 id="Mina实现心跳机制"><a href="#Mina实现心跳机制" class="headerlink" title="Mina实现心跳机制"></a>Mina实现心跳机制</h1><p>​    上一篇文章讲了Mina的简单使用，我们通过设置IoHandler来处理业务逻辑，IoHandler中有messageReceived方法，当接收到消息时回调此方法。</p>
<p>​    <strong>1.很容易想到的方法</strong></p>
<p>所以我们很容易想到，只要在任何一端（假设为A端）设置一个定时器，定时发送一个心跳请求包。然后在另一端（假设为B端）的messageReceived方法中判断接收到的消息是不是心跳请求包。如果是，则发出一个心跳回复包，同样在A端的messageReceived方法中判断接收到的消息是不是一个心跳回复包。如果是则判断连接成功。</p>
<p>​    <strong>2.定时器</strong></p>
<p>上面说的思路肯定是能够实现的，现在我们来说下这个定时器怎么设置。</p>
<p>上一篇文章中还提到了一个函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数会在判断当前Session为闲置状态时，每隔10S调用一次IoHandler的sessionIdle方法，因此我们可以使用这个函数设置合适的时间，在sessionIdle中发出心跳请求包，就不用自己写一个定时器了。</p>
<p>​    <strong>3.这么容易满足吗？</strong></p>
<p>上面说的已经能够实现正常的心跳机制了。但是把所有的代码和判断都放在IoHandler的业务逻辑处理中，是否不够优雅？</p>
<p>在上篇文章中，我们提到了消息是通过IoService接收，通过层层拦截器IoFilterChain，然后才传递到IoHandler中进行业务逻辑处理，处理之后的发送也需要通过层层拦截器才能发送出去。</p>
<p>因此我们想心跳包检测要是能在拦截器阶段就被消费掉，是否就不用传递到IoHandler中了，IoHandler就可以只处理业务逻辑，将心跳检测独立出来。</p>
<p>很庆幸，Mina已经将这个拦截器给我们封装好了，我们只需要知道如何使用即可。</p>
<p>​    <strong>4.Mina的心跳检测拦截器/过滤器</strong></p>
<p><strong>创建拦截器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            <span class="comment">//实现KeepAliveMessageFactory接口方法</span></span><br><span class="line">            HeartRequestFactoryImpl heartRequestFactory = <span class="keyword">new</span> HeartRequestFactoryImpl();</span><br><span class="line">            <span class="comment">//创建拦截器，第一个参数是心跳处理接口，第二个参数是心跳超时处理接口</span></span><br><span class="line">            KeepAliveFilter kaf = <span class="keyword">new</span> KeepAliveFilter(heartRequestFactory, <span class="keyword">new</span> KeepAliveRequestTimeoutHandlerImpl());</span><br><span class="line">            <span class="comment">//设置请求间隔，单位s</span></span><br><span class="line">            kaf.setRequestInterval(<span class="number">20</span>);</span><br><span class="line">            <span class="comment">//设置超时时间</span></span><br><span class="line">            kaf.setRequestTimeout(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//设置是否forward到下一个filter,默认为false</span></span><br><span class="line"><span class="comment">//            kaf.setForwardEvent(true);</span></span><br><span class="line">            acceptor.getFilterChain().addLast(<span class="string">&quot;heart&quot;</span>, kaf);</span><br></pre></td></tr></table></figure>


<p><strong>需要注意的是：</strong></p>
<p>（1）客户端也需要添加心跳检测拦截器，只不过KeepAliveMessageFactory实现方法不同</p>
<p>（2）由服务端发出心跳请求包的话，客户端不需要实现超时处理方法，即KeepAliveRequestTimeoutHandler。超时方法是一定时间内没有收到“心跳回复包”才调用的，而客户端只会收到心跳请求包，不会收到心跳回复包</p>
<p>我们需要做的主要是实现KeepAliveMessageFactory接口方法</p>
<p>有四个方法，isRequest，isResponse，getRequest，getResponse需要我们实现，这些方法具体作用如下：</p>
<p>isRequest：判断接收到的消息是不是心跳请求包<br>isResponse：判断接收到的消息是不是心跳回复包<br>getRequest：获取心跳请求包<br>getResponse：获取心跳回复包</p>
<p><strong>关键要理解这些方法返回值的含义和调用时机：</strong></p>
<p>以服务端发送心跳请求包为例（反过来也一样），流程如下：<br><img src="/2018/07/24/network-2018-07-24-MinaHeartbeat/mina_heartbeat02.png" alt="mina心跳包02"></p>
<p>可以看到，客户端和服务端都需要创建拦截器，实现KeepAliveMessageFactory接口方法，只不过写法不一样。其他的发送消息流程并不需要关心</p>
<p>除此之外，发送请求包的一方还可以实现超时处理接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepAliveRequestTimeoutHandlerImpl</span> <span class="keyword">implements</span> <span class="title">KeepAliveRequestTimeoutHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//在超时时间范围内没有收到消息会调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keepAliveRequestTimedOut</span><span class="params">(KeepAliveFilter keepAliveFilter, IoSession ioSession)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;心跳超时！&quot;</span>);<span class="comment">//做出相应处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>分析源码：</strong></p>
<p>心跳拦截器KeepAliveFliter源码，关键部分如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(NextFilter nextFilter, IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.messageFactory.isRequest(session, message)) &#123;</span><br><span class="line">            Object pongMessage = <span class="keyword">this</span>.messageFactory.getResponse(session, message);</span><br><span class="line">            <span class="keyword">if</span>(pongMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nextFilter.filterWrite(session, <span class="keyword">new</span> DefaultWriteRequest(pongMessage));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.messageFactory.isResponse(session, message)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resetStatus(session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.isKeepAliveMessage(session, message)) &#123;</span><br><span class="line">            nextFilter.messageReceived(session, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(NextFilter nextFilter, IoSession session, WriteRequest writeRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object message = writeRequest.getMessage();</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.isKeepAliveMessage(session, message)) &#123;</span><br><span class="line">        nextFilter.messageSent(session, writeRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(NextFilter nextFilter, IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(status == <span class="keyword">this</span>.interestedIdleStatus) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!session.containsAttribute(<span class="keyword">this</span>.WAITING_FOR_RESPONSE)) &#123;</span><br><span class="line">            Object pingMessage = <span class="keyword">this</span>.messageFactory.getRequest(session);</span><br><span class="line">            <span class="keyword">if</span>(pingMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nextFilter.filterWrite(session, <span class="keyword">new</span> DefaultWriteRequest(pingMessage));</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.getRequestTimeoutHandler() != KeepAliveRequestTimeoutHandler.DEAF_SPEAKER) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.markStatus(session);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.interestedIdleStatus == IdleStatus.BOTH_IDLE) &#123;</span><br><span class="line">                        session.setAttribute(<span class="keyword">this</span>.IGNORE_READER_IDLE_ONCE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resetStatus(session);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.handlePingTimeout(session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == IdleStatus.READER_IDLE &amp;&amp; session.removeAttribute(<span class="keyword">this</span>.IGNORE_READER_IDLE_ONCE) == <span class="keyword">null</span> &amp;&amp; session.containsAttribute(<span class="keyword">this</span>.WAITING_FOR_RESPONSE)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handlePingTimeout(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.forwardEvent) &#123;</span><br><span class="line">        nextFilter.sessionIdle(session, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）我们设置了setRequestInterval，每隔一定时间就会调用sessionIdle方法，该方法最主要的就是下面几句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object pingMessage = <span class="keyword">this</span>.messageFactory.getRequest(session);<span class="comment">//调用getRequest获得返回值</span></span><br><span class="line"><span class="keyword">if</span>(pingMessage != <span class="keyword">null</span>) &#123;                                        <span class="comment">//如果有返回值</span></span><br><span class="line">    nextFilter.filterWrite(session, <span class="keyword">new</span> DefaultWriteRequest(pingMessage));<span class="comment">//将该该返回值发送出去，因此该返回值表示的含义就是心跳请求包</span></span><br><span class="line">    …………                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>即如果getRequest方法设置了返回值，就会将该返回值发送出去，所以这个返回值的意义就是“心跳请求包”。</p>
<p>（2）客户端收到消息，会调用拦截器的messageReceived方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.messageFactory.isRequest(session, message)) &#123;<span class="comment">//我们在isRequest方法中判断接收到的是不是心跳请求包，如果是返回为true</span></span><br><span class="line">        Object pongMessage = <span class="keyword">this</span>.messageFactory.getResponse(session, message);<span class="comment">//然后调用getResponse方法获得返回值</span></span><br><span class="line">        <span class="keyword">if</span>(pongMessage != <span class="keyword">null</span>) &#123;                                                <span class="comment">//如果有返回值</span></span><br><span class="line">            nextFilter.filterWrite(session, <span class="keyword">new</span> DefaultWriteRequest(pongMessage));<span class="comment">//则将该返回值发送出去，因此该返回值的意义就是心跳回复包</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.messageFactory.isResponse(session, message)) &#123;<span class="comment">//我们在isResponse方法中判断接收到的是不是心跳回复包，如果是返回为true</span></span><br><span class="line">        <span class="keyword">this</span>.resetStatus(session);                        <span class="comment">//接收到了心跳回复包，需要重置状态，如重新开始计时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.isKeepAliveMessage(session, message)) &#123;<span class="comment">//该方法执行了一遍isRequest和isResponse，如果接收到的消息既不是心跳请求包，也不是回复包</span></span><br><span class="line">        nextFilter.messageReceived(session, message);<span class="comment">//则将该消息往下传递，即交给下个拦截器或者交给Handler的messageReceive方法处理</span></span><br><span class="line">    &#125;<span class="comment">//如果接收到的消息是心跳请求包“或者”心跳回复包，则在上面几句中就已经将该消息消费掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面还有一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            <span class="comment">//设置是否forward到下一个filter,默认为false</span></span><br><span class="line"><span class="comment">//            kaf.setForwardEvent(true);</span></span><br></pre></td></tr></table></figure>


<p>这句话的作用从源码中可以看出来，源码的sessionIdle方法后面有这么一段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.forwardEvent) &#123;</span><br><span class="line">    nextFilter.sessionIdle(session, status);<span class="comment">//如果设置为true，会将该状态往下传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>不知道大家还记不记得IoHandler里面也有sessionIdle方法，上面已经讲过，它的调用时机是通过setIdleTime来设置的，而setForwardEvent设置为false的话，则会将Idle事件拦截掉，不往下传递到IoHandle的sessionIdle，即该方法失效。</p>
<p>总的来说，就是设置了setRequestInterval的话，则设置setIdleTime将会失去意义。</p>
<p>以上是我的理解，如有谬误，恳请各位前辈指出。有不懂得也可以留言。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC和RPC框架【转载】</title>
    <url>/2018/07/24/network-2018-07-25-RPC/</url>
    <content><![CDATA[<h2 id="转载"><a href="#转载" class="headerlink" title="[转载]"></a>[转载]</h2><p>作者：EnjoyMoving</p>
<p>链接：<a href="https://www.zhihu.com/question/25536695/answer/285844835">https://www.zhihu.com/question/25536695/answer/285844835</a></p>
<p>RPC：远程调用。通过RPC框架，使得我们可以像调用本地方法一样地调用远程机器上的方法：</p>
<p>1、本地调用某个函数方法</p>
<p>2、本地机器的RPC框架把这个调用信息封装起来（调用的函数、入参等），序列化(json、xml等)后，通过网络传输发送给远程服务器</p>
<p>3、远程服务器收到调用请求后，远程机器的RPC框架反序列化获得调用信息，并根据调用信息定位到实际要执行的方法，执行完这个方法后，序列化执行结果，通过网络传输把执行结果发送回本地机器</p>
<p>4、本地机器的RPC框架反序列化出执行结果，函数return这个结果</p>
<p>服务调用端（本地机器）：</p>
<p><img src="/2018/07/24/network-2018-07-25-RPC/RPC01.png" alt="img"></p>
<p>服务提供端（远程机器）：</p>
<p><img src="/2018/07/24/network-2018-07-25-RPC/RPC02.png" alt="img"></p>
<p>Java Netty 是在TCP(Socket)层对nio进行封装的框架，在RPC框架中可用于解决网络传输问题。</p>
<p>现在流行的微服务框架（dubbo、spring cloud等），实际上就是各种各样的RPC框架</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程和Mina入门</title>
    <url>/2018/07/23/network-2018-07-23-Mina/</url>
    <content><![CDATA[<h1 id="网络编程的一些知识点"><a href="#网络编程的一些知识点" class="headerlink" title="网络编程的一些知识点"></a>网络编程的一些知识点</h1><ol>
<li>首先需要知道网络的几层架构，有好几种分类方式，如五层架构：物理层、数据链路层、网络层、传输层、应用层。其中IP是网络层协议，IP协议用于在互联网中找到对应的主机，TCP和UDP是传输层协议，应用层协议就很多了，最常用的就是HTTP协议。 </li>
<li>了解整个网络的过程是怎么样的很重要，以后学到的才可以一一对应进去。 </li>
<li>然后一些相关概念要掌握：ip、端口、协议、服务器、Socket（客户端、服务端等）、线程、阻塞、非阻塞、长连接、短连接、心跳机制（用于维持长连接的技术）、RPC（远程过程调用）、还有许多相关的协议。 </li>
</ol>
<h2 id="一些注意的点："><a href="#一些注意的点：" class="headerlink" title="一些注意的点："></a>一些注意的点：</h2><ol>
<li>TCP是传输层协议，主要用于建立连接。我们常说的Socket连接、Http连接等其实指的就是TCP连接。</li>
<li>网络是语言无关的，所以可以用两种不同的语言实现TCP连接，然后进行通信。</li>
<li>长连接和短连接是相对的：但都是TCP连接</li>
<li>对于HTTP协议，它是基于TCP/IP协议的。HTTP连接指的是TCP连接，TCP建立连接后，HTTP可以在这条连接上发出请求， 还有接受响应。因此HTTP连接叫做Http请求和Http响应更为合适。</li>
<li>HTTP1.0默认是短连接，即完成一次网络请求就断开连接（发出HTTP请求并且接受到响应的过程）。</li>
<li>HTTP1.1可以长连接，即客户端和服务端都不调用close方法。</li>
<li>UDP是无连接、不可靠的。不可靠是相对的：不保证传输的到，不保证按顺序到达，不保证错误重发等。不过可以通过代码控制来保证。</li>
</ol>
<h1 id="Mina入门"><a href="#Mina入门" class="headerlink" title="Mina入门"></a>Mina入门</h1><h2 id="Mina是什么？"><a href="#Mina是什么？" class="headerlink" title="Mina是什么？"></a>Mina是什么？</h2><p>Apache Mina是一个网络通信应用框架，实现了java NIO（非阻塞）技术，支持多种协议，能够帮助我们快速进行网络开发。 </p>
<p>除了mina框架外，还有netty框架。</p>
<h2 id="为什么要有Mina？"><a href="#为什么要有Mina？" class="headerlink" title="为什么要有Mina？"></a>为什么要有Mina？</h2><p>TCP和UDP较为高深。Socket对TCP和UDP的接口进行了封装，方便程序员使用，程序员可以通过socket 创建服务端和客户端，建立连接，进行通信。</p>
<p>但是使用Socket会有很多线程还有并发的问题需要解决（可以使用线程池，异步IO等方法），java NIO技术就是为了解决这些而提出的一套方案。</p>
<p>但是java NIO编程也很复杂，因此开发出了Mina框架，让我们能够快速的进行网络编程，而不用自己去实现一套NIO方案。Mina除了实现底层IO操作外，还支持多种协议的通信，总之是十分强大的一套框架。</p>
<p>在Mina之上还有一些第三方平台可以实现网络通讯功能，如融云等，当然借助第三方平台也受限于第三方平台。简单的项目用第三方平台是完全没问题的。</p>
<h2 id="Mina工作流程？"><a href="#Mina工作流程？" class="headerlink" title="Mina工作流程？"></a>Mina工作流程？</h2><p><img src="/2018/07/23/network-2018-07-23-Mina/mina01.png" alt="Mina流程"></p>
<ol>
<li><p>IoService：封装了IO操作，我们只需要使用即可，不需要自己实现异步和线程</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IoAcceptor和IoConnector都实现了IoService接口，其中</span><br><span class="line">	IoAcceptor创建服务端口，用于接受连接</span><br><span class="line">	IoConnector创建与服务端的连接</span><br></pre></td></tr></table></figure></li>
<li><p>IoFilterChain：过滤器/拦截器，对数据进行过滤或拦截，Mina自带许多封装好的过滤器，当然我们也可以自己实现</p>
</li>
<li><p>IoHandler：提供回调方法，我们只需要在里面实现业务逻辑。</p>
</li>
</ol>
<p>流程如图所示，因此我们编写代码也是按这个步骤。客户端和服务端代码基本相同，步骤如下：</p>
<ol>
<li>首先创建IoService</li>
<li>添加过滤器/拦截器IoFilterChain</li>
<li>实现IoHandler对数据进行业务逻辑处理</li>
</ol>
<h2 id="怎么用Mina？"><a href="#怎么用Mina？" class="headerlink" title="怎么用Mina？"></a>怎么用Mina？</h2><p>首先去<a href="%22http://mina.apache.org/downloads-mina.html%22">官网</a>下载mina包，导入这两个包（必须），Mina还有很多其他的包和功能，在这里就不介绍了，其实我也不会。 </p>
<p>Binaries是jar包，Sources是源码</p>
<p><img src="/2018/07/23/network-2018-07-23-Mina/mina02.png" alt="导入包"></p>
<h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第一步，新建accepter：服务端（等待客户端连接，所以命名为acceptor）</span></span><br><span class="line">            NioSocketAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">            <span class="comment">// 第二步，设置Handler，需要实现IOHandler接口，用于处理消息（主要有创建、连接、接收、发送、关闭、异常、闲置7个状态回调）</span></span><br><span class="line">            acceptor.setHandler(<span class="keyword">new</span> MinaServerHandler());</span><br><span class="line">            <span class="comment">// 第三步，设置拦截器</span></span><br><span class="line">            <span class="comment">//设置log拦截器</span></span><br><span class="line">            acceptor.getFilterChain().addLast(<span class="string">&quot;log&quot;</span>, <span class="keyword">new</span> LoggingFilter());</span><br><span class="line">            <span class="comment">//设定消息编码规则拦截器</span></span><br><span class="line">            acceptor.getFilterChain().addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory()));</span><br><span class="line">           <span class="comment">//添加socket配置</span></span><br><span class="line">            <span class="comment">/*设置读取数据缓冲区大小</span></span><br><span class="line"><span class="comment">            指定缓冲区大小以通知底层操作系统为读取的数据分配多少空间。*/</span></span><br><span class="line">            acceptor.getSessionConfig().setReadBufferSize(<span class="number">2048</span>);</span><br><span class="line">            <span class="comment">/*指定了什么时候检查空闲 session。</span></span><br><span class="line"><span class="comment">            第一个参数用于判断session是否闲置的条件</span></span><br><span class="line"><span class="comment">            有三个状态：1.不读取也不写入时判断为闲置，2.不读取时判断为闲置，3.不写入时判断为闲置，默认为2</span></span><br><span class="line"><span class="comment">            第二个参数表示session闲置时在10秒后调用Handler的sessionIdle方法。*/</span></span><br><span class="line">            acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 第四步，创建端口，等待连接，端口号2001，客户端需要连接到该端口</span></span><br><span class="line">            acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">2001</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaServerHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;<span class="comment">//Mina会自动调用这些方法，具体要在什么时候做什么需要自行实现</span></span><br><span class="line">    <span class="comment">//发生异常回调，可打印异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端捕捉：&quot;</span> + cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收到消息时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端消息接收：&quot;</span> + message.toString());</span><br><span class="line">        <span class="comment">//收到客户端消息为quit时，关闭该会话</span></span><br><span class="line">        <span class="keyword">if</span> (message.toString().trim().equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">            session.closeNow();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向客户端发送消息，会调用messageSent</span></span><br><span class="line">        session.write(<span class="string">&quot;回复消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送消息成功时调用，注意发送消息不能用这个方法，而是用session.write();</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端消息发送:&quot;</span> + message.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接断开时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接创建时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接闲置时调用，闲置状态通过setIdleTime第一个参数判断，调用频率通过setIdleTime第二个参数设置，这里是10s一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session闲置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接成功时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步，建立一个connecter</span></span><br><span class="line">        NioSocketConnector connecter = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        <span class="comment">// 第二步，设置消息处理的Handler，和服务端一模一样，实现IOHandler接口即可</span></span><br><span class="line">        connecter.setHandler(<span class="keyword">new</span> MinaClientHandler());</span><br><span class="line">        <span class="comment">// 第三步，设置拦截器，编码规则应该和服务端一样，即TextLineCodecFactory，除了mina自带的编码方式之外，还可以自己定义编码协议</span></span><br><span class="line">        connecter.getFilterChain().addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory()));</span><br><span class="line">        <span class="comment">// 第四步，连接服务器，127.0.0.1代表本机ip，2001是端口号</span></span><br><span class="line">        ConnectFuture future = connecter.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">2001</span>));</span><br><span class="line">        <span class="comment">// 阻塞直到和服务器连接成功</span></span><br><span class="line">        future.awaitUninterruptibly();</span><br><span class="line">        <span class="comment">//下面代码用于测试，从客户端控制台输入</span></span><br><span class="line">        BufferedReader inputReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in, <span class="string">&quot;utf-8&quot;</span>)); <span class="comment">// 从控制台读取的输入内容</span></span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span> (!(s = inputReader.readLine()).equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">                future.getSession().write(<span class="string">&quot;客户端发送消息：&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaClientHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端异常捕捉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端消息发送:&quot;</span> + message.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端session关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端session闲置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收消息：&quot;</span> + message.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，总共只要4个类就可实现简单的异步IO通讯，将客户端和服务端代码分别运行（先运行服务端，否则客户端可能会找不到端口），然后可以从客户端控制台输入，查看输出，理解各方法的调用时机。 </p>
<p>补充：看到Mina中的XXXFuture就说明这个方法是异步执行的</p>
<p>客户端的<code>future.awaitUninterruptibly();</code>相当于把异步执行转变为同步执行，因此在这个方法下面的其他语句是没法执行的。这是为了防止使用<code>future.getSession();</code>等方法时无法返回对象的情况</p>
<p>可以用下面的方法代替上面的阻塞方法，这个方法用于添加监听器，在异步执行结果返回时调用监听器中的回调方法，这个方法下面的语句是能正常执行的。future.getSession();的获取可以写在回调方法里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future.addListener(<span class="keyword">new</span> IoFutureListener&lt;IoFuture&gt;() &#123;<span class="comment">//异步执行直到结果返回时回调方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(IoFuture ioFuture)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里有一篇mina详解，讲的比较详细，有兴趣的朋友可以看这篇文章：<a href="http://tbstone.iteye.com/blog/1976487">mina框架详解</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一次写博客，表达可能不是很到位，排版和字体大小应该也有问题，希望大家多多担待和支持。</p>
<p>下一篇将介绍如何用mina框架进行心跳检测。</p>
<p>以上是我自己的一些理解，如有谬误，恳请各位前辈指出！</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>博客框架介绍：Jekyll</title>
    <url>/2018/07/15/blog-2018-07-15-Jekyll/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Jekyll是一个静态网站生成器，基于Ruby+Liquid+Markdown+HTML+CSS。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li><code>_config.yml</code>：配置文件。</li>
<li><code>_includes</code>：可以被其他的文件包含，复用。相当于网页的include，如header，footer等</li>
<li><code>_layout</code>：存放网页的模板文件</li>
<li><code>_posts</code>：存放具体的博客文章。</li>
<li><code>assets</code>：资源文件</li>
<li><code>_site</code>：这个文件夹存放的是最终生成的文件。 编译器生成，建议放到<code>.gitignore</code>里。</li>
</ul>
<p>Jekyll运行会遍历所有的文件，进行预编译、解析生成文件。因此语法要符合规范，否则会编译失败。</p>
<p>一般参考主题中内置的示例文件改写即可，例如：</p>
<p>POST文章命名格式为：<code>year-month-date-title.markup</code>。后缀可以是md、markdown等。</p>
<p>文章开头需要带头信息，和正文间通过<code>---</code>分割，如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: post</span><br><span class="line">title:  &quot;Welcome to Jekyll!&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="Liquid"><a href="#Liquid" class="headerlink" title="Liquid"></a>Liquid</h2><p>Liquid是一种模版语言，Jekyll会解析Markdown文件，将生成的内容填充到模版中。</p>
<p>Liquid使用<code>&#123;% %&#125;</code>引用代码块，使用<code>&#123;&#123; &#125;&#125;</code>引用变量。Jekyll内置了很多变量，掌握这些变量就能自行组织页面布局</p>
<p>例如：</p>
<p>引入footer页脚：<code>&#123;% include footer.html %&#125;</code></p>
<p>引入文章标题：<code>&#123;&#123; page.title &#125;&#125;</code></p>
<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>由于GitHub基于Ruby，因此内置了Jekyll的支持，<strong>只要将源工程文件通过Git上传到GitHub Pages</strong>，GitHub在会自动在远程运行Jekyll编译生成静态站点文件，当然也可以本地编译生成静态站点文件，再上传到GitHub Pages。</p>
<blockquote>
<p>GitHub Pages相关单独抽出来介绍了，参考之后的文章</p>
</blockquote>
<p>但是每次写好博客都需要提交并上传到GitHub Pages才能访问，会导致很多调试的提交，并且存在延迟，因此可以先在本地调试预览。</p>
<p><strong>本地调试需要先安装Ruby环境，再通过Ruby的包管理工具Gem来安装Jekyll</strong></p>
<h2 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h2><p>Mac内置了Ruby，位于<code>/usr/bin/ruby</code>，版本较旧，可能会出现无法运行Jekyll的情况，可以使用brew安装Ruby</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用brew安装ruby</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install ruby</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在.zshrc中配置环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;export PATH=/opt/homebrew/Cellar/ruby/3.1.2_1/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshrc</span></span><br></pre></td></tr></table></figure>

<p>使用gem安装Jekyll，gem是ruby的包管理工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装Jekyll+Bundler</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem install bundler jekyll</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建Jekyll工程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jekyll new my-awesome-site</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> my-awesome-site</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地运行Jekyll服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jekyll serve</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> =&gt;打开浏览器 http://localhost:4000</span></span><br></pre></td></tr></table></figure>

<p>如果Jekyll没有在环境变量中，则需要使用完整路径访问，使用<code>gem list jekyll -d</code>查看Jekyll安装路径。</p>
<p>也可以通过bundler访问Jekyll。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置bundler</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bundle install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用bundler运行Jekyll</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bundler <span class="built_in">exec</span> jekyll serve</span></span><br></pre></td></tr></table></figure>

<p>如果提示没有<code>Gemfile</code>，则需要手动创建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source &quot;https://rubygems.org&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Hello! This is <span class="built_in">where</span> you manage <span class="built_in">which</span> Jekyll version is used to run.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> When you want to use a different version, change it below, save the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file and run `bundle install`. Run Jekyll with `bundle <span class="built_in">exec</span>`, like so:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#     bundle exec jekyll serve</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This will help ensure the proper Jekyll version is running.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Happy Jekylling!</span></span><br><span class="line">gem &quot;jekyll&quot;, &quot;~&gt; 4.3.1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p>下载安装包不用配置环境变量。官方提供了ruby和devkit合成的安装包：<a href="https://rubyinstaller.org/downloads/">下载地址</a></p>
<p><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll01.png" alt="jekyll01"></p>
<ol>
<li>指定安装路径，勾选use UTF-8<br><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll02.png" alt="jekyll02"></li>
<li>勾选MSYS2<br><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll03.png" alt="jekyll03"></li>
<li>自动弹出命令行，输入1，等待安装成功<br><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll05.png" alt="jekyll05"></li>
<li>安装Jekyll和bundler：<code>gem install jekyll bundler</code></li>
<li>切换到工程目录，执行<code>jekyll serve</code>即可运行，<code>jekyll build</code>编译</li>
<li>浏览器中输入<code>localhost:4000</code>访问</li>
</ol>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><blockquote>
<p>问题是18年写的，比较旧了，新版本不一定会遇到。</p>
</blockquote>
<p>提示将<code>_config.yml</code>文件的<code>gem:</code>改成<code>plugins:</code></p>
<p>提示缺少依赖，需要安装，根据具体情况安装，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gem install jekyll-sitemap</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem install jekyll-seo-tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem install jekyll-feed</span></span><br></pre></td></tr></table></figure>

<p>不允许出现中文名，可能出现下面的情况：</p>
<ol>
<li>运行起来之后访问不到文章：文章文件带中文名</li>
</ol>
<p><code>[2018-07-15 16:42:37] ERROR &#39;/2018/07/15/ELK数据分析.html&#39; not found.</code></p>
<ol start="2">
<li>也可能在编译时就出错无法运行：检查是否有文件包含中文名</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Liquid Exception: Liquid error (line 13): invalid byte sequence in UTF-8 in sitemap.xml</span><br><span class="line">             Error: Liquid error (line 13): invalid byte sequence in UTF-8</span><br><span class="line">             Error: Run jekyll build --trace for more information.</span><br></pre></td></tr></table></figure>

<p>如果博客文章中出现Liquid的语法，也会被解析，可能会导致报错：例如在文章中使用了这一句，Jekyll进行了解析，找不到<code>file.ext</code>文件</p>
<p><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll07.png" alt="jekyll07"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Liquid Exception: Could not locate the included file &#x27;file.ext&#x27; in any of</span><br><span class="line">[&quot;E:/GitPageBlog/moon-lights.github.io/includes&quot;]. Ensure it exists in one of those directories </span><br><span class="line">and, if it is a symlink, does not point outside your site source. in E:/GitPageBlog/moon-</span><br><span class="line">lights.github.io/posts/tool/2018-7-15-Jekyll.md</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ul>
<li><a href="jekyllrb.com">Jekyll官网</a>、<a href="https://www.jekyll.com.cn/docs/home/">Jekyll中文网</a></li>
<li><a href="https://www.jekyll.com.cn/docs/themes/">Jekyll主题</a>：提供多个主题站点</li>
<li><a href="https://www.cnblogs.com/zjjDaily/p/8695978.html">使用Github pages+jekyll搭建自己的博客（windows版）</a></li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch+Logstash+Kibana</title>
    <url>/2018/07/15/tool-2018-07-15-ELK/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ol>
<li>Elasticsearch：后台分布式存储以及全文检索</li>
<li>Logstash: 日志加工、“搬运工” </li>
<li>Kibana：数据可视化展示。</li>
</ol>
<p>Logstash(收集服务器上的日志文件)<br>保存到 ElasticSearch(搜索引擎)<br>Kibana提供友好的web界面(从ElasticSearch读取数据进行展示)</p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>实现后台分布式存储以及全文检索<br>（全文检索就是对一篇文章进行索引，可以根据关键字搜索）</p>
<p>elasticsearch基于lucene的搜索服务器，lucene是一个库，elastic对其进行了封装，减少复杂度。<br>elasticsearch可以检索数据，返回统计结果，速度快。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><p>Cluster ：集群。</p>
<p>多个搜索服务器的集合</p>
</li>
<li><p>Node：节点。</p>
<p>组成集群的单个服务器</p>
</li>
<li><p>Shard：分片。</p>
<p>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。 </p>
<p>当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的</p>
</li>
<li><p>Replia：副本。</p>
<p>为提高查询吞吐量或实现高可用性，可以使用分片副本。<br>副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。<br>当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p>
</li>
</ul>
<h3 id="对应数据库概念"><a href="#对应数据库概念" class="headerlink" title="对应数据库概念"></a>对应数据库概念</h3><p><img src="/2018/07/15/tool-2018-07-15-ELK/ElasticSearch.jpg" alt="Elastic概念对应数据库"></p>
<h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>Kibana 是一个开源分析和可视化平台，旨在可视化操作 Elasticsearch 。Kibana可以用来搜索，查看和与存储在 Elasticsearch 索引中的数据进行交互。可以轻松地进行高级数据分析，并可在各种图表，表格和地图中显示数据。</p>
<p> Kibana 可以轻松理解海量数据。其简单的基于浏览器的界面使您能够快速创建和共享动态仪表板，实时显示 Elasticsearch 查询的更改。</p>
<p>安装Kibana简单快速。您可以安装 Kibana ，并在几分钟内开始探索您的 Elasticsearch 索引 - 不需要代码，也不需要需额外的基础架构。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>静态代码分析平台SonarQube</title>
    <url>/2018/07/14/tool-2018-07-14-SonarQube/</url>
    <content><![CDATA[<h2 id="Sonar是什么？"><a href="#Sonar是什么？" class="headerlink" title="Sonar是什么？"></a>Sonar是什么？</h2><p>SonarQube(以前叫Sonar)是持续检测代码质量的开源平台<br>静态代码分析工具、代码质量检测工具<br>支持不同编程语言</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>作为一个代码分析平台，Sonar由以下三个部分组成：</p>
<ol>
<li>数据库：存放配置信息和分析结果信息；</li>
<li>一个Web服务器：建立工程，在线浏览分析结果，配置分析规则；</li>
<li>客户端、分析端：执行源代码分析；</li>
</ol>
<p>服务端和客户端有多种搭配方式<br>sonarqube + sonar-runner<br>/sonar-scanner<br>sonarqube + maven<br>sonarqube + IDE     如：IntelliJ、android studio、eclipse</p>
<p>sonar的命令行分析端软件有两种分别是Runner和Scanner，官网文档中写的是Scanner，但Runner和它安装、使用都基本一致。</p>
<p>客户端分析代码后将结果显示在服务端（浏览器），也可以存到数据库中，服务端可以部署在本地部署到远程<br>本地默认端口为localhost:9000</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;在SonarQube平台创建工程，设置ProjectName和ProjectKey</span><br><span class="line"></span><br><span class="line">&gt;在本地需要扫描的工程目录下创建sonar-project.properties，内容如下：</span><br><span class="line">&gt;sonar.projectKey&#x3D;project_key </span><br><span class="line">&gt;sonar.projectName&#x3D;project_name </span><br><span class="line">&gt;sonar.projectVersion&#x3D;1.0 </span><br><span class="line">&gt;sonar.sources&#x3D;.&#x2F; </span><br><span class="line">&gt;sonar.language&#x3D;py &#x2F;&#x2F;需要扫描哪种语言的代码，如python:py，java:java</span><br><span class="line">&gt;sonar.sourceEncoding&#x3D;UTF-8 </span><br><span class="line">&gt;sonar.host.url&#x3D;http:&#x2F;&#x2F;your_host:your_port&#x2F;[your_prefix] </span><br><span class="line"></span><br><span class="line">&gt;执行sonar-scanner -X 命令，结果会上传到SonarQube平台</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>作为一个诗人</title>
    <url>/2018/04/14/personal-2018-04-14-AsPoetry/</url>
    <content><![CDATA[<center>
    <b><font size="5">越人歌</font></b><br>
    <font size="2">【作者】佚名 【朝代】先秦</font><br>
    今夕何夕兮搴洲中流。<br>
    今日何日兮得与王子同舟。<br>
    蒙羞被好兮不訾诟耻。<br>
    心几烦而不绝兮得知王子。<br>
    山有木兮木有枝。<br>
    心悦君兮君不知。<br>
</center>



<center>
    <b><font size="5">南歌子词二首 / 新添声杨柳枝词</font></b><br>
    <font size="2">【作者】温庭筠 【朝代】唐</font><br>
    一尺深红胜曲尘，天生旧物不如新。<br>
    合欢桃核终堪恨，里许元来别有人。<br>
    井底点灯深烛伊，共郎长行莫围棋。<br>
    玲珑骰子安红豆，入骨相思知不知。<br>
</center>


<center>
    <b><font size="5">鹧鸪天·元夕有所梦</font></b><br>
    <font size="2">【作者】姜夔 【朝代】宋</font><br>
       肥水东流无尽期。当初不合种相思。<br>
    梦中未比丹青见，暗里忽惊山鸟啼。<br>
    春未绿，鬓先丝。人间别久不成悲。<br>
    谁教岁岁红莲夜，两处沉吟各自知。<br>
</center>


<center>
    <b><font size="5">古相思曲</font></b><br>
    <font size="2">乐府</font><br>
       十三与君初相识，王侯宅里弄丝竹。<br>
    只缘感君一回顾，使我思君朝与暮。<br>
    再见君时妾十五，且为君作霓裳舞。<br>
    可叹年华如朝露，何时衔泥巢君屋？<br>
</center>


<center>
    <b><font size="5">古相思曲</font></b><br>
    <font size="2">乐府</font><br>
       君似明月我似雾，雾随月隐空留露。<br>
    君善抚琴我善舞，曲终人离心若堵。<br>
    只缘感君一回顾，使我思君朝与暮。<br>
    魂随君去终不悔, 绵绵相思为君苦。<br>
    相思苦，凭谁诉？遥遥不知君何处。<br>
    扶门切思君之嘱，登高望断天涯路。<br>
</center>



<center>
    <b><font size="5">绸缪</font></b><br>
    <font size="2">【作者】佚名 【朝代】先秦</font><br>
       绸缪束薪，三星在天。今夕何夕，见此良人？子兮子兮，如此良人何？<br>
    绸缪束刍，三星在隅。今夕何夕，见此邂逅？子兮子兮，如此邂逅何？<br>
    绸缪束楚，三星在户。今夕何夕，见此粲者？子兮子兮，如此粲者何？<br>
</center>


<center>
    <b><font size="5">我亦好歌亦好酒</font></b><br>
    <font size="2">【作者】殊同 【朝代】现代</font><br>
       我亦好歌亦好酒，唱与佳人饮与友。歌宜关西铜绰板，酒当直进十八斗。<br>
    摇摆长街笑流云，我本长安羁旅人。丛楼参差迷归路，行者匆匆谁与群。<br>
    幸有作文与谈诗，寥落情怀有君知。负气登楼狂步韵，每被游人笑双痴。<br>
    幸有浩然共蹴鞠，轻拨慢扣自欢娱。七月流火无眠夜，同向荧屏做唏嘘。<br>
    幸有彩云喜香山，兰裳桂冠共游仙，说来红尘多趣事，笑声惊动九重天。<br>
    幸有晓艳能操琴，玉葱手指石榴裙。止如高山流如水，流水溯洄桃花林。<br>
    红衣佳人白衣友，朝与同歌暮同酒。世人谓我恋长安，其实只恋长安某。<br>
</center>



<center>
    <b><font size="5">唐多令·芦叶满汀洲</font></b><br>
    <font size="2">【作者】刘过 【朝代】宋</font><br>
       芦叶满汀洲，寒沙带浅流。二十年重过南楼。柳下系船犹未稳，能几日，又中秋。<br>
    黄鹤断矶头，故人今在否？旧江山浑是新愁。欲买桂花同载酒，终不似，少年游。<br>
</center>



<center>
    <b><font size="5">四季乱语之春-樱散零乱</font></b><br>
    <font size="2">【曲】《穿越时空的思念》【词】昭朔琰【原唱】暮落枫</font><br>
       春又来 人已去 风烟残 夕阳晚 樱花开 顷刻散 零乱。<br>
    年光逝 韶华落 飞絮转 不堪看 路漫漫 空梦断 零乱<br>
    渡忘川 彼岸 忘不掉 人长叹 古井下 月光 思念 装满<br>
    樱花瓣 飞过 风幽怨 水清寒 离伤黯 忧思转 零乱<br>
</center>



<center>
    <b><font size="5">四季乱语之春残-乱紫惜芳</font></b><br>
    <font size="2">【曲】《乱红》【词】昭朔琰【原唱】柳月庭</font><br>
       青山峰外 楼千嶂 云随雁去 诉悲凉 长烟落日 羌笛声声吹断肠 残絮翻飞归路茫<br>
    疏桐流响 卷轻霜 一树晚紫 飞何方 轻红梦断 琵琶弦弦征人望 飞花空锁恨离伤<br>
    月明倚楼 尽望乡 断桥紫苏 飞落寒江 看尽落花春残 犹道碎紫十里香 容华散尽惜流芳<br>
    疏桐流响 卷轻霜 一树晚紫 飞何方 轻红梦断 琵琶弦弦征人望 飞花空锁恨离伤<br>
    孤城青山 望归客 闲云散尽 飞鸿过 烟长日落 羌笛年年断肠歌 紫桐花里枕暮色<br>
    关山画作远山长 乱红千里青草凄凉 望遍烂漫春色 所恨年年赠离伤 月华软幽 人独来往<br>
    月明倚楼 尽望乡 断桥紫苏 飞落寒江 看尽落花春残 犹道碎紫十里香 容华散尽惜流芳<br>
</center>



<center>
    <b><font size="5">花非花</font></b><br>
    <font size="2">【作者】白居易 【朝代】唐</font><br>
       花非花，雾非雾。<br>
    夜半来，天明去。<br>
    来如春梦不多时，去似朝云无觅处。<br>
</center>



<center>
    <b><font size="5">花非花 ·花曲</font></b><br>
    <font size="2"></font><br>
       花非花，夢非夢。月半彎，琴聲動。悲歌清曲暗凋零，莫問明朝誰與共。<br>
    霜非花，霧非夢。世事薄，歡情痛。紅塵離散兩匆匆，往事遙遙魂寄送。<br>
    燭燈花，向風動。錦瑟年，殘宵送。韶光流逝影重疊，慣看霜痕濕舊夢。<br>
    風中花，夜中夢。瘦盡春，斜陽弄。烽煙殘照酒回腸，半闕清詞愁也縱。<br>
</center>



<center>
    <b><font size="5">将进酒</font></b><br>
    <font size="2">【作者】李白 【朝代】唐</font><br>
       君不见，黄河之水天上来，奔流到海不复回。<br>
    君不见，高堂明镜悲白发，朝如青丝暮成雪。<br>
    人生得意须尽欢，莫使金樽空对月。<br>
    天生我材必有用，千金散尽还复来。<br>
    烹羊宰牛且为乐，会须一饮三百杯。<br>
    岑夫子，丹丘生，将进酒，杯莫停。<br>
    与君歌一曲，请君为我倾耳听。<br>
    钟鼓馔玉不足贵，但愿长醉不复醒。<br>
    古来圣贤皆寂寞，惟有饮者留其名。<br>
    陈王昔时宴平乐，斗酒十千恣欢谑。<br>
    主人何为言少钱，径须沽取对君酌。<br>
    五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。<br>
</center>



<center>
    <b><font size="5">长恨歌</font></b><br>
    <font size="2">【作者】白居易 【朝代】唐</font><br>
    汉皇重色思倾国，御宇多年求不得。杨家有女初长成，养在深闺人未识。<br>
    天生丽质难自弃，一朝选在君王侧。回眸一笑百媚生，六宫粉黛无颜色。<br>
    春寒赐浴华清池，温泉水滑洗凝脂。侍儿扶起娇无力，始是新承恩泽时。<br>
    云鬓花颜金步摇，芙蓉帐暖度春宵。春宵苦短日高起，从此君王不早朝。<br>
    承欢侍宴无闲暇，春从春游夜专夜。后宫佳丽三千人，三千宠爱在一身。<br>
    金屋妆成娇侍夜，玉楼宴罢醉和春。姊妹弟兄皆列土，可怜光彩生门户。<br>
    遂令天下父母心，不重生男重生女。骊宫高处入青云，仙乐风飘处处闻。<br>
    缓歌慢舞凝丝竹，尽日君王看不足。渔阳鼙鼓动地来，惊破霓裳羽衣曲。<br>
    九重城阙烟尘生，千乘万骑西南行。翠华摇摇行复止，西出都门百余里。<br>
    六军不发无奈何，宛转蛾眉马前死。花钿委地无人收，翠翘金雀玉搔头。<br>
    君王掩面救不得，回看血泪相和流。黄埃散漫风萧索，云栈萦纡登剑阁。<br>
    峨嵋山下少人行，旌旗无光日色薄。蜀江水碧蜀山青，圣主朝朝暮暮情。<br>
    行宫见月伤心色，夜雨闻铃肠断声。天旋地转回龙驭，到此踌躇不能去。<br>
    马嵬坡下泥土中，不见玉颜空死处。君臣相顾尽沾衣，东望都门信马归。<br>
    归来池苑皆依旧，太液芙蓉未央柳。芙蓉如面柳如眉，对此如何不泪垂。<br>
    春风桃李花开日，秋雨梧桐叶落时。西宫南内多秋草，落叶满阶红不扫。<br>
    梨园弟子白发新，椒房阿监青娥老。夕殿萤飞思悄然，孤灯挑尽未成眠。<br>
    迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共。<br>
    悠悠生死别经年，魂魄不曾来入梦。临邛道士鸿都客，能以精诚致魂魄。<br>
    为感君王辗转思，遂教方士殷勤觅。排空驭气奔如电，升天入地求之遍。<br>
    上穷碧落下黄泉，两处茫茫皆不见。忽闻海上有仙山，山在虚无缥渺间。<br>
    楼阁玲珑五云起，其中绰约多仙子。中有一人字太真，雪肤花貌参差是。<br>
    金阙西厢叩玉扃，转教小玉报双成。闻道汉家天子使，九华帐里梦魂惊。<br>
    揽衣推枕起徘徊，珠箔银屏迤逦开。云鬓半偏新睡觉，花冠不整下堂来。<br>
    风吹仙袂飘飖举，犹似霓裳羽衣舞。玉容寂寞泪阑干，梨花一枝春带雨。<br>
    含情凝睇谢君王，一别音容两渺茫。昭阳殿里恩爱绝，蓬莱宫中日月长。<br>
    回头下望人寰处，不见长安见尘雾。惟将旧物表深情，钿合金钗寄将去。<br>
    钗留一股合一扇，钗擘黄金合分钿。但教心似金钿坚，天上人间会相见。<br>
    临别殷勤重寄词，词中有誓两心知。七月七日长生殿，夜半无人私语时。<br>
    在天愿作比翼鸟，在地愿为连理枝。天长地久有时尽，此恨绵绵无绝期。<br>
</center>


<center>
    <b><font size="5">贺新郎</font></b><br>
    <font size="2">【作者】辛弃疾 【朝代】南宋</font><br>
   <font size="2">【序】邑中园亭，仆皆为赋此词。一日，独坐停云，水声山色，竞来相娱。意溪山欲援例者，遂作数语，庶几仿佛渊明思亲友之意云。</font><br>
</center>
​    甚矣吾衰矣。怅平生、交游零落，只今馀几！白发空垂三千丈，一笑人间万事。问何物、能令公喜？我见青山多妩媚，料青山见我应如是。情与貌，略相似。
​    一尊搔首东窗里。想渊明《停云》诗就，此时风味。江左沉酣求名者，岂识浊醪妙理。回首叫、云飞风起。不恨古人吾不见，恨古人不见吾狂耳。知我者，二三子。

<center>
    <b><font size="5">宽心谣</font></b><br>
    <font size="2">【作者】赵朴初</font><br>
    日出东海落西山，愁也一天，喜也一天。<br>
    遇事不钻牛角尖，身也舒坦，心也舒坦。<br>
    每月领取养老钱，多也喜欢，少也喜欢。<br>
    少荤多素日三餐，粗也香甜，细也香甜。<br>
    新旧衣服不挑捡，好也御寒，赖也御寒。<br>
    常与知己聊聊天，古也谈谈，今也谈谈。<br>
    内孙外孙同样看，儿也心欢，女也心欢。<br>
    全家老少互慰勉，贫也相安，富也相安。<br>
    早晚操劳勤锻炼，忙也乐观，闲也乐观。<br>
    心宽体健养天年，不是神仙，胜似神仙。<br>
</center>



<center>
    <b><font size="5">观猎</font></b><br>
    <font size="2">【作者】王维</font><br>
    风劲角弓鸣，将军猎渭城。<br>
    草枯鹰眼疾，雪尽马蹄轻。（字面）<br>
    忽过新丰市，还归细柳营。<br>
    回看射雕处，千里暮云平。<br>
</center>


<center>
    <b><font size="5">国风·秦风·小戎</font></b><br>
    小戎俴收，五楘梁辀。游环胁驱，阴靷鋈续。文茵畅毂，驾我骐馵。言念君子，温其如玉。在其板屋，乱我心曲。<br>
    四牡孔阜，六辔在手。骐骝是中，騧骊是骖。龙盾之合，鋈以觼軜。言念君子，温其在邑。方何为期？胡然我念之！<br>
    俴驷孔群，厹矛鋈錞。蒙伐有苑，虎韔镂膺。交韔二弓，竹闭绲縢。言念君子，载寝载兴。厌厌良人，秩秩德音。<br>
</center>



<center>
    <b><font size="5">菩萨蛮·如今却忆江南乐</font></b><br>
    <font size="2">【作者】韦庄</font><br>
    如今却忆江南乐，当时年少春衫薄。骑马倚斜桥，满楼红袖招。<br>
    翠屏金屈曲，醉入花丛宿。此度见花枝，白头誓不归。<br>
</center>


<center>
    <b><font size="5">蝶恋花·庭院深深深几许</font></b><br>
    <font size="2">【作者】欧阳修</font><br>
    庭院深深深几许，杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。<br>
    雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。 <br>
</center>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>著名台词</title>
    <url>/2018/04/14/personal-2018-04-14-Phrase/</url>
    <content><![CDATA[<ul>
<li>马东锡：可以走法律程序，但我要和他一个监狱——《恶人传》</li>
<li>“你是谁？”“我是中国最后一个皇帝。”“用什么证明？”溥仪走向龙椅，从那下面拿出了蛐蛐，笑得就像个孩子。——《末代皇帝》</li>
<li>曾经引以为傲的高音，现在已经无法驾驭了，听台下自发的大合唱，校长谭咏麟眼含热泪，70随唱不动又如何，你起头就行。</li>
<li>“我得了抑郁症，该怎么办”<ul>
<li>“不要紧，城里来了位著名的小丑，会说所有笑话，看了他的表演，你就不会再烦恼了”</li>
<li>“可是医生，我就是那个小丑啊”</li>
</ul>
</li>
<li>智力与爱人的能力无光，爱本就很纯粹，很简单。有多少自认为聪明的人确失去了爱人的能力。——《山姆先生》</li>
<li>人生陆远，只有忘得甘敬，才能得到江莱，赢得嘉禾——《好先生》<ul>
<li>人生陆远，就算没有忘得甘敬，江莱也在等你</li>
</ul>
</li>
<li>阿娘说：想吃什么，什么便是良药——《灵魂摆渡-黄泉》<ul>
<li>我见你生得好看，闻着香甜</li>
</ul>
</li>
<li>行动处处长行动不便，情报处处长为情所困，明家人身份不明</li>
<li>他的初恋不是他给了阿泽，是他自己弄丢的哦。<ul>
<li>所以搞怪的不是红绿灯不是时机，而是我数不清的犹豫——《请回答1988》</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我要是对你有感觉又不和你在一起你会不会觉得我吊着你。</span><br><span class="line">要说我对你有感觉呢有勉强和你在一起你会不会觉得我欺骗你</span><br><span class="line">你说我要是对你没感觉却和你在一起会不会觉得我玩弄你</span><br><span class="line">你要是觉得我对你没感觉又不和你在一起会不会觉得我伤害你</span><br><span class="line">	——《疯人院》</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">看对面来的是谁家女子，生得春光满面，美丽非凡，</span><br><span class="line">这位姑娘，请你停下美丽的脚步，你可知自己犯下了什么样的错误……</span><br><span class="line">这位官人，明明是你的马蹄踢翻了我的竹篮，</span><br><span class="line">你看这宽阔的道路直通蓝天，你却非让这可恶的畜生溅起我满裙污点，怎么反倒怪罪起我的错误？</span><br><span class="line">你的错误，就是美若天仙，</span><br><span class="line">你婀娜的身姿让我的手不听使唤，</span><br><span class="line">你蓬松的乌发涨满了我的眼帘，看不见道路山川，只有漆黑一片</span><br><span class="line">你明艳的面颊让我胯下的这头畜生神魂颠倒，忘记了他的主人是多么威严……</span><br><span class="line">	——《大明宫词》</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">之前总以为是湘琴拯救了银河系才能和直树在一起，后来慢慢发现是直树用光了所有的运气才遇见湘琴</span><br><span class="line"></span><br><span class="line">“我知道你讨厌笨蛋  但你不能欺负我老婆 ”  </span><br><span class="line"></span><br><span class="line">-直树,你要吃蛋糕吗?-我不要。-不是我做的，是我买的。-直树: 好吧,吃一块。</span><br><span class="line"></span><br><span class="line">“江同学你好，我是F班的袁湘琴。嗯，我想你并不认识我，但是我对你却很了解喔。 从第一次在新生训练上看到你，那一天，我的眼光就不知道该怎麼离开你。 不管是致辞的你，还是和旁人聊天的你，还是落寞不说话的你，我总可以很快的在人群中知道你的位置，找到你的位置。彷佛你在哪里，光就在哪里。”</span><br><span class="line"></span><br><span class="line">“湘琴好像永远都不知道我有多爱她”</span><br><span class="line"></span><br><span class="line">湘琴:“我真的是医学系天才江直树的妻子！”</span><br><span class="line"></span><br><span class="line">湘琴：咦你怎么买了巧克力的蛋糕啊，你不是最喜欢草莓的吗？植树：没办法，今天店里只卖这种口味。湘琴：没关系，幸好我最喜欢巧克力口味了。</span><br><span class="line"></span><br><span class="line">湘琴：这是你第二次吻我诶。    </span><br><span class="line">直树：不，这是第三次</span><br><span class="line">湘琴：可是？（努力在脑海中数啊数）</span><br><span class="line">直树：好了，不要数了（一把拥入怀中。。内心想说笨蛋，不能让你知道我偷偷亲你了。）</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>道</title>
    <url>/2018/04/14/personal-2018-04-14-Think/</url>
    <content><![CDATA[<ul>
<li><p>从来没有什么孙悟空，也没有什么西游记，师徒五人，其实只有唐僧，其他四个都是唐僧的心魔。途中的磨难，都是唐僧内心的磨砺——定住心猿则悟空，拴住意马则化龙，戒贪戒色共八戒，戒杀戒嗔是悟净，身心纯净朝佛祖，心之所在即西天</p>
</li>
<li><p>以前怕坟，觉得那里面都是鬼，自从有了亲人躺在那里才明白，原来小时候害怕的鬼，是别人日思夜想都再也见不到的人。</p>
</li>
<li><p>古代的药房门口写着：但愿世上无疾苦，宁可架上药生尘</p>
<ul>
<li>现在的药房门口写着：会员积分，买十赠二，消费58送15个鸡蛋</li>
</ul>
</li>
<li><p>有一天，我回到家无意间看见一个箱子，打开一看，里面有很多小人，它们有的拿着枪，有的背着电台，其中一个小人问我：“你看见我们司令了吗？他到哪里去了”，我愣了一下说：“你们司令不会回来了。”小人问为什么，我哽咽着说：“因为他长大了。”</p>
</li>
<li><p>小时候摔倒了，要看看周围有没有人，有就哭，没有就爬起来，长大后摔倒了，要看看周围有没有人，有就爬起来，没有就哭</p>
</li>
<li><p>我们就一天天长大，长出了胡须和白发，为柴米油盐而吵架，心里还是忘不了她。</p>
</li>
<li><p>十年前的心脏很厚，用力才能碎，里面是红袖章，发条青蛙，鸡毛毽子，信纸和崭新的回力运动鞋。十年后的心脏很薄，一吹就能破，里面是啤酒瓶，失眠夜，路灯，黑眼圈和忘关的电视机。</p>
</li>
<li><p>忍一时越想越气，退一步越想越亏</p>
<ul>
<li>同是射手（王者荣耀）</li>
</ul>
</li>
<li><p>原来最开始撕开的那道口子，就已经是你能撕开的最大的口子了，可能指以为后来能找到合适的另一半，穷尽一生，才徒然发现，最开始那个才是最好的。“画屏绣步障，物物自成双。如何湖上望，只是见鸳鸯”。说的就是这个吧</p>
<ul>
<li>这话说得好，就像我妈常说的：一嫁不中，千嫁无用</li>
</ul>
</li>
<li><p>好文章总是没人看，我曾听说过住在罗生门的恶鬼，因为害怕人性的凶残而逃走。</p>
</li>
<li><p>女孩想看世俗，在身上挂了个牌子写：我是艾滋病人，抱抱我好吗？结果她看到行人绕着她走，对她指指点点。当她暗笑那些人时，跑来个男孩抱了她，她很诧异，他告诉她：别怕，我也是艾滋病患者。她听到后像疯一样推开了他</p>
</li>
<li><p>你好。<br>很幸运看到你的问题。<br>但是又很遗憾到现在还没有人回答你的问题。也可能你现在已经在别的地方找到了答案，那就得恭喜你啦。<br>对于你的问题我爱莫能助！<br>可能是你问的问题有些专业了。或者别人没有遇到或者接触过你的问题，所以帮不了你。建议你去问题的相关论坛去求助，那里的人通常比较多，也比较热心，可能能快点帮你解决问题。<br>希望我的回答也能够帮到你！<br>快过年了，<br>最后祝您全家幸福健康快乐每一天！</p>
</li>
<li><p>小丑只是想吓一下女孩，没想到却得到了一个拥抱，孤单的人害怕有人靠近，却也渴望拥抱</p>
</li>
<li><p>自从用了网易云，我把《故事会》退订了</p>
</li>
<li><p>幸福的人用童年治愈一生，不幸的人用一生治愈童年</p>
</li>
<li><p>邪正看眼鼻，真假看嘴唇，功名看气概，富贵看精神，主意看指爪，风波看脚筋，若要看条理，全在言语中。</p>
</li>
<li><p>压死骆驼的不是最后一根稻草，而是每一根稻草</p>
</li>
<li><p>一个五岁的小男孩在一群大人的争执中不知所措。他小心翼翼地问道：收养是什么意思。旁边地小女孩低头思考了一下，说：收养的意思就是，你不是怀在妈妈肚子里，而是心里。</p>
</li>
<li><p>心比长相好，懂比爱重要。</p>
</li>
<li><p>我从来都不喜欢分享我的朋友给别人</p>
</li>
<li><p>爱笑的男孩子运气不会太差</p>
<ul>
<li>因为运气差的男孩子笑不出来。</li>
</ul>
</li>
<li><p>幸亏长得丑，没体验过各位的爱恨情仇</p>
</li>
<li><p>买名表算不算缴智商税</p>
<ul>
<li>你要是戴着名表去忽悠人，那不是智商税</li>
<li>你要是被忽悠着去买名表，那就是智商税</li>
<li>你要是被戴着名表的人忽悠了，那你既没有智商，也没有钱去缴智商税</li>
</ul>
</li>
<li><p>为什么美国富强，因为你晚上睡觉时，美国人正在努力工作。</p>
<ul>
<li>我tm在上班的时候，他们不是在睡觉吗？</li>
</ul>
</li>
<li><p>“你是如何搞砸一段关系的？”——“正常发挥”</p>
</li>
<li><p>“你感情路不顺吗？”——“顺啊，一路上都没什么人”</p>
</li>
<li><p>这个世上没有感同身受，只有冷暖自知</p>
</li>
<li><p>我曾经很奇怪为什么是瓶邪而不是灵邪，毕竟张起灵和吴邪听起来更配一些。直到我看到盗墓笔记的那句话，世上有很多张起灵，却只此一个闷油瓶。后来，我明白，张起灵是张家的张起灵，闷油瓶却是吴邪的闷油瓶。</p>
</li>
<li><p>你要的是幸福，还是对错</p>
</li>
<li><p>当矛盾发生时，一个不服软，一个在赌气，觉得对方在无理取闹，一个是有心事却得不到关心，这时往往便是疏远的开始。</p>
</li>
<li><p>《骆驼祥子》里有一段话：这世间真话本就不多，一个女子的脸红，胜过一大段对白。可后来有了胭脂，便分不清是真情还是假意。</p>
</li>
<li><p>神雕以写情见长，却狗血地加上尹志平与小龙女一段不堪事。多曾不以为然，而今明了。杨过龙女，一失臂一失贞，好似明镜蒙尘，白璧多瑕。这对璧人虽失去彼此所珍，十六年守望和一生相濡，却将世间一切虚妄地蚊子血米饭粒活成现世地明月光朱砂痣。</p>
</li>
<li><p>如果所有人都说你好，那么你已经死了；如果所有人都说你不好，那么你离死不远了；如果有人说你好，有人说你不好，那么你还活着。</p>
</li>
<li><p>我的前前任和前任都很棒，他们一个教我做温柔的女人，一个教我做成熟的大人。但我更爱我的现任，因为他教我做回小孩。——胡杏儿</p>
</li>
<li><p>我养了两盆一帆风顺，总是忘了浇水，等到叶子耷拉下来才想起来喷点水，不出一个小时，又精神起来了。其实我也和这两盆花差不多吧，每当快要死的时候喷点水就又活过来了。</p>
</li>
<li><p>每个当下的善恶都是这个“当下”之前的教育和引导以及环境所造成的人心善恶，而顺序学说却是将每个善恶进行抽丝剥茧的分析，查过程找原因，最终评定善恶的根源和大小。但顺序学说又主要是由人性本恶的学说延伸而来，我们处世，最主要的还是评判一个人的恶的情况比较多。大部分情况下我们界定善的标准是“利己而不损人”</p>
</li>
<li><p>物有本末，事有终始，知所先后，则近道矣。《大学》</p>
</li>
<li><p>陈平安的顺序学说有分先后，审大小，定善恶和知行合一这四个关键点，后来又发展出了脉络学说，也是为定善恶查漏补缺。分先后，不仅时间要分先后，逻辑也要分先后；审大小，应该小到一家人情，一地风俗，大到一国律法，一洲礼仪；定善恶，应要持中正态度，不度入个人情感，不受外物干扰。最为关键的是要按脉络从头到尾捋一遍，站在对方角度看待问题，再去判对错，定善恶。最后，知道了答案那就起而行之，知行合一。</p>
</li>
<li><p>物来顺应，未来不迎，当时不杂，既往不恋</p>
</li>
<li><p>把所有“我不会”变成“我可以学”，把所有“我怕我不行”变成“我可以试试”</p>
</li>
<li><p>男人有两大爱好，拉良家妇女下水，劝风尘女子从良;女人有两大爱好，和穷人总是谈钱，和富人谈的全是感情。如今客户也有两大爱好：和质量好的谈价格，和价格低的谈质量！市场虽然很透明，但你却什么也看不清，我只能告诉你，水很深，熟人是想给你最好的，只是你不信任罢了！</p>
</li>
<li><p>电影院里一个小孩问妈妈：“怎么这么多大人？大人也爱看动漫么？” 妈妈说“是看动漫的小孩都长大了”</p>
</li>
<li><p>如果一个人住，千万不要在下午时睡觉，一觉睡到六七点，等你一睁开眼，看着朦胧黑黑的天空和空荡的房间，会有一种被世界遗弃的感觉，孤独在这一刻体现得淋漓尽致。</p>
</li>
<li><p>戏一旦开了口，哪怕台下没有人也要唱完。人不听，鬼神听。记得两年前上课听老师讲过民国戏子和《桃花扇》的故事，后来发现了这首曲，感受愈加深刻。都道戏子无情，怎知戏子也有心。“俺曾见，金陵玉树莺声晓，秦淮水榭花开早，谁知道容易冰消！眼看他起朱楼，眼看他宴宾客，眼看他楼塌了。这青苔碧瓦堆，俺曾睡过风流觉，把五十年兴亡看饱。那乌衣巷，不姓王；莫愁湖，鬼夜哭；凤凰台，栖枭鸟!残山梦最真，旧境丢难掉。不信这舆图换稿，诌一套‘哀江南’，放悲声唱到老。”</p>
</li>
<li><p>酒逢知己千杯少，话不投机半句多，遥知湖上一樽酒，能忆天涯万里人</p>
</li>
<li><p>我用了半小时赞了500条评论，我知道，我能做的就只有这样。一个小小的赞，让你们开心一点。。陌生人。胃不好别吃辣的冷的，想哭就哭吧。累了就听听歌吧，带上耳机，坐在你爱的地方。你会发现生活没有什么多烦，多痛。有的只有你心中的哪片向往的生活。</p>
</li>
<li><p>歪理一：爱情不分先来后到，只要她还没结婚，我就有机会</p>
<ul>
<li>爱情不是任何插足行为的挡箭牌，如果喜欢的人已经有了恋爱关系，那请你和她保持距离，克制自己的感情，不要逾越。公平竞争只存在于单身的情况下，不管你有多喜欢一个人，只要他有恋人，另一方就是无辜的，爱情不是伤害别人的借口。因为它虽然不分先来后到，但是讲礼义廉耻</li>
</ul>
</li>
<li><p>于是，当我们开启上帝视角会发现：从女生的角度讲，设定了重重条件，渴望的得不到，得到的却不渴望；从男生的角度讲，千辛万苦越过护城河，爬过高墙，却发现姑娘内心的城堡仍然层层防御，壁垒森严。如果你不能打开她的内心，那么做再多感动、惊喜、有心的事，可能也无济于事。你对高原很有反应，高原对你毫无反应。现在回到最初的问题：为什么很多好女孩没有男朋友。我的看法是，如果没有爱情，条件就是一切，需要占据压倒性优势；有了爱情，条件不过是张启程票，只要让她一开始不排斥你就行。</p>
</li>
<li><p>Z姑娘总是抱怨身边没什么条件合适的人，但是通过***才发现，条件比她好的男生一抓一大把。我后来总结：这就像是春运，都知道火车票很难抢，但你要是上了车，会发现，身边个个都有票。条件这种东西，当你不具备的时候，它很关键，是一切的前提；但当你具备的时候，他就没那么重要了，只是起步的基础。这就像春运，上车前抢到票是关键，而一旦上了车，你会发现有没有座位，是软座还是硬座，是站着还是躺着，旁边的人是翩翩公子还是抠脚大汉，才是真正影响这一路上你的体验和心情的根本因素。在爱情面前，所有的条件都只是铺垫，价值交换只能满足社会需要，并不能满足情感的需要。就像Z姑娘引用一部电影的台词说道：曾经以为生命中最糟糕的事，就是孤独终老。其实不是，最糟糕的是，与那些让你感到孤独的人一起终老。</p>
</li>
</ul>
<ul>
<li><p>1.如果一个人足够聪明，知道在不同场合，不同时间，对不同的人，做不一样的行为，说不一样的话，展现不一样的情绪，呈现不同的状态，给不同的人不一样的印象。知道什么是对的什么是错的，什么是好的什么是坏的。但这并不会有什么帮助，因为心理学只能帮他知道这些却不能帮他做出选择。比如有些事明明知道不好也会去做。<br>2.有心为善、虽善不赏，有心为恶、虽恶不罚。情绪是否有好坏，如果有好坏是否就对应好人和坏人。如果没有好坏，为什么要在知道自己是焦虑，敌对等状态的时候去隐藏他，表现出合群，合理，圆滑，世故。我们选择这么做，往往不是为了自己好过，而是为了别人好过，给别人一个好的印象，让别人不会不舒服，给事情不会造成坏的影响。所以，是不是心理学第一步是认识自己，第二步在了解自己的前提下做出改变，不是为了让自己变得更好，而是为了给别人留下一个更好的自己。如果人人都是心理学专家，是不是人人都没有自我，因为这个自我已经被改变，人人都做那心理学定义了的”好人”</p>
</li>
<li><p>1.需要先明白为什么要参加社交（群体活动、场合）才能针对社恐或者社交障碍做出改变。就好像只讲了方法却没讲为什么要这么做。</p>
<ol start="2">
<li>针对第一个问题为什么要参加社交，再提出疑问：社交是否应该带有目的性或者功利性？<br>3.针对第2个问题，如果不应该，那再反问第一个问题，为什么要参加社交？</li>
<li>针对第2个问题，如果应该，我们称之为“应酬”，如果只是单纯不喜欢参加这种“应酬”，该怎么做？</li>
<li>针对第4个问题，如果答案是要参加，那再反问第1个问题，为什么要参加这种应酬，罗列应酬的好处优势，让大家喜欢上应酬？</li>
<li>针对第5个问题，如果答案是要参加但是可以不喜欢，只是为了在“不得不或者必要的场合”能够做合适的应对，那社交应该是一种辅助技能，目的并不是为了改变自我</li>
</ol>
</li>
<li><p>对于明确要求：更应该让需求方主动说清楚，以5w2h方式建立需求，而不是一点一点挤牙膏去问。如果一个一个问，一般需求方每次只会回答一小点，需要追问。如果一次问7个问题打7个问号，一个是显得不太礼貌。另一个是需求方并不一定会一次回答7个问题。还需要再追问。</p>
</li>
<li><p>对于科学衡量：最近很多问题，解决起来很简单，但是为了识别风险或者为了验证是否存在那样的风险，做了很多尝试和验证，想得太多，所以很耗时间，但是最终问题难度也只能算D，外人是从结果出发想这个问题，自然会简单了许多，但是RD解问题的时候考虑的远远不是解完该问题就好了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>星座学说</title>
    <url>/2018/04/14/personal-2018-04-14-ZodiacStudy/</url>
    <content><![CDATA[<p>泰坦尼克号4月14沉没<br> 2016年4月14日大话西游重映</p>
<p>【白羊座怪癖】</p>
<ul>
<li>双重人；</li>
<li>热爱暗恋；</li>
<li>有时自卑不喜欢跟人打交道，有点闷骚没事喜欢放空；</li>
<li>失眠或者嗜睡；</li>
<li>笑起来是个孩子，冷起来是个谜；</li>
<li>偏执、悲观、轻微强迫症、洁癖、言出必行、悲观、不自信、自恋、自以为是、多疑；</li>
<li>性格和脾气极端；</li>
<li>跟自己较劲，瞎琢磨；</li>
<li>好心肠，易被感动；</li>
<li>爱讲道理整理癖爱纠结。</li>
</ul>
<p>我突然明白为什么石进会写《白羊座的忧伤》和《可惜不是双鱼座》这两首歌了，他一定也和我一样，一直以为自己是双鱼座，直到有一天发现，原来自己一直不是双鱼座……</p>
<p>白羊男一般都很会玩，而且对自己的朋友都很好，有时候白羊男对自己的异性朋友要比对自己的恋人还要好。<br>白羊男生气时，什么狠的话都说得出，例如滚远点、爱怎么想怎么想，那个时候，即使你是他热恋中的女友，他也不会网开一面，可是一般你要是真的感觉很受伤了，不理他了，他又会觉得后悔，觉得伤你了，可是他一般还是不会主动来道歉，除非你给他台阶他才会让你知道他觉得自己错了。<br>一般若不是原则性的问题，和白羊男分手都会有回旋余地，一开始相恋时，你闹闹情绪、提提分手，一般闹完,他们也会当已经过去，可是要是你搞外遇被他晓得，若他还爱你，或许会给你一次机会，可是若你那次机会还不回头，那么很抱歉，从此他都不会再回头了，而且要是你一直闹脾气，跟他吵架，那么等到有一天他爆发出来的时候，就真的很难有任何回旋余地，除非他还没得到你。<br>白羊男，对女孩子的外貌都有一定要求，白羊男要是对一个女的只是娱乐心态，那么他就要求这个女的很性感，比如气质型、清新范。其实白羊男内心喜欢的是比较可爱、又单纯点的女孩子，傻傻的笨笨的，但不要太白痴型的。<br>白羊男一般都不喜欢女的常常一个电话打很久不挂，因为对于他们来说，根本没那么多话可以说，可是一般作为白羊的女友，每当这时候都会很伤心，要是刚开始他还在对你很有兴趣时，他即使心里不开心也会装作很喜欢跟你聊电话，可是当你跟他吵架几次后，他就会越来越对这点不爽，若你能改，那或许还有救，要是依旧跟他闹，那很抱歉，他也不会迁就你，那关系就会越来越僵。<br>白羊男一般很怕女孩子哭，不管是自己爱的人，还是爱自己的人，女孩子一哭，他们多半都会沉默，唯一不同的是，对着爱自己的女人，他们哄几句后要是没效果，就会选择不理，而对自己爱的女人，要是在他面前哭，他心里也会很难过，眼泪攻势这一招在前期用很有效果，可用多了，也没用，白羊男会觉得你很脆弱，他会有压力，当你连哭都没效果时，可能他已经在思考要离开你了。<br>白羊男一般都给人花心的感觉，其实也不是，他们不会很明显地拒绝，喜欢处于暧昧与明朗的界限，可能他们只是想选择一个真正适合自己的女孩子，要是白羊跟你一起，还是让你没安全感，那么或许他觉得跟你只能娱乐，不会放太多心思在你身上，在喜欢白羊男前期，你可以使用感动他这一招，这招在他对你还有兴趣时用对你们的感情特别有帮助，可是在他不爱你时，你做再多感人的事情也等于零。<br>白羊男心底都会有一段难忘的感情，这段感情往往白羊男都会伤得很重，于是自那段感情之后，他们就觉得很难信任女人的真心，白羊男其实比谁都聪明，让你感觉他很真诚，其实他常常玩弄一个女人也让你要死要活地不知道要放弃还是要继续，而这时候或许他早就已经在物色新的对象了。<br>如果你不是美女，那么请不要觉得自己可以感化白羊男，因为对于白羊来说，多半是一见钟情，外貌过不了关，他更没耐心去看你的性格适合不适合他了，白羊男一般喜欢长头发的女孩子居多，白羊男不喜欢太有心机的女人，要是你被他觉得你出卖了他，不管出于任何理由，他可能连解释的机会都不给你，直接疏远你。<br>白羊男，其实都很讨厌自己的女友跟以前的男友还保持着联系，他们嘴上会说着无所谓，其实心里只是怕要被伤，所以装作很不在乎，白羊男其实内心都有很柔软的地方，要是他为你付出得多了，他会觉得自己会被人看扁，这个时候他可能反而会离自己爱的人远了，因为他把自尊看得很重，所以千万不要太让你心爱的白羊男为你挖心挖肺，这样他们会觉得很受伤也很不爽。<br>白羊男有时候很神经质，前一天还很热情，后一天就很冷淡了，白羊男在遇到不开心的事情时，喜欢安静，不爱说话，要是你足够了解他，请在这时候不要打扰他，要是你打扰他，他搞不好就蹦出几句让你呕到家气到家的话，他不想说的东西，你问再多也没用，他要是想说的，他自然会告诉你。<br>不要觉得白羊男爱你，你就该让他为你改变，他或许会因为觉得自己为你心动而为了不让你伤心稍微作点改变，可是白羊天性喜好我行我素，要是他的改变你依旧不领情，那不好意思，他又会回到一开始的冷漠和让人难以理解，白羊男很受不了自己的付出没有回报，对于他们来说特别讲究公平。.<br>爱白羊男很累，你必须要给他足够的空间，因为他玩起来真的可以昏天暗地，忘了其他一切事情，其实这不代表他不爱你，只能说他在那个瞬间更想玩，有时候正当你觉得被他忽略时，他忽然给你点暗示其实他也有惦记你，有点可爱，让你又好气又好笑。<br>白羊男最讨厌解释，要是他觉得没必要解释的东西，你追问再多次，他或许也只会说没什么，白羊男其实有时候又很喜欢安静，喜欢一个人做一些发泄情绪的事情，这个时候千万不要去打扰他，白羊男的情绪一般都不会持续太久，开心或者伤心都一样。<br>白羊男多数都吃软不吃硬，他要是哄你了，请见好就收，不要因为心里不舒服还要继续跟他闹，他要是爱你，他脾气上来时，他会挂你电话，或者喊你别说了，这个时候，你千万不要觉得他是对你不在乎，他只是不会解释不懂表达，其实他只是怕说出让你伤心的话所以选择先冷静自己的情绪。<br>开始懂事的白羊，一般事业心都很强，为了事业可以暂时放掉一切影响自己情绪的因素，例如一段让他累到无法安心学习或者工作的感情，放掉一些休闲娱乐的机会，这个时候他们思考的是要在事业有成时，找一个女人安定下来，给她一辈子的幸福，白羊男在成家后，一般都是个好丈夫和好爸爸。<br>不要说白羊男分了手就会把前恋人遗忘，其实他们只是把她们的记忆放在心底深处，然后又选择让自己轻松的方式继续生活，继续恋爱，但是要是你给他的印象深刻，你真心爱过他或者让他真心爱过，一年半载之后，他们会回来找你，这个时候不要觉得是和好，可能只是把你当成他关心的朋友，他说话会有些让你想歪，可是其实他们只是真心希望你幸福，他们即使不再爱你了，也会因为你用以前爱他们的热情爱其他的男人心里而有点不爽。<br>对待白羊男，你千万要记住，不要看表面，要用心去体会他们的付出，不要让他们告诉你你应该怎么去做，而是要自己努力去走进他们的心。 </p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>博君一笑图</title>
    <url>/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/</url>
    <content><![CDATA[<img src="/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/列夫托尔斯泰日记.jpg" style="zoom:25%;">

<img src="/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/斜着看.jpg" style="zoom:25%;">

<p>神评：防窥膜，看不见</p>
<img src="/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/巨人烂尾1.jpg" style="zoom:25%;">

<img src="/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/巨人烂尾2.jpg" style="zoom:25%;">
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>独角戏</title>
    <url>/2018/04/14/personal-2018-04-14-AsSingler/</url>
    <content><![CDATA[<h1 id="情话"><a href="#情话" class="headerlink" title="情话"></a>情话</h1><ul>
<li><p>你的女朋友有缺点吗？ ：有，像星星一样的多。 ：那你的女朋友有优点吗？ ：有，像太阳一样的少。 ：那你为什么还喜欢她？ ：因为太阳一出现，星星就不见了。</p>
</li>
<li><p>女孩终于鼓足勇气向男孩表白，害羞地问男孩：“你喜欢我吗？” 男孩说：“不喜欢。” 女孩伤心欲绝，转身要走。 这时男孩叫住了女孩，对她说：“傻瓜，你还没问我爱不爱你呀。” 女孩破涕为笑：“那你爱不爱我？” “不爱。”。</p>
<ul>
<li>男孩：你怎么不问问我是不是真心的 女孩：那你是真心的吗 男孩：当然啊不是啊</li>
</ul>
</li>
<li><p>如果有一天我说想你了，不是说这天我想你了，是说这天我憋不住了。</p>
</li>
<li><p>听到这音乐，第一个通宵就是在魔法密林刷级</p>
</li>
<li><p>与其说是孤独 不如坦诚的讲自己没有全心全意的与人相处 老友没有再联系 新朋友不去信任 对亲密的人说不出口 只能从陌生人身上寻找慰藉 反正也没有人知道我是谁 去哪里 跑向谁</p>
</li>
<li><p>若你身边无爱，祝你卡里有钱。</p>
</li>
<li><p>我告诉你我喜欢你，并不是一定要和你在一起，只是希望今后地你，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。</p>
</li>
<li><p>我一岁的时候五岁，你年龄是我的五倍。我四岁的时候你八岁，你年龄是我的两倍。我十六岁的时候你二十岁，你的年龄是我的1.25倍。虽然我知道我永远无法追上你，但是我一生都在向你靠近。</p>
</li>
<li><p>今天的你对我爱答不理，明天的我还来找你</p>
</li>
<li><p>男生思维：你不做我女朋友，我怎么对你好？女生思维：你不对我好，我怎么做你女朋友？</p>
<ul>
<li>男人是结果导向，女人是过程导向</li>
</ul>
</li>
<li><p>为什么女人到了社会上会遇到越来越好的男人？而男人到了社会却再也找不到比学校里好的女人？</p>
<ul>
<li>神回复：因为车越开越旧，司机越开越六。</li>
</ul>
</li>
<li><p>她点了一个赞，你脑补出一出戏，她更新一条动态，你就像在做阅读理解，她坐在你身边，却隔着一条银河，她什么都没做，却成了你心里地最重要。</p>
</li>
<li><p>你好，同城</p>
<ul>
<li>数学里有个温柔霸道的词： 有且仅有 ； </li>
<li>还有个孤独的词： 假设存在； </li>
<li>还有个悲凉的词： 充分不必要； </li>
<li>还有一种无奈： 无限接近，永不等于；</li>
<li>最妄想的词儿： 令a和b相等；</li>
<li>还有个孤独傲慢的词： 无解； </li>
<li>还有个让人痛彻心扉的的字———略 </li>
</ul>
</li>
<li><p>相爱的人总喜欢说反话，却又渴望对方能读懂自己的心。有点像是两个人的一场美梦，彼此都害怕自己身边的人已经睡醒远去，自己还在原地做梦，所以不断的试探考验，但是如果两人都执着的要考验对方是否醒了，那两个人还会有一起做梦的可能吗？林佳和孟云都生怕自己是醒的晚被抛弃的那个，所以明明还爱着，两个人却都急匆匆地起身离开了。</p>
</li>
<li><p>初见是惊鸿一瞥，南柯一梦是你。等待是山重水复，怦然心动是你。相遇是柳暗花明，如梦初醒是你。重逢是始料未及，别来无恙是你。我喜欢你，依旧是你。</p>
</li>
<li><p>不忘人恩，不念人过。 不思人非，不计人怨。</p>
</li>
<li><p>我可以单身很久，但恋爱一定要和爱的人谈。</p>
</li>
<li><p>单是相遇便花光了我所有运气。</p>
</li>
<li><p>十年前，我有过这样一个手机，它最大容量只能存储两百条短信。每当存满了，都要精挑细选地删除我的，留住她的。那时候我多想有一个可以存储五百条短信的手机。而如今，我有了一个能无限存储短信的手机。却再也找不到一个能和我聊两百条短信的人了。</p>
<ul>
<li>因为现在都用QQ和微信了。</li>
</ul>
</li>
<li><p>爱一个人，始于颜值，陷于才华，痴于肉体，迷于声色，久于性格，终于人品。</p>
</li>
<li><p>用王家卫的台词来说，今天是我们分开的第847天，两年多的时间里，我没有爱过谁，我的手在离开你之后没有被谁牵过，我的嘴在你离开之后也没有被谁亲过，闭上眼睛，我还能感受到你的手你的唇，就离开那么一会儿，我以为我一睁开眼睛，我一叫你，你就回来了。</p>
</li>
<li><p>我自己都如此涼薄 拿什麼去溫暖別人。</p>
</li>
<li><p>你也不可能一直帮我 我怎么会不知道</p>
</li>
<li><p>你可以把一个老实人教会浪漫，但你不可能把一个花心的人永远束心</p>
</li>
<li><p>如果有人给你发了下雪的视频，你应该回复她我也想你了，因为春赏百花冬观雪，醒亦念卿，梦亦念卿</p>
</li>
<li><p>心有良人，不言于口，不形于表，亦不掩之，直言不讳，拒之坦然，得之惜之。 存人心系，大在长貌，小在言行，亦然品性，遇此之形，不急于言，拒人应礼，应人有度。</p>
</li>
<li><p>孟婆啊，如果你遇到我的妈妈，你就在她的碗里多放几块糖，她这辈子吃的苦太多了，下辈子让她吃甜的吧，把苦的放在我的碗里把，我不想让她再吃这么多的苦，我会心疼的</p>
</li>
<li><p>有没有人跟我一样？打开QQ发现没有聊天的人，于是点开看点，看一看，笑一笑，感动一下？你好陌生人，愿你天黑有灯，下雨有伞，路上有良人相伴，明天太阳依然会升起，请你不要停步，如果可以加个好友，我愿意陪你聊天。</p>
</li>
<li><p>无人与我立黄昏，无人问我粥可温，无人怜我悲与伤，无人分我乐与欢</p>
</li>
<li><p>白茶清欢无别事，我在等风也等你。清酒独酌了无趣，我在梦花也梦你</p>
</li>
<li><p>女：我结婚的时候你会来吗？</p>
<ul>
<li>男：那我劫婚，你会跟我走吗？</li>
<li>世界上最悲哀的事莫过于此，他开心幸福难过的模样你都见过，但唯独你没见过她属于你的样子</li>
</ul>
</li>
<li><p>自己喜欢的人在别人怀里，我能做什么，我能说什么，一个男人的悲剧在于如果他失败了，他不能将事情与人说，只能将愤怒屈辱不甘埋在心里</p>
</li>
<li><p>坐过最贵的“车”是爸爸的肩膀，住过最贵的“房子”是妈妈的肚子。出生时，我哭了，你们笑了；结婚时，我笑了，你们哭了。我成了你们时才知你们为何哭，为何笑</p>
</li>
<li><p>我很想恋爱，但不是因为恋爱才恋爱，我想因为那个人是你，才想恋爱，所以你没出现，我也没恋爱。</p>
</li>
<li><p>我喜欢你，像风走了八千里，不问归期。我喜欢你，像柳动蝉鸣，日落潮汐，不能自已。我喜欢你，像云漂泊九万里，不曾歇息。我喜欢你，像日落前洒下的余晖，不忍离去。我喜欢你，像太阳升了落去，无论朝夕。</p>
<ul>
<li>这句话运用排比的句式，同时也运用了比喻，句式整齐，节奏明确，真挚表达了自己的喜爱、仰慕之情。语言生动形象，读起来朗朗上口。</li>
</ul>
</li>
<li><p>聚在一起，成型，扭曲，缠绕，有时候又还原，断裂，再连接，这就是结，就是时间。——你的名字</p>
</li>
<li><p>刘涛：我一直不知道陈奕迅十年中的第一句“如果那两个字没有颤抖，我不会发现我难受”是哪两个字</p>
<ul>
<li>好胖，因为我不会发现我难瘦</li>
<li>“如果”</li>
<li>是“好的”这两个字，林夕在节目中说过的</li>
</ul>
</li>
<li><p>我见青山多妩媚，料青山见我应如是。</p>
<ul>
<li>我见众生皆草木，唯你是青山</li>
<li>众生见我皆草木，唯你视我如青山</li>
</ul>
</li>
<li><p>你是目前为止我碰到的唯一一个我追不到还会不开心的人，事情还是一样地在重复，我喜欢你的时候，你是一切，我不喜欢你了，你就什么都不是了。以前的我，也许会放大你的缺点来让自己迅速忘记，然而现在的自己已然可以将大部分错误都归到自己身上了。</p>
</li>
<li><p>我感觉从小到大我和朋友的相处总是会出现问题，一开始我都觉得是他们不好，现在想想其实因为是我吧，因为是我所以总会出现问题，有时候也控制不住自己莫名的情绪，正常人际交往都磕磕绊绊，哪还敢想两个人长时间磨合忍让，我也还是适合一个人呆着，至少情绪过后可以与自己和解。</p>
</li>
<li><p>像我这种人，不适合谈恋爱，更不适合结婚。我的情绪不太稳定，又敏感，想的太多，总是揣测对方的心意，然后又一遍遍的想是不是自己哪里出了问题。我也不擅长沟通，不知道怎么跟一个朝夕相处的人好好处理遇到的分歧和问题。我想来想去，还是独自生活更符合天性，也不会害人害己。</p>
</li>
<li><p>总会有大概合适的人。一切的事情自有道理吧。</p>
</li>
<li><p>当我说出“永远爱你”的时候，我的意思是：希望你永远都被人爱，是不是我不重要。</p>
</li>
<li><p>我其实很害怕，你会遇到一个人，可以替代我，代替我对你的那份喜欢，我虽然是独一无二的，可别人也是。</p>
</li>
<li><p>我想你一定在找文案吧。送你一句：人间忽晚，山河已秋。如果不喜欢，那就看开头的三个字吧。</p>
</li>
<li><p>既然琴瑟起，何以笙箫默。</p>
</li>
<li><p>小学时，想和喜欢的人同桌</p>
<ul>
<li>初中时，想和喜欢的人同班</li>
<li>高中时，想和喜欢的人同校</li>
<li>工作时，想和喜欢的人同城</li>
<li>年老时，想和喜欢的人同一个世界</li>
</ul>
</li>
<li><p>叮当陪了大雄80年，<br>在大雄临死前，<br>他对叮当说:<br>“我走之后你就回到属于你的地方吧！”<br>叮当同意了！<br>大雄死后…<br>叮当用时光机回到了80年前，<br>对小时候的大雄说:<br>“大雄你好，我叫叮当。” 每次看到这个段子都好感动，<br>—–人生若只如初见！<br>朋友也好，爱人也罢，如果累了，我们就回到第一天见面的时候…     我想重新认识你 从你叫什么名字开始。</p>
</li>
<li><p>汤姆：我这一生只抓你这一只老鼠，说到做到</p>
<ul>
<li>其实汤姆不是不会抓老鼠，只是不会抓杰瑞</li>
</ul>
</li>
<li><p>祝你三冬冷暖有人知，祝你头发长长，祝你狂吃不胖，祝你不败给感情，祝你嫁给爱情</p>
</li>
<li><p>愿你天黑有灯，下雨有伞，终生有人陪伴</p>
</li>
<li><p>那些翻着评论，却不评论的人，或许才是真的孤独寂寞的人，路过的陌生人，愿你贪吃不胖，愿你懒惰不丑，愿你的深情不被辜负，愿你的余生都有人</p>
</li>
<li><p>尝尽世间绚烂，难补一生心酸</p>
</li>
<li><p>过分善良就是愚蠢，过分心软就是放任，过分宽容就是纵容。 你可以做一个老实人，但你不能蠢到相信所有人。</p>
</li>
<li><p>一生一世一双人，半醉半醒半浮生</p>
</li>
<li><p>一生所寻，不过是最初的自己，愿你走出半生，归来仍是少年。</p>
</li>
<li><p>平生不会相思，才会相思，便害相思。</p>
</li>
<li><p>群处守嘴，独处守心。</p>
</li>
<li><p>最初我们来到这个世界，是因为不得不来；最终我们离开这个世界，是因为不得不走。</p>
</li>
<li><p>满目繁华何所依，<br>绮罗散尽人独立。<br>浪花扫尽千尘雪，<br>桃李无言一队春。<br>花满堵，酒满瓯，<br>世上如侬有几人！<br>一楫春风一叶舟，<br>一纶茧缕一轻钩，<br>一夜春雨一夜愁，<br>一轮明月锁清秋，<br>谁知梦，谁懂风，<br>万顷波中得自由！</p>
</li>
<li><p>不为往事扰，余生只愿笑</p>
</li>
<li><p>因为到最后你会发现，一个人的愚蠢不是几句话就能纠正的，谁也无法阻止智障坑人，正如无法阻止死神上门</p>
</li>
<li><p>茕茕白兔，东走西顾，衣不如新，人不如故</p>
</li>
<li><p>人最怕，深交后的陌生，认真后的痛苦，信任后的利用，温柔后的冷漠！</p>
<p>你好，最熟悉的陌生人</p>
</li>
<li><p>婚姻就是吵架冲出门以后，回来顺便买了个菜。</p>
</li>
<li><p>你知道吗，七年并不能忘记一个人。但一个旧细胞死亡新的细胞诞生，周围的旧细胞就会告诉这个新来的：主人之前是怎样怎样爱一个人的，就这样，即使七年后你的身体里都是新的细胞，但是他们都知道你旧的故事</p>
</li>
<li><p>从此无心爱良夜，任他明月下西楼</p>
</li>
<li><p>据说强迫症的人听歌有两种方式，一是一首单曲不断循环播放，直到听得想吐，二是随机播放，但会不断切歌。</p>
</li>
<li><p>七月有风八月有雨，九月会不会有你。</p>
</li>
<li><p>很想跟你借一个未来，有你全部的温情和热爱。</p>
</li>
<li><p>你在别人眼里可能平凡普通，但你一直是我自己唯一的信仰。</p>
</li>
<li><p>如果有一天你决定从我的生命中离开，请不要不告而别，至少好好的说一声再见。</p>
</li>
<li><p>其实没有别的什么能真正伤害你，唯一能伤害你的 是你的在意。</p>
</li>
<li><p>我以为，爱情可以填满我们心目中的遗憾。没想到，制造遗憾的偏偏就是爱情。</p>
</li>
<li><p>往后余生，洗碗是我，拖地是我，宠你也是我。</p>
</li>
<li><p>你可以帮我洗个东西吗？洗什么？喜欢我。</p>
</li>
<li><p>如果时间能重来，遇见你的瞬间，我还是会义无反顾。</p>
</li>
<li><p>遇上一个喜欢自己的人，不是什么容易的事，来日方长，你只是刚好错过一个我。</p>
</li>
<li><p>故事很长，我长话短说，我喜欢你。</p>
</li>
<li><p>因为爱，全世界都是你，喜是你悲也是你。</p>
</li>
<li><p>爱总是很美丽，结束的没道理。</p>
</li>
<li><p>曾经我一个人在世上流浪，遇见你以后，在你眼里找到了故乡。</p>
</li>
<li><p>我不清楚未来的方向，那大概是有你的地方。</p>
</li>
<li><p>怕无归期，怕空欢喜，怕来者不是你。</p>
</li>
<li><p>总有人比你好，而终无人可取代你。</p>
</li>
<li><p>很久以后才知道，原来和有些人最好的结局，就是互相杳无音信。</p>
</li>
<li><p>可惜喜欢就像乘法一样，只要一方为零，结果便为零。</p>
</li>
<li><p>如果可以，我想重新认识你，从我叫什么名字开始，然后以后的故事里，我绝对不会爱上你。</p>
</li>
<li><p>最深的孤独，是你明知道自己的渴望，却得对它装聋作哑。</p>
</li>
<li><p>忽然明白了那个叫周幽王的二百五为什么会烽火戏诸侯了，奶奶的，要是你喜欢的女孩会因此对你笑笑，踹翻全世界的事情也不是做不出来。</p>
</li>
<li><p>删去成行的字，最后打了个嗯发给你。没关系，不是所有的情绪都要告诉你，比如我的不开心，比如我好想你</p>
</li>
<li><p>人平均活到68岁，一共两万四千八百二十天，十九万个小时，三千五百万分钟，差不多二十一亿秒左右，这十秒，你在读这段话，这十秒，你只属于我，陌生人，我爱你。</p>
</li>
<li><p>我若成佛，天下无魔。我若成魔，佛奈我何。我若成仙，心游人间。我若成人，爱你万年。</p>
</li>
<li><p>上下四方谓之宇，古往今来谓之宙</p>
<ul>
<li>空间为宇，时间为宙</li>
</ul>
</li>
<li><p>我喜欢暖暖，她却喜欢凉凉</p>
<ul>
<li>真是个悲伤的故事</li>
</ul>
</li>
<li><p>小生不才，未得姑娘青睐，扰姑娘良久，姑娘勿怪，自此所有仰慕之意止于唇齿，掩于岁月，匿于年华。姑娘往北走，小生往南瞧，不再打扰姑娘，今生就此别过，望姑娘日后独善其身，遇良人，与君欢喜城，暖色度余生。</p>
</li>
<li><p>那时候，最好的朋友就在身边，喜欢的女孩近在眼前。 红衣佳人白衣友，朝与同歌暮同酒。 世人谓我恋长安，其实只恋长安某。 ，我都要成大叔了</p>
</li>
<li><p>有时候，你选择与某人保持距离，不是因为你不在乎，而是因为你清楚地知道，ta不属于你，人生遇到的每一个人，出场顺序真的很重要，很多人如果换一个时间认识，就会有不同的结局。或许，有些爱，只能止于唇齿，掩于岁月，且行且珍惜。</p>
</li>
<li><p>以前我看到：所爱隔山海，山海皆可平。</p>
<ul>
<li>那时我觉得：海有舟可渡，山有路可行</li>
<li>后来才发现：山海皆可平，难平是人心</li>
</ul>
</li>
<li><p>我之前没爱过别人，你是第一个，我怕我做得不好，让你觉得爱情不过如此</p>
</li>
<li><p>如果说以后不结婚的话，我想在一个烟火盛开的地方，生根发芽。</p>
</li>
<li><p>其实每一个人都有自己的预测，如果你去表白一个自己心仪的女孩子，其实没有那么久的考虑时间，其实那一刻你已经知道是幸福还是学会道别，我想对于自己最难的是结束自己的付出，真正的去说一句祝你幸福</p>
</li>
<li><p>你知道私人FM为什么没有倒退键只有下一首吗，因为错过了就错过了，再也回不来了。其实我想说，那你指导为什么音乐播放器都有一个最近播放的列表吗。因为只要你找的及时，那首歌一直在那里，从未离去。所以啊，人也一样， 你不去试试，怎么知道能不能成功呢。</p>
</li>
<li><p>我尊重同性恋，理解抑郁症，我会喂楼下的猫，会给老奶奶让座，会跟外卖小哥说谢谢，但是，现在我想做个有脾气的坏人了。</p>
</li>
<li><p>蛇不知己毒，人不知己罪，从古至今，时不伤人人自伤</p>
</li>
<li><p>有一种男生，不会聊天，不会撩妹，一聊天就没什么话题，很尴尬，但是内心非常想跟别人聊天，主动又不知道说什么，只有选择沉默，身边的朋友很少，但是待人很真实，对别人来说是老实巴交，追女孩没一次成功，现在还单身，却总喜欢在别人的故事里感受温暖，加油！自己，加油！这样的人</p>
</li>
<li><p>最初我买了一双鞋子，每次蹭了一点灰我都会小心翼翼地拭去，后来时间稍微久了一点，就算被别人踩了一脚，我连头都懒得低了，大抵对事对物都如此。起初她皱一下眉头你都会心疼，后来她哭你也无所谓了。</p>
<ul>
<li>那是你的鞋子不够贵或者是不够限量。还是她不够珍贵</li>
</ul>
</li>
<li><p>星河滚烫，你是人间理想。人海冷漠，你是人间炽热。皓月清凉，你是人间曙光。万物生长，你是二月朝阳。世间靡漫，你是明月繁星。满眼星河，你是清梦满船。万事浮沉，你是人间归途。众人平庸，你是人间星光。世事无常，你是满目琳琅。满树繁花，你是心之所向。</p>
</li>
<li><p>你眼中的灿烂星河，是我不曾见过的世外桃源</p>
</li>
<li><p>红桃皇后是一个头很大的皇后……这样装模做样而伪善的皇后，我一点都不喜欢。相比之下，红桃皇后，嘟着嘴巴嚷嚷说，砍掉她的头，真实而可爱多了。……不过，童话是童话，红桃皇后扮演恶人，自然要输的。</p>
</li>
<li><p>在google上输入“故事”，可以得到113000000条结果，但输入“结局”，却只能得到44900000。可见，不是每个故事都有结局。</p>
</li>
<li><p>余光中先生说月色和雪色之间你是第三种角色，于我而言你是第四种难得</p>
</li>
<li><p>村上春树写过这样一句话：如果我爱你，而你也正巧爱我，你头发乱了的时候，我会笑笑地替你拨一拨，然后手还留恋地在你发上多呆几秒。但是，如果我爱你，而不巧的，你不爱我，我只会轻轻地告诉你：你头发乱了哦~、</p>
</li>
<li><p>张爱玲说过每一个男子都有过这样的两个女人，至少两个。娶了红玫瑰，久而久之红的变了墙上地一抹蚊子血，白的还是床前明月光；娶了白玫瑰，白的便是衣服上的一粒饭黏子，红的却是心口上的一颗朱砂痣。</p>
</li>
<li><p>人在饿的时候会选择不爱的食物，会在寂寞的时候选择不爱的人，因为强扭的瓜不甜，但是解渴。</p>
</li>
<li><p>自古表白多白表，从来情书难书情。笑谈少年多年少，常与生人道人生。</p>
</li>
<li><p>你走，我不送；你来，无论多大风多大雨，我去接你。</p>
</li>
<li><p>当初走上那条相爱的路，他们谁都不知道目的地在何方，却依然坚定着信念向前走，只要对方在身边，所以去哪里都可以。年轻时，遇到让人心动的人不难，好看的皮囊，有趣的灵魂，都能令人心动不已。难的是，在心动过后，还能让彼此在长久的相守中心安，就像张家辉和关咏荷。在爱情里，他曾经很穷，穷得只能爱她，而她回报给他的，是除了他身边，她那里都不去。春来夏往，秋收冬藏，这样的爱情，来日方长。</p>
</li>
<li><p>你打瞌睡碰到我肩膀得一瞬间，我整颗心都要炸开了，虽然只是一瞬间，但至今想起来都要高兴不已。</p>
</li>
<li><p>谁曾见过风？你我皆不曾。但看木叶舞枝头（万木垂梢首），便晓风穿过。让风鼓动你的双翼，将它送去你身边。</p>
</li>
<li><p>如梦如幻月，若即若离花。</p>
</li>
<li><p>黑格尔曾经说过，历史给我们的教训是：我们从不会从历史中吸取教训。</p>
</li>
<li><p>我死后，身体将回归大地，那时，身体可触碰天际，万世仰望星空</p>
</li>
<li><p>你要做一个不动声色地大人，不准情绪化，不准偷偷想念，不准回头看。——村上春树</p>
</li>
<li><p>我熬过了所有的苦难，我已经不期待和谁在一起了。——马尔克斯</p>
</li>
<li><p>请记住那些对你好的人，因为他本可以不这样的。——宫崎骏</p>
</li>
<li><p>能离开的人，便不算是爱人。——张爱玲</p>
</li>
<li><p>幸好想念无声，否则震耳欲聋。</p>
</li>
<li><p>我只是想起了你，不是想你了</p>
</li>
<li><p>人说，林深时见鹿，海蓝时见鲸，梦醒时见你。可实际，林深时雾起，海蓝时浪涌，梦醒时也许未见鹿，未见鲸，亦未见你。但是，鹿踏雾而来，鲸随浪儿起，你没回头，又怎知我没来过</p>
</li>
<li><p>一次旅行，一次洗心，一次心动，一次亲密。哪怕再远，我都会奋不顾身放下手里的事情去找你，我不知道我有多喜欢你，但如果是去见你，我一定会用跑的。</p>
</li>
<li><p>“她割破了手指，他很紧张的跑去给她买创可贴，他是个哑巴，比划了好久，售货员还是不懂他的意思，他心急如焚地用小刀在自己手上也划了一个小口”我很喜欢这个故事，但如果爱情仅仅靠说说而已地话，那哑巴怎么办。</p>
</li>
<li><p>在有生的瞬间能遇到你，竟花光了所有的运气</p>
</li>
<li><p>海底月是天上月，眼前人是心上人</p>
</li>
<li><p>世间不如意事七八九，能与人言一二三都无</p>
</li>
</ul>
<h1 id="江湖"><a href="#江湖" class="headerlink" title="江湖"></a>江湖</h1><ul>
<li>天下英雄出我辈，一入江湖岁月催。 鸿图霸业谈笑间，不胜人生一场醉。 提剑跨骑挥鬼雨，白骨如山鸟惊飞。 尘世如潮人如水，只叹江湖几人回。 </li>
<li>何谓侠？仗剑、天涯、四海为家；可否具体？快意、恩仇、天纵潇洒；可否再具体？一人、一马、再无其它<ul>
<li>还有一个烧烤架</li>
</ul>
</li>
<li>江湖也没什么好的，也就酒还行</li>
<li>正当你背上剑决定马不停蹄一意孤行的时候，突然出现一个人，把你抱紧说：少年，我想和你分享这漫长的一生。你一激动，把剑扔了，把马烤了，一回头，人没了~</li>
<li>仙宫人竟去,空庭花乱飞,芳心向谁尽,无谓是沾衣</li>
<li>绿水本无忧，因风皱面；青山原不老，为雪白头。</li>
<li>“好想变成雪啊，这样就可以落在先生的肩上了……” “若是先生撑了伞呢？” “那就落在先生的红伞上，静载一路的月光。” “若是先生将雪拂去……” “那就任他拂去，能在他的手掌上停留一刻，便足矣。” ——《仁医》<ul>
<li>若是先生撑伞的同时快速旋转伞同时自身出了一个冰心并且以一个反方向转这样形成一股气流可以不断吹雪，加上上下横跳的走路灵巧避开所有雪呢？</li>
</ul>
</li>
<li>我倾家荡产才买了一把剑，准备喝碗酒就上路 碰巧你在邻桌笑，从此心中无江湖</li>
<li>儿女情长什么的，真的很影响大哥行走江湖</li>
<li>在古代，他们不网聊，不短信，如果你想她，就爬两座山，走五里路，去牵她的手。</li>
<li>此生来世都愿识尽世间好人，读尽世间好书，看尽世间好山水，天上风景再好，从不羡慕。</li>
<li>“何为苦涩？” “君往东，卿向西，永无相遇。” “可否具体？” “卿有情，君无意，候无佳期。” “可否再具体？” “彼岸花，花与叶，终无逢时。” “仍是不解？” “我笑着祝福你。”</li>
<li>你能渡万物轮回，能渡花草树木的枯萎，能渡恶人轮回，为什么不能渡我呢？你是世人的圣人，却唯独是我的恶人</li>
<li>进去一个寺庙，里面有个上香的人，外面是喧闹的芙蓉街，仅仅隔了一个门口，里面却非常安静。我站在里面跟小哥哥说，不能呆在里面太久了，万一被感化了，皈依我佛了怎么办？小哥哥看了我一眼：你慧根不够，怕是不能去出家。我说那你呢？我尘缘未了，也不能出家。然后我们就走了外面买了一个烤肠，好吃。</li>
<li>睡到二三更时凡荣华皆成幻境，想到一百年后无少长俱是古人</li>
<li>俺曾见金陵玉殿莺啼晓，秦淮水榭花开早，谁知道容易冰消。眼看他起朱楼，眼看他宴宾客，眼看他楼塌了。这青苔碧瓦堆，俺曾睡风流觉，将五十年兴亡看饱。</li>
<li>位卑未敢忘忧国，都道戏子无情，怎知戏子也有心</li>
<li>戏腔一开，八方来听，一方为人，三方为鬼，四方为神。凡人不看，不代表鬼神不看</li>
<li>我自谓半个活人，见山如荒骨，见海如静水，见花见草，也如死气升腾，天下万物也有白骨凋落的那一天，唯独见了你，荒骨附色，静水奔腾，花草接近新生，万物上了色，还了魂。</li>
<li>贺今朝曾经羡慕闲云野鹤，想做什么做什么，想去哪就去哪。但等他真正踏过山水，行路些许后，才发现天地山河，都比不上黎复照眉间风月，也不由地想起曾经和黎复照一起喝酒，笑说敢跟他姓的场景。 人生如一场宴会，来得人多，去的人也多，但从始至终，唯独他一直在。——观风月</li>
<li>这山河看着久了也就这模样，抵不过阿照眉目里头半分风月。——观风月</li>
<li>明月来复照，把酒贺今朝——观风月</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>我们做好朋友吧</title>
    <url>/2018/04/14/personal-2018-04-14-AsJoker/</url>
    <content><![CDATA[<h2 id="动漫梗"><a href="#动漫梗" class="headerlink" title="动漫梗"></a>动漫梗</h2><ul>
<li><p>凯多：你刚说要当什么王来着？</p>
<ul>
<li>——大哥，你听错了，我是海贼，叫王路飞。</li>
<li>王路飞：在叫我？</li>
</ul>
</li>
<li><p>雷利：我把One Piece告诉索隆了，你们去找他把。</p>
<ul>
<li>索隆：我带你们去吧。</li>
</ul>
</li>
<li><p>天空一声巨响，主角闪亮登场。</p>
<ul>
<li>黄猿闪亮登场。</li>
</ul>
</li>
<li><p>护夫狂魔汉库克已上线。</p>
</li>
<li><p>卡二指着太平洋对路飞说：看见了嘛，这是我对你放的水。</p>
</li>
<li><p>最快的果实给了最懒得人，最热的果实给了心最冷的人，最冷的果实给了心最热的人。</p>
</li>
<li><p>隔壁都写到下一代海贼王了。</p>
</li>
<li><p>桌前的尾田显得弱小，可怜又无助。他呆呆地坐在椅子上，没错，又到了交稿地日期。突然，手机发出了熟悉地“叮”的一声，尾田拿起手机激动的爆了句粗口：<code>QQ</code>看点的小编终于更新了！</p>
</li>
<li><p>但是赤犬忍了，他要留在海军去执行他心中的正义，他要是不忍，别的不说，打个路奇还是挺简单的。</p>
<ul>
<li>黄猿起码还是很听话的。</li>
</ul>
</li>
<li><p>我老沙谁都不服，和谁都五五开。</p>
</li>
<li><p>黄猿：三年又三年，一转眼三十年过去了，龙你再不来救我我就要当上元帅了。</p>
</li>
<li><p>冯克雷用右手摸别人的脸蛋就能变成那个人，用左手摸一下自己的脸蛋就能变回去</p>
<ul>
<li>要是摸了红发，没手变不会去怎么办</li>
</ul>
</li>
<li><p>柯拉松也许会迟到，但它永远不会缺席</p>
<ul>
<li>已经到了，还转发了。</li>
</ul>
</li>
<li><p>顶上战争被打到叫爸爸的男人——马歇尔·D·蒂奇</p>
<ul>
<li>原谅我不厚道的笑了。</li>
</ul>
</li>
<li><p>弗兰奇和布鲁克就是那种实力强悍，还喜欢到处划水的存在，海贼王都一千多集了，什么时候见他俩使出全力的。</p>
<ul>
<li><p>给弗兰奇三瓶二锅头，凯多早就干废了。</p>
<ul>
<li>兄弟，这里边你最懂兵法</li>
</ul>
</li>
<li><p>乔巴最可怜，打最狠的架，得最低得悬赏。</p>
</li>
</ul>
</li>
<li><p>巴基可是顶上战争开直播的男人。</p>
<ul>
<li>谁都打不过，跟谁都过两招。</li>
<li>网红鼻祖。</li>
<li>正是在下。</li>
<li>凯多送出了一个飞机。</li>
<li>大妈/罗杰/路飞/送出了一个穿云箭/玫瑰花。</li>
<li>罗杰船上估计只有巴基没有霸王色霸气，但他有霸王色运气。</li>
</ul>
</li>
<li><p>什么叫做烂尾，海贼王的船上有5个霸王色怎么了，怎么滴，你进清华北大里面不个个是大佬。</p>
</li>
<li><p>三将星之耻：斯慕吉。失踪、拔剑、榨果汁。</p>
<ul>
<li>九亿悬赏，八亿的腿</li>
<li>有事找库栗，没事找慕吉</li>
<li>斯慕吉：我不划水，三将星就死光了啊</li>
<li>斯慕吉：喂，谁快来阻止贝基他们啊</li>
</ul>
</li>
<li><p>基德：老弟我跟你说，真不是兄弟我若，咱几个谁来都一样。</p>
<ul>
<li>路飞：以前兄弟我不信你，直到那个狼牙棒过来的时候。</li>
</ul>
</li>
<li><p>你看的山贼王吧。</p>
<ul>
<li>——海军王。</li>
</ul>
</li>
<li><p>罗杰、白胡子：卡普，我当你兄弟，你却让我儿子叫你爷爷。</p>
</li>
<li><p>我是吃了人人果实的车，我的能力是没有中间商赚差价</p>
<ul>
<li>我是吃了鱼鱼果实的能力者，我的能力是可以变成鱼但是不能上岸，果实副作用是不能游泳</li>
<li>翻车鱼</li>
</ul>
</li>
<li><p>过年了，龙召集卧底们聚餐。那一日，红狗自己在空无一人的海军总部吃的年夜饭</p>
</li>
<li><p>铁骨铮铮王境泽，新人罗杰布鲁克，北大还行撒贝宁，区区四皇老甚平</p>
</li>
<li><p>莫利亚和凯多</p>
<ul>
<li>东海提督克里克可是曾经和五皇草帽分庭抗礼的。</li>
<li>这和角都在千里之外朝柱间扔了个手里剑有什么分别吗？<ul>
<li>上个打败我的，可是初代火影。</li>
</ul>
</li>
<li>没有剪刀的莫利亚是怎么玩的。</li>
<li>就是被甚平一拳打飞的那个呗，我当时看一位琦玉老师走错片场了呢。</li>
</ul>
</li>
<li><p>自从看了海贼王，我不抽烟了，酒不喝了，每天三餐营养均衡搭配，早睡早起，每天起来晨跑，就tm为了比尾田多活几天。</p>
</li>
<li><p>昨天我用明哥的步伐，还有黄猿的表情，学着斯莫格抽烟，去校长办公室，用白胡子和红发的台词，说了一句：给我个面子，做我儿子吧。后来我有了红发的胳膊，青雉的腿，藤虎的眼睛和黑胡子的牙</p>
<ul>
<li>醒醒，别做梦了</li>
</ul>
</li>
<li><p>如果你在一座荒岛上，让你选择一颗恶魔果实，你会选择哪个恶魔果实</p>
<ul>
<li>问题来了，我为什么会在荒岛上？<ul>
<li>造化钟神秀</li>
<li>阴阳割昏晓</li>
</ul>
</li>
<li>我选好了，去哪里领？是快递送到家还是去批发领还是政府统一发？</li>
<li>冰冻果实在海上造路</li>
<li>我还是想要袁世凯夺取的革命果实</li>
</ul>
</li>
<li><p>黄猿翘班闪现去月球旅游，刚好碰到正在考古的艾尼路。两人相见都吓得要死，立刻打了起来，随后发现都是能力者就停手了。黄猿：你是电？艾尼路：你是光？</p>
<ul>
<li>你是唯一的神话</li>
<li>你是秀儿吗</li>
</ul>
</li>
<li><p>瓦尔波是唯一比路飞能吃的</p>
<ul>
<li>大妈小时候吃到没朋友</li>
</ul>
</li>
<li><p>早就看出来鼬神要灭族了，因为全宇智波族唯有鼬神用的飘柔</p>
<ul>
<li>鼬神已经看透了那些杀马特</li>
<li>其他全是拉芳</li>
</ul>
</li>
<li><p>初代：四代你咋死的？</p>
<ul>
<li>四代：封印九尾死的</li>
<li>初代：啥？那玩意能死人？</li>
<li>四代：闭嘴，再问劳资打死你？</li>
<li>初代：我让你两只手</li>
<li>四代：有本事让我1002个（初代千手）</li>
<li>四代用的是查克拉，初代是查吨拉<ul>
<li>查纳拉，查微拉，查毫克拉</li>
</ul>
</li>
</ul>
</li>
<li><p>鼬：晓这衣服真难受，火遁还要伸脖子</p>
<ul>
<li>卡卡西口罩火遁都没说什么</li>
</ul>
</li>
<li><p>下一代火影应该是木叶丸吧</p>
<ul>
<li>必须的！他师傅是火影，师傅的爸爸也是火影，他师傅的老师也是火影，他爷爷也是火影，他爷爷的徒弟也是火影，他爷爷的徒弟的爷爷也是火影，他爷爷的徒弟的爷爷的弟弟也是火影，不让他当火影合适吗？</li>
<li>火影都是关系户</li>
<li>历史课代表</li>
<li>六代帝皇丸</li>
</ul>
</li>
<li><p>斑：因为你喜欢木遁，所以我起名木叶村</p>
<ul>
<li>柱间：因为你喜欢火，所以我起名火影</li>
</ul>
</li>
<li><p>水门：论实力鼬不一定打得过我，论资历我比她高。论天赋，我的天赋曾经震惊忍界，为什么他能称神。</p>
<ul>
<li>岸本：那你以后叫门神</li>
<li>水神，风神，波神</li>
</ul>
</li>
<li><p>房子漏水了，把宇智波止水叫来，宇智波止不了，叫宇智波带土来淹，土淹不了，证明宇智波鼬失败了，这时候宇智波佐助着拐杖，想移走宇智波富岳这座大山来挡水，可是他移不动，宇智波斑得动，大家都不信，只有宇智波信</p>
</li>
<li><p>初代：三代你又是咋死的？</p>
<ul>
<li>三代：我咋死的你心里没点bi数</li>
</ul>
</li>
<li><p>打辉夜的时候，一乐：鸣人记住你只有一次机会，如果你失败了，我就会秒了他</p>
<ul>
<li>一乐：现在的小孩都不吃拉面了，这样的世界毁了算了</li>
<li>一乐：现在的孩子都不吃拉面了，鸣人我要创造一个为你存在的世界，开启9勾玉轮回眼，无限月读</li>
</ul>
</li>
<li><p>旗木五五开、旗木猹猹西（闰土）</p>
</li>
<li><p>此生无悔入火影，来世愿生木叶村</p>
</li>
<li><p>木叶飞舞之处，火亦生生不息。</p>
</li>
<li><p>整个火影故事里，有人相信血统，有人相信精神，有人相信身体，有人相信眼睛，有人相信先天传承，有人相信后天努力。只有大蛇丸，他相信科学。</p>
</li>
<li><p>第四次忍界大战后，鸣人参加合营考试之前先参加中忍考试，一群规则是不允许开仙人模式，于是鸣人身后默默地升起来几个求道玉。</p>
</li>
<li><p>佩恩杀的自来也，和我长门有什么关系呢</p>
<ul>
<li>你抓鲁迅跟我周树人有什么关系</li>
<li>你抓佩恩跟我长门有什么关系</li>
</ul>
</li>
<li><p>小李用努力证明了，在一群挂逼面前什么都不是</p>
<ul>
<li>佐助证明了，只要充钱就能变强</li>
<li>大招一开封号八百集</li>
</ul>
</li>
<li><p>天晴了，雨停了，二柱子觉得自己又行了。</p>
<ul>
<li>天阴了，下雨了，二柱子一瘸一拐地回来了</li>
<li>放最狠的话，挨最毒的打</li>
</ul>
</li>
<li><p>赢了当村长，输了娶小樱</p>
</li>
<li><p>看火影那么多年，才知道。晓组织的十叛忍：佩恩，迪达拉，小南，鼬，绝，带土，鬼鲛，角都，飞段，蝎。代表了人类的十个梦想：和平，艺术，友情，亲情，统治，爱情，力量，金钱，宗教，童年。</p>
<ul>
<li>晓组织的十叛忍：佩恩，迪达拉，小南，鼬，绝，带土，鬼鲛，角都，飞段，蝎。代表了工科生的十个梦想：通信工程，爆破工程，材料工程，工程热力学，基因工程，运输工程，水利工程，医药工程，社会工程，机械工程。还有曾经加入晓的大蛇丸和佐助，代表了生物工程和电子工程。</li>
</ul>
</li>
<li><p>游龙当归海，还不迎我自来也。猛虎当归山，山不迎我大豪杰，云鹤当归天，天不迎我妙木仙。</p>
</li>
<li><p>火影里有个人，他光棍节出生，一辈子不顺，被自己亲手教的徒弟杀死，尸体沉入大海。差一点能跟女神在一起，差一点就可以看到徒弟成为火影，就连火影完结日也没能赶上，11.10日火影完结日的后一天，就是他的生日，他叫自来也，总是差一点点就能圆满。</p>
</li>
<li><p>博人问鸣人：爸爸，你年轻的时候干了什么伟大的事啊？</p>
<ul>
<li>鸣人：我用了15年，帮我曾经最喜欢的女生追回了她的丈夫</li>
<li>博人：那妈妈呢？</li>
<li>鸣人眼里光线都温柔了：妈妈坚持到了我爱她的那一天</li>
</ul>
</li>
<li><p>川木袭击木叶</p>
<ul>
<li>那家伙不在的话，村子里能装逼的，就只有我了</li>
<li>卡卡西在疯狂想带土的账号和密码</li>
</ul>
</li>
<li><p>一天，佐良娜对佐助说：爸爸，爸爸我也要万花筒写轮眼。佐助没办法，去找大蛇丸秽土转生了鼬，佐助告诉了鼬，然后鼬一巴掌呼死了佐助，对佐良娜说：愚蠢的侄女啊，憎恨我把……</p>
</li>
<li><p>斑：你tm也想起舞吗？</p>
<ul>
<li>斑：一脚踹开棺材门，左边看一眼右边看一眼。心想：柱间不在，劳资可以装逼了。</li>
<li>斑：你见过我全盛时期得样子吗？柱间：不仅见过，我还锤过。斑：你也想起舞？柱间：我甚至想蹦迪！</li>
</ul>
</li>
<li><p>木叶谁都可以惹，上忍随便虐，火影也可以玩，但是千万不要去惹下忍</p>
</li>
<li><p>都tm别惹我，我看了900多集柯南，精通两千多种杀人手法，了解800多种不在场证明，上一个不给我点赞的已经凉了，你们自己看着办吧，为了让更多的人了解我的可怕，送我上去</p>
</li>
<li><p>一袋米要扛几楼（感受痛楚吧），一袋米要扛两楼（思考痛楚吧），一袋米又给多了（接受痛苦吧），一袋米有稀泥（理解痛楚吧），苦苦有泥（现在开始），谁给你一袋米哦（让世界感受痛楚），辛辣天森（神罗天征）</p>
<ul>
<li>为了一袋米毁灭世界的人</li>
</ul>
</li>
<li><p>名声，力量，曾拥有电瓶世界一切的男人偷车王切格·D·周某，在入狱前的一句话让全世界人们奔向停车场，我把所有的电瓶车都放在那里了，于是让世界迎接大偷车时代，偷车王，老子当定了</p>
</li>
<li><p>奥特曼为什么不一开始就放死光？</p>
<ul>
<li>你斗地主一开始就放王炸？</li>
</ul>
</li>
<li><p>吃你们饭的是姚麟，和我古力德（贪婪）有什么关系？</p>
</li>
<li><p>这叫留一手（爱德华，姚麟被吃进暴食肚子里，带了阿尔一只手）</p>
</li>
<li><p>下雨=无能</p>
</li>
<li><p>金伯利：带着四个演员怎么打（钢炼）</p>
</li>
<li><p>懒惰最勤奋，暴怒最冷静</p>
</li>
<li><p>认爹大军，（父亲大人）</p>
</li>
<li><p>星爵才是真的牛逼，银护一打养父，银护二打生父，复联34打岳父，他才是真正的灭爸，真父愁者~</p>
</li>
<li><p>雷神上赛季出一把黑切拿了败方MVP，这赛季想出肉带飞全场，没想到钢铁侠顶着被封号的压力开外挂秒杀全场，导致美队心态爆炸宣布退游。</p>
</li>
<li><p>复联一，有鹰眼，赢了。复联二，有鹰眼，赢了。复联三，没鹰眼，输了。复联四，有鹰眼，赢了。这个故事告诉我们，打团不能没有射手</p>
<ul>
<li>复联1，浩克上了，赢了，复联2，浩克上了，赢了，复联3，浩克没上，输了。复联4，浩克上了，赢了。这个故事告诉我们，打团坦克不能怂</li>
</ul>
</li>
</ul>
<h2 id="沙雕网友使我快乐"><a href="#沙雕网友使我快乐" class="headerlink" title="沙雕网友使我快乐"></a>沙雕网友使我快乐</h2><ul>
<li><p>我现在还不知道如何回答你的问题， 但是总有一天我会回答它， 只要答案真的存在，我就会将其抓住， 比起等我回答更重要的是相信自己的力量。</p>
</li>
<li><p>周瑜死后，诸葛亮非常伤心的参加了周瑜的葬礼。但是诸葛亮死后，周瑜为什么没有参加诸葛亮的葬礼。由此可见周瑜妒忌怨恨，此人心中狭隘。</p>
</li>
<li><p>最近学校开了门通识课，叫《制服诱惑》，被选爆了根本抢不上。到了课上，一位大师傅带着《阿含经》给大家讲佛教哲学，如何克制、制服我们的诱惑。</p>
</li>
<li><p>虽然我也是学富五车，但是这个问题在第六车上</p>
</li>
<li><p>给你五毛，删掉，我发！</p>
<ul>
<li>有些话不能乱说，里面是有忌讳的，你还小，不懂这里面的套路，有些话说出来，冥冥之中你的生活就会改变轨迹，看似简单的一句话，将会影响你的一生，你没有能力把握它。所以听哥一句劝，把这句话删了，让我来说。</li>
</ul>
</li>
<li><p>算命先生：你算什么东西？</p>
<ul>
<li>配钥师：你配吗？配几把？</li>
</ul>
</li>
<li><p>有次考试，“惠”字忘记咋写的了，我突然想到桌子上有瓶水，赶紧打开，md再来一瓶。</p>
</li>
<li><p>日本的文化给我感觉就是我的杀父仇人有个貌美如花的女儿</p>
</li>
<li><p>多年前有个笑话研究报告。说是蜘蛛听觉在脚上。实验过程是这样的：对着蜘蛛大吼一声，蜘蛛跑开了，同一只蜘蛛，把腿都剪掉再对他大吼一声，蜘蛛没跑，由此可证，蜘蛛听觉在脚上。</p>
</li>
<li><p>我让媳妇听了这首歌，她竟然说不好听，就跟她吵了起来，可后来我想：我一个大男人，为何要和一个女人计较，何况还是媳妇。我当时就道歉了，媳妇也很高兴，放下了手里的菜刀，她妹妹抓着我头发的手也松开了，丈母娘的拐杖也扔了，老丈人拿出手机说：棺材退了吧。看看，只要多沟通，生活还是蛮和谐的。</p>
</li>
<li><p>一边看看点一边吃饭，忽然停电了，我急忙扒了两口饭，瞬间来电了，我惊呼，这莫非是扒扒拉能亮</p>
</li>
<li><p>突然好想去放牛，没有压力，没有江湖套路。以我的智商，只放一头，多了我也数不过来，它吃草就行了，累了，就趴在牛身上睡觉，饿了就喝点牛奶，无聊了就吹吹牛逼。</p>
</li>
<li><p>笑得我葡萄牙和西班牙都掉了，就剩下一颗姜子牙，还流了一身阿富汗，我就随手用吕布擦了擦，我又看了一眼天上的赵云，用狂铁打造了部饮魔刀，坐在小乔上面钓了一条周瑜，上了一炷孙尚香，默默点了个公孙瓒。</p>
</li>
<li><p>有次我去挖人参，忘记套红绳了，结果人参跑了，我一直追到了珠穆朗玛峰，我感觉人参已经达到了巅峰。</p>
</li>
<li><p>大家不要相信他发的东西，上次他说吃榴莲之前放进微波炉里五分钟会更甜，md现在家里都不能呆了，邻居们劝我搬家，说我在炖屎</p>
</li>
<li><p>人生三大错觉：1.她喜欢我 2.我能反杀 3.手机有信息</p>
</li>
<li><p>我柯镇恶行走江湖这么多年什么没见过？出手吧。。。三秒后。。。要杀要刮悉听尊便！</p>
</li>
<li><p>考拉一生99%的时间都用于吃和睡，还有1%的时候用于找对象，它们漫无目的的晃荡着找，如果实在找不到，就放弃了，回去继续睡。 </p>
</li>
<li><p>你好，我同学的号上什么也没有，希望你赶紧把号还给他当然我的号也没什么有价值的东西，也不要盗我的号，我是学计算机的，我有100种方法让你现形 ，希望你赶紧把号还给他，要不然我就要采取一些手段了，到时候你就难堪了。</p>
</li>
<li><p>银角大王将宝葫芦倒置，喊了一声：“周鸿祎！”周鸿祎应了一声，嗖的便被吸了进去。银角大王查看时，里面除了周鸿祎，还有360杀毒、360压缩、360浏览器、360安全卫士、360游戏大厅等熙熙攘攘一干人。银角大王惊讶道：“怎的来了这么多？”宝葫芦开言道：“我就只点了个‘下一步’。” 危险！您的宝葫芦有53个漏洞。银角大王正要说话，看到一旁的李彦宏在笑，大怒，反转宝葫芦正要喊，李彦宏嗖的一声钻进了宝葫芦，银角大王转过葫芦一看，里面除了李彦宏，还有百度贴吧、百度手机管家、百度浏览器、百度杀毒、百度输入法、百度外卖、百度安全中心、百度云、百度音乐、百度知道、百度百科……密密麻麻一干人，银角大王问怎么回事，宝葫芦开口道：“我什么都没干！”旁边马化腾看了笑出了声，银角大王怒了，翻过葫芦就对准了马化腾，刚想开口，突然见马化腾拿了一个一模一样的葫芦站在银角大王家门口。</p>
</li>
<li><p>我是个主玩盾卫的玩家，有一次遇到一个喇叭找人带虎狼的新人，我打得慢，我也就免费带了他，我看他装备比较奇怪，可能是个回归萌新，我就想起了刚玩这款游戏时候的我，我也是一个小白，在大家的帮助下开始冲钱的。最后出了他的武器，打完虎狼她加了我好友 当然 我同意了，那时候我还不知道她是妹子，ID不太看得出来。后来她还是每天都要蹭我的虎狼慢车， 以前我把元宝看的相当重要 但没关系，她经常忘了关宠物抢我元宝，有一次她跟我说她近一段时间应该不会玩游戏了，她被小草洗号了，然后我才后悔怎么没早告诉她预防小草关远程什么的。我这段时间也越来越强，买了新天空开始挑战宝莱坞和博士。然后她回来了，脚底有个十分显眼的甜心特效，她跟我说她开始懂得变强了，有兴趣继续玩下去了。我和她占了一条博物馆，带她一起升级，我们每天都会打虎狼，她也时不时要抢我元宝，有一次打仓库还抢了我一个挺不错的徽章，我喷了她好久。有一天她说她打不过梦幻图书馆，完全不会跑，我也解释不清楚，她就加了我扣扣让我语音教她打，我比较腼腆 接通语音我才知道她是妹子，我顿时不知道该怎样和妹子对话.. 教她打过梦幻图书馆，我运气很好地出了个格挡韧性的徽章，而更令我感到幸运的是她那句“一直以来谢谢你啦”。我们的等级越来越高，我和她挂机都没磕秘药和经验buff，我在等她升级。后来有一天我上号看到她在线，给她发了一个的表情 0.0 ，她说她260了，于是我就带他走了一波宝莱坞。我打得很艰难，毕竟我才262，她也语音跟我说这个副本这么难打的啊～第二天我正在推塔，看见她上线了就问她要打什么本不，她说不了，她挂了个黄，宝莱坞和大桥都带她打完了。我也不知道为什么，我的心情很沉重，但是我没有问她什么 怕她感到尴尬。后来在有一天在宝莱坞门口我遇见他们了，因为我们一直都喜欢在10线。她说带我一起，我看了看她黄的信息，265级的匕首，新天空百爆百速，血皇饰品，天九武器，古代披风。曾经我们在一起经历了那么多的战斗，现在我才知道我和他差距是多大。他打宝莱坞很快，也把她保护得很好，我在旁边尽可能放特效高点的技能找存在感。她坐在一旁的时候直接组队说 说以前以为我超级厉害的，后来遇到了大佬才发现我和她一样的咸鱼。我没说话，但我心里很气。之后几个星期我没有再主动找过她，她也不再需要我带副本，我不知道她对于我是怎样的存在，只是莫名地觉得心很痛。后来有一次代古斯攻城，我一眼就看到了人群中没有上位的她，但我没有说话，默默地蹭代古斯，她也没有跟我打招呼。<br>所以说谁能资助我买个三千爆手？</p>
</li>
<li><p>今天走在街上一小孩对我吐口水，我不但没有骂他反而摸摸他的头说：真懂事！给了他5块钱，告诉他对别人也要这样。等我逛一圈回来看到她脸已经肿了</p>
</li>
<li><p>马岱，字丁琳，吗丁啉专治魏延</p>
</li>
<li><p>昨儿天儿太热我家热得快炸了</p>
</li>
<li><p>我这辈子没喜欢过哪个明星，唯独蔡徐坤是个例外，真心喜欢她， 因为他救过我的命。那是2018年的晚上我吃了包过期的辣条，地沟油中毒，医生说太晚了，我在弥留之际看了一眼电视，坤坤正好在跳舞，我立马吐了出来</p>
</li>
<li><p>大家注意了！！在一些国道上，有一些不法商贩打着卖草莓的幌子贩卖人体器官。一定要警惕！就在昨天，路过路段时，有人卖草莓，我过去尝了尝，当尝到第30个的时候，他压低声音在我耳边问我：你要脸不？我没敢要</p>
</li>
<li><p>对不起，我不接受网恋，虚无缥缈的东西给不了我安全感，猜忌和怀疑是深夜流泪的根源，我要稳稳的幸福，伸手就能碰到的那种。但是——如果你问我网恋吗，前面的话就当我没说，加我。</p>
<ul>
<li>好好得为什么要网恋，是酒不好喝了，还是游戏不好玩了，看也看不见，摸也摸不着，有啥好玩的？但是你要是问我网恋吗，前面的话当我没说，加我！</li>
</ul>
</li>
<li><p>我faker谁都不服，就服兵役</p>
</li>
<li><p>余歌，多好听的名字，可惜你姓张</p>
</li>
<li><p>天醒吧的朋友们再见了，很抱歉做了这个决定，希望我们有缘再见吧，因为遇到了一些意料之外的突发状况，对我的影响和打击比较大，所以不打算继续呆在吧里了，和大家道个别吧，真的挺舍不得你们的，这么久了，能够认识你们真的很开心，谢谢你们带给我了许多的欢乐和感动，谢谢你们一直陪伴在我身边，这次离开贴吧，主要原因是我的手机没电了，等我充好电就回来。</p>
</li>
<li><p>他龙袍加身，他富可敌国。他权倾一方，他俯瞰众生。他山珍海味，他挥金如土。他博学多才，他智勇双全。他英俊潇洒，他妻妾成林。他高大威猛，他夜夜春宵。他风流倜傥，他万众瞩目。他杀尽负他之人，他斩尽世间不平。<br>他醒了。他要开始搬砖去了</p>
</li>
<li><p>吉尼斯世界纪录因记录了最多的吉尼斯世界记录而被吉尼斯世界纪录记录为吉尼斯世界纪录，而这也被吉尼斯世界纪录记录为第一个记录吉尼斯世界纪录的吉尼斯世界纪录</p>
</li>
<li><p>一天，老师开始发试卷，一个女生多拿了一张，她大喊：老师我有了我有了。一男生没有试卷，他大喊：是我的，是我的。教室瞬间安静了。</p>
</li>
<li><p>9月4日晚，无业游民张某约网友刘某到自己的出租屋内喝酒。期间刘某感叹有钱人太多，张某随即表示：不如出去弄点钱？刘某随即响应。解放路的监视探头显示，9月5号凌晨5时16分许，他们的早餐摊支起来了。</p>
</li>
<li><p>记得有次我被五步蛇咬了，我立马抓住了那条蛇。每走4步就让它咬一口，就这样坚持到了医院。有次我朋友也被五步蛇咬了，可惜他没有抓住那条蛇，于是他只能每走4步就跟别人借一步说话。就这样坚持到了医院。</p>
</li>
<li><p>如果一个男孩子对你这种彪悍的女孩子特别好，只有一个原因，他敬你是条汉子。</p>
</li>
<li><p>初墨，多么优雅的名字，可惜他姓熊。扒杰，多么高端的名字，可惜他姓朱。渔歌，多么诗意的名字，可惜他姓章。巅峰，多么上气的名字，可惜她姓杨。紫藤，多么仙气的名字，可惜她姓杜。</p>
</li>
<li><p>我上京东去买了一个降落伞，而且惊奇的里面居然没有差评，我马上就买了一个，立马坐着飞机去跳伞，在我跳下去的那一刻，我似乎明白了为什么没有差评</p>
<ul>
<li>应该是并夕夕</li>
</ul>
</li>
<li><p>看一个小妹妹在网吧玩植物大战僵尸，坚果放最后，前面放炮手，我强忍住笑问她为什么？她说那坚果笨笨傻傻，所以我要保护她，突然想，看似成熟的我们，其实丢掉了很多。然后我打举报电话查封了这家允许未成年上网的黑网吧</p>
</li>
<li><p>对啊，谁没追过星啊，追星那时候我都是啊啊啊啊啊我这辈子非朴灿烈不嫁，最后我还不是当了边伯贤的老婆嘛。</p>
</li>
<li><p>埋炸弹的小女孩一晚上没有卖出去一个炸弹，她冷的不行了，点燃了一个炸弹，结果全镇人都见到了他们的祖母</p>
</li>
<li><p>我今年22岁，男，年纪轻轻就有车有房，和一个成熟稳重的80岁的女朋友，我不想表达什么，只是想跟大家说，加油，一定会闯出属于自己的一片天！</p>
</li>
<li><p>最近买了电子烟，使用感觉还不错。昨天出门坐公交车随手就塞到了牛仔裤兜里，可能是牛仔裤太紧，压倒开关了，整个车厢的人都看我胯下部位一直在冒烟，我还根本没发觉，知道一个好心的哥们拍拍我：哥们，你好像屌炸了。</p>
</li>
<li><p>学校统一订购辅导书，价格十块，回家跟老妈报12块，多出的2块准备私藏。老妈不行，问了我同年级的邻居，他竟然说15块……我永远忘不了老妈惊讶的表情看着我说：是多少就说多少嘛，你那点零花钱留着自己用。说完给了我15块，望着邻居，我真心觉得自愧不如。</p>
</li>
<li><p>1、在非洲，毎60秒，就有一分钟过去。</p>
<ul>
<li>2、凡是每天憋尿过多的人，有高几率100年内死去！</li>
<li>3、据研究，毎呼吸60秒，就减少1分钟寿命。</li>
<li>4、当你吃下了20碗米饭，换算下来竟然相当于摄入了20碗米饭的热量。</li>
<li>5、谁能想到，这名16岁少女，4年前只是一位12岁少女。</li>
<li>6、中国人在睡觉时，大多数美国人在工作。</li>
<li>7、当蝴蝶在南半球拍了两下翅膀，他就会稍微飞高一些。</li>
<li>8、据统计：未婚生育的人中有大多数为女性。</li>
<li>9、如果你每天省下来一包烟钱，10天后你就能买10包烟。</li>
<li>10、当你左脸被打，你的左脸就会痛。</li>
<li>11、人被杀，就会死。</li>
<li>12、中国教英语方式有极大错误，在美国就连小学生都能说一口流利的英语。</li>
</ul>
</li>
<li><p>紧急通知，据科学研究表明，千万不要喝刚烧开的热水。——因为会烫</p>
</li>
<li><p>一天，蔡徐坤在拿抹布擦桌子，看到一只小蚂蚁，于是他儒雅随和的问，小蚂蚁，你的父母呢？怎么只有你一个？小蚂蚁回答：你抹死了</p>
</li>
<li><p>你不得不承认的6个事实：</p>
<ul>
<li>1、你的头转不了两圈；</li>
<li>2、你数不了自己的头发；</li>
<li>3、当你把舌头伸出来鼻子不能呼吸；</li>
<li>4、你正在做第三条；</li>
<li>5、你发现原来你可以做到；不过样子看起来像小狗；</li>
<li>6、你正在笑，因为我把你整了。</li>
</ul>
</li>
<li><p>昨天我去鬼屋玩，被吓了一跳摔了一跤，整个屋子的鬼都围过来问我有没有事！</p>
</li>
<li><p>今天去电影院看前任3我没哭，出电影院我哭了，我的电瓶车不见了</p>
<ul>
<li>周某：我胡汉三又回来了</li>
</ul>
</li>
<li><p>刚才坐公交过大桥，上了大桥我对司机说我坐过站了，车内的人全站了起来，其中一个掏出20元给我，我说tmd20元做出租车怎么够啊，又有几个人站出来拿100元给我说，大兄弟别激动，这些钱给你等一下叫滴滴</p>
</li>
<li><p>西天取经，六耳猕猴混了进来，真假美猴王只有唐僧能分辨出来。唐僧说：“为师想吃桃子。”两猴犹豫了一下，都变成了桃子，突然唐僧大喊：“八戒，给我拿下那只猕猴桃”</p>
</li>
<li><p>小时候说要把头发梳成大人摸样，长大了发现大人并没有什么头发。</p>
</li>
<li><p>高中那时候，我坐暖气垫旁边，一个冬天的早上，女同桌带来了一袋牛奶，他放在暖气垫上想把牛奶加热，过了一会，她碰了碰我，说：摸摸我的奶，热了没有。结果那一整天我都没有好好听课。</p>
</li>
<li><p>以前有个学长，四川的，军训的时候有一天早上他就喊：孩子，我的孩子呢。</p>
<ul>
<li>我们都看他挺年轻的就问他：你孩子多大啊？</li>
<li>四十二啊</li>
<li>你多大？</li>
<li>十八啊？</li>
</ul>
</li>
<li><p>校长说了：看到老人跌倒就要扶，要是讹你，我来替你出30万，政治老师陪你去法庭，语文老师做辩护，数学老师算胜率，你要是被关进去，地理和物理老师勘测地形，化学老师配置炸药，体育老师救你出来</p>
</li>
<li><p>小姐姐能求你们件事麻？小时候家里比较穷，断奶比较早，希望这几位姐姐能帮我找回那段不完整的童年，好人一生平安</p>
</li>
<li><p>只要你喜欢沙雕表情包，我们就是好朋友</p>
<ul>
<li>沙雕网友拿了就走</li>
</ul>
</li>
<li><p>在胡同里听见有人喊：陛下、陛下。我抬头应了一声：谁在呼唤朕。然后被泼了一脸水，楼上泼水那妹子却说：早喊你避一下了，活该。我捡起砖头，叫了她一声王后！</p>
</li>
<li><p>曾经有人跟我说，只要去了广东，就会在一声声靓仔中迷失自我，可我到了广东之后，他们都叫我叼毛。</p>
</li>
<li><p>我要去马来西亚开会，3月8号那天给老婆发信息，告诉老婆我已上飞机，搭乘马航MH370回来，结果马航……出事了。我已经在宾馆呆了两年多了，求高人支个招，我想回家……</p>
<ul>
<li>三年前，我老公要去出差，三月八回来，当天新闻马航370出事了，正好老公那班，伤心抱着隔壁老王嚎啕大哭，怎么会这样<ul>
<li>他在一楼</li>
</ul>
</li>
</ul>
</li>
<li><p>一场辩论赛主题是“辩论赛究竟有没有意义”，正方选手进行了认真的准备，并按时到达了辩论赛场。过了半个小时，反方还没有出现。</p>
</li>
<li><p>我爱上一个女孩，可是她的家人极力反对，哎，尤其是她的老公，扬言要砍我</p>
</li>
<li><p>刘备驾马将跌入悬崖，张飞见此便喝到：主公，你快勒马！刘备：我快乐你妈隔壁</p>
</li>
<li><p>古代有个商人从川中收购了一批柑橘、芝麻、小麦、兽皮准备运过河对面去卖，然后他租了一条小船运货物，突然船桨断掉了，船夫就问商人，你的货物中有没有什么东西可以做船桨的？</p>
<ul>
<li>——我有橘麻麦皮不知当桨不当桨</li>
<li>古有一商，于川中购一批麻、橘、麦、皮，以船运于外地贩卖。船半途，水急桨朽，桨断而顺水失，船夫甚急，顾商人：无桨不得行，尔货中有长直之物可当桨？商人道：吾有橘麻麦皮不知当桨不当桨？</li>
</ul>
</li>
<li><p>我杀谁都是死刑，生命在我面前，何其平等</p>
</li>
<li><p>程序员：我去相亲网站找女朋友了</p>
<ul>
<li>——找到了么？</li>
<li>程序员：找到了他们页面的bug（敬业）</li>
</ul>
</li>
<li><p>心理学上有潜意识激励的说法。例如你每天早上出门前对着镜子说一句“你很棒”，一段时间后，那块镜子就会成为一块很棒的镜子</p>
</li>
<li><p>泽大怒，怒以手指天曰：吾王境泽，便是饱受饥之苦，即死于野兮下临不测之渊，乎又以手折腰指于众，众人皆惊，速退数步，泽见而笑矣，仰天长笑曰：吾定不为五斗米，必不食尔等小粒食！未几，泽顾左右，笑曰：甚香！</p>
</li>
<li><p>吾得一元，购糖，拐幼童，得千，寻风尘女子，事毕迷之，取得肾，得万，购弹药，抢银行，得五百万，钱已有，已不愁身后之事，自觉坏事做绝，需改过，于午时遇一跌倒老者，遂扶之，剩八角。。。</p>
</li>
<li><p>我养了一条鱼，我非常喜欢他，有一天我发现他死了，这令我悲伤不已，我不想土葬，我想把它给火葬，把骨灰洒回海洋让她回到母亲的怀抱，谁知道这玩意越烤越香，于是我开了瓶啤酒，真香。</p>
</li>
<li><p>木兰从军后，很想念母亲，于是就把母亲的样子绣到了手帕上，将军看到了，关切的问：“你秀你妈呢？”待木兰凯旋而归，皇上论功行赏，看见了木兰秀的这个手帕，皇上说：“此手帕可有人与卿共秀之？”木兰答：“没有，臣独秀”</p>
</li>
<li><p>高手在人间，失手在阴间，人躺太平间，视频留人间，兄弟吊炸天，死后必升天，这人我见过，走的很安详，那天风很大，火烧得很旺，骨灰还滚烫，家属很坚强，没有流眼泪，还在打麻将。</p>
</li>
<li><p>车速不快，嚼颗槟榔；槟榔加烟，法力无边；槟榔生吞，道法乾坤；槟榔配酒，永垂不朽；槟榔加烟又加酒，阎王在向你招手，槟榔加狗屎，枪都打不死；槟榔加红牛，嚼完操地球；槟榔加月经，越吃越年轻。</p>
</li>
<li><p>懵逼树上懵逼果，懵逼树下你和我，懵逼树前排排坐，一人一个懵逼果，懵逼有你还有我，原来懵逼不止我，懵逼树下懵逼魂，懵逼魂中懵逼人，一人一个懵逼魂，人生懵逼最销魂。一人一座懵逼坟，来世再做懵逼人。哦~耶……</p>
</li>
<li><p>昨天我在网吧，玩吃鸡一看只剩一块，便无聊打开苍老师的视频，看了一个多小时还没下机，我就去问网管是不是机子出问题了，网管深吸了一口烟，斜着眼看着我说：“你后面那三个小学生没人给你充了5块”</p>
</li>
<li><p>1998年我去云南瑞丽逛赌石市场时随手买了一个，鹅蛋大小，讨价还价半天5块钱拿下，切开一看当场惊呆所有人，糯种、满色、正阳绿、六分水，没有一丝绺裂！唯一的缺点就是有点酸，不过老板说正常，缅甸猕猴桃都这样。</p>
</li>
<li><p>你好！我叫宅博士，我是星星球上最杰出的机器师，我的父亲叫宅在佳，桃子姐姐是我暗恋的对象，我有五个孩子， 名字叫开心、花心、甜心、小心、粗心，他们都是半机器人，总有一天我会让QQ看点里的人都认识我宅博士</p>
<ul>
<li>——认识你了，好了你的愿望实现了，快去睡觉把</li>
<li>——应该是搬砖把</li>
</ul>
</li>
<li><p>当鲸鱼在海洋中死去，它的尸体最终会沉入海底，生物学家赋予这个过程一个名字“鲸落”，一座鲸鱼的尸体可以供养整套生命系统长达百年，这是它留给大海最后的温柔。但很多人不知道的是，当鲨鱼在海洋中死去，也会掉落海底，也有一个浪漫而孤独的名字——鲨凋</p>
</li>
<li><p>萧峰开局满级，段誉半路开挂，虚竹盗满级账号，慕容复前期靠着充值大礼包到处浪，后期都没有满级，只有鸠摩智前期一步一个脚印打怪升级，后期满级，但由于前期欺负段誉，后期被段誉开挂暴打，一气之下删装备退游</p>
<ul>
<li>——乔峰是遇强则强</li>
<li>乔峰：只要音响没灭就每一个人能打败我，导演说的</li>
<li>bgm在乔峰就不会败</li>
</ul>
</li>
<li><p>我一个人默默地走在路上，忽然看到一个背影很像辰东的人，我快速冲了上去，然后，到了近前发现不是他，我叹了一口气，轻轻放下了手中的板砖。</p>
</li>
<li><p>叙利亚：美国你为什么打我？</p>
<p>​    ——美国：因为我怀疑你有核武器。</p>
<p>​    叙利亚：那中国也有核武器，你怎么不打中国</p>
<p>​    ——美国：因为中国真的有核武器</p>
</li>
<li><p>“娘娘让我用魔器取大王心脏，朝歌城便可失而复得了”</p>
<ul>
<li>“来吧，只要爱妃高兴，我什么都愿意”</li>
<li>“大王，没有了大王，天下对我又有何用？”</li>
<li>“臣妾有一事隐瞒大王多时了”</li>
<li>“朕早就知道爱妃是狐狸变的，寡人宁负天下也绝不负你。就像我们当初相识，来来来，我和美人斟酒对饮”</li>
<li>“其实臣妾是公狐狸变的～”</li>
</ul>
</li>
<li><p>李云龙：什么他娘的精锐，老子打的就是精锐。</p>
</li>
<li><p>渣男 全体起立 ，入队宣言：从此寻花问柳，不谈一生厮守， 从此灯红酒绿，再也不想牵谁的手， 从此人海漂流，闭口不谈爱到白头， 从此单打独斗，再也不会为谁彻夜流泪，从此放下离愁生生世世酒，敬自由 再见了</p>
</li>
<li><p>小明很冷，把毯子裹在身上，老师说：请改成被字句。小华不假思索地说：小明很冷，把被子裹在身上。老师说：你可以滚了</p>
</li>
<li><p>等我哪天死了，不要把我埋了，把我的骨灰撒到大海里，我不是为国家省土地，也不是心怀宽广去守护祖国的海洋，只是希望死后依然能够浪起来……</p>
</li>
<li><p>她对我说：这班上有你喜欢的吗？我嗯了一声，她问我是谁？我说你猜，然后她把班上同学猜个遍，我都摇摇头，她问还有别人吗？我没说话，她立马脸色绯红，我把嘴凑到她耳朵边说：还有男生你没猜呢。</p>
</li>
<li><p>大学里，看我不顺眼的一定告诉我，我马上改，千万别在水里下毒；觉得我让你丢面子的可以好好和我交流，千万别趁郊游时让我溺水身亡；觉得我哪里招惹你了可以放学留下我，千万不要深夜连捅我18刀；如果你觉得我上课表现积极过于装逼，请一定给我小纸条，不要最后下课了用教学用具将我殴打至半身不遂；如果觉得我和你女神男神走的太近，请和我成为好基友，我会帮你搞定他，千万别看到我的时候泼硫酸；如果觉得你精神出现了问题，可以告诉一起的室友，我们一定不会放弃你的，别演变成灭寝惨案…如果我能顺利毕业，真心感谢各位同学的不杀之恩/微笑</p>
</li>
<li><p>好男生不会撩妹，会撩妹大半渣男，喜欢你的你看不上，没对上眼废话贼多，对上眼了又不敢说，总之你喜欢的名花有主，喜欢你的惨不忍睹，我是个有故事的男生，你是个没想法的女生，游戏好玩，学业繁重，我就是直男。</p>
</li>
<li><p>小时候家里穷，买不起鞋，只能穿着破洞的小布鞋躲在角落里看着人家穿着光鲜亮丽的球鞋在球场上奔驰，从那起我就发誓以后一定要让像我一样的人穿的起球鞋。长大后我的梦想实现了，成为了一名出色的莆田鞋贩，买鞋加我。</p>
</li>
<li><p>午时三刻，监斩投令，刽子手举刀欲斩，死囚仰天大笑三声“哈哈哈！”刀止，监斩不解，问死囚为何发笑，死囚一脸沉思：“养生专家诚不我欺，每天笑一笑果然能多活几秒”</p>
</li>
<li><p>世界上最没尊严的三种生物：印度的蛇，俄罗斯的熊和中国的已婚男人</p>
</li>
<li><p>大家好，我是埃及法老，相信大家今天都听到神秘的“埃及牛逼”的呼喊了吧，是的，我要复活了，现在只差100人民币即可复活，如果你愿意助我复活，请将100元转入我的微信，等我统治世界之后，你就是我的左护法</p>
<ul>
<li>IG夺冠后我哭了，我对象没有哭，然后我把她也打哭了。</li>
<li>满屏都是IG，IG，IG确实牛逼，课是又有谁记得今天11月3号是我们民族史上一个沉痛的日子，哎，沉痛哀悼五年前的11月3号……东莞大扫黄</li>
</ul>
</li>
<li><p>擎天柱战斗中被炸成了碎片，大黄蜂带着他的碎片来到了山东蓝翔，唐国强校长愁眉苦脸的问：这一堆是啥？大黄蜂：你若安好，便是擎天。</p>
</li>
<li><p>“每天起床第一句，希望老公快死去。婚后的我有怨气，老公不死不平息！世上好人活不长，渣男长寿不公平！死去，你快死去，变成寡妇我开心！……我唱起来了怎么回事</p>
</li>
<li><p>彭于晏这种就是虚肌肉，就是吃各种蛋白质，增肌。看上去很结实，其实没卵用，打个比方就是我和他单挑，过不了五秒，他就会跪在我前面的地面上，掐我的人中求我不要死。</p>
<ul>
<li>——兄弟，40米的刀不好收啊</li>
<li>——唉，你40米的大刀还好了，我80米的大刀拔到一半又得收回去……</li>
</ul>
</li>
<li><p>君子不拆夫妻秒，匠人不拆鸳鸯锁，不是不能拆，是这锁头有毒，这锁头镇外，锁的是艳阳净，护的是月下明，这个时候，它就会出现毒，小偷若是不慎，他就会中毒，毒是锈毒，锈从锁中生，毒从锈中来，这锈，就是沉毒锈。</p>
<ul>
<li>——要不是看到最后三个字我差点就信了</li>
<li>——一本正经的胡扯</li>
<li>——你来晚了</li>
</ul>
</li>
<li><p>有个女生问我520是什么意思？我做出了以下回答：5个落实，落实经济结构调整，落实精准扶贫，落实社会保障，落实环境治理，落实反腐倡廉；2是2个要，既要金山银山，又要绿水青山；0是对犯法犯罪行为的零容忍</p>
</li>
<li><p>有个十四岁的小子欠我九块钱，听说他要去国外躲一躲，我要不要去追？毕竟不是一块两块的事</p>
</li>
<li><p>4年前，一个男孩喝多了给我打电话，唱的美人鱼，唱完他说他喜欢我，虽然我们没有在一起，但是会永远记得有一个人喜欢过我，给我唱过歌，和我牵过手，没能在一起也许只因为都是男生吧。</p>
</li>
<li><p>哪个男生没有蹲着尿尿过</p>
</li>
<li><p>验证了那句，放下砖块不能养你，搬起砖块不能抱你</p>
</li>
<li><p>兄弟两每天都要剪刀石头布</p>
<ul>
<li>输了总会哭</li>
<li>一个人太孤独</li>
</ul>
</li>
<li><p>取少量学生放入试管中，加入过量作业，溶解过滤，得到学霸和学渣，往学霸中加入少量试卷，学霸无明显变化，往学渣中加入少量试卷，学渣全部溶解并产生大量气泡，若加入大量游戏，学渣瞬间沸腾。</p>
</li>
<li><p>活着污染空气，死了浪费土地，半死不活浪费人民币</p>
</li>
<li><p>上学时有一个女孩，皮肤很白，笑起来很好看，全校公认的笑话，一次下课我在楼梯间亲了她，她红着脸跑开了，我亲她不是因为我喜欢她，而是她是学校的扛把子的女朋友，我就喜欢那种被人追着打的感觉，死亡如风，常伴吾身。</p>
</li>
<li><p>小葵花妈妈又来上课了，一楼咳嗽老不好，估计是装的，打一顿就好了，一楼撸管老不射，多半是废了，切掉就好</p>
</li>
<li><p>我和她相处六年，她一直不准我吸烟，可惜时光荏苒，我和她还是分开了，虽然很是不舍。两年后我在街上碰见了她，我慌忙地把烟掐了，她一脸诧异的看着我，我才突然想起来，她，已不再是我的班主任！</p>
</li>
<li><p>今天打一盘排位，我家诸葛亮武陵仙君一直追着对面庄周打，我于是忍不住问诸葛亮为什么他要死追着庄周打，于是他说：武陵人捕鱼为业。</p>
</li>
<li><p>女朋友让我拧罐头，我拧不开，她生气了，跑到隔壁老王大哥家求助，求半个小时了还不回来，我过去偷偷趴在门上偷听，听女朋友在里面喊：用力！不要停！用力。我心里一喜，哈哈，原来老王也拧不开。</p>
</li>
<li><p>手控：想到这么好看的手要用来擦屁股……答应我，以后不要上厕所了好吗？</p>
<ul>
<li>现在的科技不是搓屁股自动水洗了吗？</li>
<li>我家马桶就是，上完厕所可以直接水洗屁股，但是冬天你不提前把温度设好的话，冻得你菊花疼。</li>
</ul>
</li>
<li><p>我有个小姨，只比我大几岁，有次我和小姨手挽手上街。结果被路过的班主任发现了，回去给我妈告状说我早恋，我妈质问我那天怎么回事，我回忆了一下说：你问你妹啊。我妈瞬间一个嘴巴抽过来了。</p>
</li>
<li><p>如果有一个男生他能把你的照片当成手机屏幕，可以随时让你翻他的手机，可以把微信和支付宝的密码给你，甚至可以把银行卡的密码也给你，那你就取他的钱打给我知道了吗。</p>
</li>
<li><p>记得我小时候看到一个男生，精致地五官，帅气地脸庞，纯洁干净地气息，像极了不食人间烟火地精灵，那天妈妈告诉我，我也是第一天知道。“孩子，那叫镜子”</p>
</li>
<li><p>去便利店买矿泉水，老板拿了一瓶哇哈哈地矿泉水给我，就顺口问了一句多少钱，老板说2块，我拿起矿泉水，指着包装对老板说：上面建议零售价不是1.5元吗？老板回道：我不接受它的建议。</p>
</li>
<li><p>这谁发明的，真是害人不浅，女生可千万别去学。（衬衫，扣子，双面贴）</p>
<ul>
<li>我一直以为安全裤是用来防小人的，没想到连我这样的正人君子也防。</li>
</ul>
</li>
<li><p>拿天她误入打架混战，我为救她被人砍了一刀，后来我们相爱了，我以为这就是爱情。直到她跟有钱的人走了，她婚礼我去纹身店把疤盖住，从此我不相信爱情！可是我一点都不难过，因为我也不知道这是谁编的，这是我复制过来的。</p>
</li>
<li><p>和朋友去吃小龙虾，隔壁桌一个小女孩问他妈：妈妈，小龙虾回不了家他妈妈会不会着急啊。他妈妈楞那了，这么善良的问题让我怎么下得了口，这时老板来解围了：不会的，它们一家都在这了</p>
</li>
<li><p>不管你在哪里你都要记住：当你放屁时一定要说一声好像什么东西糊了，这样你的屁就被别人吸光了。</p>
</li>
<li><p>预备，唱！在那山的那边海的那边有一群大水B，他们抢楼真牛B，他们升级坐电梯，他们回贴水贴从来不看题，噢可爱的大水B，噢可爱的大水B，他们齐心协力开动脑筋升到了十三级，他们吐槽占楼卖萌又装B。</p>
</li>
<li><p>“买狗吗？便宜卖”</p>
<ul>
<li>你这狗忠诚吗？</li>
<li>必须的，我已经卖了26次了</li>
</ul>
</li>
<li><p>我们都是九年义务教育，只有你是十年寒窗苦读</p>
<ul>
<li>同九义，汝何秀</li>
</ul>
</li>
<li><p>我是一名夜班公交车司机，一天我因为看《灵车》撞到了树上，醒来后发现自己到了古代，听有人说：侯府生嫡女了，我离开这里当了官，我官升一品时发现成龙大哥提着大宝剑来到我身边：你们看小说是不是很不方便啊。</p>
</li>
<li><p>一只乌鸦想和瓶子里的水，瓶子太高喝不到，乌鸦跑到很远的河边捡石子，扔到瓶子里，就在他快要喝到水的时候，他才想起来，卧槽，我刚刚是不是到了河边？</p>
<ul>
<li>让我黑魔仙赐予你智慧。</li>
</ul>
</li>
<li><p>我这个人脾气是好，但是一旦有人触碰到了我的底线，那么，我会降低我的底线。</p>
</li>
<li><p>明明有别墅，我却租房住，明明有豪车，我却骑自行车，明明有女朋友，我却打光棍。这就是我……和明明的区别</p>
</li>
<li><p>张三和李四都是门卫，两人是好兄弟，某天中午张三来值班，换李四吃饭，张三突然说：大哥你等等，我要拉肚子。李四答：那你快去拉，拉完了我好去吃。</p>
</li>
<li><p>我以前救了一只受伤的老虎，痊愈后就放生了。那一年我路过那片森林的时候看到了它，它看着我，我看着它，我们都向对方跑去，等我们距离只有两米的时候，我发现，我tm认错了！</p>
</li>
<li><p>消防员：不，你不能进去</p>
<ul>
<li>我：不，放开我，让我进去。</li>
<li>消防员：里面火势太大了，你进去会有生命危险的！</li>
<li>我：不行！难道我就眼睁睁的看着火势蔓延下去吗？</li>
<li>消防员：那你拿着寒假作业进去干什么？</li>
</ul>
</li>
<li><p>康师傅方便面用的那头牛，这么多年过去了，别说皮外伤了，都长胖了。</p>
</li>
<li><p>曹操墓发现一具小孩尸骨。专家：那是小时候的曹操</p>
<ul>
<li>500块钱和锦旗正在路上</li>
</ul>
</li>
<li><p>自由美利坚，枪击每一天。快乐阿富汗，提枪就是干。和平叙利亚，地雷满地炸。英勇俄罗斯，单挑一个师。大国梵蒂冈，怎么都不慌。和平伊拉克，地铺子弹壳。韩国有点迷，万物皆申遗。威武大中华，和平千万家</p>
<ul>
<li>是核。下次不要犯这么低级的错误了</li>
</ul>
</li>
<li><p>我有贤相董卓，孝子吕布，忠臣司马懿，聪慧之子刘禅，上将邢道荣、潘凤，王牌说客蒋干，神速运粮苟安，何愁大业不成。</p>
</li>
<li><p>现在B站有的视频真的过分了，已经是严重地网络暴力，网络暴力是什么意思我就不说了，自己查，但我想说网络暴力真的可能导致生命危险，比如我可能会被笑死。（蔡徐坤告b站）</p>
</li>
</ul>
<h2 id="活该你单身"><a href="#活该你单身" class="headerlink" title="活该你单身"></a>活该你单身</h2><ul>
<li>今天陪学妹逛街，她看中一条裙子可没带钱，我借钱给她，学妹问我，有女朋友吗？我说没有，学妹提起裙摆转了一圈问我：好看吗？我：好看。学妹说：男朋友买的。我一巴掌抽过去，明明是我给买的，你是不是不想还了！</li>
<li>女：我可以喜欢你吗？男：可以啊，我也喜欢我自己。</li>
<li>其实男生和女生不一样的，女生小时候喜欢学习好的，大一点喜欢阳光帅气的，再往后想找个有钱人，再往后可能经历太多看破了，只想找个老实人。一直在改变。哪像男生一直喜欢好看的，从未改变过。<ul>
<li>男生也想找个喜欢的，后来发现女生喜欢有钱的，后来努力赚钱，见到她看到她悔过的眼神眼里渐渐有了点水雾，心底呐喊一声：有钱真特么爽啊！</li>
</ul>
</li>
<li>我发现我挺会哄女孩子上床的，只要我一发消息给她，她就会说我要睡觉了，我还真是个渣男</li>
<li>劳资没有故事，没有女朋友，没有考研，没有不治之症，不骑猪上战场，KTV也唱不哭小姐，也不是从哪里来的，一个平凡到极致得单身狗，老子就是单纯来要赞的，就要200个，就是那么狂，而且还是复制的。</li>
<li>现在的女生真TM会装，和几个同学KTV小聚，最后走的时候女神说她喝醉了，要我送她回家，我说你TMD喝果汁也醉？幸亏老子机灵，要不又耽误劳资回去玩王者荣耀了。</li>
<li>今天我正在打王者荣耀，突然想起女朋友还在大雪中等我，我反手就给了自己一巴掌，觉得自己真不是东西，妈的巅峰赛怎么能分心呢。</li>
<li>我们就该让女人们吃点苦，跟男人子啊一起，现在比个例子：男人和女人劫婚要一栋房一辆车。但是男人和男人劫婚就会有两栋房和两辆车，懂我意思吧！</li>
<li>女：我去洗澡了。男：注意安全。</li>
<li>突然好想我的女朋友，不知道她下课了没？那边冷不冷，吃饭了吗，今天有没有不开心的事，现在住哪，多大了，叫什么名字，长什么样？</li>
<li>其实，我对你是有一些失望的。当初给你定级女朋友，是高于你面试时的水平的。我是希望成为女朋友后，你能够拼一把，快速成长起来的。女朋友这个层级，不是把班上好就可以的。你需要有体系化思考的能力。你做的事情，它的价值点在哪里？你是否作出了壁垒，形成了核心竞争力？下班到家了要主动汇报，期待你后续的表现。</li>
<li>我的女朋友很优秀，他不撒娇，不粘人，不拜金，不胆小，不暴力，不做作，不心机，不娇气，不存在。</li>
<li>那一年开学没多久，我暗恋的女孩子坐在树下哭泣，好象是被人打了，我走过去安慰着她替她擦药，我们就这样看着彼此也渐渐地有了好感。直到多年以后我们结婚了，她还不知道那天是我叫人打她的。</li>
<li>女孩子大姨妈来了，却见她拿出手机玩起了游戏，女孩心里一下凉了半截，女孩只好拿出自己的手机充电。两分钟后，男孩突然把手机贴到她肚子上，原来是小米手机，一股暖意涌上心头，女孩偷偷把充电的三星Note7拔了下来<ul>
<li>小米发烫，三星爆炸</li>
</ul>
</li>
<li>第一句话，真诚地问她：美女，你是处女吗？如果她说是，你就说我也是处，如果她说不是，你就说，我也不是，我是白羊座。</li>
<li>很久以前，我得到了阿拉丁神灯，许了一个愿望，愿我在死前能找到女朋友，结果，精灵掐指一算：恭喜你，骚年，你得到了永生。</li>
<li>是烟不好抽，是酒不好喝，是游戏不好玩，还是基情不够，为什么你们要去碰爱情这个狗东西？</li>
<li>花心被人骂，专心被人耍，真心被人骗，好心被践踏。</li>
<li>刚刚准备要睡觉了，突然，前女友打电话来对我说：她男朋友不要她了，我安慰地说：傻瓜，别哭，站在那里等我。说完我就挂了电话，盖好被子睡觉了。晚安！</li>
<li>骨子里有份倔强，刚刚没忍住。对不起<ul>
<li>那你说，你为什么说对不起，你哪里不对</li>
<li>对不起，我倔强了。。</li>
</ul>
</li>
<li>这么可爱的小姐姐，打一拳应该会哭很久。</li>
<li>我和你是什么关系呢？就像是上海的南京路和南京的上海路听起来相似又亲密，实际上，毫无关系。</li>
<li>我不干净了，我现在真的是个很脏的女孩子，都说女孩子要保护好自己，开始我也没想到一时不慎会发生这种事，我是在家里啊！我以为家里就可以放松了，谁能想到我竟然会一脚踩到垃圾桶。。。</li>
<li>其实我很想关心你，可是你就是不生病。我很想为你哭一次，可是你就是不死</li>
<li>女：陪陪我？男：干嘛？女：你别走。男：有事吗？？女：我喜欢你。男：666<ul>
<li>男：陪陪我？女：有病吧？男：你别走。女：傻叉？男：我喜欢……女：吃翔？</li>
</ul>
</li>
<li>有小姐姐养火花的吗？一天一句cnm，七天一个小火花，一月一个大火花。</li>
<li>英文字母A和B谈恋爱了，B对A说：只要我存在一天就会爱你一天，一直一直到永远。A宠溺的抱抱她深情的说到，你个傻B</li>
<li>有一次晚自习老师不在，班里炸开了锅，突然校长从后门进来，把我们训斥了一顿，顿时班里鸦雀无声了，接着……他又从前门进来了，点了点头说：这个班真不错，很有纪律性，不像刚刚那个班。</li>
<li>我爱一个人，可是他全家都不同意，尤其是她老公</li>
<li>卧槽，这是赢了还是输了（斗地主，单生狗和情侣）<ul>
<li>输了人生赢了人民币</li>
<li>赢了游戏输了人生</li>
</ul>
</li>
<li>你要是喜欢一个女生，就好好学习，找个好工作，挣好多好多的钱，等她结婚的时候，你多出些份子钱！</li>
<li>我对象一秒钟见不到我都不行，时刻都要粘着我，睡觉都要搂着我，不搂着我睡不着觉地那种，好烦。够了没？不够的话，我再编</li>
<li>我开始恋爱啦，和一个认识蛮久的女孩子，真的是太喜欢了，以后没有丧气话了，全是甜言蜜语，她也很体贴，多开心啊。至于我为什么突然有了男朋友呢？我也不知道， 因为这是我复制的。</li>
<li>给朋友们八条建议：<ul>
<li>1.谈恋爱首先要找你爱的，如果结婚就要找爱你的</li>
<li>2.千万别输在“等”这个字上</li>
<li>3.永远留住30%的神秘</li>
<li>4.不要低估任何一个人</li>
<li>5.别把没教养当作有气场</li>
<li>6.谈恋爱可以穷，结婚不可以</li>
<li>7.谈恋爱一定要找我</li>
<li>8.牢记第7条，前6条并没有什么卵用</li>
<li>9.最后，这是我复制的，但是7，8条是真的</li>
</ul>
</li>
</ul>
<h2 id="神评论"><a href="#神评论" class="headerlink" title="神评论"></a>神评论</h2><ul>
<li><p>秀儿，是你吗？</p>
<ul>
<li>是秀儿吗？回答爸比。</li>
<li>就你秀</li>
<li>你真优秀</li>
<li>天秀</li>
<li>同是腰间盘，为啥你那么突出？</li>
<li>来人，把朕的传国玉玺拿来，给我的秀儿砸个核桃</li>
<li>扶寡人起来，给我的秀儿赐座</li>
<li>秀儿坐下休息休息</li>
<li>我不敢乱评论，怕等会有人用青龙偃月刀教我梳中分，用方天画戟给我削苹果，用传国玉玺给我砸核桃，爬高压线给我弹奏东风破，然后叫我秀儿</li>
<li>最近，博物馆的珍贵文物青龙偃月刀，传国玉玺，方天画戟，丈八蛇矛，屠龙刀，伯乐琴等频频失窃，望各位转发此消息，见到可疑人物要积极举报，谢谢合作！</li>
<li>青龙偃月刀为何沦为水果刀？传国玉玺缺的一角竟是砸核桃所致？何人能用13500斤得金箍棒擀饺子皮？张飞为何哭诉自己的蛇矛被抢去织毛衣？京外高压线为何频频发出琴声？敬请关注今日说法《秀儿，是你吗？》</li>
</ul>
</li>
<li><p>好消息! 2262年有闰正月!就是有两个春节!可以放两次假 !!! 距离2262年只有241年了! 大家要坚持活下去！</p>
<ul>
<li>待到春节休两次，家祭无忘告乃翁</li>
<li>下一世约好了喝酒啊！</li>
</ul>
</li>
<li><p>我的天，瞧瞧这个优秀答案，我亲爱的上帝，这是汤姆斯·尤独秀的奖杯，是谁把它那到这儿来的，来，我亲爱的汤姆斯，这是你的，摸他之前记得用蒂花之秀洗手液，这会让您显得庄重</p>
</li>
<li><p>为什么厉鬼都是女的，男鬼这么少。</p>
<ul>
<li>男的脑瓜比较好用，大多数怨能自己理清，所以死后成不了厉鬼。</li>
</ul>
</li>
<li><p>自古一楼爱吃屎</p>
<ul>
<li>自古二楼爱喝尿</li>
<li>自古三楼长得丑</li>
<li>……</li>
<li>怀疑我们的控楼能力？（点赞数控制楼层）</li>
</ul>
</li>
<li><p>如果我是一楼，跟二楼说，你是我的</p>
<ul>
<li>如果我是二楼，告诉一楼我喜欢他， 如果一楼是小姐姐，那么不好意思打扰了<ul>
<li>不好意思你不是</li>
</ul>
</li>
<li>如果我是三楼，请告诉一楼和二楼祝你们幸福</li>
<li>二楼是男的，难不成你想搞基</li>
</ul>
</li>
<li><p>当年大和号为了防止侧翻在另一侧紧急损管，放入同等重量的海水。</p>
<ul>
<li>然后怎么样了</li>
<li>然后竖直沉下去了。</li>
</ul>
</li>
<li><p>老师：我教书给你，你却想跟我育人？</p>
</li>
<li><p>拥有最多手办的秦始皇表示不服</p>
<ul>
<li>女娲：你说什么？</li>
</ul>
</li>
<li><p>旱的旱死，涝的老死</p>
<ul>
<li>hands hands，loads loads</li>
</ul>
</li>
<li><p>衣服很ok，服务也很好，但人生从来不是一帆风顺的，处处充满了惊喜与考验，所以给个差评锻炼一下你</p>
<ul>
<li>是买个闺蜜的，她穿着竟然特别好看，差评</li>
</ul>
</li>
<li><p>网易《我爱她》（群星）</p>
<ul>
<li>网易我就喜欢你这么奸诈的样子</li>
<li>我没有版权的歌，总有一个叫群星的歌手能模仿原唱</li>
</ul>
</li>
<li><p>“你瞅啥”——“你丑，丑到我了”</p>
</li>
<li><p>我有一个朋友……</p>
<ul>
<li>好一个无中生友</li>
<li>从现在开始，假设你就是你的朋友</li>
<li>你说的朋友是不是就是你自己</li>
</ul>
</li>
<li><p>记得小时候喜欢看枪战片，有一次升旗仪式，一个女生晕倒了，我大喊：有狙击手，卧倒，一瞬间全校都趴下了，都十几年了校长还记得我，学校还流传我的传说。</p>
<ul>
<li>我是一名顶尖的狙击手，一天我在执行任务，准备狙杀目标时，目标突然倒地，一名小学生喊道：有狙击手！我至今不明白他是怎么发现我的</li>
<li>我是那个女生，当时有颗子弹飞快地从我眼前划过，之后我看见天台有血，然后我因为恐惧和晕血就昏了，之后还流传了什么鬼传说</li>
<li>我是那个校长，当时学生卧倒时地上掉一堆手机</li>
<li>在现场，我是那个国旗，当时全部吓趴了，全场只有我一个站的</li>
<li>现场，我是那把巴雷特M82A1狙击枪，狙击手用我时卡壳了，至今我也不明白为什么目标会倒地</li>
<li>我是那个升旗台，说真的我挺懵，本来好好的升旗仪式，我在女生晕倒的瞬间感到了压力，随后一声大喊所有人面对我趴倒在地上，那一刻我以为我是天王老子上身</li>
<li>我是副校长，当时说好了打死正校长，结果校长突然趴下，我还以为被发现了，吓死了</li>
<li>……</li>
</ul>
</li>
<li><p>看了这个视频，我还是要总结一下六个点，……</p>
<ul>
<li>我比你少，我总结了三点，…</li>
<li>我感觉那两点也是要说下的，..</li>
<li>还有这点，.</li>
<li>我给你补充一点，.</li>
<li>还不完善，我改一点，.</li>
<li>我就比较牛逼了，我总结不出来</li>
</ul>
</li>
<li><p>初听不知曲中意，再听已是付费曲。（网易云音乐）</p>
</li>
<li><p>这也就是win8之后直接win10的原因，因为win9要去斩华雄</p>
</li>
<li><p>马云卸任唱《怒放的生命》</p>
<ul>
<li>马老板果然凭亿近人</li>
<li>这位歌手真是多财多亿啊</li>
</ul>
</li>
<li><p>不说了，和顺侯府生嫡女了你知道吗？（看点小说梗）</p>
<ul>
<li>宠，给我往死里宠。</li>
<li>侯门嫡女，如珠似宝，唯一美中不足的是，她姓王，在家排行第八</li>
</ul>
</li>
<li><p>一想到联合国我就想到了乌克兰提议取消俄罗斯一票否决权被俄罗斯一票否决</p>
<ul>
<li>土耳其更牛逼，说让五常轮流来。然后被五常一致否决</li>
<li>五大流氓的权力都是打出来的</li>
</ul>
</li>
<li><p>我是一个直男，最烦这种gay里gay气的人，所以我希望我的另一半也是一个直男</p>
</li>
<li><p>小李子：颜值是什么，有我的水枪好玩吗？</p>
<ul>
<li>小栗旬：水枪好玩，但太累了，和我一起挖鼻屎把</li>
<li>来，接水枪</li>
</ul>
</li>
<li><p>第……第一次当喷子，有……有点紧张，你们……你们都是小笨蛋，啊，对……对不起，好像有点过分了，不，我骂人了，警察叔叔会不会把我抓走啊，啊！我的……我的奶瓶掉了，呜呜呜</p>
<ul>
<li>第一次……当……爸爸……嗯……点紧张</li>
<li>儿子啊，你让我找的好苦啊，当年你被嫖娼的拐走，没想到你还能活着出来，来来俩，告诉爸爸你是吃了多少东西活过来的</li>
</ul>
</li>
<li><p>最后一次警告看这个评论的人，你们都tm给老子小心点，首先我不管你是什么身份，什么背景，混的多么牛逼，是不是老板，是不是社会人。这些我都不知道，我也都不在意，你们给我记住，最近天气转凉，大家多穿衣服</p>
</li>
<li><p>鬼这种东西是存在的，记得有一次早上，我起了床，突然感觉有一种神秘的力量在拉扯着我，我感觉难受极了，还好村里的灵婆来了，告诉我，我的毛衣穿反了，不然，那次我就死于非命了</p>
<ul>
<li>第一次见到把衣服穿反说的这么有灵性的</li>
</ul>
</li>
<li><p>我觉得吧，看点里的人总是爱跟风，蔡徐坤人长得挺帅得啊，徐峥大光头怎么都没见他们骂？坤哥多帅啊，就他们一群喷子总骂人，一遇到真正厉害的就怂了，傻子们积点德吧，毕竟像我这样会写藏头诗的人不多了。</p>
</li>
<li><p>你们这些撞衫的不算什么，我前几天在街上撞老婆了，和我老婆长得一模一样，要不是我老婆告诉我他出差了，我还真以为那是我老婆了。</p>
<ul>
<li>醒醒，你没有老婆</li>
</ul>
</li>
<li><p>酒以陈为香，人以冠为首，物以稀为贵！</p>
<ul>
<li>大家好，我是香首贵</li>
<li>大家好，我是酒人物</li>
<li>大家好，我是以以以</li>
<li>大家好，我是为为为</li>
<li>大家好，我是陈冠希</li>
</ul>
</li>
<li><p>盛到碗里再盛到嘴里，为什么不直接进碗呢</p>
<ul>
<li>吃到肚子里再拉到马桶里，为什么不直接把盛好的饭倒进马桶里？还省得你拉了，对吧。</li>
</ul>
</li>
<li><p>三石弟弟的神仙颜值终于还是被你们发现了，藏不住了，我好酸……</p>
<ul>
<li>小明：神仙长什么样，告诉我</li>
<li>听说过天蓬元帅吗</li>
<li>还有南极仙翁</li>
<li>再见到我这样的神仙之前，别老是拿他们和我对比好吗</li>
</ul>
</li>
<li><p>我记得小时候喜欢把脑袋摘下来，那时候也没人告诉我不能摘，久而久之我摘习惯了就安不回去了</p>
<ul>
<li>我生前也这么完</li>
<li>别吹牛了，摘下来你还能活？我小时候就因为脑袋摘下来死过</li>
</ul>
</li>
<li><p>你知道海水为什么是蓝色的吗</p>
<ul>
<li>因为海里有鱼，鱼会吐泡泡，布鲁布鲁（blue）</li>
</ul>
</li>
<li><p>鸟可以一边飞一边拉屎吗？</p>
<ul>
<li>可以</li>
</ul>
</li>
<li><p>马云：一家啤酒公司出三百万让我拍个广告，我不去，三百万对我来说太便宜了，马卖脾。</p>
</li>
<li><p>今年17，希望比楼下高17个赞，不要多了，多了就老了</p>
<ul>
<li>你在挑衅我们的控楼能力</li>
<li>不，你在考验我们的数学运算能力</li>
</ul>
</li>
<li><p>我也是一名退伍地狙击手，参加过两次集体任务，我看着我的副手牺牲在我不到10米的地方，我只能看着无能为力（战狼一：围尸打援）</p>
<ul>
<li>当年打巨人城废墟，我看着我的队友没有复活币一个个死去，我却无能为力，最后我自己一个人亲手干掉了泰坦（穿越火线）</li>
</ul>
</li>
<li><p>拜月：地球是圆的</p>
<ul>
<li>李逍遥：你懂爱吗？</li>
<li>拜月：我在说地球</li>
<li>李逍遥：你tm根本就不懂爱，去死吧</li>
<li>拜月：我就想说地球是圆的，你们疯了吗？</li>
<li>——我说地球是圆的，他们不相信，还要来打我</li>
</ul>
</li>
<li><p>蔡徐坤上台时被蚊子咬了以下，哎呦好痛啊，顿时瘫倒在地，满头大汗，捂住伤口，保安问还可以嘛，蔡徐坤强忍剧痛爬起来，粉丝们哭成泪人（冒死发文，友军厚葬）</p>
<ul>
<li>友军在此</li>
</ul>
</li>
<li><p>一头公牛从远处狂奔而来说：快跑啊！小编来了！母牛说：小编来了关我屁事啊？公牛急忙说：小编吹牛逼啊。母牛大惊：拔腿就跑，边跑边问：你是公牛你怕什么啊？公牛无奈道：现在的小编不仅吹牛逼，还扯蛋。</p>
<ul>
<li>小牛也跑，还爱扯犊子</li>
</ul>
</li>
<li><p>那年我破门而出，结果我家门坏了</p>
<ul>
<li>那年我背井离乡，村里的人再没有喝过一口井水</li>
<li>那年我浪子回头，整个村子都被水淹了</li>
<li>那年我卷土重来，整个村子都被土埋了</li>
<li>那年我金盆洗手，整个村子都暴富了</li>
<li>那年我意气风发，整个村子都被吹飞了</li>
<li>那年我牛逼哄哄，整个村子的牛逼都没有了</li>
<li>那年我悬梁刺股，村里的人再也没有了屁股</li>
<li>这层楼有毒</li>
</ul>
</li>
<li><p>地振高岗，一派溪山千古秀；</p>
<ul>
<li>门朝大海，三河合水万年流。敢问兄弟可是韦香主？</li>
</ul>
</li>
<li><p>终于找到你</p>
<ul>
<li>原来你在这</li>
</ul>
</li>
<li><p>被金钱蒙蔽了双眼，被爱情冲昏了头脑，被社会吞没了人性</p>
<ul>
<li>——这是一条被网友吞没的优秀评论</li>
</ul>
</li>
<li><p>五十块钱？早恋？我要伸张正义，不不不，我不是为了那五十块钱，我是为了伸张正义，为了祖国的花朵。（举报早恋奖50块）</p>
</li>
<li><p>开局三张图，内容全靠编</p>
</li>
<li><p>我的儿子是最帅的，前提是你们谁要和我生个儿子。</p>
<ul>
<li>——我我我！</li>
<li>——善意的提醒一下，两个男人是不能生孩子的。</li>
</ul>
</li>
<li><p>明天我要去动手术了，我尽量在拖，但是因为最近的气候原因必须要做的，头部结缔组织群里切除手术，祝我好运，陌生人，可以给个赞吗？</p>
<ul>
<li>——剪个头发至于吗</li>
</ul>
</li>
<li><p>“你感动吗？”——“不敢动”</p>
</li>
<li><p>这男的现在在医院，我看见他了，他说医院的wifi挺好的</p>
</li>
<li><p>在下野猪佩奇，明猪不装暗逼，我出去吃一口猪食，回来要是没有十个赞，我就拱死在坐的各位，注意 是拱死（路过的也跑不了） </p>
<ul>
<li>——“非洲瘟都没能死你” </li>
<li>——“闹猪瘟”</li>
</ul>
</li>
<li><p>游戏中毒是种病，得治，治病就得去医院，医院在G港旁边，不谢。</p>
</li>
<li><p>我是精神病医院主任，我院领导在看到你发表的文章后，对你的病情十分重视，让我来和你取得联系。神经病是一种可治可防的病，只要你积极主动和配合，就一定可以治愈，最后希望你能树立信心，祝你早日康复，病魔早日战胜你。</p>
</li>
<li><p>你是什么？和尚还是科学家？</p>
<ul>
<li>我是一位出家的科学家</li>
</ul>
</li>
<li><p>我和小编是世交，我和他爷爷常常以棋会友，杀的你死我活，定分个高下。一次，最后我只剩一个士，他爷爷只剩个象。于是便约定，两棋都可以过河，然后他爷爷用象象我，我用士士他爷爷，就这样，他爷爷象我，我士他爷爷。</p>
</li>
<li><p>“我有一个大胆的想法，不知当讲不当讲”——“我国有一套完整的刑法，请收起你的想法”</p>
</li>
<li><p>楼主，虽然没有看到源码，仅凭那寥寥数几的图片，就让我汗颜啊，对楼主瞬间佩服的五体投地，有如醍醐灌顶之效，暮然回首发现自己已经没有什么技术可言，真是关公面前耍大刀班门弄斧。楼主的无私奉献精神，值得生活在物欲横流的当今社会背景下的人深思，让我再次感受到世上还有好人在好人一生平安，至此请容许我再次对楼主产生敬佩之情，此敬佩非彼敬佩，是由心而发令人肃然起敬。于是经过深思熟虑之后，我终于做出了一个令我都不敢相信的决定，那就是超过百字的回复。至此，我又做出了决定，要顶起这个帖子，不然将会受到道德的谴责，让真理无法重见天日，我相信一滴水也能激起千层浪，好帖不应石沉大海，顶起</p>
</li>
<li><p>“草!”——此回复虽有且仅有一个字,却深刻地表达了回复人的深深的祝福与刻骨的情感,可谓言简意赅,一字千金,字字扣人心弦,催人泪下,足以见作者扎实的文字功底和信手拈来的写作技巧及惨绝人寰的创新能力.实是佩服佩服!再加上以感叹号收尾,点睛之笔,妙笔生花,意境深远,照应前文,升华主题,把作者的感情表达得淋漓尽致,给人无限感动和惆怅,有浑然天成之感,实乃回复中之极品,祝福中之绝笔.）</p>
</li>
<li><p>路过。这句话虽然只有短短两个字，却透露出一丝高冷与漫不经心的从容，与本人那放荡不羁的身影相得益彰，结尾的句号礼貌又不失疏离，恰如其分地显示了本人高贵而优雅地气质，此时你若回头，便会看到一位心情似乎不太好地西楼扛把子与你擦肩而过。</p>
</li>
<li><p>老夫装逼20多年，自以为无人能敌，今日得见贤弟，才知一山还有一山高，能将装逼这种艺术和装可爱融为一体，实乃老夫生平之仅见，贤弟的装逼技术已至化境，老夫自叹不如，老夫决定退隐装逼界，从此不问世事</p>
</li>
<li><p>袁隆平爷爷一定后悔让你们吃太饱。</p>
</li>
<li><p>要是秦始皇还活着，看到你们这么闲，长城起码还能在多加两万米，兵马俑的坑还能挖大点</p>
<ul>
<li>要是隋炀帝还活着，看到你们这么闲，大运河还能再挖两万米</li>
</ul>
</li>
<li><p>评论一群活在新时代的垃圾废物有资格说别人么</p>
<ul>
<li>屁话，历史就是拿给后人评论的，你可以评论未来的人？</li>
</ul>
</li>
<li><p>老子寸土不让，儿子一枪不放（张作霖、张学良）</p>
</li>
<li><p>东北三连击：老铁、太君、666</p>
</li>
<li><p>当领导吃喝嫖赌的时候开开心心，遇到麻烦就是你行你上，当年曹刿论战的时候也是先加官再打仗的</p>
</li>
<li><p>如果这赞是单数我吃翔，如果是双数楼下全部吃翔，玩的就是心跳，要的就是刺激！</p>
<ul>
<li>——请不要骗屎吃</li>
</ul>
</li>
<li><p>从前有个商人说：“我的矛可以刺穿天下所有的盾，我的盾可以防住天下所有的矛”，这时一个人说到：“那拿你的矛刺你的盾会怎样？”商人拿矛戳死了他：“就你特么b话多”</p>
</li>
<li><p>抓住小编了！！快！！一楼拿绳子，二楼架锅烧水，三楼准备柴火，四楼准备好盐、油、酱、醋，五楼，哎，五楼你脱裤子干嘛？这个不能日，不能日！六楼拦住五楼，七楼、八楼一起把小编扛来，小心！它咬人！</p>
</li>
<li><p>你错了，长得丑，别人才不会嫉妒你，路上坏人不会惦记你，长得丑才好，长得丑是我为人处事的第二标准。</p>
<ul>
<li>完了，怎么办，我长得这么好看</li>
</ul>
</li>
<li><p>确认过眼神，是我惹不起的人。</p>
</li>
<li><p>猫：我回头就是一爪子，结果发现他爸站在后面，我也很无奈</p>
</li>
<li><p>能遇到邓超这样的future，可以说是很幸运了</p>
<ul>
<li>further</li>
<li>不是father？</li>
</ul>
</li>
<li><p>你不是一个人</p>
<ul>
<li>楼主，楼上说你不是人</li>
</ul>
</li>
<li><p>我记得5年前看到一个被土拨鼠咬伤的帖子，楼主到现在也没回复我们</p>
</li>
<li><p>我打王者荣耀的时候遇到了陈奕迅</p>
<ul>
<li>我还遇到薛之谦呢，可是被我们吊打</li>
</ul>
</li>
<li><p>冰封战神返场了，期待了很长时间，但我决定不买了，天气变冷了，给妈妈添件衣服</p>
<ul>
<li>希望你真是这样想的，不是骗赞的</li>
</ul>
</li>
<li><p>大家好，我是铠，有人加我铠哥，有人叫我铠爷，还有人叫我八秒真男人，甚至有人叫我铠甲勇士，这都不重要，我妹妹露娜要结婚了，我亏欠她太多了，所以我准备在她结婚的时候送她一件嫁衣，希望有人能资助我71块钱，感激不尽。</p>
</li>
<li><p>问：周瑜的媳妇叫小乔，小乔的姐姐叫大乔，大乔嫁给了孙策，孙策妹妹叫孙尚香，孙尚香后来嫁给了刘备，刘备有个儿子叫刘禅，刘禅即位后，他的皇后叫张皇后，张皇后的母亲叫夏侯娟，夏侯娟的父亲叫夏侯渊，夏侯渊的哥哥叫夏侯惇，夏侯惇管周瑜叫什么？</p>
<ul>
<li>叫周瑜去中路</li>
<li>叫周瑜别送</li>
</ul>
</li>
<li><p>曹操宴请家将，席间两个小妾为了争宠而相互打闹，吵着要曹操替他们佐助，曹操大怒：你俩同归于尽好了！全场鸦雀无声，突然一将冲出跪地说到：末将于禁谢丞相赏赐！。</p>
<ul>
<li>末将于禁，愿为曹家世代延续香火。（赴汤蹈火）</li>
</ul>
</li>
<li><p>大家好，我只想告诉大家，我爱学习，学习使我快乐，所以我想买两本练习册做做，只要88.88+58.88块，请大家资助我，绝对不是为了什么冰封战神美猴王，如果没有的话我等会再来发一遍</p>
<ul>
<li>你应该学学楼上</li>
</ul>
</li>
<li><p>千万不要点这个赞，三个月前有人赞我他考上了清华。一个月前有人赞我，他追到了心仪的女孩，上周有人赞我，他捡了五百块钱，昨天有人赞我，他免了暑假作业。各位切勿以身试险啊</p>
<ul>
<li>——之前有人赞了你，被罚抄作业了</li>
</ul>
</li>
<li><p>别再骂鹿晗了，你们了解鹿晗吗，你们知道鹿晗有多么不容易吗？他拍戏时手指划破了，都坚持没去医院，医生说要是晚来一小时的话就痊愈了（友军快来，我坚持不住了）</p>
<ul>
<li>突击手已就位</li>
<li>狙击手已就位</li>
<li>蔡徐坤原名蔡萝莉，号女装大佬，与鹿晗并称铁血硬汉，上次被蚊子咬了，只哭了三天</li>
</ul>
</li>
<li><p>女装只有0次和无数次</p>
</li>
<li><p>大家好，我是一名小学生，我刚刚在外面观察蚂蚁，我先放了一颗糖，不一会一个蚂蚁来了，可是他拿不动，于是我看到他去找同伙了，等他们快来了，我把糖拿走了。</p>
</li>
<li><p>我在等一个女孩<em>子</em>拿掉我手头的烟，我就不抽了。等喜欢的人睡到我怀里我就不熬夜了。等我穿到喜欢的人送的衣服,我就不要风度只要温度了。我们喝不到清晨的粥，只可喝到深夜的酒，哈喽，陌生人。</p>
</li>
<li><p>很一般的一首歌，旋律不优美，演唱不出彩，歌词无内涵，总体评价不及小苹果一半的一半</p>
<ul>
<li>李荣浩：本来想唱一句完整的歌词来着，后来忘了</li>
<li>感谢荣浩在百忙之中抽空敷衍我们</li>
</ul>
</li>
<li><p>没文化真可怕，我给你们科普一下，这叫海螺，又名眼镜蛇，学名北极熊，医学用名又叫大海龟，一般生活再沙漠，所以俗称贵宾犬，不懂就不要乱说你们一个个的，连八爪鱼都不认识，你们好意思说他是皮皮虾，佩服</p>
</li>
<li><p>最新的解压方法：平躺，放松大腿，大脚拇指尽量往下按，其他四根脚趾头尽量上抬，记得回来赞我哦</p>
<ul>
<li>抽筋怎么办，在线等</li>
</ul>
</li>
<li><p>我有个朋友，跟这作者差不多，也是爱编故事，去年走的，走的时候并不安详，尸体在太平间抽搐了三天，火化时烧到一半还停电了，等了半天再烧。家属坚强的忍住没有哭，甚至还有一个笑出了声</p>
</li>
<li><p>中国脑残千千万，快手抖音各一半，开个直播像要饭，只要能红啥都干，要是礼物给到位，各种姿势啥都会，完全任由你支配，又不脏又不累，又不担心会犯罪，南抖音北快手，智障界两泰斗，喷我TM全是狗</p>
</li>
<li><p>啥也别说，快！有哪位兄弟在湘潭万达广场的，我在四楼厕所的第二个蹲位。</p>
</li>
<li><p>大家好，我是骗子，我想吃棒棒糖，愿意上当受骗的就给我发2块钱红包，就当给自己买个教训，不要问我为什么别人骗15我骗2块，因为我是一个不贪心的片子，傻的来，不傻的就别来了，因为我感觉我可能骂不过你</p>
<ul>
<li>你倒是留个联系方式啊</li>
</ul>
</li>
<li><p>最近新皮肤出了很多，钱又不够花了，今天又找妈妈要钱，妈妈问我为什么最近钱花的这么快，我哭着对妈妈说我吸毒了。妈妈浑身颤抖着，扶起了我，突然大笑道：还好还好，我还以为你玩王者荣耀了呢。</p>
</li>
<li><p>这个太简单了，只要把自己的头切下来，然后用手拿着，你问我结束之后怎么弄回去，说实话我也不知道，我只弄过一遍。</p>
<ul>
<li>闯了你嘞鬼咯，哪个哈戳戳的看到起相信嘛</li>
<li>四川人说，听的你的话，斤斤拉到卡！信你个锤子</li>
</ul>
</li>
<li><p>佛：我可以满足你一个愿望。</p>
<ul>
<li>我：让每个人都健康快乐</li>
<li>佛：愿望太大了就四天</li>
<li>我：那就春天夏天秋天冬天</li>
<li>佛：就三天</li>
<li>我：那就昨天今天明天</li>
<li>佛：就一天</li>
<li>我：那就每一天好了</li>
<li>佛苦笑着说：那就赞你的人每天健康快乐</li>
</ul>
</li>
<li><p>元芳你怎么看？</p>
<ul>
<li>大人，用眼睛看</li>
<li>大人，属下用暴风影音看</li>
</ul>
</li>
<li><p>你好，网恋吗？不用爆照不用见面，每天跟你说早安，中午跟你说午安，晚上跟你说晚安，感冒了给你驱寒温暖，当我们聊久了，聊出感情时，我会告诉你，对不起，我只是玩玩</p>
</li>
<li><p>深海鱼一般没人看见，所以长得很放肆</p>
</li>
<li><p>有个很傻的男孩，每天在看点里发评论，但没人理他，回复他，或关注他，他的出现只想默默的祝福所有人。抱歉，那个很傻的男孩就是我，如果你看到这条评论，那么祝福你，陌生人，希望你余生有人相伴，祝你幸福。</p>
</li>
<li><p>有一天我问魔镜：天下那个男的最帅。魔镜说：当然是您最帅了。我反手就把魔镜朝地上一摔，大吼道：再做给我点赞的哪个不比我帅？</p>
</li>
<li><p>在下不才，有一诗相送：霄边失沙壁，暮幽晓寂寂。朔画镶方辟，酒会虾碧碧。诗歌笑抬剑，大步鸟飞疾。春才尔白雾，成田方沟辟。泥若香不透，卧草逆麻蔽。</p>
</li>
<li><p>女孩子不小心把手划一个口子，男孩看见了，也用刀把自己的手划了个口子，女孩问他为什么，男孩说：这样我们就是两口子了。女孩笑了，过了两天，两人得破伤风死了。</p>
<ul>
<li>女孩给男孩做可乐鸡翅！男孩吃了以后对女孩说很好吃。女孩拿过来吃了一口对男孩说没熟。男孩对女孩笑了笑。你做的不管怎么样我多喜欢！女孩看着男孩英俊的面孔笑了！ 两天后，他们两个得禽流感死了。</li>
</ul>
</li>
<li><p>什么是内卷？</p>
<ul>
<li>林平之为了避免江湖追杀，把《辟邪剑谱》印出去好几万份。交钱就可以买，江湖上人人都可以轻易得到。一下子，再也没有人找林家的麻烦了。但江湖人士却陷入深深的矛盾和煎熬中：不练，别人练了秒杀你；练了，不仅要挥刀自宫，而且练完后也就那么回事，因为别人也都练了。最后活生生的把江湖给搞乱，搞残了…</li>
<li>为啥瑞士没有内卷？</li>
<li>那瑞士卷怎么来的？</li>
</ul>
</li>
<li><p>兄弟，男人的手是用来打天下的，不是用来打女人的</p>
<ul>
<li>但是这个女人拦着他们打天下了怎么办</li>
</ul>
</li>
<li><p>帖子写的很好。不过兄弟，别怪我多疑，以你的语言表达能力，文字组织能力，我绝对不相信你是一个刚从达内培训出来，一个月拿7000块，头发油腻不修边幅得安卓程序员。写作这个东西看起来容易，但这么长得帖子，要写的井井有条，张弛有度，要长期训练才行的。何况要再懂技术，那就更难了，这也许是你好些年前得经历，现在有时间重新回忆，也许你是很专业得写作者，只是不知道干嘛到这个已经快没落得论坛上来灌水，万一你真是沧海遗珠，也不要做什么安卓后端了，互联网行业能够写作的技术人员太稀缺了，你给我留个言，工资翻一倍，北京，广州，上海随你挑</p>
<ul>
<li>回帖写的很好，不过兄弟，别怪我多疑，以你的路子人际关系网的范围，我绝不相信你是一个互联网猎头，你吹牛逼的能力在茫茫天涯太稀缺了，万一你真是偷天换日，欲盖弥彰，巧言令色，口舌如簧，见光死，自圆其说，自欺欺人，欺世盗名，瞒天过海，贼眉鼠眼，心怀鬼胎的吹牛皮职业大神，你也不要在天涯回帖骗人了，天涯你这种人才太稀缺了，你给我留个言，天涯各大板块版主任你挑。</li>
</ul>
</li>
<li><p>nmsl，意思就是Never Mind the Scandal and Libel，意思是永远不要理会谣言和中伤，所以蔡徐坤加油，蔡徐坤nmsl！蔡徐坤nmsl！</p>
</li>
<li><p>果然猫的天敌是狗。</p>
<ul>
<li>狗永远是狗，但人，不一定是人。</li>
<li>您当年退出文坛的时候，我是极力反对的</li>
<li>可我记得那个鼓掌的也是你。</li>
</ul>
</li>
<li><p>文体两开花</p>
<ul>
<li>什么都不说了，开花</li>
<li>大家好，谈到七龙珠我就想起猴子，想起猴子我就想起了，今年下半年的中美合拍的西游记即将开拍……</li>
<li>中国老一辈的艺术家，美猴王的扮演者六小龄童，合计36年的演艺生涯，拍下无数经典的荧幕形象，文化人说话不能体面点吗？体谅体谅六小龄童老师不行吗，两次三次的黑就算了，开始到现在黑个不停，花时间黑人有意思吗？（藏头）</li>
</ul>
</li>
<li><p>老婆这么漂亮还出轨，想不通啊！（陈思成）</p>
<ul>
<li>给你个全皮肤的王者号，你也会不想打王者了</li>
<li>你以后有了孩子就知道了，我买了各种汽车变形金刚给孩子，他就是跑去隔壁邻居家的马桶圈，我说你咋这么没眼光，这么多玩具不玩，他回答：因为没玩过……</li>
</ul>
</li>
<li><p>蚩尤（网名）：好可爱，一种复杂的眼神</p>
<ul>
<li>说吧，兄弟你想干嘛。</li>
<li>这是他的坐骑</li>
<li>你当年就是骑着这个打黄帝的。。。</li>
</ul>
</li>
<li><p>为啥以前那么穷头发那么多，现在人的生活水平好了，路上好多年轻秃子</p>
<ul>
<li>以前洗发水是洗发水，现在造假太多了</li>
<li>现在秃顶的是以前那帮长头发的二愣子</li>
</ul>
</li>
<li><p>周慧敏，当年的最爱 我的最爱</p>
<ul>
<li>错了，最开始是你爸爸的最爱，后来是你和你爸爸的最爱，现在是你爸爸和你还有你儿子的最爱</li>
</ul>
</li>
<li><p>一个巴掌拍不响</p>
<ul>
<li>呼你脸上响不响</li>
<li>你脸伸过来，我打一下，看响不响</li>
<li>你路上被狗咬了，难不成是因为你勾引了疯狗？</li>
</ul>
</li>
</ul>
<h2 id="看弹幕让我知道不是一个人在皮，而是一群人"><a href="#看弹幕让我知道不是一个人在皮，而是一群人" class="headerlink" title="看弹幕让我知道不是一个人在皮，而是一群人"></a>看弹幕让我知道不是一个人在皮，而是一群人</h2><ul>
<li>单身久了，看只尸蟞都觉得眉清目秀。</li>
<li>北冥有鱼，其名为鲲，鲲之大，一锅炖不下</li>
<li>你以为你接受的是谁的爱？是一个天神的爱，她背叛了所有的神灵去爱你，为你忍受一切痛苦，带给你欢乐，你居然去泡一条鱼？<ul>
<li>我现在就把他抓回来煲鱼头汤</li>
</ul>
</li>
<li>性感云龙，在线指挥（亮剑）<ul>
<li>性感成瞎子，在线撤退</li>
<li>性感大喵，在线摔帽</li>
<li>性感燕双鹰，在线杀鬼子</li>
<li>性感丁伟，在线炸钱</li>
</ul>
</li>
<li>周卫国：等劳资上大号，三十万东北军给你打成筛子（文章：周卫国，张学良）<ul>
<li>您的余额已不足，请及时充值</li>
</ul>
</li>
<li>世上能跟小僧打成平手的没有几个，能把小僧打死的倒很多（天龙八部：鸠摩智）<ul>
<li>阁下就是乔峰，贫僧今天总算有幸会齐北乔峰，南慕容，只可惜南慕容早已不堪一击。……降龙十八掌果然是世上绝学，世上能够和小僧打成平手的没有几人。</li>
<li>大师你错了，慕容公子乃是在下的朋友，他的武功造诣在下十分清楚。一时成败何以定输赢？况且他实在是烂，是乔某所不能及。</li>
<li>他的武功造诣在下十分清楚，菜的一匹，我都不愿说他</li>
</ul>
</li>
<li>刚开服的时候大家起点一样，所以慕容复大杀四方，但是后期慕容复坚持不充值，天真的认为踏踏实实做任务打怪升级，就可以做全服第一，还说自己玩的是真天龙。再看乔峰，首充就送音响一台，虚竹、段誉更厉害，入行虽然晚，但是强力充值全服第一，激活游戏隐藏剧情，瞬间爆炸，你玩的过RMB玩家吗</li>
<li>马东锡：可以走法律程序，但我要和他一个监狱<ul>
<li>他在韩国是神一样的存在，所以我们叫他神马东锡</li>
</ul>
</li>
<li>过儿何苦为难过儿。（扫毒，刘德华，古天乐）</li>
<li>咏春，张天志<ul>
<li>咏梅，王安石</li>
<li>咏鹅，骆宾王</li>
<li>咏柳，贺知章</li>
<li>咏雪，刘义庆</li>
</ul>
</li>
</ul>
<h2 id="雷人台词"><a href="#雷人台词" class="headerlink" title="雷人台词"></a>雷人台词</h2><ul>
<li>因为这种锁，一旦锁上了，只能用钥匙才能打开</li>
<li>目测着十二只断手不是来自一个人</li>
<li>如果是自杀，那他的动机肯定是不想活了</li>
<li>在子弹飞出去的时候快速抖动，让子弹拐弯，这就是枪斗术（抖枪术）</li>
<li>我爷爷在9岁那年就死了</li>
<li>八年抗战马上就要开始了</li>
<li>柯镇恶：看我眼色行事</li>
<li>谢三哥，我这辈子没说过谢字</li>
<li>说出吾名，吓汝一跳，吾乃零陵上将邢道荣！主公，尽可放心，凭末将手中这把梨花开山斧，一定能教什么张飞、赵云之流有来无回，主公，末将必生擒诸葛亮，待末将把他们引入瓮城，万箭齐发，射杀刘备、张飞、诸葛亮。到时候本将军再领一队军马，直取荆州，拿下关羽。<ul>
<li>若军师肯放我回去，我愿为内应，引贵军来袭，活捉刘氏父子，献与军师，我邢道荣若有半句虚言，生时天打雷霹，死时挫骨扬灰。</li>
<li>说出吾名，吓汝一跳，待吾下去，逗你一笑</li>
</ul>
</li>
<li>我有贤相董卓，孝子吕布，忠臣司马懿，聪慧之子刘禅，上将邢道荣、潘凤，王牌说客蒋干，神速运粮苟安，何愁大业不成</li>
</ul>
<h2 id="猥琐笑话"><a href="#猥琐笑话" class="headerlink" title="猥琐笑话"></a>猥琐笑话</h2><ul>
<li>董卓为试众人忠，会晚宴时，令貂蝉抹墨于胸，灯熄，再亮时，众人手皆黑，唯吕布非也，卓大喜，乃赏布，布笑之，而露黑齿。</li>
<li>我不反对夏天女孩子穿裙子，特别是超短裙，想要凉快地心情大家都懂，可你们为什么要在短裤下面穿安全裤？人与人之间最基本的信任都没有了吗？难道我还会偷窥你们不成？想到这，我愤怒地从地上爬了起来。</li>
<li>新婚之夜，小编问妈妈：“妈妈，怎么才能生小孩。”妈妈说：“用你最坚硬的部位碰撞你媳妇尿尿的地方就可以了。”于是，小编用头撞向马桶，当场去世，螺旋升天。<ul>
<li>头铁</li>
</ul>
</li>
<li>性盛至灾，割以永治</li>
<li>是艺术请不要打码，是色情请不要传播<ul>
<li>色情艺术，打码传播</li>
<li>艺术和码不能共存</li>
<li>马家的败类</li>
<li>心中无码，自然高清</li>
<li>兄弟，借一部说话</li>
</ul>
</li>
<li>如果已婚，请穿好你的衣服，这是对你丈夫的尊重；如果未婚，也请穿好衣服，这是对你自己的尊重，如果是出来卖的，请说明价格和服务，这是对消费者的尊重；如果不卖只是为了博眼球，请你再穿少点，老衲看的不够清楚。</li>
<li>有天，唐僧饿了说：悟空，为师饿了，你去化点斋饭吧！悟空很快回来，手里只拿了几根黄瓜，唐僧：这是到哪里了？悟空：方圆几百里都是黄瓜地，我也不知道这是哪里！唐僧：扶我起来，想必是到了女儿国了！</li>
<li>生人不敢开口，熟人不敢下手。没有一见钟情的资本，又缺乏日久生情的条件，人群中的段子手，人群后的单身狗，躲得过对酒当歌的夜，逃不掉四下无人的街。我期盼着以为富婆看穿我的坚强，让我卸下我的伪装。</li>
<li>那年我在深圳一家充气娃娃厂上班，厂里每个人的工作岗位都不一样，有的是装胳膊的，有的装腿的，我的工作是负责装逼，整个流水线有几十个装逼的人，但他们靠装逼混时间混工资，只有我装的逼既逼真又耐用</li>
<li>我是外地的，刚来庵埠，不小心被蜈蚣咬了口，伤口开始肿胀，吃药打针都没得用，看到没办法了，正好遇到一个道士，道士说我遇到的是百年蜈蚣精，要治好必须去寻找它的天敌。所以问大家，庵埠附近哪里有鸡。<ul>
<li>找个鸡都这么委婉</li>
</ul>
</li>
<li>坐公交，一妹子上车，我拍拍他的大腿说：这有软座，谁知妹子叫道：得了吧，一会软座变硬座，硬座变插座，到时候走都走不了了</li>
<li>我在经过了思想斗争之后，实在是忍不住，终于推开了妹妹的房间门，我把妹妹扑倒在床上，开始扒她的裤子，妹妹激烈反抗，但是面对我还是没有用，他只能在那默默的哭泣，半天过后，我终于帮她换号了纸尿裤。</li>
<li>汤唯，杨幂，江疏影，莉哥3块全部带走<ul>
<li>借一部说话</li>
</ul>
</li>
<li>上次给我莉哥种子的那个哥们，请你出来一下，184G特么下载了我两个晚上，下载完一看竟然是春晚合集，感谢你让我意识到健康生活，请你留下你的联系方式，还有地址，方便我登门拜访。<ul>
<li>——送你上去，借楼，那个给我325G新闻联播的兄弟，你出来，保证不打死你</li>
</ul>
</li>
<li>上次有一个傻哥们问我要莉哥种子，我为了他的健康，就把184G春晚合集发给了他，听说这个哥们在看点上找我，要登门拜访我，我家住在翻斗花园二号楼一零零一室，我叫胡图图，记得来我们家要按门铃<ul>
<li>——终于找到你了</li>
<li>——cnm原来就是你，我下了好几天</li>
</ul>
</li>
<li>我看到路边车里有一对男女被锁车里了，衣服都脱了，拼命挣扎，车一晃一晃的，女的很难受，好像缺氧，男的正在做人工呼吸，人命关天，我捡块砖头就砸过去，他们得救了，一直喊着是谁是谁，可我已走远了，不用谢我，我叫雷锋</li>
<li>等我练出腹肌，以后再有小姐姐问路，我就掀开上衣，指着肚子说：小姐姐你看，你现在在这个路口，上北下南，您往南走，走过三个路口，你会看见一片草地，上面有个大电线杆子，你可以坐上去等车</li>
<li>语文课上，老师说：“‘炎炎烈日下，一个少女正在用手挡住阳光’，谁能把这句话翻译成文言文?”小明站起来说：“一女怕日，以手遮阴。”全班响起了轰轰烈烈的掌声。</li>
<li>知男而上，迎男而上，男上加男，强人锁男，世上无难事只怕有心人，奸男显阻，左右为男，步履奸男，孤掌男鸣，插炽男桃，男颜之隐，难舍男分，本性男移，男能可贵，天理男容。<ul>
<li>满头大汉，满汉全席，汉留夹背</li>
</ul>
</li>
<li>美国有个节目，说小伙网恋对象是女装大佬，然后得知实情后，说：人生苦短，何妨一试？于是就亲起来了</li>
<li>一世鹰名，毁于一蛋。<ul>
<li>鸡鹰突变</li>
<li>东条鹰鸡</li>
</ul>
</li>
<li>小编啊，你爹让我带句话给你，在大城市打工，你小子千万不要乱搞，不然回去传染给你媳妇，害了你哥不要紧，如果你嫂子传染给你爹，让你妈有事，那全村人就都完了<ul>
<li>——一个感冒看你说的</li>
</ul>
</li>
<li>‘我爱上了一个比我小6岁的女孩，现在还在上学’，造孽啊！你要是把‘爱’字去掉，那才是造孽啊，再把‘比我小’去掉那就真的造孽了，再把‘了’字去掉还要造孽啊，再把‘学’字去掉我就可以拖出去枪毙了。</li>
<li>寝室一上铺室友在和女友聊短信，女友说：“月亮下去了，太阳怎么还不出来”，室友想半天不懂什么意思，就问我们，我们也不懂……只听寝室长幽幽地说了一句：月经走了，怎么还不来日。嗖的一声，上铺那家伙就不见了……<ul>
<li>——之所以他是寝室长不是没有原因的</li>
</ul>
</li>
<li>听最嗨的歌曲，喝最强烈的酒，日最骚的女鬼，开最快的跑车，出最惨的车祸，住最好的医院，打最贵的石膏，撩最翘的护士，玩最炫的轮椅，睡最好的棺材，挖最深的坑口，埋最好的土地，烧最厚的钱纸，长最高的坟草，投最牛逼的胎 看最牛的评论，叼最小的路过，屌最大的都点赞。</li>
<li>工资四千每月都拿出三千去做慈善，身边的朋友说我傻，劝我把钱存起来娶老婆，但是当我看见漆黑的巷里站着的弱女子，望着那无辜的眼神，我所做的一切都是值得的，我会把慈善当成我生活中的一部分，坚持下去，心存善念，加油<ul>
<li>嫖个娼给你说的这么高大上</li>
</ul>
</li>
<li>夜已深，天微凉。路过小巷见几女，衣甚薄，风中瑟瑟抖，爱心起，欲施二三百，岂料女甚感恩硬拽屋中，更怜爱，遂生情，云雨三刻，觉不爱，施之分手费二百，何错之有？<ul>
<li>嫖娼都能被你说的那么冠冕堂皇，你真是个人才</li>
<li>人家只是一见钟情，陷入爱河，不能自拔，后来发现不能长相厮守，于是给了点分手费，这么凄美的爱情故事怎么到了你们嘴里就变成嫖娼了呢？</li>
<li>然尔等不知礼数，肆意妄为，国有法制之，尔虽心怜，但汝等家中尚有妻室，可施钱粮，不可施精血，天意难测，若尔因与此女云雨而身染隐疾，岂不呜呼？</li>
</ul>
</li>
<li>从前有个穷学生，买不起灯油，他的隔壁住着一对新婚夫妇，昼夜烽烟灯火通明，他就在墙上凿了一个洞，从此学业荒废，一蹶不振。</li>
<li>我们男生快手玩多了戒不了，正如女生玩抖音一个道理，舒服</li>
<li>牛顿说过，你有一个苹果我有一个苹果，我们交换了还是有一个苹果，但是你有一个网站，我有一个网站，我们交换了就有了两个网站。<ul>
<li>兄弟，借一部说话</li>
</ul>
</li>
<li>一男老师气愤地对上课睡觉的女生说：我在上面累的要死，你在下面一动不动，不配合也就罢了，连一点反应都没有，将来要是肚子里没东西，别怪老师不行</li>
<li>有一位伟人曾经说过：我们的女同志，从上往下要看两个突出的问题，从下往上看，有个明显的漏洞，身为男人的我们要用勤劳的双手去抓住问题，用革命的枪杆，堵住漏洞</li>
<li>日本人觉得女孩子有小虎牙很可爱，欧美人觉得女孩子有雀斑就很可爱，而你们这些人，居然觉得女孩子下面有大宝贝才可爱。</li>
<li>有没有网恋的小哥哥，我会撒娇，会卖萌，会娇喘，游戏打得也不吭，处的好的话可以奔现，但是有一点，你不能摸人家的几把。</li>
<li>小生不才，愿用一夜冲动换姑娘十月安稳，若姑娘不愿，但请莫怪小生用三年牢狱之灾换姑娘一生阴影。</li>
<li>身不在高，米五就行。胸不在大，有型则灵。斯是萝莉，为吾是侵，洋装猫耳朵，小嘴大眼睛，短发很俏丽，长发也飘逸，可以给糖果，玩亲亲。无八卦之乱耳，无血拼之劳行。学校游泳室，公园小凉亭。孔子云：三年起步，最高死刑。</li>
<li>之前打排位，一个安其拉突然说：我男朋友想要，我先挂机。她还开着麦，最后我们四个硬生生守了两个小时</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>程序基础（更新中）</title>
    <url>/2018/04/10/basic-2018-04-10-ProgramBasic/</url>
    <content><![CDATA[<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>在计算机系统中，数值一律用<strong>补码</strong>来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理（为了计算方便）。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。（百度百科）</p>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>举例</p>
<table>
<thead>
<tr>
<th></th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
</tr>
</thead>
<tbody><tr>
<td>正数5</td>
<td>0000 0101</td>
<td>0000 0101</td>
<td>0000 0101</td>
</tr>
<tr>
<td>负数5</td>
<td>1000 0101</td>
<td>1111 1010</td>
<td>1111 1011</td>
</tr>
</tbody></table>
<p>8位2进制数表示-128~127的范围，第一位表示符号位，1表示负数、0表示正数</p>
<p>正数三码都相同</p>
<p>负数：用绝对值的补码表示，负数=模-|负数|、-1=100-|-1|=100-001=011</p>
<ul>
<li>原码=正数最高位改为1</li>
<li>反码=正数取反，第一位符号位不变</li>
<li>补码=反码+1，即取反+1，也可以用原码-1，再取反</li>
<li>模 = 原码+补码</li>
</ul>
<p>想象成时钟，2点到4点，可以顺时针旋转2小时，也可以逆时针旋转10小时，即2=12-|-10|，12为模</p>
<p>想象成360度的圆，模代表一圈的度数：</p>
<ul>
<li>起点为0度，范围是0~359。-1度=359度，-180度=180度，模=360度=1度+359度。</li>
<li>起点为-180度，范围是-180~179。那么：-181度=179度，模=360度=181度+179度。</li>
</ul>
<p>位数越多、刻度越多：</p>
<ul>
<li>如2位：能表示-2~1的数。1=01、-1=11、-2=2=10，模=100=01+11=10+10=进一位。进一位表示：2=010、-2=110，第一位表示符号位。</li>
<li>如3位：能表示-4~3的数。1=001、-1=111、-4=4=100，模为=001+111=100+100=1000=进一位。进一位表示：4=0100、-4=1100，第一位表示符号位。模为1000</li>
<li>如8位：能表示-128~127的数。1=00000001、-1=11111111、-128=128=10000000</li>
<li>可以总结出：n为位数，能表示-2^(n-1)=2^(n-1)</li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><p>例：二进制<code>00001000</code>转换为十进制</p>
<p><code>(2^0)*0+(2^1)*0+(2^2)*0+(2^3)*1 = 8</code></p>
<h3 id="十进制整数转二进制整数"><a href="#十进制整数转二进制整数" class="headerlink" title="十进制整数转二进制整数"></a>十进制整数转二进制整数</h3><p><strong>除2取余，逆序排列</strong>：将循环除以2，直到商为0，记录每一步的余数，将每一步的余数倒序组成二进制</p>
<p>例：十进制5转换为二进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5&#x2F;2&#x3D;2···1</span><br><span class="line">2&#x2F;2&#x3D;1···0</span><br><span class="line">1&#x2F;2&#x3D;0...1</span><br><span class="line">(5)10&#x3D;(101)2，最后商为1</span><br><span class="line"></span><br><span class="line">7&#x2F;2&#x3D;3···1</span><br><span class="line">3&#x2F;2&#x3D;1···1</span><br><span class="line">1&#x2F;2&#x3D;0···1</span><br><span class="line">(7)10&#x3D;(111)2，最后商为0</span><br></pre></td></tr></table></figure>

<h3 id="十进制小数转换成二进制小数"><a href="#十进制小数转换成二进制小数" class="headerlink" title="十进制小数转换成二进制小数"></a>十进制小数转换成二进制小数</h3><p><strong>乘2取整，顺序排列</strong>：整数部分同上，小数部分循环乘2，直到小数部分为0，记录每一步的积并取整数部分，顺序组成二进制小数部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2.25)10转为二进制</span><br><span class="line">整数转二进制</span><br><span class="line">2&#x2F;2&#x3D;1...0</span><br><span class="line">1&#x2F;2&#x3D;0...1</span><br><span class="line"></span><br><span class="line">小数转二进制</span><br><span class="line">0.25*2&#x3D;0.5 &#x2F;&#x2F;整数部分为0</span><br><span class="line">0.5*2&#x3D;1.0 &#x2F;&#x2F;整数部分为1</span><br><span class="line">2.25(10)&#x3D;(10.01)2</span><br></pre></td></tr></table></figure>

<p>同样的算法，小数部分可能永远不为0，如0.4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.2*2&#x3D;0.4  &#x2F;&#x2F;整数部分为0</span><br><span class="line">0.4*2&#x3D;0.8  &#x2F;&#x2F;整数部分为0</span><br><span class="line">0.8*2&#x3D;1.6  &#x2F;&#x2F;整数部分为1</span><br><span class="line">0.6*2&#x3D;1.2  &#x2F;&#x2F;整数部分为1</span><br><span class="line">0.2*2&#x3D;0.4  &#x2F;&#x2F;整数部分为0</span><br><span class="line">...</span><br><span class="line">结果为无限循环小数：0.001100110011...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因子中包含5才能用2进制表示</p>
</blockquote>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>&amp;：位与and，将两个数转换为二进制，每一位进行比较，如果都为1则结果为1，否则为0</li>
<li>|：位或or，将两个数转换为二进制，每一位进行比较，只要有一个为1则结果为1，否则为0</li>
<li>~：位非not，单目运算符，将每位取反，使用补码进行计算<ul>
<li>如~37，8位机器上，补码为：00100101</li>
<li>取反：11011010=-38。</li>
<li>第一位是符号位，为1表示负数，负数的原码需要计算，对负数补码进行还原。（补码取反+1，或者补码-1取反）</li>
<li>补码减1得到反码：11011001</li>
<li>反码取反得正数（负数的反码为正数取反）：00100110，即38</li>
<li>所以<del>37=</del>(00100101)补码=11011010补码=-38</li>
</ul>
</li>
<li>^：异或xor，将两个数转换为二进制，每一位进行比较，如果相同则为0，不相同则为1</li>
</ul>
<h3 id="左移（-lt-lt-）、右移（-gt-gt-）"><a href="#左移（-lt-lt-）、右移（-gt-gt-）" class="headerlink" title="左移（&lt;&lt;）、右移（&gt;&gt;）"></a>左移（&lt;&lt;）、右移（&gt;&gt;）</h3><p>左移n位相当于乘以2的n次方：把二进制的高位左移n位，溢出舍弃，右边空出来的补0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：4&lt;&lt;2 &#x3D; 4*2^2 &#x3D; 16</span><br><span class="line">&#x3D; 0000 0100 &lt;&lt; 2 &#x3D; 0001 0000 &#x3D; 16</span><br></pre></td></tr></table></figure>

<p>右移n位相当于处以2的n次方：把二进制的低位右移n位，溢出舍弃，左边空出来的补0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：4&gt;&gt;2 &#x3D; 4&#x2F;2^2 &#x3D; 1</span><br><span class="line">&#x3D; 0000 0100 &lt;&lt; 2 &#x3D; 0000 0001 &#x3D; 16</span><br></pre></td></tr></table></figure>

<h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><table>
<thead>
<tr>
<th>进制</th>
<th>缩写</th>
<th>C语言</th>
<th>Java</th>
<th>书写</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>B</td>
<td>不能表示</td>
<td>不能表示</td>
<td>括号加下标：如(11)2，缩写后缀：11B，下同</td>
</tr>
<tr>
<td>八进制</td>
<td>O</td>
<td>0开头</td>
<td>0开头</td>
<td></td>
</tr>
<tr>
<td>十进制</td>
<td>D</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>十六进制</td>
<td>H</td>
<td>0x或0X开头</td>
<td>0x开头</td>
<td></td>
</tr>
</tbody></table>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>位（bit）是计算机存储的最小单位，字节是计算机处理数据的最小单位，1字节=8位</p>
]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>程序基础</tag>
      </tags>
  </entry>
  <entry>
    <title>书单（挖坑）</title>
    <url>/2018/01/01/reader-2018-01-01-%E9%98%85%E8%AF%BB%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<style>
  .item-list {
  }
  .item {
    margin: 0 12px 12px 0;
    border: 1px solid #ccc;
    background: #fbfbfb;
    position: static;
    border-radius: 4px;
    transition: box-shadow 0.3s ease-in-out;
    padding: 10px 15px 10px 8px;
    color: #444;
  }
  .item:hover {
    box-shadow: 0 3px 8px 0 rgb(0 0 0 / 20%);
  }
  .item-title {
    font-size: 20px;
    font-weight: bold;
  }
  .item-desc {
    border-top: 1px solid #ddd;
    margin-top: 8px;
    padding: 10px 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .item-url {
    color: #999;
  }
  .item-list tbody {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(750px, 1fr));
    justify-content: space-evenly;
    border: none;
    padding-left: 8px;
  }
  .item-list tbody tr {
    margin: 0 12px 12px 0;
    background: #fbfbfb;
    position: static;
    border-radius: 4px;
    transition: box-shadow 0.3s ease-in-out;
    padding: 8px 14px;
    color: #444;
    position: relative;
  }
  .item-list td,
  .item-list tr {
    display: block;
    border: none;
  }
  .item-list thead,
  .item-list th {
    display: none;
  }
  .item-list tr:hover {
    box-shadow: 0 3px 8px 0 rgb(0 0 0 / 20%);
  }
  .item-list tbody tr td:first-child {
    font-size: 18px;
    font-weight: bold;
    display: inline-block;
    padding: 0px 8px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .item-list tbody tr td:first-child a{
    color: #66D;
  }
  .item-list tbody tr td:nth-child(2) {
    font-size: 12px;
    color: #999;
    display: inline-block;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
    word-break: break-all;
    overflow: hidden;
    text-align: right;
    text-overflow: ellipsis;
    padding: 0px 8px;
  }
  .item-list tbody tr td:last-child {
    font-size: 14px;
    color: #999;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
    word-break: break-all;
    overflow: hidden;
    text-overflow: ellipsis;
    padding: 0px 8px;
  }
  .item-list td a {
    text-decoration: none;
    border: none;
  }
</style>

<div class="item-list">

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>收藏一些好书，有链接的用蓝色显示，待阅读补充介绍</p>
<p>//todo</p>
<h1 id="生活-amp-情感-amp-娱乐"><a href="#生活-amp-情感-amp-娱乐" class="headerlink" title="生活&amp;情感&amp;娱乐"></a>生活&amp;情感&amp;娱乐</h1><p>休闲阅读的书：扩宽视野</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>如何阅读一本书</td>
<td>[美] 莫提默·J·艾德勒；查尔斯·范多伦</td>
<td>阅读指南</td>
</tr>
<tr>
<td>那些古怪又让人忧心的问题</td>
<td></td>
<td>回答了一系列荒谬但又有趣的问题，例如需要多少兵蚁才能在一个小时内咬断我的腿</td>
</tr>
<tr>
<td>生命中最简单又最困难的事</td>
<td></td>
<td>来自华莱士的公开演讲，你除了需要扩大对历史、科学或任何随机事实的知识，还需要扩大对周围人的理解和认识。</td>
</tr>
<tr>
<td>爱的五种语言</td>
<td></td>
<td>表达和接受爱的五种不同方式</td>
</tr>
<tr>
<td><a href="https://what-if.xkcd.com/">《What If : Serious Scientific Answers to Absurd Hypothetical Questions》</a></td>
<td></td>
<td>假如 : 对荒谬假设性问题的严肃科学解答<br><a href="https://zhuanlan.zhihu.com/p/20116067?from_voters_page=true">知乎-What if？</a></td>
</tr>
<tr>
<td>三体</td>
<td>刘慈欣</td>
<td>“中国科幻文学里程碑“式的作品</td>
</tr>
<tr>
<td>白鹿原</td>
<td>陈忠实</td>
<td>渭河平原的雄奇史诗，中国农村的斑斓画卷</td>
</tr>
<tr>
<td>围城</td>
<td>钱钟书</td>
<td>”城里的人想逃出来，城外的人想冲进去，对婚姻也罢、职业也罢，人生的愿望大都如此。“</td>
</tr>
<tr>
<td>我们仨</td>
<td>杨绛</td>
<td>回忆一家三口快乐而艰难，爱与痛交织的日子</td>
</tr>
<tr>
<td>呼兰河传</td>
<td>萧红</td>
<td>感受萧红笔下爱恨交织的故乡情</td>
</tr>
<tr>
<td>长恨歌</td>
<td>王安忆</td>
<td>一个女人四十年的请与爱，一座城市四十年的常与变</td>
</tr>
<tr>
<td>解忧杂货铺</td>
<td>[日] 东野圭吾</td>
<td></td>
</tr>
<tr>
<td>白夜行</td>
<td>[日] 村上春树</td>
<td></td>
</tr>
<tr>
<td>挪威的森林</td>
<td>[日] 村上春树</td>
<td>动人心弦、平缓舒雅、略带感伤的恋爱小说</td>
</tr>
<tr>
<td>海边的卡夫卡</td>
<td>[日] 村上春树</td>
<td></td>
</tr>
<tr>
<td>雪国</td>
<td>[日] 川端康成</td>
<td></td>
</tr>
<tr>
<td>瓦尔登湖</td>
<td>[美] 梭罗</td>
<td>记录了作家长达两年的日常生活状态以及所思所想。在小木屋旁开荒种地，春种秋收，自给自足</td>
</tr>
<tr>
<td>月亮与六便士</td>
<td>[英] 毛姆</td>
<td></td>
</tr>
<tr>
<td>追风筝的人</td>
<td>[美] 卡勒德·胡塞尼</td>
<td></td>
</tr>
<tr>
<td>叫魂：1768年中国妖术大恐慌</td>
<td>孔飞力</td>
<td></td>
</tr>
<tr>
<td>霍乱时期的爱情</td>
<td>[哥伦比亚] 加西亚·马尔克斯，拉丁美洲魔幻现实主义文学代表人物</td>
<td>跨越半个多世纪的爱情史诗，穷尽所有爱情的可能性</td>
</tr>
<tr>
<td>百年孤独</td>
<td>[哥伦比亚] 加西亚·马尔克斯</td>
<td></td>
</tr>
<tr>
<td>牧羊少年的奇幻之旅</td>
<td></td>
<td></td>
</tr>
<tr>
<td>偷影子的人</td>
<td>[法] 马克·李维</td>
<td></td>
</tr>
<tr>
<td>了不起的盖茨比</td>
<td>[美] FS菲兹杰拉德</td>
<td>”他的梦想看起来离他如此之近，他几乎无法错过它“</td>
</tr>
<tr>
<td>小王子</td>
<td>[法] 安东尼·德·圣·埃克苏佩里</td>
<td></td>
</tr>
<tr>
<td>人类的群星闪耀时</td>
<td>[奥地利] 史蒂夫·茨威格</td>
<td>撷取十四个历史时刻加以刻画。</td>
</tr>
<tr>
<td>老人与海</td>
<td>[美] 海明威</td>
<td></td>
</tr>
<tr>
<td>玩偶之家</td>
<td>[挪威] 亨利·易卜生</td>
<td></td>
</tr>
<tr>
<td>红与黑</td>
<td>[法] 司汤达</td>
<td></td>
</tr>
<tr>
<td>人性的弱点</td>
<td>[美] 戴尔·卡耐基</td>
<td></td>
</tr>
<tr>
<td>悲惨世界</td>
<td>[法] 维克多·雨果</td>
<td></td>
</tr>
<tr>
<td>这里</td>
<td>[美]理查德·麦奎尔</td>
<td>被称为“带上孤岛的图像小说”</td>
</tr>
</tbody></table>
<h1 id="哲学-amp-历史-amp-人文-amp-科学-amp-神话"><a href="#哲学-amp-历史-amp-人文-amp-科学-amp-神话" class="headerlink" title="哲学&amp;历史&amp;人文&amp;科学&amp;神话"></a>哲学&amp;历史&amp;人文&amp;科学&amp;神话</h1><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>史记</td>
<td>[汉] 司马迁</td>
<td>纪传体通史，十二本纪（记历代帝王政绩）、三十世家（记诸侯国和汉代诸侯、勋贵兴亡）、七十列传（记重要人物的言行事迹，主要叙人臣，其中最后一篇为自序）、十表（大事年表）、八书（记各种典章制度记礼、乐、音律、历法、天文、封禅、水利、财用）</td>
</tr>
<tr>
<td>资治通鉴</td>
<td>[北宋] 司马光</td>
<td>编年体通史</td>
</tr>
<tr>
<td>孙子兵法</td>
<td>[春秋] 孙武</td>
<td></td>
</tr>
<tr>
<td>山海经</td>
<td></td>
<td></td>
</tr>
<tr>
<td>社会契约论</td>
<td>卢梭</td>
<td>第一卷论述了社会结构和社会契约，第二卷阐述主权及其权利，第三卷阐述政府及其运作形式，第四卷讨论几种社会组织。《社会契约论》中主权在民的思想，是现代民主制度的基石，深刻地影响了欧洲的革命运动和英属北美殖民地的独立战争。</td>
</tr>
<tr>
<td>万物简史</td>
<td></td>
<td>解答了关于宇宙、生命、人类等的一些基本问题。</td>
</tr>
<tr>
<td>人类简史：从动物到上帝</td>
<td>[以色列] 尤瓦尔·赫拉利</td>
<td>填补传统人类史的3大鸿沟：历史观与哲学观的鸿沟、人类和生态系统之间的鸿沟、集体与个人之间的鸿沟</td>
</tr>
<tr>
<td>时间简史</td>
<td>[英] 史蒂夫·霍金</td>
<td></td>
</tr>
<tr>
<td>国富论</td>
<td>[英] 亚当·斯密</td>
<td>总结近代初期各国资本主义发展经验，批判地吸收当时重要的经济理论，提出一套系统全面地经济学说</td>
</tr>
<tr>
<td>资本论</td>
<td>[德] 马克思</td>
<td>哲学、政治经济学、科学社会主义</td>
</tr>
<tr>
<td>西方哲学史</td>
<td>[美] 罗素</td>
<td></td>
</tr>
<tr>
<td>菊与刀</td>
<td>[美] 鲁斯·本尼迪克特</td>
<td>日本文化，二战后美日国际关系史</td>
</tr>
<tr>
<td>理想国</td>
<td>[古希腊] 柏拉图</td>
<td>人类正义问题的开山之作，规划未来理想社会的蓝本</td>
</tr>
<tr>
<td>不能承受的生命之轻</td>
<td>[法] 米兰·昆德拉</td>
<td>揭示人类命运、爱情、斗争和结局</td>
</tr>
<tr>
<td>明朝那些事儿</td>
<td>当年明月</td>
<td></td>
</tr>
<tr>
<td>大数据时代：生活、工作与思维的大变革</td>
<td>[英] 迈尔·舍恩伯格；库克耶</td>
<td></td>
</tr>
<tr>
<td>平凡的世界</td>
<td>路遥</td>
<td>浓缩中国西北农村历史变迁过程</td>
</tr>
<tr>
<td>万历十五年</td>
<td>黄仁宇</td>
<td></td>
</tr>
<tr>
<td>1984</td>
<td>乔治•奥威尔</td>
<td>反乌托邦三部代表作：英国赫胥黎《美丽新世界》、俄国扎米亚京《我们》</td>
</tr>
</tbody></table>
<h1 id="思想-amp-心理-amp-感悟"><a href="#思想-amp-心理-amp-感悟" class="headerlink" title="思想&amp;心理&amp;感悟"></a>思想&amp;心理&amp;感悟</h1><p>有点内涵、思想的书</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>乌合之众</td>
<td>[法] 古斯塔夫·勒庞</td>
<td>解析群体心理的经典名著，了解集体，也了解每个个体</td>
</tr>
<tr>
<td>清醒思考的艺术</td>
<td></td>
<td></td>
</tr>
<tr>
<td>梦的解析</td>
<td>[奥] 西格蒙德·弗洛伊德</td>
<td></td>
</tr>
<tr>
<td>Seeking Wisdom</td>
<td></td>
<td>探索真正的智慧</td>
</tr>
<tr>
<td>异类：不一样的成功启示录</td>
<td></td>
<td></td>
</tr>
<tr>
<td>拖延心理学</td>
<td>简·博克、莱诺拉·袁</td>
<td></td>
</tr>
<tr>
<td>影响力</td>
<td>[美] 罗伯特·西奥迪尼</td>
<td>一是当你真正的意图是要说“不”时，你不会再说“是”，二是可以令你自己变得比以前更具影响力。</td>
</tr>
<tr>
<td>设计心理学</td>
<td>唐纳德·A·诺曼</td>
<td></td>
</tr>
<tr>
<td>策略思维</td>
<td>阿维纳什·K·迪克西特 / 巴里·J·奈尔伯夫</td>
<td></td>
</tr>
<tr>
<td>无价</td>
<td>威廉·庞德斯通</td>
<td>价格只是一场集体幻觉。在心理学里，人们无法准确地估计“公平价格”，反而受到无意识、不理性、政治等不正确因素的强烈影响。</td>
</tr>
<tr>
<td>浅薄</td>
<td>尼古拉斯·卡尔</td>
<td>互联网正在按照自己的面目改造我们。我们变得对扫描和略读越来越得心应手，但是，我们正在丧失的却是专注能力、沉思能力和反省能力。</td>
</tr>
<tr>
<td>定位</td>
<td>艾·里斯 / 杰克·特劳特</td>
<td>如何进入用户心智以赢得用户</td>
</tr>
<tr>
<td>高效能人士的七个习惯</td>
<td>史蒂芬·柯维</td>
<td></td>
</tr>
<tr>
<td>语言的魔力</td>
<td>罗伯特·迪尔茨</td>
<td></td>
</tr>
<tr>
<td>思考，快与慢</td>
<td>[美]丹尼尔·卡尼曼</td>
<td>指导我们如何做出更好的选择，以及如何运用不同技巧来避免思维失误</td>
</tr>
</tbody></table>
<h1 id="程序员必读书单"><a href="#程序员必读书单" class="headerlink" title="程序员必读书单"></a>程序员必读书单</h1><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>黑客与画家</td>
<td>保罗•格雷厄姆，硅谷创业之父</td>
<td></td>
</tr>
<tr>
<td><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/">大教堂和集市</a></td>
<td>Eric Raymond</td>
<td>开源</td>
</tr>
<tr>
<td>人月神话</td>
<td></td>
<td>一个需要10天才能干完的活，不可能让10个人在1天干完</td>
</tr>
<tr>
<td>漫步华尔街</td>
<td></td>
<td></td>
</tr>
<tr>
<td>代码整洁之道</td>
<td>Robert C.Martin（Uncle Bob）</td>
<td>《Clean Code》：如何提高自己的代码质量。<br>《The Clean Coder》：如何成为一名更优秀的开发者。</td>
</tr>
<tr>
<td>重构：改善既有代码的设计</td>
<td>Martin Fowler，《重构》一书作者，敏捷开发大师</td>
<td></td>
</tr>
<tr>
<td>修改代码的艺术</td>
<td>[美] Michael C. Feathers</td>
<td></td>
</tr>
<tr>
<td>程序员修炼之道</td>
<td></td>
<td></td>
</tr>
<tr>
<td>程序员的思维修炼</td>
<td>[美国] 亨特（Andy Hunt）,敏捷开发权威人士，敏捷宣言首倡者之一</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html">程序员的酒后真言</a></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="技术书籍"><a href="#技术书籍" class="headerlink" title="技术书籍"></a>技术书籍</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>图解HTTP</td>
<td></td>
<td></td>
</tr>
<tr>
<td>图解TCP/IP</td>
<td></td>
<td></td>
</tr>
<tr>
<td>网络是怎样连接的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>计算机网络-自顶向下方法</td>
<td>[美] James，F.Kurose，Keith，W.Ross</td>
<td></td>
</tr>
<tr>
<td>TCP/IP详解</td>
<td>[美] W.Richard Stevens</td>
<td></td>
</tr>
</tbody></table>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>大话数据结构</td>
<td></td>
<td></td>
</tr>
<tr>
<td>剑指Offer</td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据结构与算法分析</td>
<td>[美] 马克·艾伦·维斯</td>
<td></td>
</tr>
<tr>
<td>算法图解</td>
<td></td>
<td></td>
</tr>
<tr>
<td>计算机程序设计艺术</td>
<td></td>
<td></td>
</tr>
<tr>
<td>编程珠玑</td>
<td></td>
<td></td>
</tr>
<tr>
<td>算法（第四版）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>算法导论</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="架构和设计模式"><a href="#架构和设计模式" class="headerlink" title="架构和设计模式"></a>架构和设计模式</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>设计模式</td>
<td>GoF，四人帮</td>
<td>设计模式开山之作，提出经典的23种设计模式</td>
</tr>
<tr>
<td>Head First设计模式</td>
<td>[美] 弗里曼（Freeman E.）</td>
<td></td>
</tr>
<tr>
<td>深入浅出面向对象分析与设计</td>
<td></td>
<td></td>
</tr>
<tr>
<td>软件建模与设计：UML、用例、模式和软件体系结构</td>
<td>[美] Hassan Gomaa</td>
<td></td>
</tr>
<tr>
<td>架构之美：行业思想领袖揭秘软件设计之美</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Java编程思想</td>
<td>[美] Bruce Eckel</td>
<td></td>
</tr>
<tr>
<td>深入理解Java虚拟机</td>
<td>周志明</td>
<td></td>
</tr>
<tr>
<td>Java核心技术</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Effective Java</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Java 性能优化权威指南</td>
<td>Charlie Hunt，Binu John</td>
<td></td>
</tr>
<tr>
<td>Java并发编程实战</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Java并发编程的艺术</td>
<td>方腾飞</td>
<td></td>
</tr>
</tbody></table>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>C程序设计语言</td>
<td>[美] 布莱恩·W.克尼汉，[美] 丹尼斯·M.里奇</td>
<td></td>
</tr>
<tr>
<td>C和指针</td>
<td>[美] 里科（Kenneth·Reek）</td>
<td></td>
</tr>
<tr>
<td>C专家编程</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C陷阱与缺陷</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C++ Primer</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Effective C++</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>数据库系统概念</td>
<td>[美] Abraham Silberschatz，Henry F.Korth，S.Sudarshan</td>
<td></td>
</tr>
<tr>
<td>MySQL技术内幕：InnoDB存储引擎</td>
<td>姜承尧</td>
<td></td>
</tr>
<tr>
<td>MySQL必知必会</td>
<td>[英] Ben Forta</td>
<td></td>
</tr>
<tr>
<td>高性能MySQL</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Redis设计与实现</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Redis深度历险</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>计算机科学导论</td>
<td>[美] 贝赫鲁兹.佛罗赞（Behrouz Forouzan）</td>
<td></td>
</tr>
<tr>
<td>计算机组成原理</td>
<td>唐朔飞</td>
<td></td>
</tr>
<tr>
<td>汇编语言</td>
<td></td>
<td></td>
</tr>
<tr>
<td>编译原理</td>
<td>[美] Alfred V.Aho，[美] Monica S.Lam，[美] Ravi Sethi 等 著</td>
<td></td>
</tr>
<tr>
<td>计算机组成与设计 硬件/软件接口</td>
<td></td>
<td></td>
</tr>
<tr>
<td>离散数学及其应用</td>
<td>[美] 肯尼思·H·罗森</td>
<td></td>
</tr>
<tr>
<td>编码</td>
<td></td>
<td></td>
</tr>
<tr>
<td>计算机程序的构造和解释（SICP）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>现代操作系统</td>
<td>Andrew S. Tanenbaum，Herbert Bos</td>
<td>主要内容包括进程与线程、内存管理、文件系统、输入/输出、死锁、虚拟化和云、多处理机系统、安全，以及关于UNIX、Linux、Android和Windows的实例研究等。</td>
</tr>
<tr>
<td>操作系统真象还原</td>
<td></td>
<td></td>
</tr>
<tr>
<td>现代操作系统：原理与实现</td>
<td></td>
<td></td>
</tr>
<tr>
<td>深入理解计算机系统</td>
<td>[美] 兰德尔 E.布莱恩特 （Randal E.·Bryant）</td>
<td></td>
</tr>
<tr>
<td>鸟哥的Linux私房菜</td>
<td></td>
<td>鸟哥</td>
</tr>
<tr>
<td>UNIX环境高级编程</td>
<td></td>
<td></td>
</tr>
<tr>
<td>程序员自我修养</td>
<td></td>
<td>系统软件的运行机制和原理，涉及在Windows和Linux两个系统平台上，一个应用程序在编译、链接和运行时刻所发生的各种事项</td>
</tr>
<tr>
<td>UNIX网络编程</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TCP/IP网络编程</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Linux高性能服务器编程</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Linux多线程服务端编程</td>
<td></td>
<td></td>
</tr>
<tr>
<td>深入Linux内核架构</td>
<td></td>
<td></td>
</tr>
<tr>
<td>深入理解Linux内核</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="其他推荐"><a href="#其他推荐" class="headerlink" title="其他推荐"></a>其他推荐</h1><p>三大推理文学宗师：松本清张、阿加莎·克里斯蒂、阿瑟·柯南·道尔</p>
<p>中国武侠四大宗师：金庸、古龙、梁羽生、温瑞安</p>
<p>四大名著</p>
</div>

<p><a href="http://www.catb.org/esr/">Eric Raymond的站点</a>：一位优秀的黑客和作家，《大教堂和集市》作者</p>
<ul>
<li><a href="http://www.catb.org/~esr/faqs/hacker-howto.html">How To Become A Hacker</a>：如何成为一名黑客</li>
<li><a href="http://catb.org/~esr/faqs/hacking-howto.html">How To Learn Hacking</a>：如何学习黑客</li>
<li><a href="http://www.catb.org/~esr/faqs/hacker-hist.html">A Brief History of Hackerdom</a>：黑客简史</li>
<li><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/hacker-revenge/">Revenge of the Hackers</a>：黑客的复仇</li>
<li><a href="http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a>：如何聪明的提问</li>
<li>…</li>
</ul>
<p><a href="http://www.everypoet.com/archive/">Every Poet站点</a>：收录世界经典诗歌</p>
<p><a href="https://www.tuicool.com/books">推酷书单推荐</a></p>
<p><a href="http://gen.lib.rus.ec/">书籍下载</a></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul>
<li>一个人一生实际上只用读5、6本书，就能解决人生所有的困惑；但为了找到生命中的6本书，他需要去读上千本。——马家辉</li>
<li>千万不要指望通过阅读就能有所改变，如果不思考不行动，看什么书都没用。</li>
<li>看那么书有什么用？最后不都忘了吗？<ul>
<li>——你每天吃那么多饭菜有什么用？最后也不都拉了吗？！食物消化后被拉了，但营养都被吸收到了血液和骨髓里，读书亦是如此！</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>党员笔记</title>
    <url>/2017/12/21/personal-2017-12-21-Party/</url>
    <content><![CDATA[<h2 id="思想汇报书写格式"><a href="#思想汇报书写格式" class="headerlink" title="思想汇报书写格式"></a>思想汇报书写格式</h2><ol>
<li><p>标题：一般在第一行居中写“思想汇报”。</p>
</li>
<li><p>称谓：一般在第二行顶格写“敬爱的党支部”或“敬爱的党组织”，后面加冒号。</p>
</li>
<li><p>正文：这是思想汇报的主要部分，一般写以下内容：</p>
<ul>
<li>对当前和一个时期党的一个时期党的中心任务或党的路线、方针、政策的看法、态度，阐明自己的观点，写清楚自己的认识或自己还有什么疑虑和理解不清楚的问题等。</li>
<li>参加重要活动或学习重要文章、文件所受的启发、教育和体会，把自己的认识、体会和收获向党组织汇报。</li>
<li>本人在政治、思想、学习、工作、作风等方面的主要表现情况。</li>
<li>对照党员的标准，找出存在问题及今后的努力方向，表明自己要求进步的决心和信心。</li>
</ul>
</li>
<li><p>结尾：在思想汇报的最后部分，可写上自己对党组织的请求和希望，一般用“恳请党组织给予批评、帮助”或“希望党组织加强对我的培养和教育”等作为结束语。</p>
</li>
<li><p>落款：在结尾的右下方要写上汇报人的姓名，并注明汇报的年月日。</p>
</li>
</ol>
<h2 id="思想汇报书写要求"><a href="#思想汇报书写要求" class="headerlink" title="思想汇报书写要求"></a>思想汇报书写要求</h2><ol>
<li>实事求是，写清自己的真情实感，切忌空话套话。</li>
<li>根据不同时期的思想认识情况，集中深刻对一两个问题谈深谈透，不要泛泛而谈。</li>
<li>要紧密联系实际，本人亲自书写，不得简单抄录党章、报告和报刊文章，也不得抄袭他人思想汇报。</li>
<li>一分为二，既要肯定自己的进步，又要找准自己的不足，敢于向党组织暴露自身的缺点和问题。</li>
<li>要按时、经常、主动、自觉地向党组织写思想汇报，一般不应由党组织、培养人提醒或督促。</li>
<li>书写过程中不得有任何勾抹迹象，字迹清晰，切忌潦草。</li>
<li>不能有错别字，注意标点符号等严格符合高考作文要求。</li>
</ol>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>一带一路，两学一做，三会一课，四个自信，四个全面，五位一体，五大发展等知识点</p>
<h2 id="评议"><a href="#评议" class="headerlink" title="评议"></a>评议</h2><p>从思想、工作、学习、生活各方面结合实际概括，并给予评价和期望</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>《寻梦环游记》</title>
    <url>/2017/11/24/reader-2017-11-24-Coco/</url>
    <content><![CDATA[ <center>
     <font size="5">《寻梦环游记》</font><br>
 </center>
​    看了《寻梦环游记》，号称媲美《WALL·E》的近年来最感人的动画电影，名不虚传，很庆幸自己没有错过。看简介的时候尚觉得不以为然，以为是平平无奇的追梦励志片，却没想到出乎意料的精彩。
​    或许是从“燃烧着”的万寿菊随着吉他旋转起来的瞬间，也或许是从踏上花瓣桥的那一刻开始感到震撼。
我想大概是从“亡灵的世界并非永恒，他们靠着人们的记忆活下来。当有一天，他们不再被任何人提起，在人间再无一点痕迹，那么，他们在亡灵世界的生命也就走到了尽头”开始，想到了《龙族》中江南曾引用的一句话：“人的一生，要死去三次。第一次，当你的心跳停止，呼吸消逝，你在生物学上被宣告了死亡；第二次，当你下葬，人们穿着黑衣出席你的葬礼，他们宣告，你在这个社会上不复存在，你从人际关系网里消逝，你悄然离去；而第三次死亡，是这个世界上最后一个记得你的人，把你忘记，于是，你就真正地死去。整个宇宙都将不再和你有关。”
​    影片原本叫《DiadelosMuertos》（亡灵节），后来因涉及文化剥削改名为《Coco》，处于阴阳生死交界的曾祖母的名字，贯穿了整部片的泪点，再合适不过，也算无心插柳。译名为寻梦，故事始于家，经过奇妙的旅程，最后却回到原点。想到了《牧羊少年奇幻之旅》，少年圣地亚哥的梦始于废弃教堂的无花果树下，经过一段段奇妙和极不平凡的旅程，最后还是将回到这棵平凡的无花果树下。牧羊人就像船员或旅行推销员一样，终究会在某个村庄遇见某个人，让他们忘了四处游荡的生活多么无忧无虑。就像圣地亚哥和父亲的对话： 
​    “全世界的人都来过这个地方，来寻找新的事物，然而当他们离去的时候，基本还是跟来时同一个人呢，他们爬上高山去，看过城堡，最后还是觉得过去的比眼前好，他们或许是金头发，或许有着黑皮肤，但他们大致跟这里的人差不多” 
​    ——“但我很想去看看他们住的城市和城堡。” 
​    “那些人看了我们的地方以后说，他们很想永远住在这里。” 
​    ——“我却希望能认识他们住的地方，知道他们怎么过活。” 
​    ……  ……  …… 
​    “……尽管向原野去吧，总有一天你会明白我们的土地最肥，我们的女人最美……”。
其实梦就在家，平凡又伟大的智慧，蕴含着炼金术的哲学精髓。我们一生苦苦追寻梦想，不断跌倒爬起，不惜撞得头破血流，见过了富丽堂皇，浮世繁华，最后还是会怀念自己住过的茅屋，选择回到原点栖息。
“人真正害怕的，并不是肉体的消亡，而是畏惧被遗忘，千百年来，所有的人都在以自己的方式，想要在这个世界上留下自己存在过的证明。君王修建规模宏大的陵寝，学者著书立说传承思想，艺术家留下作品洞见自然与文明。这就是所谓的 向死而生 。但是一个普通人，他平平凡凡的一生，该怎么被记住呢？作为这个世界的大多数，多少人来了又走，匆匆忙忙，毫无痕迹。我们的故事，只有最亲近的人记得，我们的名字，也只会被他们提起……当有一天，连他们都忘了，我们就真的消失地干干净净。就算真的有灵魂尚存，也只能像埃克托一样不知魂归何处。”
“记忆，是一张连接阴阳两个世界的船票。我会一直记得你，直到在另一个世界，再次找到你。”
“一个活着的人，需要带着逝去亲人的祝福才能活下去，而一个死去的魂魄，也依赖在世的人的记忆而存在”
最后，“这首《Remember me》不是给世界的，而是给我最爱的女儿Coco”，希望你能记住我。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>《道德经》</title>
    <url>/2017/11/11/reader-2017-11-11-%E9%81%93%E5%BE%B7%E7%BB%8F/</url>
    <content><![CDATA[ <center>
     <font size="5">《道德经》</font><br>
     <font size="4">老子著</font>
 </center>

<p>01.道可道，非常道。名可名，非常名。无名天地之始。有名万物之母。故常无欲以观其妙。常有欲以观其徼。此两者同出而异名，同谓之玄。玄之又玄，众妙之门。</p>
<p>02.天下皆知美之为美，斯恶矣；皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相倾，音声相和，前後相随。是以圣人处无为之事，行不言之教。万物作焉而不辞。生而不有，为而不恃，功成而弗居。夫唯弗居，是以不去。</p>
<p>03.不尚贤， 使民不争。不贵难得之货，使民不为盗。不见可欲，使民心不乱。是以圣人之治，虚其心，实其腹，弱其志，强其骨；常使民无知、无欲，使夫智者不敢为也。为无为，则无不治。</p>
<p>04.道冲而用之，或不盈。渊兮似万物之宗。解其纷，和其光，同其尘，湛兮似或存。吾不知谁之子，象帝之先。</p>
<p>05.天地不仁，以万物为刍狗。圣人不仁，以百姓为刍狗。天地之间，其犹橐迭乎？虚而不屈，动而愈出。多言数穷，不如守中。</p>
<p>06.谷神不死是谓玄牝。玄牝之门是谓天地根。绵绵若存，用之不勤。</p>
<p>07.天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人後其身而身先，外其身而身存。非以其无私邪！故能成其私。</p>
<p>08.上善若水。水善利万物而不争，处众人之所恶，故几於道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。</p>
<p>09.持而盈之不如其己；揣而锐之不可长保；金玉满堂莫之能守；富贵而骄，自遗其咎。功遂身退，天之道。</p>
<p>10.载营魄抱一，能无离乎？专气致柔，能如婴儿乎？涤除玄览，能无疵乎？爱国治民，能无为乎？天门开阖，能为雌乎？明白四达，能无知乎。</p>
<p>11.三十幅共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。</p>
<p>12.五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨。是以圣人，为腹不为目，故去彼取此。</p>
<p>13.宠辱若惊，贵大患若身。何谓宠辱若惊？宠为下。得之若惊失之若惊是谓宠辱若惊。何谓贵大患若身</p>
<p>？吾所以有大患者，为吾有身，及吾无身，吾有何患。故贵以身为天下，若可寄天下。爱以身为天下，若可托天下。</p>
<p>14.视之不见名曰夷。听之不闻名曰希。抟之不得名曰微。此三者不可致诘，故混而为一。其上不皦<br>(jiǎo)，其下不昧，绳绳不可名，复归於无物。是谓无状之状，无物之象，是谓惚恍。迎之不见其首，随之不见其後。执古之道以御今之有。能知古始，是谓道纪。</p>
<p>15.古之善为士者，微妙玄通，深不可识。夫唯不可识，故强为之容。豫兮若冬涉川；犹兮若畏四邻；俨兮其若容；涣兮若冰之将释；敦兮其若朴；旷兮其若谷；混兮其若浊；澹兮其若海；飉(liáo,风的声音)兮若无止。孰能浊以静之徐清。孰能安以动之徐生。保此道者不欲盈。夫唯不盈故能蔽而新成。</p>
<p>16.致虚极守静笃。万物并作，吾以观复。夫物芸芸各复归其根。归根曰静，是谓复命；复命曰常，知常曰明。不知常，妄作凶。知常容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。</p>
<p>17.太上，下知有之。其次，亲而誉之。其次，畏之。其次，侮之。信不足焉，有不信焉。悠兮其贵言，功成事遂，百姓皆谓∶我自然。</p>
<p>18.大道废有仁义；慧智出有大伪；六亲不和有孝慈；国家昏乱有忠臣。</p>
<p>19.绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有；此三者，以为文不足。故令有所属，见素抱朴少私寡欲。</p>
<p>20.绝学无忧，唯之与阿，相去几何？善之与恶，相去若何？人之所畏，不可不畏。荒兮其未央哉！众人熙熙如享太牢、如春登台。我独泊兮其未兆，如婴儿之未孩；儡儡(lěi,羸弱)兮若无所归。众人皆有馀，而</p>
<p>我独若遗。我愚人之心也哉！沌沌兮。俗人昭昭，我独昏昏；俗人察察，我独闷闷。众人皆有以，而我独顽且鄙。我独异於人，而贵食母。</p>
<p>21.孔德之容惟道是从。道之为物惟恍惟惚。惚兮恍兮其中有象。恍兮惚兮其中有物。窈兮冥兮其中有精。其精甚真。其中有信。自古及今，其名不去以阅众甫。吾何以知众甫之状哉！以此。</p>
<p>22.曲则全，枉则直，洼则盈，敝则新少则得，多则惑。是以圣人抱一为天下式。不自见故明；不自是故彰；不自伐故有功；不自矜故长；夫唯不争，故天下莫能与之争。古之所谓∶曲则全者」岂虚言哉！诚全而归之。</p>
<p>23.希言自然。故飘风不终朝，骤雨不终日。孰为此者？天地。天地尚不能久，而况於人乎？故从事於道者，同於道。德者同於德。失者同於失。同於道者道亦乐得之；同於德者德亦乐得之；同於失者失於乐得之信不足焉有不信焉。</p>
<p>24.企者不立；跨者不行。自见者不明；自是者不彰。自伐者无功；自矜者不长。其在道也曰∶馀食赘形。物或恶之，故有道者不处。</p>
<p>25.有物混成先天地生。寂兮寥兮独立不改，周行而不殆，可以为天下母。吾不知其名，强字之曰道。强为之名曰大。大曰逝，逝曰远，远曰反。故道大、天大、地大、人亦大。域中有大，而人居其一焉。人法地，地法天，天法道，道法自然。</p>
<p>26.重为轻根，静为躁君。是以君子终日行不离轻重。虽有荣观燕处超然。奈何万乘之主而以身轻天下。轻则失根，躁则失君。</p>
<p>27.善行无辙迹。善言无瑕谪。善数不用筹策。善闭无关楗而不可开。善结无绳约而不可解。是以圣人常善救人，故无弃人。常善救物，故无弃物。是谓袭明。故善人者不善人之师。不善人者善人之资。不贵其师、不爱其资，虽智大迷，是谓要妙。</p>
<p>28.知其雄，守其雌，为天下溪。为天下溪，常德不离，复归於婴儿。知其白，守其黑，为天下式。为天下式，常德不忒，复归於无极。知其荣，守其辱，为天下谷。为天下谷，常德乃足，复归於朴。朴散则为器，圣人用之则为官长。故大制不割。</p>
<p>29.将欲取天下而为之，吾见其不得已。天下神器，不可为也，为者败之，执者失之。夫物或行或随、或觑或吹、或强或羸、或挫或隳。是以圣人去甚、去奢、去泰。</p>
<p>30.以道佐人主者，不以兵强天下。其事好还。师之所处荆棘生焉。军之後必有凶年。善有果而已，不敢以取强。果而勿矜。果而勿伐。果而勿骄。果而不得已。果而勿强。物壮则老，是谓不道，不道早已。</p>
<p>31.夫佳兵者不祥之器，物或恶之，故有道者不处。君子居则贵左，用兵则贵右。兵者不祥之器，非君子之器，不得已而用之，恬淡为上。胜而不美，而美之者，是乐杀人。夫乐杀人者，则不可得志於天下矣。吉事尚左，凶事尚右。偏将军居左，上将军居右。言以丧礼处之。杀人之众，以悲哀泣之，战胜以丧礼处之。</p>
<p>32.道常无名。朴虽小天下莫能臣也。侯王若能守之，万物将自宾。天地相合以降甘露，民莫之令而自均。始制有名，名亦既有，夫亦将知止，知止可以不殆。譬道之在天下，犹川谷之於江海。</p>
<p>33.知人者智，自知者明。胜人者有力，自胜者强。知足者富。强行者有志。不失其所者久。死而不亡者，寿。</p>
<p>34.大道泛兮，其可左右。万物恃之以生而不辞，功成而不名有。衣养万物而不为主，常无欲可名於小。万物归焉，而不为主，可名为大。以其终不自为大，故能成其大。</p>
<p>35.执大象天下往。往而不害安平太。乐与饵，过客止。道之出口淡乎其无味。视之不足见。听之不足闻。用之不足既。</p>
<p>36.将欲歙之，必固张之。将欲弱之，必固强之。将欲废之，必固兴之。将欲取之，必固与之。是谓微明。柔弱胜刚强。鱼不可脱於渊，国之利器不可以示人。</p>
<p>37.道常无为，而无不为。侯王若能守之，万物将自化。化而欲作，吾将镇之以无名之朴。无名之朴，夫亦将无欲。不欲以静，天下将自定。</p>
<p>38.上德不德是以有德。下德不失德是以无德。上德无为而无以为。下德无为而有以为。上仁为之而无以为。上义为之而有以为。上礼为之而莫之以应，则攘臂而扔之。故失道而後德。失德而後仁。失仁而後义</p>
<p>。失义而後礼。夫礼者忠信之薄而乱之首。前识者，道之华而愚之始。是以大丈夫，处其厚不居其薄。处其实，不居其华。故去彼取此。</p>
<p>39.昔之得一者。天得一以清。地得一以宁。神得一以灵。谷得一以盈。万物得一以生。侯王得一以为天下贞。其致之。天无以清将恐裂。地无以宁将恐废。神无以灵将恐歇。谷无以盈将恐竭。万物无以生将恐灭。侯王无以贞将恐蹶。故贵以贱为本，高以下为基。是以侯王自称孤、寡、不谷。此非以贱为本邪？非乎。至誉无誉。不欲琭琭如玉，珞珞如石。</p>
<p>40.反者道之动。弱者道之用。天下万物生於有，有生於无。</p>
<p>41.上士闻道勤而行之。中士闻道若存若亡。下士闻道大笑之。不笑不足以为道。故建言有之。明道若昧。进道若退。夷道若纇。上德若谷。大白若辱。广德若不足。建德若偷。质真若渝。大方无隅。大器晚成。大音希声。大象无形。道隐无名。夫唯道善贷且成。</p>
<p>42.道生一。一生二。二生三。三生万物。万物负阴而抱阳，冲气以为和。人之所恶，唯孤、寡不谷，而王公以为称，故物或损之而益，或益之而损。人之所教，我亦教之，强梁者，不得其死。吾将以为教父。</p>
<p>43.天下之至柔，驰骋天下之至坚。无有入无间，吾是以知无为之有益。不言之教，无为之益天下希及之。</p>
<p>44.名与身孰亲。身与货孰多。得与亡孰病。是故甚爱必大费。多藏必厚亡。知足不辱。知止不殆。可以长久。</p>
<p>45.大成若缺，其用不弊。大盈若冲，其用不穷。大直若屈。大巧若拙。大辩若讷。静胜躁，寒胜热。清静为天下正。</p>
<p>46.天下有道，却走马以粪。天下无道，戎马生於郊。祸莫大於不知足。咎莫大於欲得。故知足之足常足矣。</p>
<p>47.不出户知天下。不窥牖见天道。其出弥远，其知弥少。是以圣人不行而知。不见而明。不为而成。</p>
<p>48.为学日益。为道日损。损之又损，以至於无为。无为而不为。取天下常以无事，及其有事，不足以取天下。</p>
<p>49.圣人无常心。以百姓心为心。善者吾善之。不善者吾亦善之，德善。信者吾信之。不信者吾亦信之，德信。圣人在天下，歙歙(xīxī,无所偏执的样子)焉，为天下浑其心。百姓皆注其耳目，圣人皆孩之。</p>
<p>50.出生入死。生之徒，十有三。死之徒，十有三。人之生，动之於死地，亦十有三。夫何故？以其生生之厚。盖闻善摄生者，陆行不遇凶虎，入军不被甲兵。凶无所投其角。虎无所用其爪。兵无所容其刃。夫何故？以其无死地。</p>
<p>51.道生之，德畜之，物形之，势成之。是以万物莫不尊道，而贵德。道之尊，德之贵，夫莫之命而常自然。故道生之，德畜之。长之育之。亭之毒之。养之覆之。生而不有，为而不恃，长而不宰。是谓玄德。</p>
<p>52.天下有始，以为天下母。既得其母，以知其子。既知其子，复守其母，没身不殆。塞其兑，闭其门，终身不勤。开其兑，济其事，终身不救。见其小曰明，守柔曰强。用其光，复归其明，无遗身殃。是为习常。</p>
<p>53.使我介然有知，行於大道，唯施是畏。大道甚夷，而人好径。朝甚除，田甚芜，仓甚虚。服文彩，带利剑，厌饮食，财货有馀。是谓盗夸。非道也哉。</p>
<p>54.善建者不拔。善抱者不脱。子孙以祭祀不辍。修之於身其德乃真。修之於家其德乃馀。修之於乡其德乃长。修之於邦其德乃丰。修之於天下其德乃普。故以身观身，以家观家，以乡观乡，以邦观邦，以天下观天下。吾何以知天下然哉？以此。</p>
<p>55.含德之厚比於赤子。毒虫不螫，猛兽不据，攫鸟不抟。骨弱筋柔而握固。未知牝牡之合而全作，精之至也。终日号而不嗄，和之至也。知和曰常。知常曰明。益生曰祥。心使气曰强。物壮则老。谓之不道，不道早已。</p>
<p>56.知者不言。言者不知。挫其锐，解其纷，和其光，同其尘，是谓玄同。故不可得而亲。不可得而疏。不可得而利。不可得而害。不可得而贵。不可得而贱。故为天下贵。</p>
<p>57.以正治国，以奇用兵，以无事取天下。吾何以知其然哉？以此。天下多忌讳而民弥贫。民多利器国家滋昏。人多伎巧奇物泫起。法令滋彰盗贼多有。故圣人云我无为而民自化。我好静而民自正。我无事而民自富。我无欲而民自朴。</p>
<p>58.其政闷闷，其民淳淳。其政察察，其民缺缺。祸尚福之所倚。福尚祸之所伏。孰知其极，其无正。正复为奇，善复为妖。人之迷其日固久。是以圣人方而不割。廉而不刿。直而不肆。光而不耀。</p>
<p>59.治人事天莫若啬。夫唯啬是谓早服。早服谓之重积德。重积德则无不克。无不克则莫知其极。莫知其极可以有国。有国之母可以长久。是谓深根固柢，长生久视之道。</p>
<p>60.治大国若烹小鲜。以道莅天下，其迨ㄞ哄非其鬼不神，其神不伤人。非其神不伤人，圣人亦不伤人。夫两不相伤，故德交归焉。</p>
<p>61.大国者下流，天下之交。天下之牝。牝常以静胜牡。以静为下。故大国以下小国，则取小国。小国以下大国，则取大国。故或下以取，或下而取。大国不过欲兼畜人。小国不过欲入事人。夫两者各得所欲，大者宜为下。</p>
<p>62.道者万物之奥。善人之宝，不善人之所保。美言可以市尊。美行可以加人。人之不善，何弃之有。故立天子、置三公，虽有拱璧以先驷马，不如坐进此道。古之所以贵此道者何。不曰∶求以得，有罪以免邪？故为天下贵。</p>
<p>63.为无为，事无事，味无味。大小多少，报怨以德。图难於其易，为大於其细。天下难事必作於易。天下大事必作於细。是以圣人终不为大，故能成其大。夫轻诺必寡信。多易必多难。是以圣人犹难之，故终无难矣。</p>
<p>64.其安易持，其未兆易谋。其脆易泮，其微易散。为之於未有，治之於未乱。合抱之木生於毫末。九层之台起於累土。千里之行始於足下。为者败之，执者失之。是以圣人无为故无败，无执故无失。民之从事常於几成而败之。慎终如始则无败事。是以圣人欲不欲，不贵难得之货。学不学，复众人之所过，以辅万物之自然而不敢为。</p>
<p>65.古之善为道者，非以明民，将以愚之。民之难治，以其智多。故以智治国，国之贼。不以智治国，国之福。知此两者，亦稽式。常知稽式，是谓玄德。玄德深矣、远矣！与物反矣。然後乃至大顺。</p>
<p>66.江海之所以能为百谷王者，以其善下之，故能为百谷王。是以圣人欲上民，必以言下之。欲先民，必以身後之。是以圣人处上而民不重，处前而民不害。是以天下乐推而不厌。以其不争，故天下莫能与之争。</p>
<p>67.天下皆谓我道大似不肖。夫唯大故似不肖。若肖，久矣！其细也夫。我有三宝持而保之∶一曰慈， 二曰俭，三曰不敢为天下先。慈故能勇，俭故能广，不敢为天下先故能成器长。今舍慈且勇，舍俭且广，舍後且先，死矣！夫慈以战则胜，以守则固。天将救之以慈卫之。</p>
<p>68.善为士者不武。善战者不怒。善胜敌者不与。善用人者为之下。是谓不争之德。是谓用人之力。是谓配天之极。</p>
<p>69.用兵有言，吾不敢为主而为客。不敢进寸而退尺。是谓行无行。攘无臂。扔无敌。执无兵。祸莫大於轻敌。轻敌几丧吾宝。故抗兵相加哀者胜矣。</p>
<p>70.吾言甚易知、甚易行。天下莫能知、莫能行。言有宗、事有君。夫唯无知，是以我不知。知我者希，则我者贵。是以圣被褐怀玉。</p>
<p>71.知不知上，不知知病。夫唯病病，是以不病。圣人不病，以其病病。夫唯病病，是以不病。</p>
<p>72.民不畏威，则大威至。无狎其所居，无厌其所生。夫唯不厌，是以不厌。是以圣人自知不自见。自爱不自贵。故去彼取此。</p>
<p>73.勇於敢则杀。勇於不敢则活。此两者或利或害。天之所恶孰知其故。天之道不争而善胜。不言而善应。不召而自来。繟(chǎn,舒缓)然而善谋。天网恢恢疏而不失。</p>
<p>74.民不畏死，奈何以死惧之。若使民常畏死，而为奇者，吾得执而杀之，孰敢。常有司杀者杀。夫代司杀者杀，是谓代大匠斫。夫代大匠斫者，希有不伤其手矣。</p>
<p>75.民之饥以其上食税之多，是以饥。民之难治以其上之有为，是以难治。民之轻死以其求生之厚，是以轻死。夫唯无以生为者，是贤於贵生。</p>
<p>76.人之生也柔弱，其死也坚强。草木之生也柔脆，其死也枯槁。故坚强者死之徒，柔弱者生之徒。是以兵强则灭，木强则折。强大处下，柔弱处上。</p>
<p>77.天之道其犹张弓与。高者抑之，下者举之。有馀者损之，不足者补之。天之道，损有馀而补不足。人之道，则不然，损不足以奉有馀。孰能有馀以奉天下，唯有道者。是以圣人为而不恃，功成而不处。其不欲见贤邪！</p>
<p>78.天下莫柔弱於水。而攻坚强者，莫之能胜。以其无以易之。弱之胜强。柔之胜刚。天下莫不知莫能行。是以圣人云，受国之垢是谓社稷主。受国不祥是为天下王。正言若反。</p>
<p>79.和大怨必有馀怨，安可以为善。是以圣人执左契，而不责於人。有德司契，无德司彻。天道无亲常与善人。</p>
<p>80.小国寡民。使有什伯之器而不用。使民重死而不远徙。虽有舟舆无所乘之。虽有甲兵无所陈之。使民复结绳而用之。甘其食、美其服、安其居、乐其俗。邻国相望，鸡犬之声相闻。民至老死不相往来。</p>
<p>81.信言不美。美言不信。善者不辩。辩者不善。知者不博。博者不知。圣人不积。既以为人己愈有。既以与人己愈多。天之道利而不害。圣人之道为而不争。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
</search>
