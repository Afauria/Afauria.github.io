<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>知识体系构建中......</title>
    <url>/2021/04/04/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<center><a href="https://blog.afauria.xyz/KnowledgeTree/" style="font-size:30px">点此进入</a></center>

]]></content>
  </entry>
  <entry>
    <title>Flutter构建流程分析</title>
    <url>/2022/01/12/flutter-2022-01-12-Flutter%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Flutter构建流程"><a href="#Flutter构建流程" class="headerlink" title="Flutter构建流程"></a>Flutter构建流程</h1><h2 id="构建模式"><a href="#构建模式" class="headerlink" title="构建模式"></a>构建模式</h2><ul>
<li>Debug模式下，Flutter应用在VM上运行，能够保存应用状态，提供热重载能力。支持断点，调试信息等。</li>
<li>Release模式下，Flutter会使用<code>gen_snapshot</code>将应用代码预编译成目标平台的机器代码，针对web平台，会编译成JavaScript代码。进行了编译优化、压缩等。</li>
<li>Profile模式下，与Release类似，会进行预编译，进行了一些优化，使性能更接近Release模式，同时也支持调试和跟踪。模拟器上无法使用该模式</li>
</ul>
<blockquote>
<p><code>flutter run</code>命令默认为debug模式，<code>flutter build</code>命令默认为release模式。构建时可以指定<code>--debug</code>、<code>--release</code>、<code>--profile</code>选项</p>
</blockquote>
<h2 id="Flutter项目构建源码分析"><a href="#Flutter项目构建源码分析" class="headerlink" title="Flutter项目构建源码分析"></a>Flutter项目构建源码分析</h2><p>以<code>flutter build apk</code>为例，分析apk构建执行过程。目的如下：</p>
<ol>
<li>便于分析定位构建错误，一般报错之后可以在<code>flutter_tools</code>中搜索关键字，找到报错的地方，分析代码上下文。</li>
<li>可以修改<code>flutter_tools</code>流程，定制构建命令</li>
<li>了解Flutter代码的编译，如何生成产物然后合并打包</li>
</ol>
<h3 id="Flutter命令脚本"><a href="#Flutter命令脚本" class="headerlink" title="Flutter命令脚本"></a>Flutter命令脚本</h3><p>查看<code>&#123;flutter_sdk&#125;/bin/flutter</code>脚本，内部会调用<code>shared.sh</code>脚本的execute方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source &quot;$BIN_DIR/internal/shared.sh&quot;</span><br><span class="line">shared::execute &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<p>查看<code>shared.sh</code>脚本，最终会执行dart命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;$DART&quot; --disable-dart-dev --packages=&quot;$FLUTTER_TOOLS_DIR/.packages&quot; $FLUTTER_TOOL_ARGS &quot;$SNAPSHOT_PATH&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>$DART：Dart可执行文件，用于启动Dart虚拟机。对应<code>&#123;flutter_sdk&#125;/bin/cache/dart-sdk/bin/dart</code></li>
<li>$FLUTTER_TOOLS_DIR：<code>flutter_tools</code>项目路径，对应<code>&#123;flutter_sdk&#125;/packages/flutter_tools</code></li>
<li>$SNAPSHOT_PATH：<code>flutter_tools</code>项目的snapshot文件，包含编译过的kernel中间代码，可以被Dart虚拟机执行，对应<code>&#123;flutter_sdk&#125;/bin/cache/flutter_tools.snapshot</code></li>
<li>$FLUTTER_TOOL_ARGS：用于调试Flutter SDK，一般情况为空。可以开启断言和调试端口。</li>
<li>$@：输入的参数</li>
</ul>
<p>因此实际的命令即：<code>flutter/bin/cache/dart-sdk/bin/dart flutter/bin/cache/flutter_tools.snapshot build apk</code></p>
<blockquote>
<p>类似java执行jar文件：<code>java -jar main.jar</code>，jar运行在java环境，snapshot运行在dart环境。</p>
</blockquote>
<h3 id="flutter-tools流程"><a href="#flutter-tools流程" class="headerlink" title="flutter_tools流程"></a>flutter_tools流程</h3><p><code>flutter_tools.snapshot</code>类似jar文件，也有对应的main函数入口，位于<code>flutter/packages/flutter_tools/lib/executable.dart</code>中，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_tools/executable.dart&#x27;</span> <span class="keyword">as</span> executable;</span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  executable.main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>executable.dart</code>源码：<code>runner.run</code>比较复杂，我们只需要知道<code>flutter build</code>命令会匹配到<code>BuildCommand</code>类即可</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">await</span> runner.run(</span><br><span class="line">    args,</span><br><span class="line">    () =&gt; generateCommands(</span><br><span class="line">      verboseHelp: verboseHelp,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;FlutterCommand&gt; generateCommands(&#123;</span><br><span class="line">  <span class="meta">@required</span> <span class="built_in">bool</span> verboseHelp,</span><br><span class="line">  <span class="meta">@required</span> <span class="built_in">bool</span> verbose,</span><br><span class="line">&#125;) =&gt; &lt;FlutterCommand&gt;[</span><br><span class="line">  <span class="comment">//省略其他命令...</span></span><br><span class="line">  BuildCommand(verboseHelp: verboseHelp),</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看<code>runner.run</code>源码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; run(</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args,</span><br><span class="line">  <span class="built_in">List</span>&lt;FlutterCommand&gt; <span class="built_in">Function</span>() commands) <span class="keyword">async</span> &#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">  <span class="keyword">return</span> runInContext&lt;<span class="built_in">int</span>&gt;(() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> FlutterCommandRunner runner = FlutterCommandRunner(verboseHelp: verboseHelp);</span><br><span class="line">    commands().forEach(runner.addCommand); <span class="comment">//将所有Flutter命令存入map中</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> runZoned&lt;Future&lt;<span class="built_in">int</span>&gt;&gt;(() <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> runner.run(args); <span class="comment">//FlutterCommandRunner根据参数找到对应的Command执行</span></span><br><span class="line">  &#125;, overrides: overrides);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FlutterCommandRunner</code>会调用父类<code>CommandRunner</code>的run方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandRunner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  Future&lt;T?&gt; run(<span class="built_in">Iterable</span>&lt;<span class="built_in">String</span>&gt; args) =&gt; Future.<span class="keyword">sync</span>(() =&gt; runCommand(parse(args)));</span><br><span class="line">  </span><br><span class="line">  Future&lt;T?&gt; runCommand(ArgResults topLevelResults) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> argResults = topLevelResults;</span><br><span class="line">    <span class="keyword">var</span> commands = _commands; <span class="comment">//Flutter命令</span></span><br><span class="line">    Command? command;</span><br><span class="line">    <span class="keyword">var</span> commandString = executableName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (commands.isNotEmpty) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">// Step into the command.</span></span><br><span class="line">      argResults = argResults.command!;</span><br><span class="line">      command = commands[argResults.name]!; <span class="comment">//遍历参数找到对应的命令类和子命令类，先找到BuildCommand类</span></span><br><span class="line">      command._globalResults = topLevelResults;</span><br><span class="line">      command._argResults = argResults;</span><br><span class="line">      commands = command._subcommands <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Command&lt;T&gt;&gt;; <span class="comment">//找到BuildCommand支持的子命令，下一次循环根据参数匹配子命令</span></span><br><span class="line">      commandString += <span class="string">&#x27; <span class="subst">$&#123;argResults.name&#125;</span>&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">await</span> command.run()) <span class="keyword">as</span> T?; <span class="comment">//执行最终匹配到的Command类的run方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先找到<code>BuildCommand类</code>：其中包含多个子命令，如下，<code>flutter build apk</code>命令最终会匹配到<code>BuildApkCommand</code>类，然后调用run方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildCommand</span> <span class="keyword">extends</span> <span class="title">FlutterCommand</span> </span>&#123;</span><br><span class="line">  BuildCommand(&#123; <span class="built_in">bool</span> verboseHelp = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    _addSubcommand(BuildAarCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildApkCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildAppBundleCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildIOSCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildIOSFrameworkCommand(</span><br><span class="line">      buildSystem: globals.buildSystem,</span><br><span class="line">      verboseHelp: verboseHelp,</span><br><span class="line">    ));</span><br><span class="line">    _addSubcommand(BuildIOSArchiveCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildBundleCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildWebCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildMacosCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildLinuxCommand(</span><br><span class="line">      operatingSystemUtils: globals.os,</span><br><span class="line">      verboseHelp: verboseHelp</span><br><span class="line">    ));</span><br><span class="line">    _addSubcommand(BuildWindowsCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildWindowsUwpCommand(verboseHelp: verboseHelp));</span><br><span class="line">    _addSubcommand(BuildFuchsiaCommand(verboseHelp: verboseHelp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XXCommand继承自FlutterCommand类，调用FlutterCommand父类的run方法，如下：<code>verifyThenRunCommand</code>验证命令并调用runCommand方法。注释中说明了让子类重写<code>runCommand</code>来执行命令。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterCommand</span> <span class="keyword">extends</span> <span class="title">Command</span>&lt;<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Rather than overriding this method, subclasses should override</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[verifyThenRunCommand] to perform any verification</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">and [runCommand] to execute the command</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">so that this method can record and report the overall time to analytics.</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; run() &#123;</span><br><span class="line">    <span class="keyword">return</span> context.run&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">      name: <span class="string">&#x27;command&#x27;</span>,</span><br><span class="line">      overrides: &lt;<span class="built_in">Type</span>, Generator&gt;&#123;FlutterCommand: () =&gt; <span class="keyword">this</span>&#125;,</span><br><span class="line">      body: () <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          commandResult = <span class="keyword">await</span> verifyThenRunCommand(commandPath); <span class="comment">//验证命令并调用runCommand方法</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>BuildApkCommand</code>的<code>runCommand</code>方法：通过<code>androidBuilder.buildApk</code>执行构建，<code>AndroidBuilder</code>从<code>context.get&lt;AndroidBuilder&gt;()</code>中获取，使用箭头函数，在调用的时候才会创建对象实现了懒加载。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildApkCommand</span> <span class="keyword">extends</span> <span class="title">BuildSubCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;FlutterCommandResult&gt; runCommand() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (globals.androidSdk == <span class="keyword">null</span>) &#123;</span><br><span class="line">      exitWithNoSdkMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> BuildInfo buildInfo = <span class="keyword">await</span> getBuildInfo();</span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">final</span> AndroidBuildInfo androidBuildInfo = AndroidBuildInfo(</span><br><span class="line">      buildInfo,</span><br><span class="line">      splitPerAbi: boolArg(<span class="string">&#x27;split-per-abi&#x27;</span>),</span><br><span class="line">      targetArchs: stringsArg(<span class="string">&#x27;target-platform&#x27;</span>).map&lt;AndroidArch&gt;(getAndroidArchForName),</span><br><span class="line">    );</span><br><span class="line">    validateBuild(androidBuildInfo);</span><br><span class="line">    displayNullSafetyMode(androidBuildInfo.buildInfo);</span><br><span class="line">    <span class="keyword">await</span> androidBuilder.buildApk(</span><br><span class="line">      project: FlutterProject.current(),</span><br><span class="line">      target: targetFile,</span><br><span class="line">      androidBuildInfo: androidBuildInfo,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> FlutterCommandResult.success();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会调用<code>AndroidGradleBuilder</code>的<code>buildGradleApp</code>方法，内部就是拼接<code>gradle</code>命令，指定不同的参数，然后执行。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;project_path&#125;/gradlew -q -Ptarget=lib/main.dart -Ptrack-widget-creation=<span class="literal">false</span> -Ptarget-platform=android-arm  -Psplit-per-abi=<span class="literal">true</span> assembleRelease</span><br></pre></td></tr></table></figure>

<h3 id="flutter-gradle"><a href="#flutter-gradle" class="headerlink" title="flutter.gradle"></a>flutter.gradle</h3><p>Android本身的代码构建基本没什么疑问，这里主要关心Flutter项目中的dart代码如何构建打包成so的。</p>
<p>查看<code>build.gradle</code>文件，主要是引入了<code>flutter.gradle</code>，位于<code>flutter_tools</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply from: &quot;$flutterRoot&#x2F;packages&#x2F;flutter_tools&#x2F;gradle&#x2F;flutter.gradle&quot;</span><br></pre></td></tr></table></figure>

<p><code>flutter.gradle</code>自定义了gradle插件，解析gradle命令参数，并添加自定义task完成flutter项目的构建和打包。分析几段关键代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">    <span class="comment">//添加自定义task</span></span><br><span class="line">    <span class="built_in">this</span>.addFlutterTasks(project)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//so分包构建，否则会将多个架构的so打包到一个apk中</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSplitPerAbi()) &#123;</span><br><span class="line">      project.android &#123;</span><br><span class="line">        splits &#123;</span><br><span class="line">          abi &#123;</span><br><span class="line">            <span class="comment">// Enables building multiple APKs per ABI.</span></span><br><span class="line">            enable <span class="literal">true</span></span><br><span class="line">            <span class="comment">// Resets the list of ABIs that Gradle should create APKs for to none.</span></span><br><span class="line">            reset()</span><br><span class="line">            <span class="comment">// Specifies that we do not want to also generate a universal APK that includes all ABIs.</span></span><br><span class="line">            universalApk <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析target-platform参数，指定编译目标平台的so</span></span><br><span class="line">    getTargetPlatforms().each &#123; targetArch -&gt;</span><br><span class="line">      String abiValue = PLATFORM_ARCH_MAP[targetArch]</span><br><span class="line">      project.android &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldSplitPerAbi()) &#123;</span><br><span class="line">          splits &#123;</span><br><span class="line">            abi &#123;</span><br><span class="line">              include abiValue</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加引擎库：io.flutter:xxx，即libflutter.so</span></span><br><span class="line">    <span class="comment">//添加嵌入层库：io.flutter:flutter_embedding_xxx，即FlutterActivity、FlutterView等</span></span><br><span class="line">    project.android.buildTypes.all <span class="built_in">this</span>.&amp;addFlutterDependencies</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>addFlutterTask</code>方法：主要是添加compileTask用于编译Flutter，生成so库。再通过其他Task对产物进行重命名、移动、合并，最终打包出apk</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> addFlutterTasks(Project project) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">def</span> targetPlatforms = getTargetPlatforms()</span><br><span class="line">    <span class="keyword">def</span> addFlutterDeps = &#123; variant -&gt;</span><br><span class="line">      </span><br><span class="line">      String taskName = toCammelCase([<span class="string">&quot;compile&quot;</span>, FLUTTER_BUILD_PREFIX, variant.name])</span><br><span class="line">      FlutterTask compileTask = project.tasks.create(<span class="attr">name:</span> taskName, <span class="attr">type:</span> FlutterTask) &#123;</span><br><span class="line">        <span class="comment">//创建Flutter编译Task：如compileFlutterRelease，编译Flutter代码</span></span><br><span class="line">      &#125;</span><br><span class="line">      File libJar = project.file(<span class="string">&quot;$&#123;project.buildDir&#125;/$&#123;AndroidProject.FD_INTERMEDIATES&#125;/flutter/$&#123;variant.name&#125;/libs.jar&quot;</span>)</span><br><span class="line">      <span class="comment">//创建Flutter打包Task，并dependsOn等待编译Task执行完成</span></span><br><span class="line">      Task packFlutterAppAotTask = project.tasks.create(<span class="attr">name:</span> <span class="string">&quot;packLibs$&#123;FLUTTER_BUILD_PREFIX&#125;$&#123;variant.name.capitalize()&#125;&quot;</span>, <span class="attr">type:</span> Jar) &#123;</span><br><span class="line">        destinationDir libJar.parentFile</span><br><span class="line">        archiveName libJar.name <span class="comment">//打包到/build/intermediates/flutter/debug/libs.jar中</span></span><br><span class="line">        dependsOn compileTask</span><br><span class="line">        targetPlatforms.each &#123; targetPlatform -&gt;</span><br><span class="line">          String abi = PLATFORM_ARCH_MAP[targetPlatform]</span><br><span class="line">          from(<span class="string">&quot;$&#123;compileTask.intermediateDir&#125;/$&#123;abi&#125;&quot;</span>) &#123;</span><br><span class="line">            include <span class="string">&quot;*.so&quot;</span></span><br><span class="line">            <span class="comment">// Move `app.so` to `lib/&lt;abi&gt;/libapp.so`</span></span><br><span class="line">            <span class="comment">//Flutter项目代码最终会转换成目标平台的libapp.so文件，将so文件打包到libs.jar中</span></span><br><span class="line">            rename &#123; String filename -&gt;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;lib/$&#123;abi&#125;/lib$&#123;filename&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将Flutter项目编译打包好的libs.jar包添加到项目依赖中</span></span><br><span class="line">      addApiDependencies(project, variant.name, project.files &#123;</span><br><span class="line">        packFlutterAppAotTask</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//这里定义了三个Task：packageAssets、cleanPackageAssets、copyFlutterAssets，将Flutter产物移到/build/app/intermediates/merged_assets/release/out目录下</span></span><br><span class="line">      Task packageAssets = project.tasks.findByPath(<span class="string">&quot;:flutter:package$&#123;variant.name.capitalize()&#125;Assets&quot;</span>)</span><br><span class="line">      Task cleanPackageAssets = project.tasks.findByPath(<span class="string">&quot;:flutter:cleanPackage$&#123;variant.name.capitalize()&#125;Assets&quot;</span>)</span><br><span class="line">      Task copyFlutterAssetsTask = project.tasks.create(</span><br><span class="line">        <span class="symbol">name:</span> <span class="string">&quot;copyFlutterAssets$&#123;variant.name.capitalize()&#125;&quot;</span>,</span><br><span class="line">        <span class="symbol">type:</span> Copy,</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> copyFlutterAssetsTask</span><br><span class="line">    &#125; <span class="comment">// end def addFlutterDeps</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFlutterAppProject()) &#123;</span><br><span class="line">      project.android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        Task assembleTask = getAssembleTask(variant)</span><br><span class="line">        <span class="keyword">if</span> (!shouldConfigureFlutterTask(assembleTask)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        Task copyFlutterAssetsTask = addFlutterDeps(variant)</span><br><span class="line">        <span class="keyword">def</span> variantOutput = variant.outputs.first()</span><br><span class="line">        <span class="keyword">def</span> processResources = variantOutput.hasProperty(<span class="string">&quot;processResourcesProvider&quot;</span>) ?</span><br><span class="line">          variantOutput.processResourcesProvider.get() : variantOutput.processResources</span><br><span class="line">        <span class="comment">//先编译生成Flutter产物，将Flutter任务加到Android构建流程中</span></span><br><span class="line">        processResources.dependsOn(copyFlutterAssetsTask)</span><br><span class="line"></span><br><span class="line">        variant.outputs.all &#123; output -&gt;</span><br><span class="line">          assembleTask.doLast &#123; <span class="comment">//将生成的apk拷贝到对应路径，并重命名：app&lt;-abi&gt;?&lt;-flavor-name&gt;?-&lt;build-mode&gt;.apk</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      configurePlugins()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...其他模块编译类似</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>FlutterTask</code>源码如何编译Flutter代码生成so：调用<code>flutter assemble</code>命令编译flutter资源</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterTask</span> <span class="keyword">extends</span> <span class="title">BaseFlutterTask</span> &#123;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="meta">@TaskAction</span></span><br><span class="line">  <span class="keyword">void</span> build() &#123;</span><br><span class="line">    <span class="comment">//调用父类方法</span></span><br><span class="line">    buildBundle()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFlutterTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> buildBundle() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sourceDir.isDirectory()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;Invalid Flutter source directory: $&#123;sourceDir&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intermediateDir.mkdirs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the rule name for flutter assemble. To speed up builds that contain</span></span><br><span class="line">    <span class="comment">// multiple ABIs, the target name is used to communicate which ones are required</span></span><br><span class="line">    <span class="comment">// rather than the TargetPlatform. This allows multiple builds to share the same</span></span><br><span class="line">    <span class="comment">// cache.</span></span><br><span class="line">    <span class="comment">//根据ruleNames找到对应的编译目标</span></span><br><span class="line">    String[] ruleNames;</span><br><span class="line">    <span class="keyword">if</span> (buildMode == <span class="string">&quot;debug&quot;</span>) &#123;</span><br><span class="line">      ruleNames = [<span class="string">&quot;debug_android_application&quot;</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deferredComponents) &#123;</span><br><span class="line">      ruleNames = targetPlatformValues.collect &#123; <span class="string">&quot;android_aot_deferred_components_bundle_$&#123;buildMode&#125;_$it&quot;</span> &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ruleNames = targetPlatformValues.collect &#123; <span class="string">&quot;android_aot_bundle_$&#123;buildMode&#125;_$it&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    project.exec &#123; <span class="comment">//执行命令flutter assemble命令，加上各种参数，旧版本使用的可能是flutter build aot/bundle命令</span></span><br><span class="line">      logging.captureStandardError LogLevel.ERROR</span><br><span class="line">      executable flutterExecutable.absolutePath</span><br><span class="line">      workingDir sourceDir</span><br><span class="line">      <span class="keyword">if</span> (localEngine != <span class="literal">null</span>) &#123;</span><br><span class="line">        args <span class="string">&quot;--local-engine&quot;</span>, localEngine</span><br><span class="line">        args <span class="string">&quot;--local-engine-src-path&quot;</span>, localEngineSrcPath</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        args <span class="string">&quot;--verbose&quot;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        args <span class="string">&quot;--quiet&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      args <span class="string">&quot;assemble&quot;</span></span><br><span class="line">      args <span class="string">&quot;--no-version-check&quot;</span></span><br><span class="line">      args <span class="string">&quot;--depfile&quot;</span>, <span class="string">&quot;$&#123;intermediateDir&#125;/flutter_build.d&quot;</span></span><br><span class="line">      args <span class="string">&quot;--output&quot;</span>, <span class="string">&quot;$&#123;intermediateDir&#125;&quot;</span></span><br><span class="line">      <span class="comment">//省略其他参数...</span></span><br><span class="line">      args ruleNames</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Deferred Component延迟组件：可以在运行时下载Dart代码编译，减少包大小。目前只在Android上可用，利用Android和Google Play商店的动态功能模块实现延迟加载。</p>
<p>参考<a href="https://flutter.cn/docs/perf/deferred-components">Flutter延迟加载组件</a></p>
</blockquote>
<h3 id="flutter-assemble编译"><a href="#flutter-assemble编译" class="headerlink" title="flutter assemble编译"></a>flutter assemble编译</h3><p>有了上面flutter命令执行经验，直接找到<code>AssembleCommand</code>类的<code>runCommand</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssembleCommand</span> <span class="keyword">extends</span> <span class="title">FlutterCommand</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;FlutterCommandResult&gt; runCommand() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Target&gt; targets = createTargets(); <span class="comment">//根据ruleNames创建编译目标</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Target&gt; nonDeferredTargets = &lt;Target&gt;[];</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Target&gt; deferredTargets = &lt;AndroidAotDeferredComponentsBundle&gt;[]; <span class="comment">//延迟组件</span></span><br><span class="line">    Target target;</span><br><span class="line">    <span class="comment">//省略deferredComponents目标判断...</span></span><br><span class="line">    <span class="comment">//调用buildSystem.build方法对target进行编译</span></span><br><span class="line">    <span class="keyword">final</span> BuildResult result = <span class="keyword">await</span> _buildSystem.build(</span><br><span class="line">      target,</span><br><span class="line">      environment,</span><br><span class="line">      buildSystemConfig: BuildSystemConfig(</span><br><span class="line">        resourcePoolSize: argResults.wasParsed(<span class="string">&#x27;resource-pool-size&#x27;</span>)</span><br><span class="line">          ? <span class="built_in">int</span>.tryParse(stringArg(<span class="string">&#x27;resource-pool-size&#x27;</span>))</span><br><span class="line">          : <span class="keyword">null</span>,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> FlutterCommandResult.success();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建编译目标</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Target&gt; createTargets() &#123;</span><br><span class="line">    <span class="keyword">if</span> (argResults.rest.isEmpty) &#123;</span><br><span class="line">      throwToolExit(<span class="string">&#x27;missing target name for flutter assemble.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> name = argResults.rest.first;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Target&gt; targetMap = &lt;<span class="built_in">String</span>, Target&gt;&#123; <span class="comment">//_kDefaultTargets预定义了一堆默认编译目标，存到map中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> Target target <span class="keyword">in</span> _kDefaultTargets)</span><br><span class="line">        target.name: target <span class="comment">//目标名作为key</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Target&gt; results = &lt;Target&gt;[</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="built_in">String</span> targetName <span class="keyword">in</span> argResults.rest)</span><br><span class="line">        <span class="comment">//根据rest参数（除了options和flags之外的参数），从map中获取编译目标对象</span></span><br><span class="line">        <span class="comment">//此处的rest即上文中的ruleNames，可以是一个数组，如：[android_aot_bundle_$&#123;buildMode&#125;_$it]，$it指目标平台</span></span><br><span class="line">        <span class="keyword">if</span> (targetMap.containsKey(targetName))</span><br><span class="line">          targetMap[targetName]</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">if</span> (results.isEmpty) &#123;</span><br><span class="line">      throwToolExit(<span class="string">&#x27;No target named &quot;<span class="subst">$name</span>&quot; defined.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FlutterBuildSystem</code>继承自<code>BuildSystem</code>，源码较长，简单来说就是将编译目标Target和其依赖的编译目标，组成一个个编译节点，依次调用Target的build方法。默认的编译目标如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译目标之间可以有依赖关系</span></span><br><span class="line"><span class="built_in">List</span>&lt;Target&gt; _kDefaultTargets = &lt;Target&gt;[</span><br><span class="line">  <span class="comment">// Shared targets</span></span><br><span class="line">  <span class="keyword">const</span> CopyAssets(),</span><br><span class="line">  <span class="keyword">const</span> KernelSnapshot(), <span class="comment">//生成kernel文件，即app.dill</span></span><br><span class="line">  <span class="keyword">const</span> AotElfProfile(TargetPlatform.android_arm),</span><br><span class="line">  <span class="keyword">const</span> AotElfRelease(TargetPlatform.android_arm), <span class="comment">//将dart kernel生成elf文件</span></span><br><span class="line">  <span class="keyword">const</span> AotAssemblyProfile(), <span class="comment">//将dart kernel生成汇编文件</span></span><br><span class="line">  <span class="keyword">const</span> AotAssemblyRelease(),</span><br><span class="line">  <span class="comment">// macOS targets</span></span><br><span class="line">  <span class="keyword">const</span> DebugMacOSFramework(),</span><br><span class="line">  <span class="keyword">const</span> DebugMacOSBundleFlutterAssets(),</span><br><span class="line">  <span class="keyword">const</span> ProfileMacOSBundleFlutterAssets(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseMacOSBundleFlutterAssets(),</span><br><span class="line">  <span class="comment">// Linux targets</span></span><br><span class="line">  <span class="keyword">const</span> DebugBundleLinuxAssets(TargetPlatform.linux_x64),</span><br><span class="line">  <span class="keyword">const</span> DebugBundleLinuxAssets(TargetPlatform.linux_arm64),</span><br><span class="line">  <span class="keyword">const</span> ProfileBundleLinuxAssets(TargetPlatform.linux_x64),</span><br><span class="line">  <span class="keyword">const</span> ProfileBundleLinuxAssets(TargetPlatform.linux_arm64),</span><br><span class="line">  <span class="keyword">const</span> ReleaseBundleLinuxAssets(TargetPlatform.linux_x64),</span><br><span class="line">  <span class="keyword">const</span> ReleaseBundleLinuxAssets(TargetPlatform.linux_arm64),</span><br><span class="line">  <span class="comment">// Web targets</span></span><br><span class="line">  <span class="keyword">const</span> WebServiceWorker(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseAndroidApplication(),</span><br><span class="line">  <span class="comment">// This is a one-off rule for bundle and aot compat.</span></span><br><span class="line">  <span class="keyword">const</span> CopyFlutterBundle(),</span><br><span class="line">  <span class="comment">// Android targets,</span></span><br><span class="line">  <span class="keyword">const</span> DebugAndroidApplication(),</span><br><span class="line">  <span class="keyword">const</span> ProfileAndroidApplication(),</span><br><span class="line">  <span class="comment">// Android ABI specific AOT rules.</span></span><br><span class="line">  androidArmProfileBundle,</span><br><span class="line">  androidArm64ProfileBundle,</span><br><span class="line">  androidx64ProfileBundle,</span><br><span class="line">  androidArmReleaseBundle,</span><br><span class="line">  androidArm64ReleaseBundle,</span><br><span class="line">  androidx64ReleaseBundle,</span><br><span class="line">  <span class="comment">// Deferred component enabled AOT rules</span></span><br><span class="line">  androidArmProfileDeferredComponentsBundle,</span><br><span class="line">  androidArm64ProfileDeferredComponentsBundle,</span><br><span class="line">  androidx64ProfileDeferredComponentsBundle,</span><br><span class="line">  androidArmReleaseDeferredComponentsBundle,</span><br><span class="line">  androidArm64ReleaseDeferredComponentsBundle,</span><br><span class="line">  androidx64ReleaseDeferredComponentsBundle,</span><br><span class="line">  <span class="comment">// iOS targets</span></span><br><span class="line">  <span class="keyword">const</span> DebugIosApplicationBundle(),</span><br><span class="line">  <span class="keyword">const</span> ProfileIosApplicationBundle(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseIosApplicationBundle(),</span><br><span class="line">  <span class="comment">// Windows targets</span></span><br><span class="line">  <span class="keyword">const</span> UnpackWindows(),</span><br><span class="line">  <span class="keyword">const</span> DebugBundleWindowsAssets(),</span><br><span class="line">  <span class="keyword">const</span> ProfileBundleWindowsAssets(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseBundleWindowsAssets(),</span><br><span class="line">  <span class="comment">// Windows UWP targets</span></span><br><span class="line">  <span class="keyword">const</span> DebugBundleWindowsAssetsUwp(),</span><br><span class="line">  <span class="keyword">const</span> ProfileBundleWindowsAssetsUwp(),</span><br><span class="line">  <span class="keyword">const</span> ReleaseBundleWindowsAssetsUwp(),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>挑一个<code>androidArmReleaseBundle</code>编译目标的源码：依赖<code>androidArmRelease</code>编译目标生成<code>.so</code>文件，依赖<code>AotAndroidAssetBundle</code>生成<code>flutter_assets</code>文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AndroidAotBundle androidArmReleaseBundle = AndroidAotBundle(androidArmRelease); <span class="comment">//依赖androidArmRelease</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidAotBundle</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Create an [AndroidAotBundle] implementation for a given [targetPlatform] and [buildMode].</span></span></span><br><span class="line">  <span class="keyword">const</span> AndroidAotBundle(<span class="keyword">this</span>.dependency);</span><br><span class="line">  <span class="comment">//ruleNames匹配的名称</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; <span class="string">&#x27;android_aot_bundle_<span class="subst">$&#123;getNameForBuildMode(dependency.buildMode)&#125;</span>_&#x27;</span></span><br><span class="line">    <span class="string">&#x27;<span class="subst">$&#123;getNameForTargetPlatform(dependency.targetPlatform)&#125;</span>&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Source&gt; <span class="keyword">get</span> inputs =&gt; &lt;Source&gt;[</span><br><span class="line">    Source.pattern(<span class="string">&#x27;&#123;BUILD_DIR&#125;/<span class="subst">$_androidAbiName</span>/app.so&#x27;</span>),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可以看出AndroidAotBundle只是将app.so移动打包而已</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Source&gt; <span class="keyword">get</span> outputs =&gt; &lt;Source&gt;[</span><br><span class="line">    Source.pattern(<span class="string">&#x27;&#123;OUTPUT_DIR&#125;/<span class="subst">$_androidAbiName</span>/app.so&#x27;</span>),</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//依赖androidArmRelease和AotAndroidAssetBundle编译目标</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Target&gt; <span class="keyword">get</span> dependencies =&gt; &lt;Target&gt;[</span><br><span class="line">    dependency,</span><br><span class="line">    <span class="keyword">const</span> AotAndroidAssetBundle(),</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>AotAndroidAssetBundle</code>目标：<code>copyAssets</code>中生成Flutter静态资源并拷贝，如果是Debug模式，还会拷贝JIT快照文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidAssetBundle</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; build(Environment environment) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> Directory outputDirectory = environment.outputDir</span><br><span class="line">      .childDirectory(<span class="string">&#x27;flutter_assets&#x27;</span>)</span><br><span class="line">      ..createSync(recursive: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only copy the prebuilt runtimes and kernel blob in debug mode.</span></span><br><span class="line">    <span class="keyword">if</span> (buildMode == BuildMode.debug) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">String</span> vmSnapshotData = environment.artifacts.getArtifactPath(Artifact.vmSnapshotData, mode: BuildMode.debug);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">String</span> isolateSnapshotData = environment.artifacts.getArtifactPath(Artifact.isolateSnapshotData, mode: BuildMode.debug);</span><br><span class="line">      environment.buildDir.childFile(<span class="string">&#x27;app.dill&#x27;</span>)</span><br><span class="line">          .copySync(outputDirectory.childFile(<span class="string">&#x27;kernel_blob.bin&#x27;</span>).path);</span><br><span class="line">      environment.fileSystem.file(vmSnapshotData)</span><br><span class="line">          .copySync(outputDirectory.childFile(<span class="string">&#x27;vm_snapshot_data&#x27;</span>).path);</span><br><span class="line">      environment.fileSystem.file(isolateSnapshotData)</span><br><span class="line">          .copySync(outputDirectory.childFile(<span class="string">&#x27;isolate_snapshot_data&#x27;</span>).path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用copyAssets</span></span><br><span class="line">    <span class="keyword">final</span> Depfile assetDepfile = <span class="keyword">await</span> copyAssets(</span><br><span class="line">      environment,</span><br><span class="line">      outputDirectory,</span><br><span class="line">      targetPlatform: TargetPlatform.android,</span><br><span class="line">      buildMode: buildMode,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>androidArmRelease</code>编译目标：依赖<code>KernelSnapshot</code>编译目标生成<code>.dill</code>文件，可以将<code>.dill</code>文件编译成<code>.so</code>文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AndroidAot androidArmRelease = AndroidAot(TargetPlatform.android_arm,  BuildMode.release);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidAot</span> <span class="keyword">extends</span> <span class="title">AotElfBase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; <span class="string">&#x27;android_aot_<span class="subst">$&#123;getNameForBuildMode(buildMode)&#125;</span>_&#x27;</span></span><br><span class="line">    <span class="string">&#x27;<span class="subst">$&#123;getNameForTargetPlatform(targetPlatform)&#125;</span>&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//依赖KernelSnapshot编译目标</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Target&gt; <span class="keyword">get</span> dependencies =&gt; <span class="keyword">const</span> &lt;Target&gt;[</span><br><span class="line">    KernelSnapshot(),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; build(Environment environment) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> snapshotExitCode = <span class="keyword">await</span> snapshotter.build(</span><br><span class="line">      platform: targetPlatform,</span><br><span class="line">      buildMode: buildMode,</span><br><span class="line">      mainPath: environment.buildDir.childFile(<span class="string">&#x27;app.dill&#x27;</span>).path,</span><br><span class="line">      outputPath: output.path,</span><br><span class="line">      bitcode: <span class="keyword">false</span>,</span><br><span class="line">      extraGenSnapshotOptions: extraGenSnapshotOptions,</span><br><span class="line">      splitDebugInfo: splitDebugInfo,</span><br><span class="line">      dartObfuscation: dartObfuscation,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AOTSnapshotter</code>内部调用<code>_genSnapshot.run</code>方法，将<code>.dill</code>文件生成<code>.so</code>文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AOTSnapshotter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Builds an architecture-specific ahead-of-time compiled snapshot of the specified script.</span></span></span><br><span class="line">  Future&lt;<span class="built_in">int</span>&gt; build(</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  ) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//添加genSnapshot参数...</span></span><br><span class="line">    <span class="comment">//iOS编译出.S文件</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> assembly = _fileSystem.path.join(outputDir.path, <span class="string">&#x27;snapshot_assembly.S&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (platform == TargetPlatform.ios || platform == TargetPlatform.darwin) &#123;</span><br><span class="line">      genSnapshotArgs.addAll(&lt;<span class="built_in">String</span>&gt;[</span><br><span class="line">        <span class="string">&#x27;--snapshot_kind=app-aot-assembly&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;--assembly=<span class="subst">$assembly</span>&#x27;</span>,</span><br><span class="line">      ]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//Android编译出elf文件，.so文件</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">String</span> aotSharedLibrary = _fileSystem.path.join(outputDir.path, <span class="string">&#x27;app.so&#x27;</span>);</span><br><span class="line">      genSnapshotArgs.addAll(&lt;<span class="built_in">String</span>&gt;[</span><br><span class="line">        <span class="string">&#x27;--snapshot_kind=app-aot-elf&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;--elf=<span class="subst">$aotSharedLibrary</span>&#x27;</span>,</span><br><span class="line">      ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> SnapshotType snapshotType = SnapshotType(platform, buildMode);</span><br><span class="line">    <span class="comment">//执行gen_snapshot程序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> genSnapshotExitCode = <span class="keyword">await</span> _genSnapshot.run(</span><br><span class="line">      snapshotType: snapshotType,</span><br><span class="line">      additionalArgs: genSnapshotArgs,</span><br><span class="line">      darwinArch: darwinArch,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//iOS上将.S文件再通过XCode编译出.O文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终是调用对应架构引擎的<code>gen_snapshot</code>程序，命令如下，省略部分参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flutter/bin/cache/artifacts/engine/android-arm-release/darwin-x64/gen_snapshot </span><br><span class="line">--snapshot_kind=app-aot-elf</span><br><span class="line">--elf=&#123;output_path&#125;/app.so</span><br></pre></td></tr></table></figure>

<p><code>KernelSnapshot</code>目标调用<code>KernelCompiler.compile</code>方法，将Flutter代码编译为<code>app.dill</code>文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KernelSnapshot</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; <span class="string">&#x27;kernel_snapshot&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; build(Environment environment) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> KernelCompiler compiler = KernelCompiler(</span><br><span class="line">      fileSystem: environment.fileSystem,</span><br><span class="line">      logger: environment.logger,</span><br><span class="line">      processManager: environment.processManager,</span><br><span class="line">      artifacts: environment.artifacts,</span><br><span class="line">      fileSystemRoots: &lt;<span class="built_in">String</span>&gt;[],</span><br><span class="line">      fileSystemScheme: <span class="keyword">null</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//执行frontend_server.dart.snapshot程序</span></span><br><span class="line">    <span class="keyword">final</span> CompilerOutput output = <span class="keyword">await</span> compiler.compile(</span><br><span class="line">      sdkRoot: environment.artifacts.getArtifactPath(</span><br><span class="line">        Artifact.flutterPatchedSdkPath,</span><br><span class="line">        platform: targetPlatform,</span><br><span class="line">        mode: buildMode,</span><br><span class="line">      ),</span><br><span class="line">      outputFilePath: environment.buildDir.childFile(<span class="string">&#x27;app.dill&#x27;</span>).path,</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终是执行<code>frontend_server.dart.snapshot</code>程序，命令如下，省略部分参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter/bin/cache/dart-sdk/bin/dart /path-to-flutter-sdk/flutter/bin/cache/artifacts/engine/darwin-x64/frontend_server.dart.snapshot </span><br><span class="line">--sdk-root flutter/bin/cache/artifacts/engine/common/flutter_patched_sdk/ </span><br><span class="line">--target=flutter </span><br><span class="line">--aot --tfa </span><br><span class="line">--packages .packages </span><br><span class="line">--output-dill &#123;build_dir&#125;/app.dill </span><br><span class="line">--depfile &#123;build_dir&#125;/kernel_snapshot.d </span><br><span class="line">mainUri</span><br></pre></td></tr></table></figure>

<p>FlutterTask用于编译Flutter资源，实际是执行<code>flutter assemble</code>命令。编译流程如下：</p>
<p><img src="/2022/01/12/flutter-2022-01-12-Flutter%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/FlutterTask%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png"></p>
<blockquote>
<p><code>frontend_server.dart.snapshot</code>是一个dart程序，作为Dart编译前端，可以将dart源码编译成<code>.dill</code>中间代码文件。源码入口为<code>&#123;flutter_engine&#125;/flutter_frontend_server/bin/starter.dart</code>，内部会调用Dart SDK中的<code>frontend_server</code>，源码位于<code>&#123;dart_sdk&#125;/pkg/frontend_server</code>中</p>
<p><code>gen_snapshot</code>是一个可执行程序，可以将<code>.dill</code>文件编译成目标代码，生成<code>.so</code>或者<code>App.framework</code>，源码入口为<code>&#123;dart_sdk&#125;/runtime/bin/gen_snapshot.cc</code></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Flutter命令脚本会启动一个dart虚拟机，执行<code>flutter_tools</code>的dart程序。</li>
<li><code>flutter_tools</code>封装了不同的命令类，通过解析参数，执行对应的Command类，例如<code>BuildApkCommand.runCommand()</code></li>
<li>Command类中解析参数，最终调用相应平台的构建工具进行构建，例如<code>gradlew assembleRelease</code></li>
<li><code>flutter_tools</code>中自定义了一个gradle脚本<code>flutter.gradle</code>，将FlutterTask编译任务加到Android构建中，生成so库，合并打包生成最终的apk</li>
<li>FlutterTask执行<code>flutter assemble</code>命令编译Flutter代码和资源。依次构建多个编译目标，关键的编译目标如下：<ol>
<li><code>KernelSnapshot</code>目标：调用<code>KernelCompiler.compile()</code>方法，执行<code>dart frontend_server.dart.snapshot</code>命令，生成<code>.dill</code>文件</li>
<li><code>AndroidAot</code>目标：调用<code>AOTSnapshotter.build()</code>方法，执行<code>gen_snapshot</code>命令，生成<code>app.so</code>文件</li>
<li><code>AotAndroidAssetBundle</code>目标：调用<code>AssetBundle.build()</code>，生成<code>flutter_assets</code>资源</li>
</ol>
</li>
</ol>
<p>Flutter构建源码分析流程如下：</p>
<p><img src="/2022/01/12/flutter-2022-01-12-Flutter%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/Flutter%E6%9E%84%E5%BB%BA%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%B5%81%E7%A8%8B.png"></p>
<p>Android中的Flutter Release产物编译总体流程如下：</p>
<p>![](2022-01-12-Flutter构建流程分析/Android Flutter Release产物编译流程.png)</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于Dart前端编译（生成Dart Kernel文件，即<code>.dill</code>）和AOT编译（生成目标代码）可以参考：<a href="/2022/01/03/Dart%E7%AE%80%E4%BB%8B/">Dart简介</a></p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/4e8ccb02e92d">研读Flutter——打包编译流程详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter架构和源码编译</title>
    <url>/2022/01/06/flutter-2022-01-06-Flutter%E6%9E%B6%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="Flutter架构"><a href="#Flutter架构" class="headerlink" title="Flutter架构"></a>Flutter架构</h1><p>Flutter源码包含两部分：</p>
<ol>
<li><a href="https://github.com/flutter/engine">Flutter Engine</a>：负责Flutter渲染和与宿主机的交互。包括图形渲染、网络IO、插件通道、Dart运行时、平台嵌入层等</li>
<li><a href="https://github.com/flutter/flutter">Flutter Framework</a>：为开发者提供dart封装的API接口和开发调试工具。类似Android SDK，应用开发者只需要下载和使用SDK，一般不需要接触底层系统代码。</li>
</ol>
<blockquote>
<p>Flutter SDK默认会下载和使用官方构建好的engine，打包到应用中</p>
</blockquote>
<p>架构如下：</p>
<img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%9E%B6%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/Flutter架构.png" style="zoom: 33%;">

<ol>
<li><p>嵌入层：源码包含在Engine中的<code>shell/platform</code>文件夹下。适配了多个平台，使用当前平台语言编写，提供营养程序入口，程序通过嵌入层与底层操作系统交互，例如访问surface渲染、辅助功能、输入设备、线程管理、窗口管理等。</p>
</li>
<li><p>引擎层：提供Flutter核心API实现，包括图形（Skia）和动画，文本布局、文件、网络IO、插件通道、Dart运行环境以及编译环境的工具链。引擎将底层C++代码包装成Dart代码，即<code>dart:ui</code>，供上层使用。</p>
</li>
<li><p>框架层：提供Flutter应用开发的框架，包括响应式框架、布局、组件、基础库等</p>
<ol>
<li>foundation：提供上层常用的抽象和函数</li>
<li>基本模块：如 <a href="https://api.flutter-io.cn/flutter/animation/animation-library.html">animation</a>、 <a href="https://api.flutter-io.cn/flutter/painting/painting-library.html">painting</a> 和 <a href="https://api.flutter-io.cn/flutter/gestures/gestures-library.html">gestures</a></li>
<li>渲染层：提供布局操作的抽象，构建可渲染对象的树</li>
<li>widgets层：和渲染层中的渲染对象对应，并提供响应式编程模型</li>
<li>Material和Cupertino：封装widgets，实现Material和iOS设计规范</li>
</ol>
</li>
<li><p>软件包：封装开发者常用的功能，分为普通包和插件包</p>
<ol>
<li>Packages：与平台无关。如http、路由导航、依赖管理、应用内支付、组件等</li>
<li>Plugins：封装原生平台调用，如webview、camera等</li>
</ol>
</li>
<li><p>应用层：APP主体或以模块的方式集成到原生应用中</p>
</li>
</ol>
<blockquote>
<p>Flutter界面构建、布局、合成、绘制都由自身完成，而不是转换为原生控件。Flutter引擎与平台无关，通过嵌入层ABI调用操作系统方法。</p>
<p>应用启动时，嵌入层初始化Flutter引擎，获取UI和栅格化线程，创建Surface供Flutter写入</p>
</blockquote>
<h2 id="平台嵌入层"><a href="#平台嵌入层" class="headerlink" title="平台嵌入层"></a>平台嵌入层</h2><p>嵌入层是Flutter实现跨平台的核心。这里简单介绍一下，列举一些案例，需要移植到定制嵌入式系统的时候可以参考这些案例代码。</p>
<p>Flutter提供了Android、iOS、Windows、macOS、Linux、Fuchsia等平台嵌入层。</p>
<p>Flutter最早只支持Android、iOS跨平台、不支持桌面平台。为了移植到桌面，出现了一些自定义嵌入层的项目</p>
<ul>
<li><a href="https://github.com/go-flutter-desktop/go-flutter">go-flutter</a>：使用go语言和GLFW实现桌面平台支持。</li>
<li><a href="https://github.com/google/flutter-desktop-embedding">Flutter Desktop Embedding</a>：已经合入到Flutter官方源码中</li>
<li><a href="https://github.com/flutter/engine/tree/master/examples/glfw">Flutter官方GLFW案例</a>：使用GLFW渲染Flutter</li>
</ul>
<blockquote>
<p>GLFW（Graphics Library Framework，图形库框架）：开源多平台的OpenGL框架，封装OpenGL调用API，用于创建窗口，渲染OpenGL、管理输入等。由C语言实现，GitHub上也有Go语言的实现等</p>
</blockquote>
<p>对于嵌入式系统，开发者可以创建自定义的嵌入层。案例：</p>
<ul>
<li>VNC风格的远程Flutter会话<a href="https://github.com/chinmaygarde/fluttercast">Flutter Cast</a></li>
<li><a href="https://github.com/ardera/flutter-pi">树莓派</a>上运行</li>
</ul>
<h2 id="Web上的Flutter"><a href="#Web上的Flutter" class="headerlink" title="Web上的Flutter"></a>Web上的Flutter</h2><p>Flutter引擎中的嵌入层是为了与底层操作系统进行交互，而Web是运行在浏览器上的，因此接入方式和其他平台有所不同。</p>
<p>将Flutter代码和框架一起编译成JavaScript。架构如下</p>
<img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%9E%B6%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/FlutterWeb架构.png" style="zoom: 33%;">

<h1 id="SDK下载和编译"><a href="#SDK下载和编译" class="headerlink" title="SDK下载和编译"></a>SDK下载和编译</h1><p>目的：</p>
<ol>
<li>学习源码</li>
<li>定制框架：如修改<code>flutter_tools</code>编译工具等</li>
</ol>
<p>方法和搭建Flutter开发环境类似</p>
<ol>
<li><p>直接clone或先fork到本地：<code>git clone git@github.com:&lt;github_username&gt;/flutter.git</code></p>
</li>
<li><p>设置环境变量：也可以直接进入bin目录执行flutter命令</p>
</li>
<li><p>安装依赖包：<code>&#123;flutter_framework&#125;/bin/flutter update-packages</code></p>
</li>
<li><p>检查环境：<code>&#123;flutter_framework&#125;/bin/flutter doctor</code></p>
</li>
<li><p>Android Studio打开<code>&#123;flutter_framework&#125;/packages/</code>下的项目，默认会当做Android工程，IDE提示<code>Dart SDK is not configured</code>或者<code>Dart support is not enabled for the module &#39;flutter_tools&#39;</code>，如下</p>
<p><img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%9E%B6%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/AS%E6%89%93%E5%BC%80Dart%E9%85%8D%E7%BD%AE.png"></p>
</li>
<li><p>配置Flutter工程：直接点击上图的<code>Open Dart Settings</code>或者打开<code>Prefereneces&gt;Language&gt;Dart/Flutter</code>。配置Dart SDK和Flutter SDK路径，对照下Flutter应用项目的配置即可。如下</p>
<img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%9E%B6%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/AS配置DartSDK.png" style="zoom: 67%;">

<img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%9E%B6%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/AS配置FlutterSDK.png" style="zoom:67%;"></li>
<li><p>配置完之后即可在IDE查看和修改源码</p>
</li>
<li><p>编译源码</p>
<ol>
<li>删除<code>&#123;flutter_framework&#125;/bin/cache/flutter_tools.snapshot</code>（Dart快照文件）和<code>&#123;flutter_framework&#125;/bin/cache/flutter_tools.stamp</code>（当前SDK的commit id文件）</li>
<li>运行flutter命令的时候会自动编译源码，重新生成dart快照文件（下面会介绍flutter命令执行过程）</li>
</ol>
</li>
</ol>
<h1 id="Engine下载和编译"><a href="#Engine下载和编译" class="headerlink" title="Engine下载和编译"></a>Engine下载和编译</h1><p>这里只演示了官方支持的平台编译，还不涉及嵌入层的定制和交叉编译（用于定制的嵌入式平台运行Engine）。</p>
<p>主要有几个目的</p>
<ol>
<li>学习源码</li>
<li>定制引擎，使得Flutter能够在其他目标平台运行，例如树莓派，鸿蒙系统等</li>
<li>通过压缩、裁剪引擎优化包体积</li>
</ol>
<p>推荐使用macOS，桌面应用需要在对应的平台上编译，暂不支持交叉编译</p>
<ul>
<li>macOS支持Android和iOS的交叉编译</li>
<li>Linux支持Android和Fuchsia的交叉编译，不支持iOS</li>
<li>Windows不支持Android、Fuchsia或iOS交叉编译</li>
</ul>
<p>x64主机交叉编译arm目标平台应用：参考<a href="https://github.com/flutter/flutter/issues/74929">issue</a>和<a href="https://docs.google.com/document/d/19tzWySgtgtTA99XQsjx5Pg0SFJeZKXyUlYavR0EXv8c/edit#">说明</a></p>
<h2 id="depot-tools介绍"><a href="#depot-tools介绍" class="headerlink" title="depot_tools介绍"></a>depot_tools介绍</h2><p>Google用python开发的git仓库管理工具，用于管理chromium源码。包括gclient、repo、gn和ninja等工具。是对Git的增强，大项目由几十个独立的git仓库构成，不便于下载、提交和管理。</p>
<ul>
<li><a href="https://chromium.googlesource.com/chromium/tools/depot_tools.git">下载地址</a></li>
<li><a href="https://www.chromium.org/developers/how-tos/depottools">简介</a></li>
<li><a href="https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html">使用手册</a></li>
</ul>
<p><code>gclient</code>：将多个git仓库组成一个<code>Solution</code>进行管理，通过gclient获取源码和依赖的仓库，类似Git submodule。</p>
<blockquote>
<ul>
<li><code>git submodule</code>：git子仓库管理工具</li>
<li><code>repo</code>：与<code>gclient</code>作用相同，gclient更新一点。gclient根据.gclient和DEPS配置文件检出依赖模块源码，repo根据manifest.xml配置文件检出模块源码。</li>
<li><code>Solution</code>：包含DEPS文件的仓库</li>
<li><code>DEPS</code>：记录Solution中的项目依赖关系</li>
<li><code>roll_deps</code>：用于更新DEPS文件中某个依赖的代码版本</li>
<li><code>Gerrit/Rietveld</code>：Code Review（代码审核）的系统，可以和<code>git/svn</code>集成</li>
<li><code>git cl</code>：Change List，用于查看代码修改，类似<code>git diff</code></li>
<li><code>LKGR</code>（Last Known Good Revision）：记录最新的测试通过的版本</li>
</ul>
</blockquote>
<p><a href="https://ninja-build.org/">ninja</a>：编译工具，负责编译最终的可执行文件。依赖其他构建工具进行高级语言编译。</p>
<p><a href="https://gn.googlesource.com/gn">gn</a>：生成ninja所需的构建文件，可以针对不同平台生成不同的ninja构建文件。<code>gn help</code>查看帮助</p>
<p><code>depot_tools</code>安装：</p>
<ol>
<li>clone仓库：<code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code></li>
<li>设置环境变量：<code>.bash_profile</code>文件中添加<code>export PATH=/your_path/depot_tools/:$PATH</code></li>
</ol>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">官方文档</a></p>
<p>生成<code>.gclient</code>文件：<code>gclient config git@github.com:flutter/engine.git --unmanaged --name=src/flutter</code></p>
<blockquote>
<p>也可以手动创建文件填写。这里直接使用官方仓库地址，如果要修改提交源码，则需要fork到自己的仓库下载。</p>
</blockquote>
<p>下载源码和依赖项目（大概10个G，不要中断下载）：<code>gclient sync --verbose</code></p>
<blockquote>
<p>依赖项目如glwf、skia、dart、android sdk等，一般不需要修改，只需要修改flutter engine项目</p>
</blockquote>
<p>切分支：默认获取master分支的版本，如果需要切到指定engine版本，需要进入<code>src/flutter</code>目录执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切分支，commitId可以使用和当前Flutter SDK对应的版本：cat bin/internal/engine.version，如下图</span></span><br><span class="line">git reset --hard &lt;commiId&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次同步代码：不同engine版本依赖的项目版本可能不同</span></span><br><span class="line">gclient sync --with_branch_heads --with_tags --verbose</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/06/flutter-2022-01-06-Flutter%E6%9E%B6%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/Flutter%E5%BC%95%E6%93%8E%E7%89%88%E6%9C%AC.png"></p>
<h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p><a href="https://github.com/flutter/flutter/wiki/Compiling-the-engine">官方文档</a></p>
<p>使用<code>gn</code>生成ninja构建文件（参数参考官方文档）：<code>&#123;engine_path&#125;/src/flutter/tools/gn --unoptimized --android --runtime-mode debug --android-cpu arm</code></p>
<blockquote>
<p>这里的gn只是一个shell脚本，内部调用<code>gn gen</code>命令执行</p>
<p>对应的构建产物会有多种组合：</p>
<ul>
<li>平台：iOS, Android, macOS, Linux, Windows</li>
<li>构建模式：debug, release, profile</li>
<li>是否优化：opt, unopt</li>
<li>cpu架构：arm、arm64、x86、x64</li>
</ul>
<p>产物命名格式：<code>android/ios/host_debug/profile/release_unoptimized/optimized_cpu架构</code></p>
<p>除此之外还可以根据图形后端进行编译：如OpenGL、Vulkan、software</p>
</blockquote>
<p>构建完之后生成<code>out</code>目录，根据参数生成不同文件夹，如<code>android_debug_unopt</code>、<code>ios_debug_unopt</code>等。</p>
<p>内部包括ninja构建文件、<code>compile_commands.json</code>文件（Intellisense，用于编辑器索引）、xcode项目文件等</p>
<p>使用<code>ninja</code>编译：<code>ninja -C out/android_debug_unopt</code></p>
<blockquote>
<p>编译生成的文件在<code>out/android_debug_unopt</code>目录下，主要产物如下：</p>
<ul>
<li><code>flutter_embedding_debug.jar</code>：Android嵌入层代码</li>
<li><code>libflutter.so</code>：flutter引擎层代码</li>
</ul>
<p>二者最终会合并到<code>flutter.jar</code>中</p>
<p>iOS引擎编译主要产物是<code>Flutter.framework</code>，其中包含<code>icudtl.dat</code>国际化数据文件和<code>FlutterEmbedder.framework</code>嵌入层代码</p>
</blockquote>
<h2 id="替换Engine"><a href="#替换Engine" class="headerlink" title="替换Engine"></a>替换Engine</h2><p><a href="https://github.com/flutter/flutter/wiki/The-flutter-tool#using-a-locally-built-engine-with-the-flutter-tool">官方文档</a></p>
<p><strong>Flutter默认会下载和使用官方构建好的engine</strong>，包括各种架构的版本，位于<code>&#123;flutter_sdk&#125;/bin/cache/artifacts/engine</code>下。要替换自己编译出来的引擎，使用<code>local-engine-src-path</code>和<code>--local-engine</code>选项。如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定的引擎需要与构建模式对应：debug版的引擎编译debug版的应用</span></span><br><span class="line">flutter run --local-engine-src-path &#123;path&#125;/engine/src --local-engine=&#123;path&#125;/engine/src/out/host_debug_unopt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果flutter引擎和sdk在同级目录下，或者<code>-local-engine</code>使用绝对路径，可以省略<code>--local-engine-src-path</code>参数。</p>
<p>下面会分析<code>flutter_tools</code>解析该参数过程</p>
</blockquote>
<p>为Web应用构建，使用主机引擎即可：<code>flutter run --local-engine=host_debug_unopt -d chrome</code></p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>参考<a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">官方文档</a></p>
<h3 id="Clion"><a href="#Clion" class="headerlink" title="Clion"></a>Clion</h3><p>将gn生成的<code>compile_commands.json</code>文件复制到<code>src/flutter</code>中，使用Clion打开，indexing之后就可以跟踪和跳转代码</p>
<blockquote>
<p>JetBrains系列，需要激活</p>
</blockquote>
<h3 id="Xcode【Objective-C-】"><a href="#Xcode【Objective-C-】" class="headerlink" title="Xcode【Objective-C++】"></a>Xcode【Objective-C++】</h3><p>Mac电脑上，对于Objective-C++项目，可以直接打开xcode工程文件<code>open out/host_debug_unopt/flutter_engine.xcodeproj</code></p>
<h3 id="VSCode【C-C-】"><a href="#VSCode【C-C-】" class="headerlink" title="VSCode【C/C++】"></a>VSCode【C/C++】</h3><ol>
<li><p>安装cmake：<code>brew install cmake</code></p>
</li>
<li><p>安装cquery或者ccls：<code>brew install cquery</code>，<code>brew install ccls</code></p>
<blockquote>
<p><a href="https://github.com/jacobdufault/cquery">cquery</a>已经不再维护，推荐<a href="https://clangd.llvm.org/">clangd</a>和<a href="https://github.com/MaskRay/ccls">ccls</a></p>
<p>三者都是语言服务器，用于代码语义分析，通过插件与其他编辑器一起工作。可以给编辑器添加智能功能：代码提示和补全、格式化、代码跳转、编译错误提示等</p>
<p>ccls源自cquery。clangd基于Clang C++编译器，属于LLVM项目</p>
</blockquote>
</li>
<li><p><a href="https://github.com/jacobdufault/cquery/wiki/Building-cquery">构建cquery</a>或者<a href="https://github.com/MaskRay/ccls/wiki/Build">构建ccls</a></p>
</li>
<li><p>安装VSCode插件，如<code>VSCode-cquery</code>或<code>vscode-ccls</code>，配置插件（参考上面cquery和ccls文档）</p>
</li>
<li><p>配置Intellisense文件：</p>
<ol>
<li>将gn生成的<code>compile_commands.json</code>文件拷贝到要打开的项目根目录，如<code>src/flutter</code>下，打开项目</li>
<li>或者在<code>c_cpp_properties.json</code>文件中配置<code>compile_commands.json</code>的绝对路径</li>
</ol>
</li>
</ol>
<h3 id="VSCode【Java】"><a href="#VSCode【Java】" class="headerlink" title="VSCode【Java】"></a>VSCode【Java】</h3><p>对于Java项目，VSCode需要配置jar包依赖。</p>
<ol>
<li>安装VSCode插件<code>vscjava.vscode-java-pack</code>和<code>vscjava.vscode-java-dependency</code></li>
<li>添加文件夹路径，如<code>shell/platform/android</code></li>
<li>打开Java Dependencies资源管理器窗口，或者使用命令打开”Explorer: Focus on Java Dependencies View”</li>
<li>刷新视图窗口</li>
<li>配置<code>Referenced Libraries</code>，添加src/third_party/android_embedding_dependencies<code>文件夹。</code></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相当于配置settings.json如下</span></span><br><span class="line">&quot;java.project.referencedLibraries&quot;: [</span><br><span class="line">  <span class="string">&quot;&#123;path to engine&#125;/src/third_party/android_embedding_dependencies/lib/**/*.jar&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="flutter命令执行原理"><a href="#flutter命令执行原理" class="headerlink" title="flutter命令执行原理"></a>flutter命令执行原理</h1><p>分析下<code>flutter_tools</code>和本地编译引擎替换的原理。关于Flutter命令执行过程可以参考<a href="/2022/01/12/Flutter%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%92%8C%E4%BA%A7%E7%89%A9%E5%88%86%E6%9E%90/">Flutter构建流程和产物分析</a>，这里直接定位到关键代码。</p>
<h2 id="替换flutter-tools"><a href="#替换flutter-tools" class="headerlink" title="替换flutter_tools"></a>替换flutter_tools</h2><p>上一篇文档已经介绍了Flutter命令执行过程：主要通过dart运行<code>&#123;flutter_sdk&#125;/bin/cache/flutter_tools.snapshot</code>程序解析参数，调用不同平台工具进行构建。</p>
<p><code>flutter_tools.snapshot</code>对应的源码位于<code>&#123;flutter_framework&#125;/packages/flutter_tools/</code>中，可以直接修改。</p>
<p>修改了<code>flutter_tools</code>源码之后如何编译并替换呢？</p>
<p>查看<code>bin/internal/shared.sh</code>脚本的<code>upgrade_flutter</code>方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function upgrade_flutter () (</span><br><span class="line">  mkdir -p &quot;$FLUTTER_ROOT/bin/cache&quot;</span><br><span class="line"></span><br><span class="line">  local revision=&quot;$(cd &quot;$FLUTTER_ROOT&quot;; git rev-parse HEAD)&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Invalidate cache <span class="keyword">if</span>:</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  * SNAPSHOT_PATH is not a file, or</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  * STAMP_PATH is not a file with nonzero size, or</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  * Contents of STAMP_PATH is not our <span class="built_in">local</span> git HEAD revision, or</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  * pubspec.yaml last modified after pubspec.lock</span></span><br><span class="line">  if [[ ! -f &quot;$SNAPSHOT_PATH&quot; || ! -s &quot;$STAMP_PATH&quot; || &quot;$(cat &quot;$STAMP_PATH&quot;)&quot; != &quot;$revision&quot; || &quot;$FLUTTER_TOOLS_DIR/pubspec.yaml&quot; -nt &quot;$FLUTTER_TOOLS_DIR/pubspec.lock&quot; ]]; then</span><br><span class="line">    # 等待锁</span><br><span class="line">    _wait_for_lock</span><br><span class="line">    # 获取锁之后再次判断，防止并发</span><br><span class="line">    # A different shell process might have updated the tool/SDK.</span><br><span class="line">    if [[ -f &quot;$SNAPSHOT_PATH&quot; &amp;&amp; -s &quot;$STAMP_PATH&quot; &amp;&amp; &quot;$(cat &quot;$STAMP_PATH&quot;)&quot; == &quot;$revision&quot; &amp;&amp; &quot;$FLUTTER_TOOLS_DIR/pubspec.yaml&quot; -ot &quot;$FLUTTER_TOOLS_DIR/pubspec.lock&quot; ]]; then</span><br><span class="line">      exit $?</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    #...</span><br><span class="line">    </span><br><span class="line">    # 重新编译生成快照文件snapshot</span><br><span class="line">    &quot;$DART&quot; --verbosity=error --disable-dart-dev $FLUTTER_TOOL_ARGS --snapshot=&quot;$SNAPSHOT_PATH&quot; --packages=&quot;$FLUTTER_TOOLS_DIR/.packages&quot; --no-enable-mirrors &quot;$SCRIPT_PATH&quot;</span><br><span class="line">    echo &quot;$revision&quot; &gt; &quot;$STAMP_PATH&quot;</span><br><span class="line">  fi</span><br><span class="line">  exit $?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>  什么时候会重新编译<code>flutter_tools</code>？</p>
<blockquote>
<p>注释已经写的很清楚了：</p>
<ol>
<li>snapshot或者stamp文件不存在</li>
<li>stamp的commit id不是当前的HEAD id</li>
<li>pubspec.yaml文件被修改</li>
</ol>
</blockquote>
<h2 id="替换本地引擎"><a href="#替换本地引擎" class="headerlink" title="替换本地引擎"></a>替换本地引擎</h2><p>Flutter可以指定<code>local-engine</code>和<code>local-engine-src-path</code>选项来替换本地引擎，这是如何生效的呢？</p>
<p>上一篇文档已经介绍了Flutter命令执行过程，这里我们直接找到解析<code>local-engine-src-path</code>参数的地方</p>
<p>查看<code>lib/src/runner/flutter_command_runner</code>源码，获取<code>local-engine</code>相关参数，查找本地构建引擎路径</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterCommandRunner</span> <span class="keyword">extends</span> <span class="title">CommandRunner</span>&lt;<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; runCommand(ArgResults topLevelResults) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//传入参数，执行命令，根据local-engine参数获取本地构建的引擎</span></span><br><span class="line">    <span class="comment">// Set up the tooling configuration.</span></span><br><span class="line">    <span class="keyword">final</span> EngineBuildPaths engineBuildPaths = <span class="keyword">await</span> globals.localEngineLocator.findEnginePath(</span><br><span class="line">      topLevelResults[<span class="string">&#x27;local-engine-src-path&#x27;</span>] <span class="keyword">as</span> <span class="built_in">String</span>,</span><br><span class="line">      topLevelResults[<span class="string">&#x27;local-engine&#x27;</span>] <span class="keyword">as</span> <span class="built_in">String</span>,</span><br><span class="line">      topLevelResults[<span class="string">&#x27;packages&#x27;</span>] <span class="keyword">as</span> <span class="built_in">String</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>lib/src/runner/local_engine.dart</code>源码<code>findEnginePath</code>方法，如何获取引擎路径</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalEngineLocator</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Returns the engine build path of a local engine if one is located, otherwise <span class="code">`null`</span>.</span></span></span><br><span class="line">  Future&lt;EngineBuildPaths?&gt; findEnginePath(<span class="built_in">String?</span> engineSourcePath, <span class="built_in">String?</span> localEngine, <span class="built_in">String?</span> packagePath) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//如果没有指定参数，从系统环境变量$FLUTTER_ENGINE读取</span></span><br><span class="line">    engineSourcePath ??= _platform.environment[kFlutterEngineEnvironmentVariableName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (engineSourcePath == <span class="keyword">null</span> &amp;&amp; localEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果local-engine参数是绝对路径，且父文件夹为src/out/，则使用src目录</span></span><br><span class="line">        engineSourcePath = _findEngineSourceByLocalEngine(localEngine);</span><br><span class="line">        <span class="comment">//从配置中读取</span></span><br><span class="line">        engineSourcePath ??= <span class="keyword">await</span> _findEngineSourceByPackageConfig(packagePath);</span><br><span class="line">      &#125; <span class="keyword">on</span> FileSystemException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        _logger.printTrace(<span class="string">&#x27;Local engine auto-detection file exception: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">        engineSourcePath = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//判断如果engine源码和flutter sdk目录同级，则不需要该参数</span></span><br><span class="line">      engineSourcePath ??= _tryEnginePath(</span><br><span class="line">        _fileSystem.path.join(_fileSystem.directory(_flutterRoot).parent.path, <span class="string">&#x27;engine&#x27;</span>, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">String?</span> _findEngineSourceByLocalEngine(<span class="built_in">String</span> localEngine) &#123;</span><br><span class="line">    <span class="comment">// When the local engine is an absolute path to a variant inside the</span></span><br><span class="line">    <span class="comment">// out directory, parse the engine source.</span></span><br><span class="line">    <span class="comment">// --local-engine /path/to/cache/builder/src/out/host_debug_unopt</span></span><br><span class="line">    <span class="keyword">if</span> (_fileSystem.path.isAbsolute(localEngine)) &#123;</span><br><span class="line">      <span class="keyword">final</span> Directory localEngineDirectory = _fileSystem.directory(localEngine);</span><br><span class="line">      <span class="keyword">final</span> Directory outDirectory = localEngineDirectory.parent;</span><br><span class="line">      <span class="keyword">final</span> Directory srcDirectory = outDirectory.parent;</span><br><span class="line">      <span class="keyword">if</span> (localEngineDirectory.existsSync() &amp;&amp; outDirectory.basename == <span class="string">&#x27;out&#x27;</span> &amp;&amp; srcDirectory.basename == <span class="string">&#x27;src&#x27;</span>) &#123;</span><br><span class="line">        _logger.printTrace(<span class="string">&#x27;Parsed engine source from local engine as <span class="subst">$&#123;srcDirectory.path&#125;</span>.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> srcDirectory.path;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Future&lt;<span class="built_in">String?</span>&gt; _findEngineSourceByPackageConfig(<span class="built_in">String?</span> packagePath) <span class="keyword">async</span> &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断out文件夹是否存在</span></span><br><span class="line">  <span class="built_in">String?</span> _tryEnginePath(<span class="built_in">String</span> enginePath) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_fileSystem.isDirectorySync(_fileSystem.path.join(enginePath, <span class="string">&#x27;out&#x27;</span>))) &#123;</span><br><span class="line">      <span class="keyword">return</span> enginePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取Flutter编译引擎源码路径？<code>--local-engine-src-path</code>什么时候可以省略？</p>
<blockquote>
<p>流程如下</p>
<ol>
<li>如果没有指定该参数，从系统环境变量<code>$FLUTTER_ENGINE</code>读取源码路径</li>
<li>如果<code>--local-engine</code>参数是绝对路径，且父文件夹为src/out/，则使用src目录</li>
<li>根据<code>--packages</code>参数加载<code>package_config.json</code>文件，读取<code>sky_engine</code>配置路径，例如<code>&#123;flutter-engine-local-path&#125;/src/out/host_debug_unopt/gen/dart-pkg/sky_engine/lib/</code></li>
<li>如果engine源码和flutter sdk目录同级，且存在<code>src/out</code>文件夹，则使用src目录</li>
</ol>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ul>
<li><a href="https://flutter.cn/docs/resources/architectural-overview">Flutter架构概览</a></li>
<li><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">Flutter Wiki官方文档</a></li>
</ul>
<p>gclient使用可以参考<a href="https://www.cnblogs.com/xl2432/p/11596695.html">chromium开发工具–gclient</a>、<a href="https://keyou.github.io/blog/2017/11/02/gclient/">gclient 介绍</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU和构建工具介绍</title>
    <url>/2022/01/05/basic-2022-01-05-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="GNU介绍"><a href="#GNU介绍" class="headerlink" title="GNU介绍"></a>GNU介绍</h1><ul>
<li>1983年：Richard Stallman发起GNU计划，目标是创建一套完全自由的操作系统，起因是Unix版权问题</li>
<li>1985年：成立FSF，为GNU计划提供技术、法律以及财政支持</li>
<li>1990年：完成Emacs编辑器，GCC编译器以及大部分Unix系统的程序库和工具。但操作系统内核（Hurd）仍未完成</li>
<li>1991年：Linus开发与Unix兼容的Linux内核，并采用GPL条款发布。之后许多程序员参与了开发和修改</li>
<li>1992年：Linux与其他GNU软件结合，诞生GNU/Linux操作系统，简称Linux系统。</li>
</ul>
<blockquote>
<p>内核：用于资源分派和硬件管理的程序</p>
<p>Linux只是一个内核，用户态还是使用GNU系的软件，如bash shell、emacs编辑器、gcc编译器套装、glibc（GNU的C库）等</p>
<p>GNU官方核心是GNU Hurd，GNU/Linux是变种，除了Linux之外，还有FreeBSD内核、NetBSD内核等</p>
<p>Google在Linux内核的基础上，开发了bionic库，替换了glibc库，用于Android系统</p>
</blockquote>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>GNU（GNU’s Not Unix!）：是一个自由的操作系统，是由多个应用程序、系统库、开发工具组成的程序集合。模仿Unix界面和使用方式（类Unix），做的一个开源的版本。</p>
<blockquote>
<p>自由软件：</p>
<ol>
<li>运行软件的自由</li>
<li>研究该软件如何工作，按需改写软件的自由</li>
<li>重新发布拷贝的自由</li>
<li>向公众发布改进版软件的自由</li>
</ol>
</blockquote>
<p>GNU计划：又称“革奴计划”，在这个计划下做了很多工作和项目，如GCC、glibc、bash shell、emacs等，并成立了FSF，起草了GPL协议条款。</p>
<p>FSF：（Free Software Foundation，自由软件基金会）</p>
<p>GPL：（GNU General Public License，GNU通用公共许可证）</p>
<p>LGPL：(GNU Lesser General Public License，GNU较宽松公共许可证 ) ，旧称 GNU Library General Public License (GNU 库通用公共许可证)；</p>
<p>GFDL：（GNU Free Documentation License，GNU自由文档许可证）</p>
<p>BSD：（Berkeley Software Distribution，伯克利软件套件），Unix的衍生系统（类Unix）</p>
<p>BSD许可证：允许软件闭源发布</p>
<h1 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h1><ul>
<li>GCC：GNU编译套件。只有一个文件的时候使用gcc编译器比较方便。当有多个文件时，编译顺序以及依赖关系处理使用gcc很麻烦</li>
<li>Clang：C语言、C++、Objective-C的编译器前端，使用底层虚拟机（LLVM，Low Level Virtual Machine）作为编译器后端</li>
<li>make工具：批处理工具。makefile中规定了编译和链接的顺序，make根据makefile文件进行编译，比直接调用gcc逐个编译文件方便。手写makefile文件较麻烦，并且不同平台makefile不一样。<ul>
<li>Makefile定义了多个规则，每个规则由目标、依赖、命令构成</li>
</ul>
</li>
<li>CMake工具：更加方便的生成makefile文件，并且能够跨平台，解决不同平台手写makefile较麻烦的问题，但仍然需要手写<code>CMakelist.txt</code>文件</li>
</ul>
<pre class="mermaid">graph LR
编辑器--编写-->源文件-->cmakelist--cmake生成-->makefile--make批处理-->可执行程序</pre>

<p>make、mm、mmm命令</p>
<blockquote>
<p>m是对make的封装</p>
<p>make用来编译整个工程，首次编译需要使用make，</p>
<p>mm和mmm用来编译某个目录下的模块</p>
<p>默认是增量编译，使用-B选项可以强制编译所有目标文件</p>
</blockquote>
<p>make和Gradle</p>
<blockquote>
<ul>
<li>gradle命令类似make命令，根据配置文件（makefile、gradle文件）进行构建</li>
<li>gradle文件类似makefile，用于编译配置管理，语法使用groovy</li>
<li>gradle通过dependencies配置依赖库，makefile通过gcc/g++编译器的链接参数引用第三方库</li>
<li>makefile中的目标对应gradle中的task</li>
<li>由于每种工程类型构建过程较固定（如Java项目、Android项目、Android库）。因此gradle中预置了很多task，打包在plugin中。使用不同的plugin即可直接构建。</li>
<li>由于不同项目配置上存在差异，因此Gradle提供了一些自定义配置项：如项目id、sdk版本等</li>
</ul>
</blockquote>
<p>Clang与GCC</p>
<blockquote>
<ul>
<li>Clang采用BSD协议，GCC采用GPL协议</li>
<li>Clang高度更轻量，编译提示更友好</li>
<li>GCC使用<code>libstdc++</code>标准库，Clang使用<code>libc++</code>标准库</li>
<li>Android NDK<ul>
<li>r11：建议使用Clang编译</li>
<li>r13：默认使用Clang编译</li>
<li>r18：移除GCC</li>
</ul>
</li>
</ul>
</blockquote>
<p>Clang与LLVM</p>
<blockquote>
<p><a href="https://llvm.org/">LLVM</a>项目是模块化、可重用的编译器和工具链集合。虽然全称是Low Level Virtual Machine，但它实际与虚拟机并没有关系。</p>
<p>Clang是LLVM项目下的一个子项目</p>
<ul>
<li>广义的LLVM指LLVM编译器框架系统，包括前端（源码转为中间代码）、优化器、后端（中间代码转为汇编代码）以及相关的库或模块。如下<ul>
<li>核心库：源代码到中间代码的优化，与目标平台无关</li>
<li>Clang：C/C++/Objective-C的编译器</li>
<li>LLDB：基于Clang的调试库</li>
<li>libc++：LLVM提供的c++标准库</li>
<li>libclc：OpenCL标准库</li>
<li>LLD：链接器</li>
<li>…</li>
</ul>
</li>
<li>狭义的LLVM聚焦于编译后端，Clang对应编译前端。</li>
</ul>
</blockquote>
<p>make和ninja、cmake与gn</p>
<blockquote>
<ul>
<li><a href="https://ninja-build.org/">ninja</a>：编译工具，负责编译最终的可执行文件。依赖其他构建工具进行高级语言编译。</li>
<li><a href="https://gn.googlesource.com/gn">gn</a>：生成ninja所需的构建文件，可以针对不同平台生成不同的ninja构建文件</li>
</ul>
<p>chromium工程使用gn生成不同平台的ninja构建文件，再通过ninja进行编译。适用于大型项目。</p>
</blockquote>
<h1 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h1><h2 id="gcc-g-编译过程"><a href="#gcc-g-编译过程" class="headerlink" title="gcc/g++编译过程"></a>gcc/g++编译过程</h2><ol>
<li>预处理（pre-compile）[预处理器cpp]：删除#define并展开宏定义，处理#include等，生成.i文件。<code>gcc -E file.c -o file.i</code></li>
<li>编译（compile）[编译器egcs]：语法分析、词法分析、语义分析等，生成汇编代码.s文件。<code>gcc -S file.i -o file.s</code></li>
<li>汇编（assembly）[汇编器as]：汇编代码转为机器代码.o文件。<code>gcc -c file.s -o file.o</code></li>
<li>链接（link）[链接器ld]：处理各个模块之间的引用和依赖，将目标文件链接到可执行文件或其他目标文件。生成可执行文件。<ol>
<li>静态链接：目标文件直接进入可执行文件<ol>
<li>编译静态库源码，生成.o文件：<code>gcc -c lib.c -o lib.o</code></li>
<li>生成静态库文件，归档，生成.a文件：<code>ar -q lib.a lib.o</code></li>
<li>使用静态库编译，生成.out可执行文件：<code>gcc main.c lib.a -o main.out</code></li>
</ol>
</li>
<li>动态链接：可执行程序运行时加载目标文件<ol>
<li>编译动态库源码，生成.so文件：<code>gcc -shared dlib.c -o dlib.so</code></li>
<li>使用动态库编译：<code>gcc main -ldl -o main.out</code></li>
<li>代码调用<ol>
<li><code>dlopen</code>打开动态库文件</li>
<li><code>dlsym</code>查找动态库中的函数并返回调用地址</li>
<li><code>dlclose</code>关闭动态库文件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>反汇编：使用<code>objdump</code>反汇编，输出机器码和对应的汇编代码</li>
</ol>
<p>也可以直接一条命令执行：<code>gcc -o hello.out hello.c</code>，将<code>hello.c</code>编译，生成<code>hello.out</code>文件，默认生成<code>a.out</code></p>
<h2 id="gcc和GCC"><a href="#gcc和GCC" class="headerlink" title="gcc和GCC"></a>gcc和GCC</h2><p><strong>gcc和GCC是不同的东西</strong></p>
<ul>
<li>GCC：（GNU Compiler Collection，GNU编译器套件），为GNU操作系统开发的编译器，可以编译C、C++、Java、Go、Object-c等。</li>
<li>gcc（GNU C Compiler，C 编译器）</li>
<li>g++（GNU C++ Compiler，C++编译器）</li>
</ul>
<blockquote>
<p>最早GCC是GNU C语言编译器（GNU C Compiler），只能处理C语言，后来扩展支持更多编程语言。</p>
<p>也可以理解为gcc只是一个执行入口，不是编译器，通过调用GNU C compiler进行编译。</p>
</blockquote>
<h2 id="gcc和g-区别"><a href="#gcc和g-区别" class="headerlink" title="gcc和g++区别"></a>gcc和g++区别</h2><ol>
<li>对于.c后缀的文件，gcc把它当做是C程序；g++当做是C++程序；</li>
<li>对于.cpp后缀的文件，gcc和g++都会当做c++程序。</li>
<li>编译阶段，g++会调用gcc;</li>
<li>链接阶段，通常会用g++来完成，因为gcc命令不能自动和c++程序使用的库连接。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>操作系统不太了解，简单学习下，扩宽视野。</p>
<ul>
<li>CMake使用可以参考<a href="https://blog.csdn.net/kai_zone/article/details/82656964">cmake快速入门</a></li>
<li>gcc和g++具体区别可以参考<a href="https://www.cnblogs.com/samewang/p/4774180.html">GCC的gcc和g++区别</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart简介</title>
    <url>/2022/01/03/flutter-2022-01-03-Dart%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Dart简介"><a href="#Dart简介" class="headerlink" title="Dart简介"></a>Dart简介</h1><p><a href="https://dart.dev/overview">官方网站</a></p>
<p>目标是高效地开发多平台应用，提供灵活的运行时环境和编译工具。</p>
<blockquote>
<p>理论上所有高级语言都可跨平台，关键在于语法、库好不好用，编译工具成不成熟。下面详细介绍下Dart的多平台支持</p>
</blockquote>
<h2 id="Dart-SDK安装"><a href="#Dart-SDK安装" class="headerlink" title="Dart SDK安装"></a>Dart SDK安装</h2><p>参考<a href="https://dart.dev/get-dart">Dart SDK安装</a>。Dart SDK中包含了Dart基本类型、类库、编译器、命令行工具等</p>
<ul>
<li>Flutter SDK内置了Dart SDK工具，位于<code>&#123;flutter_sdk&#125;/bin/cache/dart-sdk</code>中（编译过的Dart SDK），不需要再单独下载。</li>
<li>Flutter Engine中依赖了Dart SDK的源码，位于<code>&#123;flutter_engine&#125;/third_party/dart</code>中，通过ninja构建出Dart SDK可执行程序，供Flutter SDK使用。</li>
</ul>
<h2 id="Dart语言"><a href="#Dart语言" class="headerlink" title="Dart语言"></a>Dart语言</h2><p>支持众多特性：类型安全（静态类型检查、dynamic运行时检查）、空安全、异步调用、流、箭头函数、getter函数等。基本语法参考<a href="https://dart.dev/guides/language/language-tour">Dart语言</a></p>
<h2 id="Dart库"><a href="#Dart库" class="headerlink" title="Dart库"></a>Dart库</h2><p><a href="https://dart.dev/guides/libraries">核心库</a>和<a href="https://dart.dev/guides/libraries/useful-libraries">三方库</a></p>
<h2 id="Dart工具"><a href="#Dart工具" class="headerlink" title="Dart工具"></a>Dart工具</h2><p>Dart SDK中提供了一些工具，使用<code>-h</code>查看帮助或者参考<a href="https://dart.dev/tools/dart-tool">Dart命令行工具</a>。源码入口位于<code>&#123;dart_sdk&#125;/pkg/dartdev/</code>中</p>
<p><img src="/2022/01/03/flutter-2022-01-03-Dart%E7%AE%80%E4%BB%8B/dart%E5%B7%A5%E5%85%B7.png"></p>
<ul>
<li><code>dart</code>：用于创建、格式化、分析、测试、编译和运行dart代码</li>
<li><code>dartaotruntime</code>：用于执行aot预编译过机器码</li>
<li><code>dartdoc</code>：用于生成API文档</li>
</ul>
<p>除了上面三个工具外，还有<code>dart2js</code>、<code>dart2native</code>、<code>dartanalyzer</code>、<code>dartdevc</code>、<code>dartfmt</code>、<code>pub</code>等工具。这些工具从2.10版本开始全部被封装到了<code>dart</code>中，通过<code>dart &lt;subcommand&gt;</code>的方式执行：</p>
<ul>
<li><code>dart2native</code>, <code>dart2aot</code>,  <code>dart2js</code> 工具被 <code>dart compile</code> 替代</li>
<li><code>dartanalyzer</code>被<code>dart analyze</code>替代</li>
<li><code>dartfmt</code>被<code>dart format</code>替代</li>
<li><code>pub</code>被<code>dart pub</code>替代</li>
</ul>
<p><code>&#123;flutter_sdk&#125;/bin/dart</code>对<code>dart-sdk</code>的工具做了一层包装，执行的时候会调用<code>dart-sdk</code>中的工具。</p>
<blockquote>
<p>由于配置Flutter SDK环境变量<code>&#123;flutter_sdk&#125;/bin</code>的时候没有配置<code>dart-sdk</code>的环境变量，如果要使用<code>dartaotruntime</code>工具，需要进入对应目录执行，或者给<code>dart-sdk</code>也配置环境变量</p>
</blockquote>
<h2 id="Dart的编译和执行"><a href="#Dart的编译和执行" class="headerlink" title="Dart的编译和执行"></a>Dart的编译和执行</h2><h3 id="Dart虚拟机"><a href="#Dart虚拟机" class="headerlink" title="Dart虚拟机"></a>Dart虚拟机</h3><p>Dart虚拟机源码位于<code>&#123;dart_sdk&#125;/runtime/vm</code>中，包含以下几个部分：</p>
<p><img src="/2022/01/03/flutter-2022-01-03-Dart%E7%AE%80%E4%BB%8B/DartVM.png"></p>
<p>DartVM作为虚拟机为Dart高级语言提供执行环境，但这并不表示Dart一定运行在虚拟机中。Dart的运行主要有几种方式：</p>
<ul>
<li>虚拟机执行：通过JIT即时编译+解释器，执行Dart源文件或者Kernel二进制文件，运行在Dart虚拟机中。</li>
<li>目标代码执行：通过AOT预编译成目标代码，运行在预编译运行时环境（Precompiled Runtime）中。不包含编译器，因此无法动态加载Dart源码。</li>
</ul>
<blockquote>
<ul>
<li>开发阶段：运行在Dart虚拟机中，通过Dart虚拟机提供的即时编译器（JIT）执行，支持增量编译，热重载和调试。</li>
<li>发布阶段：通过Dart的AOT编译器编译成目标平台的代码，在Dart预编译运行时（Precompiled Runtime）中执行，提高启动速度和执行效率。</li>
</ul>
<p>Dart 2之后，Dart VM不支持直接执行源代码，只接收Kernel AST序列化成的Kernel二进制文件（即.dill文件）。通过Dart的<a href="https://github.com/dart-lang/sdk/tree/master/pkg/front_end">编译前端（CFE，common front-end）</a>编译，并被其他工具所依赖使用，例如Dart VM、dart2js、Dart Dev Compiler。</p>
</blockquote>
<p>Dart运行时会被打包到<code>Self-Contained</code>的目标可执行程序中，同时也是Dart虚拟机的一部分，包含以下功能</p>
<ul>
<li>内存管理：提供对象分配和分代垃圾回收功能。</li>
<li>运行时类型检查和强制转换</li>
<li>管理<code>isolates</code>：包括主isolate和应用自行创建的isolate</li>
</ul>
<h3 id="虚拟机执行"><a href="#虚拟机执行" class="headerlink" title="虚拟机执行"></a>虚拟机执行</h3><p>使用<code>dart run</code>命令启动虚拟机执行程序，如下</p>
<ol>
<li><p>新建<code>main.dart</code>文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.dart</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello, World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行<code>dart main.dart</code>，输出”Hello, World!”</p>
</li>
</ol>
<blockquote>
<p>run子命令启动一个Dart虚拟机，执行未编译过的源码或者部分快照类型（JIT、Kernel快照），不支持执行aot快照。</p>
<p>可以省略，例如<code>dart main.dart</code>，<code>dart main.dill</code></p>
</blockquote>
<h3 id="Dart编译"><a href="#Dart编译" class="headerlink" title="Dart编译"></a>Dart编译</h3><ul>
<li>Dart编译前端：将Dart源码编译为Kernel二进制文件，是一种平台无关的中间代码。</li>
<li>Dart编译后端：将Kernel二进制文件编译出目标代码<ul>
<li>将Kernel二进制代码生成一个控制流图（CFG，control flow graph），CFG由中间语言（IL，Intermediate Language）指令组成。</li>
<li>对IL指令进行优化</li>
<li>CFG编译成机器码，每个IL指令对应多个机器指令</li>
</ul>
</li>
</ul>
<blockquote>
<p>IL指令类似于虚拟机指令，从堆栈中获取操作数，执行操作，将结果推送到堆栈中</p>
</blockquote>
<p>使用<code>dart compile</code>命令进行编译，分为以下几种方式：</p>
<ol>
<li><code>exe</code>：生成<code>Self-Contained</code>可执行文件，*<strong>包含生成的目标代码和一个小型的Dart运行时</strong>，可以直接运行<ol>
<li>编译：<code>dart compile exe main.dart</code>，生成<code>main.exe</code>文件</li>
<li>运行：<code>./main.exe</code>，输出”Hello, World!”</li>
</ol>
</li>
<li><code>aot-snapshot</code>：生成AOT快照文件，<strong>包含生成的目标代码，但不包含Dart运行时</strong>，需要使用<code>dartaotruntime</code>执行<ol>
<li>编译：<code>dart compile aot-snapshot main.dart</code>，生成<code>main.aot</code>文件</li>
<li>执行<code>dartaotruntime main.aot</code>，输出”Hello, World!”</li>
</ol>
</li>
<li><code>jit-snapshot</code>：生成JIT快照文件，<strong>包含生成的目标代码，不同的是在训练运行期间已经加载和解析过代码</strong>，使用<code>dart run</code>运行。由于在训练运行期间已经解析和编译过，Dart虚拟机不需要再进行解析和编译，因此可以更快的执行代码。（经过训练和优化，有可能比aot执行更快）<ol>
<li>编译：<code>dart compile jit-snapshot main.dart</code>，生成<code>main.jit</code>文件，并且会执行一遍程序训练，输出”Hello, World!”</li>
<li>运行：<code>dart run main.jit</code>，输出”Hello, World!”</li>
</ol>
</li>
<li><code>kernel</code>：生成<code>.dill</code>二进制的kernel快照文件，<strong>是一种中间代码，和平台无关，具有可移植性</strong>。包含二进制格式的Dart抽象语法树（Kernel AST）<ol>
<li>编译：<code>dart compile kernel main.dart</code>，生成<code>main.dill</code>文件</li>
<li>执行：<code>dart run main.dill</code>，输出”Hello, World!”</li>
</ol>
</li>
<li><code>js</code>：生成js文件<ol>
<li>编译：<code>dart compile js main.dart</code>，生成<code>out.js</code>文件</li>
<li>可以使用<code>webdev serve</code>命令启动开发服务器运行js</li>
</ol>
</li>
</ol>
<p><code>exe</code>和<code>aot-snapshot</code>存在一些限制：</p>
<ol>
<li>不支持交叉编译、只能本地编译本地运行：需要在macOS、Windows、Linux主机上分别编译出三个目标程序</li>
<li>生成的可执行程序不支持签名</li>
<li>不支持<code>dart:mirrors</code>（用于动态反射）和<code>dart:developer</code>（用于调试检查）库，参考<a href="https://dart.dev/guides/libraries">Dart核心库</a>说明</li>
</ol>
<p>对比下编译产物文件，如下：<code>exe &gt; jit-snapshot &gt; aot-snapshot &gt; kernel &gt; dart source code</code>，一般情况下执行效率刚好相反。</p>
<p><img src="/2022/01/03/flutter-2022-01-03-Dart%E7%AE%80%E4%BB%8B/dart%E7%BC%96%E8%AF%91%E4%BA%A7%E7%89%A9%E6%96%87%E4%BB%B6.png"></p>
<p><code>.snapshot</code>文件？</p>
<p>在Flutter SDK中经常看到<code>.snapshot</code>后缀的文件，如<code>flutter_tools.snapshot</code>，查看Flutter命令脚本中源码使用了<code>dart --snapshot</code>命令，官网没有说明。使用<code>dart --snapshot</code>查看帮助如下：</p>
<p><img src="/2022/01/03/flutter-2022-01-03-Dart%E7%AE%80%E4%BB%8B/dart%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9.png"></p>
<p><code>--snapshot</code>用于生成快照文件，<code>--snapshot-kind</code>指定生成JIT快照还是kernel快照。默认生成kernel快照。</p>
<p><code>dart compile kernel/jit-snapshot</code>等价于<code>dart --snapshot-kind=kernel/app-jits</code>。只不过是新版本Dart工具统一封装到compile中而已。</p>
<p>例如<code>dart --snapshot=main.snapshot main.dart</code>生成<code>main.snapshot</code>，<code>dart compile kernel main.dart</code>生成<code>main.dill</code>。<code>main.dill</code>和<code>main.snapshot</code>实际上是一样的，都是Kernel快照文件。</p>
<p>查看<code>&#123;dart_sdk&#125;/pkg/dartdev/lib/src/commands/compile.dart</code>源码发现<code>dart compile kernel</code>和<code>dart compile jit-snapshot</code>命令实际会调用<code>dart --snapshot-kind=$formatName</code>执行。如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dart compile命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompileCommand</span> <span class="keyword">extends</span> <span class="title">DartdevCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> cmdName = <span class="string">&#x27;compile&#x27;</span>;</span><br><span class="line">  CompileCommand(&#123;<span class="built_in">bool</span> verbose = <span class="keyword">false</span>&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(cmdName, <span class="string">&#x27;Compile Dart to various formats.&#x27;</span>, verbose) &#123;</span><br><span class="line">    addSubcommand(CompileJSCommand(verbose: verbose));</span><br><span class="line">    addSubcommand(CompileSnapshotCommand( <span class="comment">//dart compile jit-snapshot子命令</span></span><br><span class="line">      commandName: CompileSnapshotCommand.jitSnapshotCmdName,</span><br><span class="line">      help: <span class="string">&#x27;to a JIT snapshot.\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;To run the snapshot use: dart run &lt;JIT file&gt;&#x27;</span>,</span><br><span class="line">      fileExt: <span class="string">&#x27;jit&#x27;</span>,</span><br><span class="line">      formatName: <span class="string">&#x27;app-jit&#x27;</span>,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ));</span><br><span class="line">    addSubcommand(CompileSnapshotCommand( <span class="comment">//dart compile kernel子命令</span></span><br><span class="line">      commandName: CompileSnapshotCommand.kernelCmdName,</span><br><span class="line">      help: <span class="string">&#x27;to a kernel snapshot.\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;To run the snapshot use: dart run &lt;kernel file&gt;&#x27;</span>,</span><br><span class="line">      fileExt: <span class="string">&#x27;dill&#x27;</span>,</span><br><span class="line">      formatName: <span class="string">&#x27;kernel&#x27;</span>,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ));</span><br><span class="line">    addSubcommand(CompileNativeCommand(</span><br><span class="line">      commandName: CompileNativeCommand.exeCmdName,</span><br><span class="line">      help: <span class="string">&#x27;to a self-contained executable.&#x27;</span>,</span><br><span class="line">      format: <span class="string">&#x27;exe&#x27;</span>,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ));</span><br><span class="line">    addSubcommand(CompileNativeCommand(</span><br><span class="line">      commandName: CompileNativeCommand.aotSnapshotCmdName,</span><br><span class="line">      help: <span class="string">&#x27;to an AOT snapshot.\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;To run the snapshot use: dartaotruntime &lt;AOT snapshot file&gt;&#x27;</span>,</span><br><span class="line">      format: <span class="string">&#x27;aot&#x27;</span>,</span><br><span class="line">      verbose: verbose,</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompileSnapshotCommand</span> <span class="keyword">extends</span> <span class="title">CompileSubcommandCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> jitSnapshotCmdName = <span class="string">&#x27;jit-snapshot&#x27;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> kernelCmdName = <span class="string">&#x27;kernel&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> commandName;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> help;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> fileExt;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> formatName;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  FutureOr&lt;<span class="built_in">int</span>&gt; run() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args = [];</span><br><span class="line">    args.add(<span class="string">&#x27;--snapshot-kind=<span class="subst">$formatName</span>&#x27;</span>);</span><br><span class="line">    args.add(<span class="string">&#x27;--snapshot=<span class="subst">$&#123;path.canonicalize(outputFile)&#125;</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> process = <span class="keyword">await</span> startDartProcess(sdk, args);</span><br><span class="line">    <span class="keyword">return</span> process.exitCode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Web平台"><a href="#Web平台" class="headerlink" title="Web平台"></a>Web平台</h3><p>dart支持在Web平台上执行，既不是JIT也不是AOT：生成JavaScript代码，运行在浏览器中，而不是目标平台代码</p>
<ol>
<li>开发阶段使用<code>dartdevc</code>增量式编译器</li>
<li>生产环境使用<code>dart2js</code>编译器，高版本替换为<code>dart compile js</code>命令</li>
</ol>
<p>官方建议使用<a href="https://dart.dev/tools/webdev">webdev</a>工具，而不是直接使用<code>dartdevc</code>和<code>dart2js</code>工具。</p>
<ul>
<li><code>webdev serve</code>：编译并部署到开发服务器，使用<code>localhost:8080</code>访问。默认使用<code>dartdevc</code>编译。添加<code>--release</code>选项，替换为<code>dart2js</code>编译</li>
<li><code>webdev build</code>：默认使用<code>dart2js</code>，添加<code>--no-release</code>选项，替换为<code>dartdevc</code>编译</li>
</ul>
<h2 id="Dart项目文件"><a href="#Dart项目文件" class="headerlink" title="Dart项目文件"></a>Dart项目文件</h2><p>Dart使用<code>pubspec.yaml</code>文件保存项目信息、发布信息、依赖包等。<a href="https://dart.dev/tools/pub/pubspec">pubspec说明</a></p>
<blockquote>
<p>类似npm的<code>package.json</code>，本地会缓存依赖包，不同项目可以共用本地缓存的依赖包</p>
</blockquote>
<p>可以使用<code>dart pub &lt;subcommand&gt;</code>命令管理项目，如add添加依赖，get获取依赖等。可以用<code>dart pub -h</code>查看帮助，也可以看<a href="https://dart.dev/tools/pub/cmd">dart pub说明</a></p>
<blockquote>
<p><strong>如果用dart开发Flutter程序，使用<code>flutter pub &lt;subcommand&gt;</code>命令替代，flutter对dart命令进行了一层包装</strong></p>
</blockquote>
<p>新建<code>pubspec.yaml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">myapp</span> <span class="comment"># 项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span> <span class="comment"># dart版本</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&quot;&gt;=2.12.0 &lt;3.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span>  <span class="comment"># 依赖包</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">^0.6.0</span></span><br></pre></td></tr></table></figure>

<p>执行<code>dart pub get</code>获取依赖，会生成几个文件。不需要提交，加到<code>.gitignore</code>中</p>
<ol>
<li><code>pubspec.lock</code>：保存项目信息</li>
<li><code>.packages</code>：已经弃用，替换为<code>package_config.json</code>文件</li>
<li><code>.dart_tool/package_config.json</code>：将依赖包映射到系统缓存该包的路径</li>
</ol>
<p><code>main.dart</code>中可以导入包使用，运行时会从<code>package_config.json</code>中查找依赖包路径</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:js/js.dart&#x27;</span> <span class="keyword">as</span> js;</span><br></pre></td></tr></table></figure>

<p><code>dart compile</code>和<code>dart --snapshot</code>可以使用<code>--packages=&lt;path&gt;</code>选项指定<code>.packages</code>文件或者<code>package_config.json</code>文件，用于编译时查找依赖包路径</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>了解Dart编译方式和产物，以及执行原理，可以为动态化，分包等提供一些思路，甚至修改虚拟机、编译器等。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://dart.dev/overview">Dart官网</a></li>
<li><a href="https://mrale.ph/dartvm/">Introduction to Dart VM</a></li>
<li><a href="https://github.com/dart-lang/sdk/wiki">Dart Wiki</a></li>
<li><a href="https://www.jianshu.com/p/a5b1997a01ba">Dart VM介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>提问的智慧</title>
    <url>/2021/12/30/reader-2021-12-30-%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    <content><![CDATA[<p>//todo</p>
<p>原文链接：<a href="http://linuxmafia.com/faq/Essays/smart-questions.html">http://linuxmafia.com/faq/Essays/smart-questions.html</a></p>
<p><a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr/faqs/smart-questions.html</a></p>
<p><a href="https://ld246.com/article/1536377163156">https://ld246.com/article/1536377163156</a></p>
<p><a href="https://blog.csdn.net/qq_34804120/article/details/89117072">https://blog.csdn.net/qq_34804120/article/details/89117072</a></p>
<p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way</a></p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>ButterKnife解析</title>
    <url>/2021/12/09/android-2021-12-09-ButterKnife/</url>
    <content><![CDATA[<h1 id="ButterKnife介绍"><a href="#ButterKnife介绍" class="headerlink" title="ButterKnife介绍"></a>ButterKnife介绍</h1><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><p><strong>已经废弃，建议切换至View Binding</strong></p>
<p>功能：使用源码注解+APT生成模版代码，进行Android视图变量和事件绑定。简化代码，提高可读性，编译时注解不会影响APP效率。</p>
<ul>
<li>视图绑定：成员变量使用<code>@BindView</code>注解避免调用<code>findViewById</code>。</li>
<li>资源绑定：字段上使用<code>@BindString、@BindColor、@BindDrawable</code>等注解，避免资源查找。</li>
<li>事件绑定：方法使用<code>@OnClick、onTextChanged</code>等注解，避免绑定监听器、创建匿名内部类。</li>
<li>绑定视图数组或列表，批量执行Action行为。<code>ViewCollections.run</code></li>
</ul>
<blockquote>
<p>运行时反射解析注解赋值，影响性能。（注解使用RUNTIME）</p>
<p>使用编译时注解+APT生成模版代码，运行时调用<code>ButterKnife.bind(...)</code>注入字段。（注解使用CLASS）</p>
<p>由于编译时处理注解较耗时，调试效率低。因此提供了两种实现，调试阶段可以使用反射，发布阶段使用编译时注解。（注解使用RUNTIME）</p>
</blockquote>
<p>项目结构如下：</p>
<p><img src="/2021/12/09/android-2021-12-09-ButterKnife/ButterKnife%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  <span class="comment">// Butterknife requires Java 8.</span></span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">&#x27;com.jakewharton:butterknife:10.2.3&#x27;</span> <span class="comment">//添加注解依赖</span></span><br><span class="line">  annotationProcessor <span class="string">&#x27;com.jakewharton:butterknife-compiler:10.2.3&#x27;</span> <span class="comment">//添加注解处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterknifeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字段不能是private或者static。否则编译会报错: @BindView fields must not be private or static.</span></span><br><span class="line">    <span class="meta">@BindView(R.id.btn1)</span></span><br><span class="line">    <span class="keyword">public</span> Button button1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_butterknife);</span><br><span class="line">        <span class="comment">//绑定activity</span></span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">        button1.setText(<span class="string">&quot;I am a button &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>bind必须在setContentView之后</li>
<li>父类bind后，子类不需要再bind</li>
<li>Fragment中使用需要传入rootView、onDestroyView中需要unbind</li>
<li>高版本AGP需要使用R2引用资源id</li>
<li>View不能使用private或static修饰，否则编译会报错</li>
</ol>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2021/12/09/android-2021-12-09-ButterKnife/ButterKnife%E5%8E%9F%E7%90%86.png"></p>
<ol>
<li>自定义注解和注解处理器</li>
<li>使用注解</li>
<li>编译时<code>butterknife-gradle-plugin</code>根据R文件生成R2文件</li>
<li>执行<code>butterknife-compile</code>APT，解析注解</li>
<li>使用JavaPoet生成XXX_ViewBinding类</li>
<li>运行时调用<code>ButterKnife.bind(...)</code>。<strong>需要使用者手动调用代理类执行，或者通过门面对象，反射找到代理类并执行</strong></li>
<li>反射实例化SimpleActivity_ViewBinding类</li>
<li>在构造方法中完成对Activity的View的绑定。</li>
</ol>
<h1 id="ButterKnife源码解析"><a href="#ButterKnife源码解析" class="headerlink" title="ButterKnife源码解析"></a>ButterKnife源码解析</h1><p>只分析View绑定部分，以Activity为例。（只保留关键代码，先源码太长，可以直接看小结部分）。</p>
<h2 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h2><ol>
<li>首先看下我们使用ButterKnife的代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="comment">//绑定视图</span></span><br><span class="line">  <span class="meta">@BindView(R.id.hello)</span> Button hello;</span><br><span class="line">  <span class="comment">//绑定监听器</span></span><br><span class="line">  <span class="meta">@OnClick(R.id.hello)</span> <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;Hello, views!&quot;</span>, LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.simple_activity);</span><br><span class="line">    <span class="comment">//进行绑定和字段注入</span></span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看<code>ButterKnife.bind(this)</code>源码，此方法有很多重载方法，区分不同目标类，如Activity、Fragment等</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnife</span> </span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(<span class="meta">@NonNull</span> Activity target)</span> </span>&#123;</span><br><span class="line">    View sourceView = target.getWindow().getDecorView();</span><br><span class="line">    <span class="comment">//构造并返回XXX_ViewBinding实例，用于主动调用unbind解除绑定</span></span><br><span class="line">    <span class="keyword">return</span> bind(target, sourceView);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(<span class="meta">@NonNull</span> Object target, <span class="meta">@NonNull</span> View source)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="comment">//根据Activity查找对应的ViewBinding类构造方法</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"> 	  <span class="comment">//实例化ViewBinding类，完成View绑定</span></span><br><span class="line">    <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">    <span class="comment">//省略异常处理...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>findBindingConstructorForClass</code>：查找对应的<code>XXX_ViewBinding</code>类构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnife</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Nullable</span> <span class="meta">@CheckResult</span> <span class="meta">@UiThread</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">    <span class="comment">//首先在缓存中查找，避免重复反射loadClass，查找构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span> || BINDINGS.containsKey(cls)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="comment">//避免查找父类找到Android源码类</span></span><br><span class="line">    <span class="keyword">if</span> (clsName.startsWith(<span class="string">&quot;android.&quot;</span>) || clsName.startsWith(<span class="string">&quot;java.&quot;</span>) || clsName.startsWith(<span class="string">&quot;androidx.&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//拼接类名，loadClass加载类对象</span></span><br><span class="line">      Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + <span class="string">&quot;_ViewBinding&quot;</span>);</span><br><span class="line">      <span class="comment">//反射获取到XXX_ViewBinding构造方法</span></span><br><span class="line">      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">//查找父类</span></span><br><span class="line">      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//省略异常处理...</span></span><br><span class="line">    <span class="comment">//缓存构造函数</span></span><br><span class="line">    <span class="comment">//此处不是缓存ViewBinding实例，而是缓存构造方法，下次进入需要重新创建实例。</span></span><br><span class="line">    <span class="comment">//由于ViewBinding会持有Activity对象，如果缓存实例，会导致无法释放</span></span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看<code>XXX_ViewBinding</code>源码，位于<code>build/generated/source/apt/</code>之下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity_ViewBinding</span> <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">  <span class="comment">//持有目标类引用</span></span><br><span class="line">  <span class="keyword">private</span> SimpleActivity target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> View view7f08001e;</span><br><span class="line">  <span class="comment">//重载构造方法</span></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleActivity_ViewBinding</span><span class="params">(SimpleActivity target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(target, target.getWindow().getDecorView());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果需要绑定监听器，target需要声明为final，供匿名内部类使用</span></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> SimpleActivity target, View source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">//findViewById并强制转换，注入Activity field，变量不能使用private或static，否则无法访问</span></span><br><span class="line">    View view;</span><br><span class="line">    view = Utils.findRequiredView(source, R.id.hello, <span class="string">&quot;field &#x27;hello&#x27; and method &#x27;sayHello&#x27;&quot;</span>);</span><br><span class="line">    target.hello = Utils.castView(view, R.id.hello, <span class="string">&quot;field &#x27;hello&#x27;&quot;</span>, Button.class);</span><br><span class="line">    view7f08001e = view;</span><br><span class="line">    <span class="comment">//使用DebouncingOnClickListener，内部实现了防抖</span></span><br><span class="line">    view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">        target.sayHello();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//外部主动调用，解除绑定，如fragment onDestroyView中调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleActivity target = <span class="keyword">this</span>.target;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Bindings already cleared.&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line">    target.hello = <span class="keyword">null</span>;</span><br><span class="line">    view7f08001e.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line">    view7f08001e = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结一下：</strong></p>
<ol>
<li>调用<code>ButterKnife.bind</code></li>
<li>拼接类名，使用ClassLoader加载<code>XXX_ViewBinding</code>类并缓存构造方法。（<strong>此处不是缓存ViewBinding实例，而是缓存构造方法，下次进入需要重新创建实例。由于ViewBinding会持有Activity对象，如果缓存实例，会导致无法释放</strong>）</li>
<li>反射创建实例</li>
<li>在构造方法中访问rootView查找View，访问Activity对象给字段赋值，或者添加监听器。并对@OnClick事件绑定做了防抖</li>
<li>返回Unbinder对象，供调用方主动解绑</li>
</ol>
<h2 id="注解解析步骤"><a href="#注解解析步骤" class="headerlink" title="注解解析步骤"></a>注解解析步骤</h2><p>上面解释了依赖注入原理，下面看看<code>XXX_ViewBinding</code>是如何生成的？</p>
<p>查看 <code>butterknife-compiler</code> 下的<code>ButterKnifeProcessor</code>类</p>
<ol>
<li>注解处理器均需要继承<code>AbstractProcessor</code>，<code>init</code>方法做初始化工作，<code>getSupportedAnnotationTypes</code>筛选需要处理的注解，<code>process</code>方法开始注解处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主要对辅助类进行初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//筛选需要处理的注解类型，也可通过@SupportedAnnotationTypes注解过滤</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span><br><span class="line">      types.add(annotation.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> types;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开始处理注解</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TypeElement表示一个类或接口，BindingSet包含需要生成的类的所有信息，用于生成java文件对象</span></span><br><span class="line">    Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);</span><br><span class="line">    <span class="comment">//遍历生成java文件 </span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</span><br><span class="line">      TypeElement typeElement = entry.getKey();</span><br><span class="line">      BindingSet binding = entry.getValue();</span><br><span class="line">      <span class="comment">//利用JavaPoet生成java文件对象，即XXX_ViewBinding.java</span></span><br><span class="line">      JavaFile javaFile = binding.brewJava(sdk, debuggable);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//写入文件</span></span><br><span class="line">        javaFile.writeTo(filer);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//使用processingEnv.getMessager()打印编译日志</span></span><br><span class="line">        error(typeElement, <span class="string">&quot;Unable to write binding for type %s: %s&quot;</span>, typeElement, e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>findAndParseTargets</code>方法：查找并解析目标注解，构建需要生成的类信息，存入Map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; <span class="title">findAndParseTargets</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key为类，值为需要绑定的成员变量或方法集合</span></span><br><span class="line">    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">//省略其他注解处理...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到所有@BindView注解的元素</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析注解和成员变量信息，加入到对应类的builder中</span></span><br><span class="line">        parseBindView(element, builderMap, erasedTargetNames);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logParsingError(element, BindView.class, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略遍历查找父类binder...</span></span><br><span class="line">    <span class="keyword">return</span> bindingMap;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>parseBindView</code>方法：解析<code>@BindView</code>注解的元素，存入对应类的<code>BindingSet.Builder</code>中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBindView</span><span class="params">(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</span></span></span><br><span class="line"><span class="function"><span class="params">      Set&lt;TypeElement&gt; erasedTargetNames)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取Field的父元素，即类，如Activity、Fragment、ViewHolder等</span></span><br><span class="line">    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查元素是否可达：</span></span><br><span class="line">    <span class="comment">//1. 字段不能为private或static，父元素为类、且类不能为private</span></span><br><span class="line">    <span class="comment">//2. 类不属于Android源码包</span></span><br><span class="line">    <span class="keyword">boolean</span> hasError = isInaccessibleViaGeneratedCode(BindView.class, <span class="string">&quot;fields&quot;</span>, element)</span><br><span class="line">        || isBindingInWrongPackage(BindView.class, element);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略检查元素是否继承自View...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注解值，即View的id</span></span><br><span class="line">    <span class="keyword">int</span> id = element.getAnnotation(BindView.class).value();</span><br><span class="line">    BindingSet.Builder builder = builderMap.get(enclosingElement);</span><br><span class="line">    <span class="comment">//解析为Id，通过Trees访问抽象语法树，保存id的值和对应的代码，如R.id.btn</span></span><br><span class="line">    Id resourceId = elementToId(element, BindView.class, id);</span><br><span class="line">    <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String existingBindingName = builder.findExistingBindingName(resourceId);</span><br><span class="line">      <span class="comment">//该资源id已经被绑定过了，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (existingBindingName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(element, <span class="string">&quot;Attempt to use @%s for an already bound ID %d on &#x27;%s&#x27;. (%s.%s)&quot;</span>,</span><br><span class="line">            BindView.class.getSimpleName(), id, existingBindingName,</span><br><span class="line">            enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果已经有对应类的builder，则直接返回。没有的话就新建一个builder，加入到map中。</span></span><br><span class="line">      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量名称</span></span><br><span class="line">    String name = simpleName.toString();</span><br><span class="line">    <span class="comment">//变量类型</span></span><br><span class="line">    TypeName type = TypeName.get(elementType);</span><br><span class="line">    <span class="comment">//变量是否有@Nullable注解</span></span><br><span class="line">    <span class="keyword">boolean</span> required = isFieldRequired(element);</span><br><span class="line">    <span class="comment">//builder中添加需要绑定的field信息</span></span><br><span class="line">    builder.addField(resourceId, <span class="keyword">new</span> FieldViewBinding(name, type, required));</span><br><span class="line">    <span class="comment">// Add the type-erased version to the valid binding targets set.</span></span><br><span class="line">    erasedTargetNames.add(enclosingElement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>BindingSet.newBuilder</code>方法：构建类基本信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingSet</span> <span class="keyword">implements</span> <span class="title">BindingInformationProvider</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">(TypeElement enclosingElement)</span> </span>&#123;</span><br><span class="line">    TypeMirror typeMirror = enclosingElement.asType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isView = isSubtypeOfType(typeMirror, VIEW_TYPE);</span><br><span class="line">    <span class="keyword">boolean</span> isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE);</span><br><span class="line">    <span class="keyword">boolean</span> isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE);</span><br><span class="line"></span><br><span class="line">    TypeName targetType = TypeName.get(typeMirror);</span><br><span class="line">    <span class="comment">//如果是泛型，则使用真实类型</span></span><br><span class="line">    <span class="keyword">if</span> (targetType <span class="keyword">instanceof</span> ParameterizedTypeName) &#123;</span><br><span class="line">      targetType = ((ParameterizedTypeName) targetType).rawType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成JavaPoet类名对象</span></span><br><span class="line">    ClassName bindingClassName = getBindingClassName(enclosingElement);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder(targetType, bindingClassName, enclosingElement, isFinal, isView, isActivity,</span><br><span class="line">        isDialog);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//得到XXX_ViewBinding类名</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> ClassName <span class="title">getBindingClassName</span><span class="params">(TypeElement typeElement)</span> </span>&#123;</span><br><span class="line">    String packageName = getPackage(typeElement).getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//如果为内部类，如Adapter.ViewHolder，会返回Adapter$ViewHolder_ViewBinding</span></span><br><span class="line">    String className = typeElement.getQualifiedName().toString().substring(</span><br><span class="line">            packageName.length() + <span class="number">1</span>).replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> ClassName.get(packageName, className + <span class="string">&quot;_ViewBinding&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaPoet生成Java文件对象"><a href="#JavaPoet生成Java文件对象" class="headerlink" title="JavaPoet生成Java文件对象"></a>JavaPoet生成Java文件对象</h2><p>这一部分简单了解一下即可，挑一部分讲，具体API使用可以看<a href="https://github.com/square/javapoet">官方文档</a>。</p>
<ol>
<li><code>binding.brewJava</code>方法：下面代码主要是使用<code>JavaPoet</code>生成Java文件对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingSet</span> <span class="keyword">implements</span> <span class="title">BindingInformationProvider</span> </span>&#123;</span><br><span class="line">  <span class="function">JavaFile <span class="title">brewJava</span><span class="params">(<span class="keyword">int</span> sdk, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    TypeSpec bindingConfiguration = createType(sdk, debuggable);</span><br><span class="line">    <span class="comment">//生成JavaPoet文件对象</span></span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(bindingClassName.packageName(), bindingConfiguration)</span><br><span class="line">        .addFileComment(<span class="string">&quot;Generated code from Butter Knife. Do not modify!&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建类型</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TypeSpec <span class="title">createType</span><span class="params">(<span class="keyword">int</span> sdk, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TypeSpec用于生成类或接口。除此之外还有MethodSpec等</span></span><br><span class="line">    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())</span><br><span class="line">        .addModifiers(PUBLIC)</span><br><span class="line">        .addOriginatingElement(enclosingElement);</span><br><span class="line">    <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">      <span class="comment">//添加final修饰符</span></span><br><span class="line">      result.addModifiers(FINAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//extends父类</span></span><br><span class="line">      result.superclass(parentBinding.getBindingClassName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//implement UnBinder接口</span></span><br><span class="line">      result.addSuperinterface(UNBINDER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加target字段，即Activity对象，需要给target的成员变量赋值</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">      result.addField(targetTypeName, <span class="string">&quot;target&quot;</span>, PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据类型生成不同的重载构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (isView) &#123;</span><br><span class="line">      result.addMethod(createBindingConstructorForView());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isActivity) &#123;</span><br><span class="line">      result.addMethod(createBindingConstructorForActivity());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDialog) &#123;</span><br><span class="line">      result.addMethod(createBindingConstructorForDialog());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constructorNeedsView()) &#123;</span><br><span class="line">      <span class="comment">// Add a delegating constructor with a target type + view signature for reflective use.</span></span><br><span class="line">      result.addMethod(createBindingViewDelegateConstructor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加构造函数</span></span><br><span class="line">    result.addMethod(createBindingConstructor(sdk, debuggable));</span><br><span class="line">    <span class="comment">//重写unbind方法</span></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings() || parentBinding == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result.addMethod(createBindingUnbindMethod(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>createBindingConstructor</code>方法：生成<code>XXX_ViewBinding</code>类的构造函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingSet</span> <span class="keyword">implements</span> <span class="title">BindingInformationProvider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> MethodSpec <span class="title">createBindingConstructor</span><span class="params">(<span class="keyword">int</span> sdk, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用MethodSpec生成方法</span></span><br><span class="line">    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()</span><br><span class="line">        .addAnnotation(UI_THREAD)</span><br><span class="line">        .addModifiers(PUBLIC);</span><br><span class="line">    <span class="comment">//添加target参数</span></span><br><span class="line">    <span class="keyword">if</span> (hasMethodBindings()) &#123;</span><br><span class="line">      <span class="comment">//需要绑定事件监听，则target要声明为final，因为匿名内部类会引用</span></span><br><span class="line">      constructor.addParameter(targetTypeName, <span class="string">&quot;target&quot;</span>, FINAL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      constructor.addParameter(targetTypeName, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加source参数</span></span><br><span class="line">    <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">      constructor.addParameter(VIEW, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      constructor.addParameter(CONTEXT, <span class="string">&quot;context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略添加SuppressWarnings注解代码...</span></span><br><span class="line">    <span class="comment">//如果有父类，需要调用父类构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parentBinding.constructorNeedsView()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;super(target, source)&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;super(target, source.getContext())&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;super(target, context)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      constructor.addCode(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给target字段赋值</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">      constructor.addStatement(<span class="string">&quot;this.target = target&quot;</span>);</span><br><span class="line">      constructor.addCode(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定视图</span></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasViewLocal()) &#123;</span><br><span class="line">        <span class="comment">// Local variable in which all views will be temporarily stored.</span></span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$T view&quot;</span>, VIEW);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//遍历添加视图绑定</span></span><br><span class="line">      <span class="keyword">for</span> (ViewBinding binding : viewBindings) &#123;</span><br><span class="line">        addViewBinding(constructor, binding, debuggable);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (FieldCollectionViewBinding binding : collectionBindings) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$L&quot;</span>, binding.render(debuggable));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">        constructor.addCode(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定资源</span></span><br><span class="line">    <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$T context = source.getContext()&quot;</span>, CONTEXT);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (hasResourceBindingsNeedingResource(sdk)) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$T res = context.getResources()&quot;</span>, RESOURCES);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (ResourceBinding binding : resourceBindings) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">&quot;$L&quot;</span>, binding.render(sdk));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructor.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>addViewBinding</code>方法：添加视图绑定代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingSet</span> <span class="keyword">implements</span> <span class="title">BindingInformationProvider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewBinding</span><span class="params">(MethodSpec.Builder result, ViewBinding binding, <span class="keyword">boolean</span> debuggable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (binding.isSingleFieldBinding()) &#123;</span><br><span class="line">      <span class="comment">// 如果只需要绑定字段，则直接查找View，并给target的字段赋值</span></span><br><span class="line">      <span class="comment">//省略添加findViewById代码块...</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//findViewById，并保存为局部变量</span></span><br><span class="line">    List&lt;MemberViewBinding&gt; requiredBindings = binding.getRequiredBindings();</span><br><span class="line">    <span class="keyword">if</span> (!debuggable || requiredBindings.isEmpty()) &#123;</span><br><span class="line">      result.addStatement(<span class="string">&quot;view = source.findViewById($L)&quot;</span>, binding.getId().code);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!binding.isBoundToRoot()) &#123;</span><br><span class="line">      result.addStatement(<span class="string">&quot;view = $T.findRequiredView(source, $L, $S)&quot;</span>, UTILS,</span><br><span class="line">          binding.getId().code, asHumanDescription(requiredBindings));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给target的字段赋值，并进行强制转换</span></span><br><span class="line">    addFieldBinding(result, binding, debuggable);</span><br><span class="line">    <span class="comment">//绑定监听器，并调用target中注解的方法</span></span><br><span class="line">    addMethodBindings(result, binding, debuggable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结一下：</strong></p>
<ol>
<li>通过继承<code>AbstractProcessor</code>定义注解处理器，重写<code>getSupportedAnnotationTypes()</code>方法筛选需要处理的注解，重写<code>process</code>方法处理注解。</li>
<li>使用<code>javax.lang.model</code>包下的类来解析Java代码。自定义解析规则，如<ol>
<li>找到所有注解过的元素</li>
<li>解析元素：变量类型、变量名，变量修饰符，注解类型，注解值等</li>
<li>检查元素合法性：如是否为private或static、是否继承自View、是否是成员变量等</li>
<li>…</li>
</ol>
</li>
<li>自定义<code>BindingSet</code>类保存需要生成的<code>ViewBinding</code>类的信息。</li>
<li>使用<code>JavaPoet</code>库的API生成Java文件对象。</li>
<li>最后使用<code>Filer</code>类写入文件。</li>
</ol>
<h2 id="APT如何找到自定义注解处理器？"><a href="#APT如何找到自定义注解处理器？" class="headerlink" title="APT如何找到自定义注解处理器？"></a>APT如何找到自定义注解处理器？</h2><p>APT是如何找到自定义的<code>ButterKnifeProcessor</code>注解处理器并执行的呢？</p>
<blockquote>
<p>使用了JavaSPI（Service Provider Interface，服务发现接口）机制。关于JavaSPI机制可以阅读<a href="/2021/12/06/architecture-2021-12-06-SPI/">另一篇文章</a></p>
</blockquote>
<p>原理：APT运行的时候加载Processor接口，通过<code>ServiceLoader</code>读取services下的服务文件，找到Processor接口的实现类（可以有多个），遍历初始化和执行多个注解处理器。（类似于<code>AndroidManifest</code>注册组件）</p>
<p>具体介绍和配置可以参考<a href="/2021/12/08/tech-2021-12-08-APT/">APT介绍和实践</a></p>
<h2 id="增量注解处理器"><a href="#增量注解处理器" class="headerlink" title="增量注解处理器"></a>增量注解处理器</h2><p>注意到<code>ButterKnife</code>中还依赖了一个<code>incap</code>的库，并且使用了它的注解<code>@IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.DYNAMIC)</code>。</p>
<blockquote>
<p>Gradle支持配置增量注解处理器，通过在<code>main</code>目录下新建<code>resources/META-INF/gradle/incremental.annotation.processors</code>文件进行配置</p>
<p>这个库实际上就是通过注解+APT自动帮我们生成了配置文件</p>
</blockquote>
<p>具体介绍和可以参考<a href="/2021/12/08/tech-2021-12-08-APT/">APT介绍和实践</a></p>
<h1 id="Android视图绑定历程"><a href="#Android视图绑定历程" class="headerlink" title="Android视图绑定历程"></a>Android视图绑定历程</h1><h2 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h2><p>原始方式，需要在Activity、Fragment中编写大量重复代码</p>
<h2 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h2><p><strong>已经被宣布废弃</strong>。</p>
<p>通过源码注解+APT方式生成XXX_ViewBinding类，并在onCreate调用<code>ButterKnife.bind(...)</code>注入字段。</p>
<p>ButterKnife存在问题：高版本AGP（Android Gradle Plugin）生成的R文件不再是常量（模块化中可能和三方库产生id冲突），而编译时注解要求在编译期就确定值。因此在Library模块中会编译失败。</p>
<p>可以添加ButterKnife提供的插件，生成R2资源id解决。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 根目录 build.gradle引入插件</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">	dependencies &#123;</span><br><span class="line">		classpath <span class="string">&#x27;com.jakewharton:butterknife-gradle-plugin:10.2.3&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. library模块build.gradle应用插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.jakewharton.butterknife&#x27;</span> <span class="comment">//生成R2资源id</span></span><br><span class="line"><span class="comment">//3. 代码中使用R2替代R引用资源id</span></span><br></pre></td></tr></table></figure>

<h2 id="KAE（Kotlin-Android-Extensions）"><a href="#KAE（Kotlin-Android-Extensions）" class="headerlink" title="KAE（Kotlin Android Extensions）"></a>KAE（Kotlin Android Extensions）</h2><p><strong>已经被宣布废弃</strong>。</p>
<p>使用方式：<code>build.gradle</code>添加插件即可<code>apply plugin: &#39;kotlin-android-extensions&#39;</code></p>
<p>原理：通过Gradle插件生成findViewById代码，并使用HashMap缓存控件。</p>
<p>反编译成java代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> HashMap _$_findViewCache;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      <span class="keyword">this</span>.setContentView(<span class="number">1300023</span>);</span><br><span class="line">      TextView var10000 = (TextView)<span class="keyword">this</span>._$_findCachedViewById(id.textView);</span><br><span class="line">      var10000.setText((CharSequence)<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> View _$_findCachedViewById(<span class="keyword">int</span> var1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._$_findViewCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache = <span class="keyword">new</span> HashMap();</span><br><span class="line">      &#125;</span><br><span class="line">      View var2 = (View)<span class="keyword">this</span>._$_findViewCache.get(var1);</span><br><span class="line">      <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">         var2 = <span class="keyword">this</span>.findViewById(var1);</span><br><span class="line">         <span class="keyword">this</span>._$_findViewCache.put(var1, var2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> var2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<ul>
<li>类型安全：res下的任何id都可以被访问，有可能因访问了非当前Layout下的id而出错，难以利用lint等静态代码校验</li>
<li>空安全：运行时可能出现NPE</li>
<li>兼容性：只能在kotlin中使用，java不友好</li>
<li>局限性：不能跨module使用</li>
<li><code>RecyclerView.Adapter onBindiViewHolder</code>中直接使用，会生成findViewById代码，丧失ViewHolder复用优势</li>
</ul>
<h2 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h2><p><a href="https://developer.android.com/topic/libraries/view-binding">官方文档</a>。内置Gradle插件，根据layout布局文件生成XXXBinding类。</p>
<p>与findViewById相比：ViewBinding能保证空安全、类型安全。</p>
<p>与DataBinding相比：ViewBinding更轻量，但不支持布局变量和布局表达式，不支持数据绑定</p>
<p>使用方式如下：</p>
<ol>
<li>启动ViewBinding功能</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Android Studio3.6以上，按模块启用build.gradle配置</span></span><br><span class="line">android &#123;</span><br><span class="line">	viewBinding &#123;</span><br><span class="line">		enabled = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写layout布局文件，build生成Binding类。如果想忽略布局文件，可以添加属性<code>tools:viewBindingIgnore=&quot;true&quot;</code></li>
<li>代码中使用</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> <span class="title">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要build之后才能生成Binding类</span></span><br><span class="line">		<span class="keyword">private</span> ResultProfileBinding binding;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View onCreateView (LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">        binding = ResultProfileBinding.inflate(inflater, container, <span class="literal">false</span>);</span><br><span class="line">        View view = binding.getRoot();</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onDestroyView() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">      	<span class="comment">//在Fragment中使用，onDestroyView的时候需要释放binding对象。</span></span><br><span class="line">        binding = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="未来？"><a href="#未来？" class="headerlink" title="未来？"></a>未来？</h2><p>响应式布局。最好的视图绑定就是不需要findViewById</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>APT</tag>
      </tags>
  </entry>
  <entry>
    <title>注解、APT介绍和实践</title>
    <url>/2021/12/08/android-2021-12-08-APT/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按运行机制分：通过@Retention注解进行分类</p>
<blockquote>
<ul>
<li>源码注解：只在源码中存在。RetentionPolicy.SOURCE，编译为class字节码之后丢失</li>
<li>编译时注解：在class中依然存在，RetentionPolicy.CLASS。</li>
<li>运行时注解：运行阶段可见，RetentionPolicy.RUNTIME。</li>
</ul>
</blockquote>
<p>按来源分：</p>
<blockquote>
<ul>
<li>JDK自带注解<ul>
<li>内置注解：如@Override，@Deprecated、@SurpressWarnings等</li>
<li>元注解：用于修饰其他注解<ul>
<li>@Retention：注解作用域（可见性、保留策略），分为SOURCE、CLASS（默认策略）、RUNTIME</li>
<li>@Target：注解作用对象，未指定时可以作用在任何元素上。可以传入数组，如<code>@Target(&#123;TYPE, Field, ...&#125;)</code></li>
<li>@Document：可以使用javadoc工具生成文档</li>
<li>@Inherited：父类使用了@Inherited修饰的注解，子类也会继承该注解。<ul>
<li>接口使用了@Inherited修饰的注解，实现类不会继承该注解</li>
<li>父类方法使用了@Inherited修饰的注解，子类不会继承该注解</li>
</ul>
</li>
<li>@Repeatable：JDK1.8之后引入。表示一个注解可以在一个元素上使用多次</li>
</ul>
</li>
</ul>
</li>
<li>三方注解：三方库提供的注解。如Hibernate，Struts，ButterKnife，ARouter等</li>
<li>自定义注解</li>
</ul>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>同class、interface一样，注解也是一种类型。</p>
<p>使用@interface关键字定义，不支持继承其他注解或接口，会自动继承Annotation接口。示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">//声明可被javadoc生成文档</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//声明作用域</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span> <span class="comment">//声明可修饰对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  <span class="comment">//注解参数，支持数据类型：基本数据类型、String类型、Class类型、enum类型、Annotation类型，以及相应的数组类型</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//可以定义默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li>IDE检测和提示编码错误或警告</li>
<li>编译时处理：通过APT检测注解，生成代码、文档等（注解作用域：SOURCE、CLASS）。会增加代码量</li>
<li>运行时处理：反射解析注解，反射修改变量、调用方法等（注解作用域：RUNTIME）。会影响性能</li>
</ol>
<p>需要注意的是：<strong>注解本身没有作用，只是一个标签，需要编写代码来提取和处理注解信息，简称APT（Annotation Processing Tool，注解处理器）</strong></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>JUnit</li>
<li>Android Annotations：配合IDE和Lint工作<ol>
<li>防止代码混淆：@Keep</li>
<li>检查资源类型：@ColorRes</li>
<li>参数是否可空：@Nullable、@NonNull</li>
<li>指定方法需要在特定线程执行：@UiThread、@MainThread、@WorkThread、@BinderThread</li>
<li>限定取值范围：@IntRange、@Size（数组或集合大小）</li>
<li>权限检查：@RequiresPermission</li>
<li>使用@IntDef或@StringDef替代枚举：见下例。</li>
</ol>
</li>
<li>ButterKnife：高版本AGP（Android Gradle Plugin）生成的R文件不再是常量。可以添加ButterKnife提供的插件，生成R2资源id解决。</li>
<li>Dagger</li>
<li>DataBinding</li>
<li>EventBus3</li>
<li>DBFlow</li>
<li>Retrofit</li>
<li>…</li>
</ol>
<h3 id="使用-IntDef或-StringDef替代枚举"><a href="#使用-IntDef或-StringDef替代枚举" class="headerlink" title="使用@IntDef或@StringDef替代枚举"></a>使用@IntDef或@StringDef替代枚举</h3><p><strong>一般我们使用枚举来限制取值，但是枚举最终会生成对象，比常量占用更多内存</strong>。</p>
<p>源码中如View的<code>VISIBLE/INVISIBLE/GONE、FOCUSABLE/NOT_FOCUSABLE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//1. 定义可用常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//&#123;...省略部分&#125;</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//2. 定义注解，使用@IntDef限制可用常量</span></span><br><span class="line">    <span class="meta">@IntDef(&#123;SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> WeekDays &#123;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//3. 限制变量、参数、返回值等为@WeekDays定义的常量。否则编译器会报错</span></span><br><span class="line">    <span class="meta">@WeekDays</span></span><br><span class="line">    <span class="keyword">int</span> currentDay = SUNDAY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentDay</span><span class="params">(<span class="meta">@WeekDays</span> <span class="keyword">int</span> currentDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentDay = currentDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WeekDays</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentDay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行时注解实现findViewById功能"><a href="#运行时注解实现findViewById功能" class="headerlink" title="运行时注解实现findViewById功能"></a>运行时注解实现findViewById功能</h1><p>避免写大量的<code>findViewById</code>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> ViewInject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 运行时注入注解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewInjectUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectViews</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends Activity&gt; activityCls = activity.getClass(); <span class="comment">// 获取activity的Class</span></span><br><span class="line">        Field[] fields = activityCls.getDeclaredFields(); <span class="comment">// 通过Class获取activity的所有字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123; <span class="comment">// 遍历所有字段</span></span><br><span class="line">            <span class="comment">// 获取字段的注解，如果没有ViewInject注解，则返回null</span></span><br><span class="line">            ViewInject viewInject = field.getAnnotation(ViewInject.class);</span><br><span class="line">            <span class="keyword">if</span> (viewInject == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> viewId = viewInject.value(); <span class="comment">// 获取字段注解的参数，这就是我们传进去控件Id</span></span><br><span class="line">            <span class="keyword">if</span> (viewId == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 执行findViewById方法，返回View实例</span></span><br><span class="line">                <span class="comment">// 给变量赋值</span></span><br><span class="line">                field.set(activity, activity.findViewById(viewId));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. Activity中调用，解析注解给变量赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewInjectActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ViewInject(R.id.viewInjectBtn1)</span></span><br><span class="line">    <span class="keyword">private</span> Button mBtn1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ViewInject(R.id.viewInjectBtn2)</span></span><br><span class="line">    <span class="keyword">private</span> Button mBtn2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_view_inject);</span><br><span class="line">        <span class="comment">//运行时反射解析注解，给变量赋值</span></span><br><span class="line">        ViewInjectUtil.injectViews(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时注解看起来不难，为什么要使用编译时注解？</p>
<blockquote>
<p>运行时注解需要反射，项目复杂度越高，反射次数越多，性能较差。</p>
<p>编译时注解反射次数固定。</p>
</blockquote>
<h1 id="APT介绍"><a href="#APT介绍" class="headerlink" title="APT介绍"></a>APT介绍</h1><p>APT是javac的一个工具，可以在编译时扫描和处理注解，并生成java文件，参与编译。</p>
<p>原理：编译前端过程中javac进行词法分析和语法分析之后会生成<strong>抽象语法树（AST）</strong>，然后调用注解处理器（注解处理器相当于javac对外提供的插件），可以在这个阶段生成新的java文件。也可以<strong>直接修改抽象语法树</strong></p>
<blockquote>
<ul>
<li>编译前端：指Java源文件编译成class文件。</li>
<li>编译后端：class文件转为本地机器码</li>
</ul>
<p>详情见<a href="/2021/11/05/basic-2021-11-05-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/">编程语言、编译器和Android虚拟机</a></p>
</blockquote>
<p>APT特点：</p>
<ol>
<li>需要自定义APT处理器</li>
<li>需要手动拼接代理的代码：可以使用<a href="https://github.com/square/javapoet">JavaPoet</a>，调用API生成java源代码。如果是Kotlin，可以使用<a href="https://github.com/square/kotlinpoet">KotlinPoet</a></li>
<li>需要使用者手动调用代理类执行，或者通过门面对象，反射找到代理类并执行。如<code>ButterKnife.bind(this)</code></li>
<li>会生成大量代理类，导致类和方法数增多</li>
<li>无法直接在源文件中插入或修改代码，而是生成代理类。</li>
</ol>
<blockquote>
<p>其实也可以通过<code>tools.jar</code>库中的API（如JCTree、TreeMaker）直接操作抽象语法树，插入代码。</p>
<p>需要添加依赖包：<code>compileOnly files(org.gradle.internal.jvm.Jvm.current().getToolsJar())</code></p>
<p>可以参考<a href="https://fanmingyi.blog.csdn.net/article/details/113766921">Java Pluginable Annotation processing</a></p>
</blockquote>
<p>代表框架：DataBinding、Dagger2、ButterKnife、EventBus3、DBFlow</p>
<p>KAPT：Kotlin注解处理器。kotlin代码生成Java AST，然后交给javac APT处理注解。生成Kotlin代码无法再被Kotlin编译器编译。（不同版本KAPT原理有一些差异）</p>
<p>为什么不使用ASM等字节码框架？</p>
<blockquote>
<p>修改字节码复杂度较高，难以保证稳定，也不易于调试。</p>
<p>APT生成的Java类更好理解</p>
</blockquote>
<p><strong>下面介绍APT涉及到的相关知识点，内容较多，可以先跳到后面看<a href="#%E8%87%AA%E5%AE%9A%E4%B9%89APT%E6%AD%A5%E9%AA%A4">自定义APT步骤</a>，再回过头来看细节</strong></p>
<h2 id="AbstractProcessor介绍"><a href="#AbstractProcessor介绍" class="headerlink" title="AbstractProcessor介绍"></a>AbstractProcessor介绍</h2><p>自定义注解处理器需要继承<code>AbstractProcessor</code>，有几个关键的方法，如下</p>
<ol>
<li><code>init</code>：用于初始化变量</li>
<li><code>process</code>：最核心的方法，用于执行注解解析逻辑、生成文件。</li>
<li><code>getSupportedAnnotationTypes</code>：返回需要被处理的注解的<strong>完整类型名</strong>，其他注解会被过滤掉</li>
<li><code>getSupportedOptions</code>：返回注解处理器可以接收的参数。使用注解处理器的时候可以传入对应的参数值。</li>
<li><code>getSupportedSourceVersion</code>：返回支持的JDK版本</li>
</ol>
<p>其中<code>getSupportedAnnotationTypes</code>除了可以用返回值的方式指定之外，还可以用注解声明。<code>AbstractProcessor</code>中重写了该方法，反射解析对应的注解<code>@SupportedAnnotationTypes</code>，拿到注解的值然后返回。<code>getSupportedOptions</code>和<code>getSupportedSourceVersion</code>同理。</p>
<blockquote>
<p>Tips：简单的可以使用注解指定，传入完整的类型名。多个注解的时候还是通过代码返回列表，不容易出错，而且路径改变的时候可以跟着一起改。</p>
</blockquote>
<h2 id="注解处理器传入参数"><a href="#注解处理器传入参数" class="headerlink" title="注解处理器传入参数"></a>注解处理器传入参数</h2><ol>
<li>例如配置<code>@SupportedOptions(&quot;content&quot;)</code></li>
<li>使用注解处理器的时候，传入参数，gradle配置如下：</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// 在gradle文件中配置选项参数值（用于APT传参接收）</span></span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="attr">content:</span> <span class="string">&#x27;Hello World&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在注解处理器代码中通过<code>processingEnvironment.getOptions().get(&quot;content&quot;);</code>拿到参数使用</li>
</ol>
<h2 id="常用类和API"><a href="#常用类和API" class="headerlink" title="常用类和API"></a>常用类和API</h2><p>参考<a href="https://fanmingyi.blog.csdn.net/article/details/116274271">注解处理器常用类说明</a></p>
<h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a><code>Element</code></h3><p>位于<code>javax.lang.model.element.Element</code></p>
<p>Java文件是有规范和格式的，源代码有对应的结构体，主要包含以下几种元素（类似于XML文件中的DOM树）：</p>
<p><img src="/2021/12/08/android-2021-12-08-APT/Element%E6%8E%A5%E5%8F%A3%E7%B1%BB.png"></p>
<ol>
<li><code>PackageElement:</code>表示包。提供对有关包及其成员的信息的访问</li>
<li> <code>TypeElement:</code>表示类或接口程序元素。提供对有关类型及其成员的信息的访问。</li>
<li> <code>ExecutableElement:</code>表示某个类或接口的方法、构造方法或初始化程序</li>
<li> <code>VariableElement:</code>表示字段、enum常量、方法或构造方法参数、局部变量或异常参数</li>
<li><code>TypeParameterElement</code>：表示泛型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.afauria.sample.apt; <span class="comment">//PackageElement</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; <span class="comment">//TypeElement</span></span><br><span class="line">  <span class="keyword">private</span> String test = <span class="string">&quot;&quot;</span>; <span class="comment">//VariableElement</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">//ExecuteableElement</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 泛型：TypeParameterElement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用API：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>accept</td>
<td>访问者模式，传入<code>ElementVisitor</code>。用于访问该元素下的所有元素。根据元素类型进行访问</td>
</tr>
<tr>
<td>getEnclosedElements</td>
<td>获取该元素的所有<strong>直接</strong>子元素</td>
</tr>
<tr>
<td>getEnclosingElement</td>
<td>获取该元素的父元素</td>
</tr>
<tr>
<td>getKind</td>
<td>返回ElementKind枚举，例如VariableElement可以表示字段、参数等，通过ElementKind可以判断元素具体类型</td>
</tr>
<tr>
<td>getSimpleName</td>
<td>返回元素名字，如变量名，类名</td>
</tr>
<tr>
<td>getQualifiedName</td>
<td>获取全名</td>
</tr>
<tr>
<td>getModifiers</td>
<td>获取修饰符集合<code>Set&lt;Modifier&gt;</code>，如public、native、synchronized等</td>
</tr>
<tr>
<td>getParameters</td>
<td>获取方法参数列表List&lt;? extends VariableElement&gt;</td>
</tr>
<tr>
<td>getReturnType</td>
<td>获取方法返回值</td>
</tr>
<tr>
<td>asType</td>
<td>返回对应的TypeMirror</td>
</tr>
</tbody></table>
<h3 id="TypeMirror"><a href="#TypeMirror" class="headerlink" title="TypeMirror"></a><code>TypeMirror</code></h3><p>位于<code>javax.lang.model.type.TypeMirror</code></p>
<p><code>Element</code>只能表示Java文件结构，不能获取具体的Java类型，需要使用<code>TypeMirror</code>相关的类</p>
<p><img src="/2021/12/08/android-2021-12-08-APT/TypeMirror%E6%8E%A5%E5%8F%A3%E7%B1%BB.png"></p>
<p>常用API：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>accept</td>
<td>访问者模式，传入<code>TypeVisitor</code>。根据子类类型进行访问</td>
</tr>
<tr>
<td>getKind</td>
<td>返回具体类型。如boolean、String等</td>
</tr>
</tbody></table>
<h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><ol>
<li><code>javax.lang.model.util.Elements</code>：用于操作Element，可以通过<code>processingEnvironment.getElementUtils();</code>获取</li>
<li><code>javax.lang.model.util.getType</code>：用于操作TyoeMirror，可以通过<code>processingEnvironment.getTypeUtils();</code>获取</li>
<li><code>javax.annotation.processing.Messager</code>：用于输出信息，可以通过<code>processingEnvironment.getMessager();</code>获取，打印error并不会中断process执行，但是会导致编译失败，无法执行下一个Task。</li>
<li><code>javax.annotation.processing.Filer</code>：用于生成文件，可以通过<code>processingEnvironment.getFiler();</code>获取。新生成的文件分为三类，会被放到不同路径<ol>
<li><code>createSourceFile</code>：源代码文件</li>
<li><code>createClassFile</code>：类文件</li>
<li><code>createResource</code>：资源文件</li>
</ol>
</li>
</ol>
<h2 id="注册JavaSPI服务配置文件"><a href="#注册JavaSPI服务配置文件" class="headerlink" title="注册JavaSPI服务配置文件"></a>注册JavaSPI服务配置文件</h2><p>APT是如何找到我们自定义的<code>Processor</code>注解并执行的呢？</p>
<blockquote>
<p>使用了JavaSPI（Service Provider Interface，服务发现接口）机制。关于JavaSPI机制可以阅读<a href="/2021/12/06/architecture-2021-12-06-SPI/">另一篇文章</a></p>
</blockquote>
<p>APT运行的时候加载Processor接口，通过<code>ServiceLoader</code>读取services下的服务配置文件，找到Processor接口的实现类（可以有多个），<strong>遍历</strong>初始化和执行多个注解处理器。（类似于<code>AndroidManifest</code>注册组件）</p>
<p>有两种注册方式，如下：</p>
<h3 id="手动创建service文件"><a href="#手动创建service文件" class="headerlink" title="手动创建service文件"></a>手动创建service文件</h3><p>main目录下面新建<code>resources/META_INF/services/javax.annotation.processing.Processor</code>文件，在文件中写入完整的自定义注解处理器类名（配置多个注解处理器的时候需要换行）。如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">butterknife.compiler.ButterKnifeProcessor</span><br></pre></td></tr></table></figure>

<h3 id="使用AutoService库生成service文件"><a href="#使用AutoService库生成service文件" class="headerlink" title="使用AutoService库生成service文件"></a>使用AutoService库生成service文件</h3><p>原理：通过APT解析<code>@AutoSerivce</code>自动生成文件。</p>
<ol>
<li>添加依赖包和对应的注解处理器</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&quot;com.google.auto.service:auto-service-annotations:1.0&quot;</span> <span class="comment">//添加注解依赖包</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;com.google.auto.service:auto-service:1.0&quot;</span> <span class="comment">//添加注解处理器，使用compileOnly可以下载AutoService源码查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>@AutoService(Processor.class)</code>，即可自动生成SPI文件，如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Google提供的@AutoService注解</span></span><br><span class="line"><span class="comment">//自动生成/META_INF/services/javax.annotation.processing.Processor文件，并打包进jar包中</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【踩坑】：低版本<code>gradle</code>直接<code>compileOnly</code>依赖即可，会自动应用<code>annotationProcessor</code>，高版本<code>gradle</code>需要单独使用<code>annotationProcessor</code>配置注解处理器。</strong></p>
<h2 id="增量注解处理器"><a href="#增量注解处理器" class="headerlink" title="增量注解处理器"></a>增量注解处理器</h2><p>具体可以参考<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_compile">官方文档</a>、<a href="https://blog.csdn.net/qfanmingyiq/article/details/116300913">Gradle编译时注解增量教程</a></p>
<ul>
<li>全量编译：改动一个注解会删除之前已经生成过的文件，再重新生成新的文件，效率较低。</li>
<li>增量注解：从<code>Gradle 4.7</code>开始,<code>gradle</code>提供了增量<code>apt</code>,可以使上层开发者更快的编译。</li>
</ul>
<h3 id="增量注解处理器类型"><a href="#增量注解处理器类型" class="headerlink" title="增量注解处理器类型"></a>增量注解处理器类型</h3><ol>
<li>isolating注解处理器：最快的增量注解处理器。一个注解处理器只处理一个注解</li>
<li>aggregationg注解处理器：可以处理多个注解。注解的Retention必须是<code>CLASS</code> or <code>RUNTIME</code></li>
<li>dynamic注解处理器：重写<code>AbstractProcessor.getSupportedOptions</code>函数，在执行APT的时候根据自身情况决定使用哪一种增量注解处理器类型</li>
</ol>
<p>配置方式如下：</p>
<h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><p>新建<code>resources/META-INF/gradle/incremental.annotation.processors</code>文件，在文件中写入注解处理器全称和增量注解处理器类型。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.afauria.sample.apt_processor.AptProcessor,DYNAMIC</span><br></pre></td></tr></table></figure>

<h3 id="使用incap-processor自动生成"><a href="#使用incap-processor自动生成" class="headerlink" title="使用incap-processor自动生成"></a>使用<code>incap-processor</code>自动生成</h3><p>原理：通过APT解析<code>@IncrementalAnnotationProcessor</code>自动生成文件，类似<code>AutoService</code>库。</p>
<ol>
<li>添加依赖包和对应的注解处理器</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&quot;net.ltgt.gradle.incap:incap:0.2&quot;</span> <span class="comment">//添加依赖包</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;net.ltgt.gradle.incap:incap-processor:0.2&quot;</span> <span class="comment">//添加注解处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>@IncrementalAnnotationProcessor</code>注解配置增量类型，如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.DYNAMIC)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用注解处理器"><a href="#应用注解处理器" class="headerlink" title="应用注解处理器"></a>应用注解处理器</h2><p>定义好注解处理器之后，如何使用呢？</p>
<ol>
<li>Gradle2.2之前，需要先依赖三方插件<code>apply plugin: &#39;com.neenbedankt.android-apt&#39;</code>，在<code>dependencies</code>中添加<code>apt project(&#39;:xxx-processor&#39;)</code></li>
<li>Gradle2.2之后，Gradle内置了了APT工具，直接在dependencies中添加<code>annotationProcessor project(&#39;:xxx-processor&#39;)</code></li>
<li>kotlin中先依赖插件<code>apply plugin: &#39;kotlin-kapt&#39;</code>，dependencies中添加<code>kapt project(&#39;:xxx-processor&#39;)</code></li>
</ol>
<h1 id="自定义APT步骤"><a href="#自定义APT步骤" class="headerlink" title="自定义APT步骤"></a>自定义APT步骤</h1><p>上面介绍了APT涉及到的知识点，比较零散，简单串联一下整个过程：</p>
<ol>
<li>创建一个<strong>Java Module</strong>，用于定义注解，如<code>xxx-annotation</code></li>
<li>创建一个<strong>Android Module</strong>，用于封装API接口，供使用者调用，如<code>xxx-library</code>，依赖<code>xxx-annotation</code></li>
<li>编写注解处理器代码<ol>
<li>创建一个<strong>Java Module</strong>：如<code>xxx-processor</code>、<code>xxx-compiler</code>，依赖<code>xxx-annotation</code></li>
<li>定义<code>XXProcessor</code>类，继承自<code>AbstractProcessor</code></li>
<li>重写<code>getSupportedAnnotationTypes</code>方法，返回要被检测的注解</li>
<li>重写<code>process</code>方法解析注解，生成对应的文件，有几种方式：<ol>
<li>手动拼接源代码</li>
<li>定义模版java文件，通过关键字匹配替换</li>
<li>使用JavaPoet，调用JavaAPI生成，可以自动缩进、导入import包，不容易出错</li>
</ol>
</li>
</ol>
</li>
<li>注册注解处理器：JavaSPI机制</li>
<li>注册增量注解处理器类型</li>
<li>应用注解处理器：<code>annotationProcessor &quot;xxx-processor&quot;</code></li>
<li>使用者依赖<code>xxx-library</code></li>
<li>源代码中使用注解</li>
<li>编译时扫描注解，生成代理类</li>
<li>调用生成的代理类方法，或者通过<code>xxx-library</code>中的门面对象，反射找到代理类并执行。</li>
</ol>
<p>流程图就不画了，可以参考<a href="/2021/12/09/android-2021-12-09-ButterKnife/#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">ButterKnife解析</a></p>
<p>为什么需要分三个module？</p>
<blockquote>
<p><code>xxx-processor</code>只有编译时会用到，打包的时候不需要依赖，使用<code>compileOnly</code>即可，因此和<code>xxx-library</code>分开。</p>
<p><code>xxx-annotation</code>会被其他两个模块使用，因此单独抽一个module处理</p>
<p><code>xxx-library</code>：主要封装API供外部调用。也可以不定义该模块，使用自定义注解+注解处理器，生成代理类之后，直接调用代理类方法</p>
</blockquote>
<h1 id="自定义APT示例"><a href="#自定义APT示例" class="headerlink" title="自定义APT示例"></a>自定义APT示例</h1><p>代码上传至<a href="https://github.com/Afauria/AOPSample">仓库</a></p>
<h2 id="确认目标功能和生成的类信息"><a href="#确认目标功能和生成的类信息" class="headerlink" title="确认目标功能和生成的类信息"></a>确认目标功能和生成的类信息</h2><p>先确认下我们的目标功能，调用方代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用@AptBindRes找到资源，使用@AptBindView找到View，使用AptOnClick设置点击事件监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AptActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AptBindRes(R.string.app_name)</span></span><br><span class="line">    String text1;</span><br><span class="line">    <span class="meta">@AptBindView(R.id.aptBtn1)</span></span><br><span class="line">    Button btn1;</span><br><span class="line">    <span class="meta">@AptOnClick</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onBtn1Click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;AptActivity&quot;</span>, <span class="string">&quot;onBtn1Click: &quot;</span> + text1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_apt);</span><br><span class="line">        <span class="comment">//方式一：调用生成的类完成视图绑定、资源查找、事件绑定等功能</span></span><br><span class="line">        <span class="keyword">new</span> AptActivity_ViewBinding(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//方式二：封装API接口，供调用方使用</span></span><br><span class="line">        <span class="comment">//AptBinder.bind(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>AptActivity</code>为例，需要生成的类如下：APT的作用就是帮我们自动生成<code>XXX_ViewBinding</code>类，免去手写的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AptActivity_ViewBinding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AptActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> AptActivity target)</span> </span>&#123;</span><br><span class="line">        target.text1 = target.getString(R.string.app_name);</span><br><span class="line">        target.btn1 = target.findViewById(R.id.aptBtn1);</span><br><span class="line">        <span class="comment">//target.btn1.setOnClickListener，这个地方想拿到变量设置监听器较麻烦，因此直接再find一次View</span></span><br><span class="line">        target.findViewById(R.id.aptBtn1).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                target.onBtn1Click();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><ol>
<li>首先创建<code>java-library</code>，名为<code>apt-annotation</code>，用于自定义注解<code>@AptBindRes、@AptBindView、@AptOnClick</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源绑定注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AptBindString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//视图绑定注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AptBindView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件绑定注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AptOnClick &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建<code>java-library</code>，名为<code>apt-processor</code>，用于自定义注解处理器<code>AptProcessor</code>。配置依赖如下</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">&quot;:apt-annotation&quot;</span>)	<span class="comment">//依赖自定义注解包</span></span><br><span class="line">    compileOnly <span class="string">&quot;com.squareup:javapoet:1.12.1&quot;</span>	<span class="comment">//使用JavaAPI方式生成Java代码</span></span><br><span class="line">    compileOnly <span class="string">&quot;com.google.auto.service:auto-service-annotations:1.0&quot;</span>	<span class="comment">//配置服务接口实现类</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;com.google.auto.service:auto-service:1.0&quot;</span>	<span class="comment">//生成SPI服务接口文件</span></span><br><span class="line">    compileOnly <span class="string">&quot;net.ltgt.gradle.incap:incap:0.2&quot;</span>	<span class="comment">//配置增量注解处理器类型</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;net.ltgt.gradle.incap:incap-processor:0.2&quot;</span>	<span class="comment">//生成增量注解处理器类型文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自定义注解处理器：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 配置`@AutoService`自动生成服务接口配置文件</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="comment">//2. 配置`@IncrementalAnnotationProcessor`自动生成增量编译配置文件</span></span><br><span class="line"><span class="meta">@IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.DYNAMIC)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Filer mFiler;</span><br><span class="line">    <span class="keyword">private</span> Messager mMessager;</span><br><span class="line">    <span class="keyword">private</span> Elements mElements;</span><br><span class="line">    <span class="comment">//3. 初始化辅助类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line">        mFiler = processingEnvironment.getFiler();</span><br><span class="line">        mMessager = processingEnvironment.getMessager();</span><br><span class="line">        mElements = processingEnvironment.getElementUtils();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 返回需要处理的自定义注解类型名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        types.add(AptBindView.class.getCanonicalName());</span><br><span class="line">        types.add(AptBindString.class.getCanonicalName());</span><br><span class="line">        types.add(AptOnClick.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> types;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//5. 封装一个error类方便打印错误信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(Element element, String msg)</span> </span>&#123;</span><br><span class="line">        mMessager.printMessage(Diagnostic.Kind.ERROR, msg, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>定义一个<code>builderMap</code>，用于保存需要生成的类的信息，并拼接Java源代码。每解析一个元素，放到对应的类信息中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按类生成文件，一个类可能包含多个注解，因此新建一个Map，保存类和对应的类信息</span></span><br><span class="line"><span class="comment">//生成类需要的信息包括：包名、类名、资源绑定、视图绑定、事件绑定等信息</span></span><br><span class="line"><span class="comment">//定义一个FileBuilder类保存，等到所有注解解析完毕之后，再统一生成文件</span></span><br><span class="line">Map&lt;TypeElement, FileBuilder&gt; builderMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//获取缓存的类信息，如果没有则新建</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FileBuilder <span class="title">getOrCreateBuilder</span><span class="params">(TypeElement element)</span> </span>&#123;</span><br><span class="line">    FileBuilder builder = builderMap.get(element);</span><br><span class="line">    <span class="keyword">if</span> (builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder = <span class="keyword">new</span> FileBuilder(element);</span><br><span class="line">        builderMap.put(element, builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略getter、setter、add代码，直接操作成员变量</span></span><br><span class="line">    TypeElement mTypeElement;</span><br><span class="line">    String mPackageName;</span><br><span class="line">    String mClassName;</span><br><span class="line">    <span class="comment">//保存资源绑定的信息：如变量名、资源id</span></span><br><span class="line">    List&lt;BindResourceInfo&gt; mBindingResources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存视图绑定的信息：如变量名，viewId</span></span><br><span class="line">    List&lt;BindViewInfo&gt; mBindingViews = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存事件绑定的信息：如方法名，viewId</span></span><br><span class="line">    List&lt;BindMethodInfo&gt; mBindingMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileBuilder</span><span class="params">(TypeElement typeElement, Elements elementsUtil)</span> </span>&#123;</span><br><span class="line">        mTypeElement = typeElement;</span><br><span class="line">        mPackageName = elementsUtil.getPackageOf(typeElement).toString();</span><br><span class="line">        mClassName = typeElement.getSimpleName() + <span class="string">&quot;_ViewBinding&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拼接Java类代码</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> String <span class="title">generateJavaCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//添加包名</span></span><br><span class="line">        sb.append(<span class="string">&quot;package &quot;</span>).append(mPackageName).append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\nimport android.view.View;\n&quot;</span>);</span><br><span class="line">        <span class="comment">//添加类定义</span></span><br><span class="line">        sb.append(<span class="string">&quot;\npublic class &quot;</span>).append(mClassName).append(<span class="string">&quot; &#123;\n&quot;</span>);</span><br><span class="line">        <span class="comment">//添加构造方法</span></span><br><span class="line">        sb.append(<span class="string">&quot;\tpublic &quot;</span>).append(mClassName).append(<span class="string">&quot;(final &quot;</span>).append(mTypeElement.getSimpleName()).append(<span class="string">&quot; target) &#123;\n&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历添加资源绑定代码</span></span><br><span class="line">        <span class="keyword">for</span> (BindResourceInfo bindResourceInfo : mBindingResources) &#123;</span><br><span class="line">            sb.append(bindResourceInfo.bindResourceCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历添加视图绑定代码</span></span><br><span class="line">        <span class="keyword">for</span> (BindViewInfo bindViewInfo : mBindingViews) &#123;</span><br><span class="line">            sb.append(bindViewInfo.bindViewCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历添加事件绑定代码</span></span><br><span class="line">        <span class="keyword">for</span> (BindMethodInfo bindMethodInfo : mBindingMethods) &#123;</span><br><span class="line">            sb.append(bindMethodInfo.bindMethodCode());</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;\t&#125;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin可以直接使用data class，java代码确实有点长</span></span><br><span class="line"><span class="comment">//省略构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindResourceInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resId;</span><br><span class="line">    String fieldName;</span><br><span class="line">    <span class="comment">//拼接资源绑定的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bindResourceCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;\t\ttarget.%s = target.getString(%s);\n&quot;</span>, fieldName, resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindViewInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resId;</span><br><span class="line">    String fieldName;</span><br><span class="line">    <span class="comment">//拼接视图绑定的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bindViewCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;\t\ttarget.%s = target.findViewById(%s);\n&quot;</span>, fieldName, resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindMethodInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resId;</span><br><span class="line">    String methodName;</span><br><span class="line">    <span class="comment">//拼接设置监听器的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bindMethodCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;\t\ttarget.findViewById(&quot;</span>).append(resId).append(<span class="string">&quot;).setOnClickListener(new View.OnClickListener() &#123;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t\t\tpublic void onClick(View view) &#123;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t\t\t\ttarget.&quot;</span>).append(methodName).append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t\t\t&#125;\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t\t&#125;);\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重写<code>process</code>方法，解析和处理注解，将需要的信息填入<code>Builder</code>中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每次执行清空下buildMap，避免下个round重复创建文件</span></span><br><span class="line">    builderMap.clear();</span><br><span class="line">    <span class="keyword">if</span> (set.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析@AptBindString注解，并加入到对应的FileBuilder中</span></span><br><span class="line">    findAndParseBindingResources(roundEnvironment);</span><br><span class="line">    <span class="comment">//解析@AptBindView注解，并加入到对应的FileBuilder中</span></span><br><span class="line">    findAndParseBindingView(roundEnvironment);</span><br><span class="line">    <span class="comment">//解析@AptOnClick注解，并加入到对应的FileBuilder中</span></span><br><span class="line">    findAndParseBindingMethod(roundEnvironment);</span><br><span class="line">    <span class="keyword">for</span> (FileBuilder fileBuilder : builderMap.values()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//方式一：使用拼接源代码方式生成Java文件</span></span><br><span class="line">            generateJavaFile(fileBuilder);</span><br><span class="line">            <span class="comment">//方式二：使用JavaPoet生成Java文件</span></span><br><span class="line">            <span class="comment">//fileBuilder.generateJavaFileByPoet().writeTo(mFiler);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//使用Messager打印日志，打印error并不会中断process执行，但是会导致编译失败</span></span><br><span class="line">            error(fileBuilder.mTypeElement, String.format(<span class="string">&quot;Unable to write ViewBinding for type %s: %s&quot;</span>, fileBuilder.mTypeElement, e.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateJavaFile</span><span class="params">(FileBuilder fileBuilder)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建Java源文件对象，完整类名</span></span><br><span class="line">    JavaFileObject javaFileObject = mFiler.createSourceFile(fileBuilder.mPackageName + <span class="string">&quot;.&quot;</span> + fileBuilder.mClassName);</span><br><span class="line">    <span class="comment">//根据存储的信息拼接Java代码</span></span><br><span class="line">    String code = fileBuilder.generateJavaCode();</span><br><span class="line">    Writer writer = javaFileObject.openWriter();</span><br><span class="line">    <span class="comment">//写入文件</span></span><br><span class="line">    writer.write(code);</span><br><span class="line">    writer.flush();</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>贴一下解析<code>@AptBindString</code>的代码，视图绑定和事件绑定类似</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAndParseBindingResources</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取所有被@BindString注解的元素</span></span><br><span class="line">    Set&lt;? extends Element&gt; s = env.getElementsAnnotatedWith(AptBindString.class);</span><br><span class="line">    <span class="keyword">for</span> (Element element : s) &#123;</span><br><span class="line">        <span class="comment">//获取注解的值</span></span><br><span class="line">        <span class="keyword">int</span> resId = element.getAnnotation(AptBindString.class).value();</span><br><span class="line">        <span class="comment">//获取Field变量名称</span></span><br><span class="line">        <span class="keyword">final</span> String name = element.getSimpleName().toString();</span><br><span class="line">        <span class="comment">//获取父元素</span></span><br><span class="line">        TypeElement parentElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line">        <span class="comment">//获取缓存的生成类信息</span></span><br><span class="line">        FileBuilder builder = getOrCreateBuilder(parentElement);</span><br><span class="line">        <span class="comment">//构造资源绑定信息，加入对应的FileBuilder中</span></span><br><span class="line">        builder.mBindingResources.add(<span class="keyword">new</span> BindResourceInfo(resId, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用JavaPoet"><a href="#使用JavaPoet" class="headerlink" title="使用JavaPoet"></a>使用JavaPoet</h2><p>第4步拼接Java源代码也可以通过调用JavaPoet API来生成，上面<code>build.gradle</code>已经添加依赖包。最终生成的结果就不贴了，和上面目标一致。</p>
<p>直接贴代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JavaFile <span class="title">generateJavaFileByPoet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义构造方法</span></span><br><span class="line">    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            .addParameter(TypeName.get(mTypeElement.asType()), <span class="string">&quot;target&quot;</span>, Modifier.FINAL);</span><br><span class="line">    <span class="comment">//遍历添加资源绑定代码</span></span><br><span class="line">    <span class="keyword">for</span> (BindResourceInfo bindResourceInfo : mBindingResources) &#123;</span><br><span class="line">        constructor.addCode(bindResourceInfo.bindResourceCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历添加视图绑定代码</span></span><br><span class="line">    <span class="keyword">for</span> (BindViewInfo bindViewInfo : mBindingViews) &#123;</span><br><span class="line">        constructor.addCode(bindViewInfo.bindViewCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历添加事件绑定代码</span></span><br><span class="line">    <span class="keyword">for</span> (BindMethodInfo bindMethodInfo : mBindingMethods) &#123;</span><br><span class="line">        <span class="comment">//创建OnClickListener匿名内部类</span></span><br><span class="line">        TypeSpec listener = TypeSpec.anonymousClassBuilder(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .addSuperinterface(ClassName.get(<span class="string">&quot;android.view&quot;</span>, <span class="string">&quot;View&quot;</span>, <span class="string">&quot;OnClickListener&quot;</span>))</span><br><span class="line">                .addMethod(MethodSpec.methodBuilder(<span class="string">&quot;onClick&quot;</span>)</span><br><span class="line">                        .addAnnotation(Override.class)</span><br><span class="line">                        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                        .returns(TypeName.VOID)</span><br><span class="line">                        .addParameter(ClassName.get(<span class="string">&quot;android.view&quot;</span>, <span class="string">&quot;View&quot;</span>), <span class="string">&quot;view&quot;</span>)</span><br><span class="line">                        .addStatement(<span class="string">&quot;target.$N()&quot;</span>, bindMethodInfo.methodName)</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//添加监听器</span></span><br><span class="line">        constructor.addStatement(<span class="string">&quot;target.findViewById($L).setOnClickListener($L)&quot;</span>, bindMethodInfo.resId, listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义类</span></span><br><span class="line">    TypeSpec typeSpec = TypeSpec</span><br><span class="line">            .classBuilder(mClassName)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            .addMethod(constructor.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//生成java文件对象</span></span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(mPackageName, typeSpec).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消第5步方式二的注释，使用JavaPoet生成文件</span></span><br><span class="line"><span class="comment">//fileBuilder.generateJavaFileByPoet().writeTo(mFiler);</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li><code>addStatement</code>会添加缩进、换行、分号结尾。<code>addCode</code>直接添加代码，不会添加缩进、换行、分号结尾</li>
<li>JavaPoet提供了一些字符串format的占位符，就是代码中的<code>$L、$N</code>等，可以查看<code>CodeBlock</code>类中的注释说明。列举几个常用的<ol>
<li><code>$L</code>：表示字面量，可以是字符串、基础数据类型、代码块等。</li>
<li><code>$N</code>：表示名称，如参数名、字段名、局部变量名、方法名等</li>
<li><code>$T</code>：表示类型，强转或者调用类静态方法、静态属性的时候会用到</li>
<li><code>$[</code>：开始一个语句，会自动添加缩进</li>
<li><code>$]</code>：结束一个语句</li>
</ol>
</li>
</ol>
<blockquote>
<p>Tips：<strong>字面量</strong>就是指这个量本身，如<code>String name = &quot;Hello World&quot;;</code>中，<code> &quot;Hello World&quot;</code>就是字面量（含引号）。</p>
<p>可以简单理解为就是<code>=</code>号右边的部分</p>
</blockquote>
<p>更多JavaPoet API可以参考<a href="https://github.com/square/javapoet">官方文档</a></p>
<h2 id="封装API接口"><a href="#封装API接口" class="headerlink" title="封装API接口"></a>封装API接口</h2><p>上面客户端是直接使用生成的代理类<code>new AptActivity_ViewBinding(this);</code>。这么写有几个不足：</p>
<ol>
<li>需要在build完之后才有代理类，没build之前代码会报红</li>
<li>不同类写法不一致，不好封装基类</li>
</ol>
<p>因此我们封装一个API接口类，让客户端能够更方便的调用。</p>
<ol>
<li>首先新建一个<code>Android Module</code>，如<code>apt-library</code>，并依赖自定义注解库<code>apt-annotation</code></li>
<li>直接贴代码，看注释即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AptBinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定Activity</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = activity.getClass();</span><br><span class="line">        <span class="comment">//找到类名：由于lib中无法拿到生成的类，因此需要使用反射来动态加载类</span></span><br><span class="line">        String clsName = activity.getClass().getName() + <span class="string">&quot;_ViewBinding&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射加载类</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(clsName);</span><br><span class="line">            <span class="comment">//反射获取构造函数，并实例化。</span></span><br><span class="line">            <span class="comment">//可以缓存构造函数，避免重复反射</span></span><br><span class="line">            clazz.getConstructor(cls).newInstance(activity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>客户端依赖<code>apt-library</code>，<code>Activity</code>中调用<code>AptBinder.bind(this)</code>完成绑定</li>
</ol>
<h2 id="可优化"><a href="#可优化" class="headerlink" title="可优化"></a>可优化</h2><p>实现的是简化版的自定义注解处理器，有很多可优化的点：</p>
<ol>
<li>考虑注解不在Activity中（如Fragment、View、Adapter或者普通类中），如何获取资源、绑定视图：需要往生成类中传入context或者view。</li>
<li>添加校验：注解对象或方法非private或static，注解对象父元素<code>TypeElement</code>不能是接口或枚举类等</li>
<li>生成释放对象的代码，<code>unbind</code>方法</li>
<li><code>@OnClick</code>注解绑定多个View解析：注解参数需要使用id数组</li>
<li>监听器回调方法有参数的时候，如何获取并生成？</li>
<li>父类和子类都有注解，如何兼容？</li>
<li>资源id非final类型，如何处理？</li>
<li>在内部类中使用注解，如何处理？</li>
<li>更多资源注解，更多事件注解，如何保存builder类信息，减少重复代码？</li>
<li>增量编译这里没有实际用到</li>
<li>…</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>代码均上传至<a href="https://github.com/Afauria/AOPSample">仓库</a></p>
<p>参考资料：</p>
<ul>
<li><a href="https://fanmingyi.blog.csdn.net/article/details/113766921">Java Pluginable Annotation processing</a></li>
<li><a href="https://fanmingyi.blog.csdn.net/article/details/116274271">注解处理器常用类说明</a></li>
<li><a href="https://blog.csdn.net/qfanmingyiq/article/details/116300913">Gradle编译时注解增量教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI和API</title>
    <url>/2021/12/06/architecture-2021-12-06-SPI/</url>
    <content><![CDATA[<h1 id="SPI和API"><a href="#SPI和API" class="headerlink" title="SPI和API"></a>SPI和API</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>面向的对象的设计里，提倡模块之间<strong>基于接口编程</strong>。调用方、接口、实现方关系如下</p>
<p><img src="/2021/12/06/architecture-2021-12-06-SPI/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B.png"></p>
<p>这个时候接口应该在哪定义呢？有三种情况：</p>
<ol>
<li>接口位于实现方所在的包中：称为API（Application Programming Interface，应用程序接口）。<ol>
<li>调用方直接依赖三方库</li>
<li>从名字上理解，API是给客户端调用的接口</li>
<li>从时间上讲，先有实现方和接口，再有调用方，实现方较固定，调用方可变。</li>
<li>常用于SDK开发，接口由三方库开发者提供，并可能提供了多种实现，调用方只负责使用。（如果调用方能够自己实现功能，何必再使用三方库呢？）</li>
<li>当然有些框架也会提供SPI接口，调用方有需求的时候也可以自己实现，替换SDK中的实现，如自定义GlideModule。</li>
</ol>
</li>
<li>接口位于调用方所在的包中：称为SPI（Service Provider Interface，服务提供接口）<ol>
<li>插件依赖调用方接口</li>
<li>从名字上理解，SPI服务接口是给服务端实现的接口</li>
<li>从时间上讲，先有调用方和接口，再有具体的实现方，实现方可变，调用方较固定</li>
<li>常用于插件开发，调用方先定义好接口，并写好调用逻辑，由插件实现接口。如自定义注解处理器、插件换肤。</li>
</ol>
</li>
<li>接口位于独立的包中：接口既可以作为API，也可以作为SPI<ol>
<li>在Clean或DDD架构中，业务层对外层提供接口，被表现层或应用层调用（API），同时外层需要实现业务层提供的接口（SPI），被业务驱动。</li>
</ol>
</li>
</ol>
<p><strong>注：</strong></p>
<ol>
<li>不管是SPI或API，接口都可以组织到独立的包中，真正的区别是由调用方提供还是由实现方提供。</li>
<li>SPI和API本质上是一个谁迁就谁的问题：<ol>
<li>使用API，对调用方来说，不同的实现方API接口可能不一致，代码中需要写条件分支判断。（例如代码中同时用了ImageLoader和Glide来加载图片）</li>
<li>使用SPI，就是由调用方来决定接口行为，不同的实现方都需要遵循这个接口定义。</li>
</ol>
</li>
<li>广义上讲API是<strong>一种提供给外部调用自身的方式</strong>，不单指Java语言中的接口，例如我们常说的Restful API，实际上是网络请求的url</li>
<li>广义上讲SPI是<strong>一种让外部能够按照自己定制的规则实现功能的方式</strong>，不单指Java语言中的接口</li>
</ol>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>在SPI的情况下，插件需要依赖调用方，调用方也需要依赖插件具体实现。是否会产生依赖冲突呢，三者的依赖关系应该是怎么样的？</p>
<blockquote>
<p>从编码上讲会存在依赖冲突，当然这个时候调用方不一定是直接依赖插件，也可以通过动态加载，如自定义ClassLoader、动态链接库等。</p>
</blockquote>
<h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p>抛开依赖冲突的问题，如果接口定义在调用方的包中，插件依赖的时候会把调用方的逻辑也依赖进来，而插件只是负责实现接口而已，这是否有必要呢？</p>
<blockquote>
<p>有一个原则可以回答这个问题</p>
<p>依赖倒置：高层模块不依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖具体，具体应该依赖抽象</p>
<p>实际上就是说把接口（抽象层）抽出来，调用方和实现方都依赖接口，也就是上面的第3种情况。</p>
</blockquote>
<h2 id="服务发现机制"><a href="#服务发现机制" class="headerlink" title="服务发现机制"></a>服务发现机制</h2><p>SPI中调用方提供接口，调用方直接实例化对象，存在问题：</p>
<ol>
<li>调用方先定义好接口，无法写逻辑，需要等到实现方实现接口之后再来添加逻辑。（当然也可以先定义一个默认的Fake实现类）</li>
<li>如果要替换一种实现，需要修改调用方的代码，不符合可插拔的原则</li>
</ol>
<p>为了解决上面的问题，让调用方不需要指定具体模块，需要一种服务注册和发现的机制：服务端注册了服务之后，客户端可以找到对应的服务。</p>
<p><img src="/2021/12/06/architecture-2021-12-06-SPI/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6.png"></p>
<p>服务发现是IoC（Inversion of Control，控制反转）思想的一种实现，将初始化实例的控制权移到了程序之外。</p>
<blockquote>
<p>Tips：IoC主要有两种实现：</p>
<ul>
<li>服务提供模式：从外部服务容器抓取依赖对象</li>
<li>依赖注入：以参数的形式注入依赖对象</li>
</ul>
</blockquote>
<p>控制反转（或服务发现）有以下优势：</p>
<ul>
<li>在外部注入或配置依赖项，因此我们可以重用这些组件。当我们需要修改依赖项的实现时，只需要修改配置文件；</li>
<li>可以配置依赖项的模拟实现（Fake），让代码测试更加容易。</li>
</ul>
<h1 id="Java-SPI机制"><a href="#Java-SPI机制" class="headerlink" title="Java SPI机制"></a>Java SPI机制</h1><p>JDK6中引入了ServiceLoader，通过配置文件来装载指定的服务。也叫做Java SPI机制（<strong>这里要和上文所说的SPI接口区分开来</strong>）</p>
<p><code>ServiceLoader</code>是Java提供的一种SPI机制，但服务发现机制不是Java特有的</p>
<p>类似地，在Android中，通过Manifest注册组件，让Launcher能够找到应用程序的入口，或者让AMS能够启动应用内的Activity、Service，发送广播等</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol>
<li>客户端定义服务接口</li>
<li>服务端实现该接口</li>
<li>服务端在<code>META-INF/services</code>目录下新建一个以服务接口命名的文件，文件内填入该服务接口的具体实现类（完整类名，可以填多个）</li>
<li>客户端使用<code>ServiceLoader</code>加载配置文件中的具体实现类并返回实例化对象。存在多个实现类，通过迭代器<code>iterator</code>访问</li>
</ol>
<blockquote>
<p>Tips：这里客户端指接口调用方，服务端指接口实现方</p>
</blockquote>
<p>第4步除了使用<code>ServiceLoader</code>去加载配置文件外，我们也可以自己读取文件，通过<strong>反射创建实例</strong>。实际上<code>ServiceLoader</code>正是帮我们做了这件事</p>
<p>第3步除了手动创建之外，还可以使用<code>AutoService</code>库帮我们自动生成文件：通过APT解析<code>@AutoSerivce</code>自动生成文件。</p>
<ol>
<li>添加依赖包和对应的注解处理器</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&quot;com.google.auto.service:auto-service-annotations:1.0&quot;</span> <span class="comment">//添加注解依赖包</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;com.google.auto.service:auto-service:1.0&quot;</span> <span class="comment">//添加注解处理器，使用compileOnly可以下载AutoService源码查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>@AutoService(Processor.class)</code>，即可自动生成SPI文件，如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Google提供的@AutoService注解</span></span><br><span class="line"><span class="comment">//自动生成/META_INF/services/javax.annotation.processing.Processor文件，并打包进jar包中</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>首先看<code>Service.load</code>源码，返回<code>ServiceLoader</code>对象：可以看到这个时候还没加载实现类，一个服务接口对应一个<code>ServiceLoader</code>实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ServiceLoader类</span></span><br><span class="line"><span class="comment">//方法1：使用 SystemClassLoader 类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">loadInstalled</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">    ClassLoader prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = cl;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, prev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法2：使用线程上下文类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法3：自定义类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ServiceLoader构造函数：保存<strong>服务接口的类对象</strong>，并创建了一个<code>LazyIterator</code>对象，迭代器中暂时只是保存了<code>service</code>类对象和类加载器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; var1, ClassLoader var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.service = (Class)Objects.requireNonNull(var1, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.loader = var2 == <span class="keyword">null</span> ? ClassLoader.getSystemClassLoader() : var2;</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() != <span class="keyword">null</span> ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.reload();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空服务Providers</span></span><br><span class="line">    <span class="keyword">this</span>.providers.clear();</span><br><span class="line">    <span class="comment">//创建懒加载迭代器</span></span><br><span class="line">    <span class="keyword">this</span>.lookupIterator = <span class="keyword">new</span> ServiceLoader.LazyIterator(<span class="keyword">this</span>.service, <span class="keyword">this</span>.loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>到这里还没开始加载具体的实现类，继续看迭代器中关键的<code>nextService</code>方法：可以看到使用<code>Class.fromName</code>反射加载了<code>nextName</code>类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasNextService()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String var1 = <span class="keyword">this</span>.nextName;</span><br><span class="line">        <span class="keyword">this</span>.nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class var2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射加载nextName类</span></span><br><span class="line">            var2 = Class.forName(var1, <span class="keyword">false</span>, <span class="keyword">this</span>.loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var5) &#123;</span><br><span class="line">            ServiceLoader.fail(<span class="keyword">this</span>.service, <span class="string">&quot;Provider &quot;</span> + var1 + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查注册的类是不是服务接口的实现类</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.service.isAssignableFrom(var2)) &#123;</span><br><span class="line">            ServiceLoader.fail(<span class="keyword">this</span>.service, <span class="string">&quot;Provider &quot;</span> + var1 + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化服务对象，并强制转换成服务接口。调用的是无参构造函数</span></span><br><span class="line">            Object var3 = <span class="keyword">this</span>.service.cast(var2.newInstance());</span><br><span class="line">            <span class="comment">//缓存接口实现类的实例</span></span><br><span class="line">            ServiceLoader.<span class="keyword">this</span>.providers.put(var1, var3);</span><br><span class="line">            <span class="keyword">return</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            ServiceLoader.fail(<span class="keyword">this</span>.service, <span class="string">&quot;Provider &quot;</span> + var1 + <span class="string">&quot; could not be instantiated&quot;</span>, var4);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>nextName</code>从哪来的呢，继续看<code>hasNextService</code>方法：可以看到读取了<code>META-INF/services/</code>下的服务配置文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//读取META-INF/services/下的服务配置文件</span></span><br><span class="line">                String var1 = <span class="string">&quot;META-INF/services/&quot;</span> + <span class="keyword">this</span>.service.getName();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.configs = ClassLoader.getSystemResources(var1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.configs = <span class="keyword">this</span>.loader.getResources(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">                ServiceLoader.fail(<span class="keyword">this</span>.service, <span class="string">&quot;Error locating configuration files&quot;</span>, var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.pending == <span class="keyword">null</span> || !<span class="keyword">this</span>.pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//parse中按行读取配置文件（utf-8编码），并排除已经加载过的服务，返回配置文件中的服务类型名列表</span></span><br><span class="line">            <span class="keyword">this</span>.pending = ServiceLoader.<span class="keyword">this</span>.parse(<span class="keyword">this</span>.service, (URL)<span class="keyword">this</span>.configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给nextName赋值为下一个类的类名</span></span><br><span class="line">        <span class="keyword">this</span>.nextName = (String)<span class="keyword">this</span>.pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>继续看<code>ServiceLoader</code>的<code>iterator</code>方法，对懒加载迭代器进行了包装，首先返回已经实例化过并缓存下来的服务对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;String, S&gt;&gt; knownProviders;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取缓存的providers列表</span></span><br><span class="line">            <span class="keyword">this</span>.knownProviders = ServiceLoader.<span class="keyword">this</span>.providers.entrySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.knownProviders.hasNext() ? <span class="keyword">true</span> : ServiceLoader.<span class="keyword">this</span>.lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//首先返回缓存的provider服务对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.knownProviders.hasNext() ? ((Entry)<span class="keyword">this</span>.knownProviders.next()).getValue() : ServiceLoader.<span class="keyword">this</span>.lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：<code>ServiceLoader</code>本质就是实现了一个迭代器，读取<code>META-INF/services</code>下的文件，通过ClassLoader加载文件中的接口实现类，放到懒加载迭代器中，访问的时候才加载类并实例化对象。</p>
<p>有几个注意的点：</p>
<ol>
<li>使用了懒加载创建服务实例</li>
<li>使用<code>LinkedHashMap</code>缓存创建过的provider实例</li>
<li>服务实现类必须实现服务接口：<code>if (!service.isAssignableFrom(c))</code>；</li>
<li>服务实现类需包含无参的构造器，LazyInterator 是反射创建服务对象的：<code>S p = service.cast(c.newInstance())</code>；</li>
<li>配置文件需要使用 UTF-8 编码：<code>parse</code>方法中<code>new BufferedReader(new InputStreamReader(in, &quot;utf-8&quot;))</code>。</li>
<li>存在多个实现类的时候，并不一定需要全部使用，只能迭代筛选合适的实现类，因此可以尽可能把常用的放到配置文件前面，避免加载不常用的类</li>
<li>服务无法注销remove，只能当没有引用时被GC回收，<code>ServiceLoader</code>提供了<code>reload</code>方法清除自身的缓存</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol>
<li>JDBC加载不同的数据库驱动，服务接口为<code>java.sql.Driver</code>，由不同的数据库驱动要实现该服务接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MySQL实现JDBC服务驱动接口，即Driver类</span></span><br><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将自身存入DriverManager</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DriverManager源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//初始化所有数据库驱动</span></span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//使用ServiceLoader加载驱动类</span></span><br><span class="line">    ServiceLoader var1 = ServiceLoader.load(Driver.class);</span><br><span class="line">    Iterator var2 = var1.iterator();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//参数：数据库连接url、账号、密码</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String var0, String var1, String var2)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取数据库Driver对象，调用connect连接并返回</span></span><br><span class="line">    Iterator var5 = registeredDrivers.iterator();</span><br><span class="line">    <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">      DriverInfo var6 = (DriverInfo)var5.next();</span><br><span class="line">      <span class="keyword">if</span> (isDriverAllowed(var6.driver, var3)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          println(<span class="string">&quot;    trying &quot;</span> + var6.driver.getClass().getName());</span><br><span class="line">          Connection var7 = var6.driver.connect(var0, var1);</span><br><span class="line">          <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;getConnection returning &quot;</span> + var6.driver.getClass().getName());</span><br><span class="line">            <span class="comment">//找到一个就返回</span></span><br><span class="line">            <span class="keyword">return</span> var7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到mysql的jdbc驱动包中确实存在服务配置文件</p>
<p><img src="/2021/12/06/architecture-2021-12-06-SPI/MySQL%E9%A9%B1%E5%8A%A8.png"></p>
<p><strong>如果三方数据库驱动没有配置服务文件（例如Oracle数据库），就需要我们自己通过<code>Class.forName</code>去加载驱动类了</strong></p>
<ol start="2">
<li>APT加载不同的注解处理器。服务接口为<code>javax.annotation.processing.Processor</code>，由不同的注解处理器实现该服务接口</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本来是打算介绍JavaSPI机制，放到Java分类下的。但是研究之后发现更应该归属到架构分类。</p>
<p>了解SPI和API区别，有助于我们更好的理解IoC、依赖倒置原则、DDD（Domain Driven Design,领域驱动设计）等。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html">设计原则：小议SPI和API</a></li>
<li><a href="https://www.jianshu.com/p/a18499b5df1c">「Java 路线」| 服务发现框架 ServiceLoader</a></li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>AspectJ介绍和示例</title>
    <url>/2021/12/02/tech-2021-12-02-AspectJ%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="AspectJ介绍"><a href="#AspectJ介绍" class="headerlink" title="AspectJ介绍"></a>AspectJ介绍</h1><p>介绍：一个字节码处理框架，实现AOP的工具。</p>
<p>原理：使用专门的编译器（ajc，可以执行ajc命令编译，也可以通过java执行）操作Class字节码，内部使用<a href="https://github.com/apache/commons-bcel">BCEL框架</a>。</p>
<p>由三部分组成：</p>
<ul>
<li><code>aspectjtools</code>：包含ajc编译器</li>
<li><code>aspectjweaver</code>：织入器，包含切点表达式处理，供ajc使用。并提供了javaagent用于类加载时期织入代码</li>
<li><code>aspectjrt</code>：包含@AspectJ注解</li>
</ul>
<p>三种织入时机（参考<a href="https://www.jianshu.com/p/3c5b09f6f563">AspectJ使用介绍</a>）：</p>
<ul>
<li>compile-time：编译期织入，处理Java源文件，使用ajc编译期替代javac编译器</li>
<li>post-compile：编译后织入，处理class字节码文件，如增强三方库中的方法</li>
<li>load-time：在 JVM 进行类加载的时候进行织入，使用wearver织入器</li>
</ul>
<p>特点：</p>
<ol>
<li>使用简单：不需要了解 .class 字节码文件格式 ，在目标位置插入或替换为自定义代码;</li>
<li>成熟稳定：直接修改字节码很容易出错，导致程序无法运行。AspectJ使用了专门的编译器，基本不需要考虑生成字节码正确性的问题。</li>
<li>不受访问限制：final、static、private都可以修改</li>
<li>切入点固定：AspectJ 只能在固定的几个切入点插入，如方法调用前、方法内部、异常前后、变量修改等；</li>
<li>匹配规则：AspectJ 的匹配规则类似于正则表达式；也可以结合注解匹配；</li>
<li>使用静态织入，<strong>无法织入Android SDK</strong>。如：需要先重写生命周期方法才能被织入。</li>
<li>重复织入：同样的方法，父类和子类都会织入，除非匹配具体类型。</li>
<li>性能较低：AspectJ 插入逻辑时，会添加一些冗余代码，如果<strong>大面积使用</strong>会影响性能；</li>
<li>增加编译时间：编译时需要扫描匹配规则，插入代码。——可以排除不需要扫描的包，匹配规则尽可能具体，减少匹配时间。配置只在debug/release环境生效</li>
<li>多个切点匹配到同一个方法，需要关注通知优先级。</li>
</ol>
<h1 id="AspectJ基本使用"><a href="#AspectJ基本使用" class="headerlink" title="AspectJ基本使用"></a>AspectJ基本使用</h1><p>具体语法可参考<a href="https://www.eclipse.org/aspectj/doc/released/progguide/starting.html">AspectJ官方文档</a>、<a href="https://www.eclipse.org/aspectj/doc/released/aspectj5rt-api/index.html">文档</a></p>
<p>两种用法：</p>
<ol>
<li>创建aj文件，使用AspectJ的语言（语法类似java，多了一些关键字）定义切点和通知（即切面），<strong>需要使用ajc进行编译</strong></li>
<li>使用纯Java语言开发，通过AspectJ进行注解，简称@AspectJ，<strong>也要通过ajc进行编译</strong></li>
</ol>
<p>从切点匹配角度看，有两种方式</p>
<ol>
<li>非侵入式：通过关键字匹配目标连接点<ol>
<li>不需要修改连接点代码</li>
<li>难以精确控制切入点</li>
<li>如果有10个方法，分别需要检查不同权限，我们需要定义10个切点和通知</li>
<li>如果方法名和路径变了，需要检查和修改切面</li>
</ol>
</li>
<li>侵入式：通过自定义注解找到目标连接点。<ol>
<li>需要在连接点处加入注解</li>
<li>不需要修改切面代码，即可修改切点。</li>
<li>如果运行时需要读取注解参数，则使用<code>RetentionPolicy.RUNTIME</code>，否则可以使用<code>RetentionPolicy.CLASS</code>。</li>
</ol>
</li>
</ol>
<h2 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h2><ol>
<li>*：匹配任何数量字符；</li>
<li>..：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包；而在方法参数模式中匹配任何数量参数。</li>
<li>+：匹配指定类型的子类型；仅能作为后缀放在类型模式后边。</li>
</ol>
<p>可以使用 且（&amp;&amp;）、或（||）、非（！）来组合切入点表达式。</p>
<p>切点定义有两种写法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法1：切点和Advice一起定义</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* *..*Activity.on*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforLifecycle</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法2：先定义切点，Advice关联切点，可以复用切点</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*Activity.on*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Before(&quot;onLifecycle&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforLifecycle</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接选择JoinPoint"><a href="#直接选择JoinPoint" class="headerlink" title="直接选择JoinPoint"></a>直接选择JoinPoint</h3><p>匹配方法Signature信息。切点和连接点对应选择条件如下</p>
<table>
<thead>
<tr>
<th>Joint Point</th>
<th>Pointcuts 表达式</th>
</tr>
</thead>
<tbody><tr>
<td>Method call</td>
<td>call(MethodSignature)</td>
</tr>
<tr>
<td>Method execution</td>
<td>execution(MethodSignature)</td>
</tr>
<tr>
<td>Constructor call</td>
<td>call(ConstructorSignature)</td>
</tr>
<tr>
<td>Constructor execution</td>
<td>execution(ConstructorSignature)</td>
</tr>
<tr>
<td>Class initialization</td>
<td>staticinitialization(TypeSignature)</td>
</tr>
<tr>
<td>Field get</td>
<td>get(FieldSignature)</td>
</tr>
<tr>
<td>Field set</td>
<td>set(FieldSignature)</td>
</tr>
<tr>
<td>Exception Handler，try-catch中的catch代码块</td>
<td>handler(TypeSignature)</td>
</tr>
<tr>
<td>Object initialization</td>
<td>initialization(ConstructorSignature)</td>
</tr>
<tr>
<td>Object pre-initialization</td>
<td>preinitialization(ConstructorSignature)</td>
</tr>
</tbody></table>
<p><code>![](2021-12-02-AspectJ介绍和示例/AspectJ切点类型.png)</code></p>
<h3 id="间接选择JoinPoint"><a href="#间接选择JoinPoint" class="headerlink" title="间接选择JoinPoint"></a>间接选择JoinPoint</h3><p>除了上面与 Join Point 对应的选择外，Pointcuts 还有其他选择方法。如选择某个类中所有的JPoint、某个方法执行过程中包含的JPoint、满足某些条件的JPoint等</p>
<table>
<thead>
<tr>
<th>Pointcuts 表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>within(TypePattern)</td>
<td>TypePattern标识类或者包，表示在某个包或者类中的所有JPoint</td>
</tr>
<tr>
<td>withincode(MethodPattern|ConstructorPattern)</td>
<td>在方法/构造方法执行过程中涉及到的JPoint</td>
</tr>
<tr>
<td>cflow(Pointcut)</td>
<td>call flow，调用切点方法时所包含的JPoint，包括切点本身</td>
</tr>
<tr>
<td>cflowbelow(Pointcut)</td>
<td>调用切点方法时所包含的JPoint，不包括切点本身</td>
</tr>
<tr>
<td>this(Type)</td>
<td>JPoint 所属的 this 对象是否是Type类型</td>
</tr>
<tr>
<td>target(Type)</td>
<td>JPoint 所在的对象（例如 call 或 execution 操作符应用的对象）是否是Type类型</td>
</tr>
<tr>
<td>args(Type, …)</td>
<td>JPoint方法或构造函数参数的类型</td>
</tr>
<tr>
<td>if(BooleanExpression)</td>
<td>满足表达式的 Join Point，表达式只能使用静态属性、Pointcuts 或 Advice 暴露的参数、thisJoinPoint 对象</td>
</tr>
</tbody></table>
<p><code>![](2021-12-02-AspectJ介绍和示例/间接选择JPoint.png)</code></p>
<h2 id="this和target区别"><a href="#this和target区别" class="headerlink" title="this和target区别"></a>this和target区别</h2><ul>
<li>this：指织入代码所属类的实例对象（织入代码的地方）</li>
<li>target：指切入点方法的所有者（方法定义的地方）</li>
</ul>
<blockquote>
<p>切点为call情况下，织入代码的地方（方法调用的地方）和方法的所有者（方法定义的地方）不一样</p>
<p>切点为execution的情况下，this=target</p>
</blockquote>
<h2 id="call和execution区别"><a href="#call和execution区别" class="headerlink" title="call和execution区别"></a>call和execution区别</h2><p><strong>可以反编译对比</strong></p>
<ul>
<li>call：代表调用方法的位置，插入在函数体外面。</li>
<li>execution：代表方法执行的位置，插入在函数体内部。</li>
</ul>
<h2 id="Before、After和Around区别"><a href="#Before、After和Around区别" class="headerlink" title="Before、After和Around区别"></a>Before、After和Around区别</h2><p><strong>可以反编译对比</strong></p>
<ol>
<li>Before和After通知：在匹配到的JoinPoint前后插入代码</li>
<li>Around通知：使用代理+闭包进行替换。将原方法体放到一个闭包（<code>AroundClosure</code>）中，通过调用<code>ProceedingJoinPoint.proceed</code>方法执行原逻辑。（可以调用set$AroundClosure替换闭包，即修改原逻辑）</li>
</ol>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ol>
<li>类加载时Hook</li>
<li>对项目中的三方库进行Hook</li>
<li>增加接口实现、添加成员变量等</li>
</ol>
<h1 id="Android中引入AspectJ"><a href="#Android中引入AspectJ" class="headerlink" title="Android中引入AspectJ"></a>Android中引入AspectJ</h1><p>大部分资料和框架（如Hugo、AspectJX等）都比较老，AspectJ可能不够主流，更多用在Spring中。因此可能存在版本兼容问题（如Gradle版本、JDK版本 Lambda、R8等）。</p>
<p><strong>AspectJ需要使用ajc编译器处理，因此要配置加入Android构建流程中</strong></p>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ol>
<li>根目录<code>build.gradle</code>添加AspectJ Gradle插件</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根目录build.gradle</span></span><br><span class="line">classpath <span class="string">&#x27;org.aspectj:aspectjtools:1.8.9&#x27;</span> <span class="comment">//包含ajc编译器</span></span><br><span class="line">classpath <span class="string">&#x27;org.aspectj:aspectjweaver:1.8.9&#x27;</span> <span class="comment">//包含切点表达式处理，供ajc使用。并提供了javaagent用于类加载时期织入代码</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>模块<code>build.gradle</code>添加ajc编译</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.bridge.IMessage</span><br><span class="line"><span class="keyword">import</span> org.aspectj.bridge.MessageHandler</span><br><span class="line"><span class="keyword">import</span> org.aspectj.tools.ajc.Main</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">def</span> log = project.logger</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">def</span> variants = project.android.applicationVariants</span><br><span class="line">variants.all &#123; variant -&gt;</span><br><span class="line">    <span class="keyword">if</span> (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Skipping non-debuggable build type &#x27;$&#123;variant.buildType.name&#125;&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    JavaCompile javaCompile = variant.javaCompileProvider.get()</span><br><span class="line">    javaCompile.doLast &#123;</span><br><span class="line">      <span class="comment">//在Java编译完之后执行</span></span><br><span class="line">				print(<span class="string">&quot;——————————ajc start——————————&quot;</span>)</span><br><span class="line">        String[] args = [<span class="string">&quot;-showWeaveInfo&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;-1.8&quot;</span>,<span class="comment">//注意版本保存一致</span></span><br><span class="line">                         <span class="string">&quot;-inpath&quot;</span>, javaCompile.destinationDir.toString(),</span><br><span class="line">                         <span class="string">&quot;-aspectpath&quot;</span>, javaCompile.classpath.asPath,</span><br><span class="line">                         <span class="string">&quot;-d&quot;</span>, javaCompile.destinationDir.toString(),</span><br><span class="line">                         <span class="string">&quot;-classpath&quot;</span>, javaCompile.classpath.asPath,</span><br><span class="line">                         <span class="string">&quot;-bootclasspath&quot;</span>, project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line">        log.debug <span class="string">&quot;ajc args: &quot;</span> + Arrays.toString(args)</span><br><span class="line"></span><br><span class="line">        MessageHandler handler = <span class="keyword">new</span> MessageHandler(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">new</span> Main().run(args, handler)</span><br><span class="line">        <span class="keyword">for</span> (IMessage <span class="attr">message :</span> handler.getMessages(<span class="literal">null</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (message.getKind()) &#123;</span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">ABORT:</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">ERROR:</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">FAIL:</span></span><br><span class="line">                    log.error message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">WARNING:</span></span><br><span class="line">                    log.warn message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">INFO:</span></span><br><span class="line">                    log.info message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> IMessage.<span class="attr">DEBUG:</span></span><br><span class="line">                    log.debug message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加@AspectJ依赖库：<code>implementation &#39;org.aspectj:aspectjrt:1.8.9&#39;</code>，包含@AspectJ注解</li>
<li>使用注解定义切面</li>
</ol>
<p><strong>可以查看AspectJ构建时的打印，会提示匹配规则语法错误，或者未匹配到切点等，用于排查错误</strong></p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>自定义Gradle插件，将ajc编译脚本进行封装，使用<code>apply plugin</code>即可插入构建流程</p>
<p>插件编写可以参考：</p>
<ul>
<li><a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx">沪江AspectJX</a>：支持扫描三方库jar、aar。</li>
<li><a href="https://github.com/JakeWharton/hugo">Hugo</a>：提供@DebugLog注解用于打印方法耗时等，可以配置只在Debug环境生效。不支持扫描三方库</li>
<li><a href="https://github.com/uPhyca/gradle-android-aspectj-plugin">Gradle-Android-AspectJ-Plugin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/67563228">AspectJ在Android中的应用</a></li>
</ul>
<p>基于AspectJ实现的框架：（可以参考AOP应用场景和实现）</p>
<ul>
<li><a href="https://github.com/fengzhizi715/SAF-AOP">SAF-AOP</a>：依赖沪江AspectJX。提供子线程切换，Log打印，方法Hook、捕获异常、追踪方法耗时、动态申请权限等功能</li>
</ul>
<h2 id="配置只在Debug环境生效"><a href="#配置只在Debug环境生效" class="headerlink" title="配置只在Debug环境生效"></a>配置只在Debug环境生效</h2><ul>
<li>如果是三方库，可以使用<code>debugImplementation</code>依赖</li>
<li>如果是自己写编译脚本，可以判断buildType，不执行ajc编译</li>
</ul>
<h1 id="AspectJ示例"><a href="#AspectJ示例" class="headerlink" title="AspectJ示例"></a>AspectJ示例</h1><p>只列出切面方法，测试代码均在<code>AspectJActivity</code>中。</p>
<p>代码已上传至<a href="https://github.com/Afauria/AOPSample">仓库</a></p>
<h2 id="打印生命周期"><a href="#打印生命周期" class="headerlink" title="打印生命周期"></a>打印生命周期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;LifecycleAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义切点：匹配Activity中on开头的方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* *..*Activity.on*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在切点之前执行</span></span><br><span class="line">    <span class="meta">@Before(&quot;onLifecycle()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforLifecycle</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<ol>
<li>由于AspectJ使用静态织入，无法检测到Android SDK中的方法，因此只会对Activity中重写的生命周期生效</li>
<li>on开头的不一定是生命周期方法</li>
<li>重复织入：如果定义BaseActivity并且继承的话，会打印两遍生命周期</li>
</ol>
<p>解决方法：</p>
<ol>
<li>定义BaseActivity，以 BaseActivity 作为切入点。如：<code>execution(* BaseActivity.on**(..))</code></li>
<li>通过Application.ActivityLifecycleCallbacks监听生命周期的变化。</li>
</ol>
<h2 id="对APP中所有方法进行Systrace函数插桩，用于分析性能"><a href="#对APP中所有方法进行Systrace函数插桩，用于分析性能" class="headerlink" title="对APP中所有方法进行Systrace函数插桩，用于分析性能"></a>对APP中所有方法进行Systrace函数插桩，用于分析性能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugTraceAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Around和Before、After匹配到同一个目标的时候，Around切点需要放到前面</span></span><br><span class="line">  	<span class="comment">//匹配所有方法</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* **(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTrace</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;beginTrace: &quot;</span> + <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        Trace.beginSection(joinPoint.getSignature().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* **(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTrace</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;endTrace: &quot;</span> + <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        Trace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监测和捕获异常"><a href="#监测和捕获异常" class="headerlink" title="监测和捕获异常"></a>监测和捕获异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;ExceptionAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原理：匹配代码中的try-catch块，且catch的类型要一样，否则无法匹配。</span></span><br><span class="line">  	<span class="comment">//比如切点表达式使用Exception，如果代码中catch的是NullPointerException，则无法匹配到。</span></span><br><span class="line">    <span class="comment">//或者使用通配符</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;handler(java.lang.*Exception) &amp;&amp; args(e)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(value = &quot;onException(e)&quot;, argNames = &quot;e&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExceptionBefore</span><span class="params">(JoinPoint joinPoint, Exception e)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;handleExceptionBefore: &quot;</span> + <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; &quot;</span> + e.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原理：在目标位置加try-catch，catch之后先执行方法，再throw抛异常。并不会阻止程序崩溃</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* *(..))&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Exception e)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;afterThrowing: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//如果要捕获异常，可以使用注解，在指定方法的Around中加try-catch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 校验方法参数是否为空，为空则不执行</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckArgsAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;CheckArgsAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配有一个String类型参数的方法，可以使用..匹配多参数</span></span><br><span class="line">  	<span class="comment">//Advice方法中参数名称需要和args表达式中名称一样</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* *(String)) &amp;&amp; args(arg)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkArgs</span><span class="params">(ProceedingJoinPoint joinPoint, String arg)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;checkArgs: &quot;</span> + arg + <span class="string">&quot; [&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        <span class="keyword">if</span> (arg != <span class="keyword">null</span> &amp;&amp; !arg.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(((Context) joinPoint.getThis()), <span class="string">&quot;参数为空&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 目标：对@CheckLogin注解声明的方法进行登录校验</span></span><br><span class="line"><span class="comment">//2. 定义@CheckLogin注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckLogin &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckLoginAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;CheckLoginAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(@CheckLogin * *(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLogin</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//Aspect中只处理简单的逻辑，复杂的功能交给专业模块处理，Aspect只负责拦截收集信息</span></span><br><span class="line">        <span class="keyword">if</span> (Tools.checkLogin()) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;checkLogin: 已登录&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//或者直接跳转登录页面</span></span><br><span class="line">            Log.e(TAG, <span class="string">&quot;checkLogin: 未登录&quot;</span>);</span><br><span class="line">            Toast.makeText(((Context) joinPoint.getThis()), <span class="string">&quot;请登录...&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统计特定方法耗时"><a href="#统计特定方法耗时" class="headerlink" title="统计特定方法耗时"></a>统计特定方法耗时</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 目标：打印@DebugTrace注解方法的耗时</span></span><br><span class="line"><span class="comment">//2. 定义DebugTrace注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DebugTrace &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugTraceAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;DebugTraceAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(@DebugTrace * *(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> duration = System.currentTimeMillis() - time;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;[&quot;</span>+joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法耗时: &quot;</span> + duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出示例</span></span><br><span class="line"><span class="comment">//E/DebugTraceAspect: [MainActivity.java:34] clickEvent方法耗时: 1000</span></span><br></pre></td></tr></table></figure>

<h2 id="权限检查和动态申请"><a href="#权限检查和动态申请" class="headerlink" title="权限检查和动态申请"></a>权限检查和动态申请</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 目标：@CheckPermissions注解声明的方法需要检查权限</span></span><br><span class="line"><span class="comment">//2. 定义CheckPermission注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckPermissions &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckPermissionsAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;CheckPermissionAspect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(@CheckPermissions * *(..)) &amp;&amp; @annotation(annotation)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(ProceedingJoinPoint joinPoint, CheckPermissions annotation)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//复杂逻辑可以抽出去，如使用PermissionUtil</span></span><br><span class="line">        Log.e(TAG, <span class="string">&quot;checkPermission: &quot;</span> + <span class="string">&quot;[&quot;</span> + joinPoint.getSourceLocation() + <span class="string">&quot;] &quot;</span> + joinPoint.getSignature().getName() + annotation);</span><br><span class="line">        String[] permissions = annotation.value();</span><br><span class="line">        <span class="keyword">if</span> (permissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Activity activity = (Activity) joinPoint.getTarget();</span><br><span class="line">            List&lt;String&gt; deniedPermission = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; permissions.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (activity.checkSelfPermission(permissions[i]) == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">                    deniedPermission.add(permissions[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!deniedPermission.isEmpty()) &#123;</span><br><span class="line">              	<span class="comment">//动态申请权限，需要在onRequestPermissionsResult中检查是否授权成功。也可以通过切入的方式检查</span></span><br><span class="line">                activity.requestPermissions(permissions, <span class="number">0x1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    joinPoint.proceed();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动findViewById"><a href="#自动findViewById" class="headerlink" title="自动findViewById"></a>自动findViewById</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 确定目标：@BindView注解声明的变量使用的时候自动findViewById</span></span><br><span class="line"><span class="comment">//2. 定义BindView注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindViewAspect</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//切点为@BindView注解声明的变量的get方法，传入annotation参数</span></span><br><span class="line">		<span class="meta">@Around(&quot;get(@BindView * *) &amp;&amp; @annotation(annotation)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">bindViewById</span><span class="params">(JoinPoint joinPoint, BindView annotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Activity) joinPoint.getTarget()).findViewById(annotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="点击事件节流"><a href="#点击事件节流" class="headerlink" title="点击事件节流"></a>点击事件节流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 目标：使用@ThrottleClick注解声明的方法一段时间内只会触发一次</span></span><br><span class="line"><span class="comment">//2. 定义@ThrottleClick注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ThrottleClick &#123;</span><br><span class="line">  	<span class="comment">//支持设置间隔时间</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duration</span><span class="params">()</span> <span class="keyword">default</span> 500</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrottleAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存上一次点击时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTime = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(@ThrottleClick * *(..)) &amp;&amp; @annotation(annotation)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleThrottle</span><span class="params">(ProceedingJoinPoint joinPoint, ThrottleClick annotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> duration = annotation.duration();</span><br><span class="line">        <span class="comment">//超过间隔时间才可触发点击事件</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - lastTime &gt; duration) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">                lastTime = System.currentTimeMillis();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>面向切面编程（AOP）</title>
    <url>/2021/12/01/tech-2021-12-01-AOP/</url>
    <content><![CDATA[<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><h2 id="OOP和AOP"><a href="#OOP和AOP" class="headerlink" title="OOP和AOP"></a>OOP和AOP</h2><ul>
<li>OOP（Object Oriented Program，面向对象编程）：侧重对功能进行模块化和封装继承。关注静态的对象层次结构。</li>
<li>AOP（Aspect Oriented Program，面向切面编程）：侧重对横跨各个模块中的公共功能进行统一处理。关注动态的运行时的业务流程。</li>
</ul>
<p>例如使用OOP封装了一个日志框架，包含打印、缓存、上报等功能。看起来很完美，实际上存在以下问题：</p>
<ol>
<li>对调用方来说，需要在多处地方添加方法调用，和调用方的主业务耦合，违背单一职责原则。代码分散，需求变动的时候需要改动多处。</li>
<li>难以对<strong>现有对象</strong>（如三方库中的类）动态添加功能，需要通过继承或组合的方式扩展对象功能。</li>
<li>编写代码的时候需要考虑不同类之间的共性，再提取方法或者接口。</li>
</ol>
<p>如下图</p>
<pre class="mermaid">graph TB
subgraph 验证用户方法封装
a[验证用户]
b[验证用户]
c[验证用户]
end
流程1[开始]-->a-->查询余额
流程2[开始]-->b-->取款
流程3[开始]-->c-->转账</pre>

<p>需要在每个流程中加入验证用户的步骤，即使对重复代码进行了封装，但还是免不了要调用方法。</p>
<p>解决：将验证用户的方法抽离出来（切面），在编译或者运行期间讲代码<strong>织入</strong>到目标位置（连接点）。我们把这种方法叫AOP。</p>
<p><strong>AOP能够将这些与业务无关，却被业务模块所共同调用的逻辑封装起来（切面）；在不侵入业务代码的情况下，将这些公共的功能插入到主业务流程中（连接点）。减少系统的重复代码，降低模块间的耦合度，提高可维护性。</strong></p>
<p><strong>AOP的思想可以让我们在写代码的时候只考虑主业务流程，而不用考虑这些不重要的流程。</strong></p>
<p>AOP和OOP是互补的关系</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><p>横切关注点（Cross-cutting concerns）：面向对象模型中大多数类会实现单一特定的功能，但有时候也需要添加一些公共的附属功能。例如日志、埋点等功能会分布在不同对象层次中，与对象自身的功能没有关系。这些散布在各处的无关的代码称为<strong>横切关注点</strong>。</p>
</li>
<li><p>连接点（JoinPoint）：程序运行时的一些执行点，可以在这些地方插入代码。如方法调用、方法执行、类初始化、构造、变量get和set等。</p>
</li>
<li><p>切点（Pointcut）：用于选择和匹配我们想要插入代码的目标JoinPoint。</p>
<blockquote>
<p>关于切点，有两种说法，刚开始看概念很容易混乱，两种理解都可以，只是角度不同。</p>
<ol>
<li>切点是指写匹配规则的地方，定义在切面中。关注从哪里切入（切入的点）</li>
<li>切点是指匹配到的结果（目标JoinPoint），是JoinPoint的子集。关注切到的结果（切到的点）</li>
</ol>
</blockquote>
</li>
<li><p>通知（Advice）：Pointcut拦截到JoinPoint之后要做的事情，即要增强的功能（要注入的代码，如log打印，权限检查等）。常见的通知类型如前置通知（在Pointcut之前执行）、后置通知、异常通知、最终通知、环绕通知。</p>
</li>
<li><p>切面（Aspect）：切入点+通知=切面</p>
</li>
<li><p>织入（Weaving）：注入代码（Advice）到目标位置（JoinPoint）的过程。分为静态织入（编译期或类加载期）和动态织入（运行期）</p>
</li>
<li><p>目标对象（Target）：被代理的对象</p>
</li>
<li><p>代理（Proxy）：一个类被增强实际上是生成一个代理类，调用的时候实际上是调用代理类的方法。</p>
</li>
</ul>
<p><img src="/2021/12/01/tech-2021-12-01-AOP/AOP%E6%A6%82%E5%BF%B5.png"></p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ol>
<li>静态织入：编译期织入代码。又分为不同阶段：java、class、dex代码。如APT、AspectJ、ASM、Javassit、ASMDex、DexMaker、操作AST、手动修改class文件。</li>
<li>动态织入：运行时织入代码。又分为类加载和运行。如Java动态代理、Cglib、Javassit、XPosed、Dexposed、自定义类加载器。</li>
</ol>
<pre class="mermaid">graph TB
subgraph 编译期
源代码--"APT"-->java文件--"AspectJ"-->class1[class字节码]--"Javassist、ASM、AspectJ"-->dex字节码
end
subgraph 运行期
dex字节码--"Javassist、ASM、ASMDex、DexMaker"-->ClassLoader类加载--"Dexposed、Xposed"-->运行
end</pre>

<p>Android注解解析主要分为两种：</p>
<ol>
<li>运行时反射解析当前类（注解作用域：RUNTIME）：性能较低。</li>
<li>编译期生成代理类和代理对象（注解作用域：SOURCE、CLASS）：需要生成额外代码</li>
</ol>
<h2 id="APT（Annotation-Processing-Tool，注解处理器）"><a href="#APT（Annotation-Processing-Tool，注解处理器）" class="headerlink" title="APT（Annotation Processing Tool，注解处理器）"></a>APT（Annotation Processing Tool，注解处理器）</h2><p>见<a href>APT介绍和实践</a></p>
<table>
<thead>
<tr>
<th>AOP技术</th>
<th>作用时机</th>
<th>输入</th>
<th>输出</th>
<th>代表框架</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>APT</td>
<td>编译期</td>
<td>Java文件</td>
<td>Java文件</td>
<td>DataBinding、Dagger2、ButterKnife、EventBus3、DBFlow</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="方法优缺点、难点比对"><a href="#方法优缺点、难点比对" class="headerlink" title="方法优缺点、难点比对"></a>方法优缺点、难点比对</h2><p>//todo</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用时机</th>
<th>操作对象</th>
<th>优点</th>
<th>缺点</th>
<th>为了上手，我需要掌握什么？</th>
</tr>
</thead>
<tbody><tr>
<td><strong>APT</strong></td>
<td>编译期：还未编译为 class 时</td>
<td>.java 文件</td>
<td>1. 可以织入所有类；2. 编译期代理，减少运行时消耗</td>
<td>1. 需要使用 apt 编译器编译；2. 需要手动拼接代理的代码（可以使用 Javapoet 弥补）；3. 生成大量代理类</td>
<td>设计模式和解耦思想的灵活应用</td>
</tr>
<tr>
<td><strong>AspectJ</strong></td>
<td>编译期、加载时</td>
<td>.java 文件</td>
<td>功能强大，除了 hook 之外，还可以为目标类添加变量，接口。也有抽象，继承等各种更高级的玩法。</td>
<td>1. 不够轻量级；2. 定义的切点依赖编程语言，无法兼容Lambda语法；3. 无法织入第三方库；4. 会有一些兼容性问题，如：D8、Gradle 4.x等</td>
<td>复杂的语法，但掌握几个简单的，就能实现绝大多数场景</td>
</tr>
<tr>
<td><strong>Javassist</strong></td>
<td>编译期：class 还未编译为 dex 时或运行时</td>
<td>class 字节码</td>
<td>1. 减少了生成子类的开销；2. 直接操作修改编译后的字节码，直接绕过了java编译器，所以可以做很多突破限制的事情，例如，跨 dex 引用，解决热修复中 CLASS_ISPREVERIFIED 问题。</td>
<td>运行时加入切面逻辑，产生性能开销。</td>
<td>1. 自定义 Gradle 插件；2. 掌握groovy 语言</td>
</tr>
<tr>
<td><strong>ASM</strong></td>
<td>编译期或运行期字节码注入</td>
<td>class 字节码</td>
<td>小巧轻便、性能好，效率比Javassist高</td>
<td>学习成本高</td>
<td>需要熟悉字节码语法，ASM 通过树这种数据结构来表示复杂的字节码结构，并利用 Push 模型来对树进行遍历，在遍历过程中对字节码进行修改。</td>
</tr>
<tr>
<td><strong>ASMDEX</strong></td>
<td>编译期和加载时：转化为 .dex 后</td>
<td>Dex 字节码，创建 class 文件</td>
<td>可以织入所有类</td>
<td>学习成本高</td>
<td>需要对 class 文件比较熟悉，编写过程复杂。</td>
</tr>
<tr>
<td><strong>DexMaker</strong></td>
<td>同ASMDEX</td>
<td>Dex 字节码，创建 dex 文件</td>
<td>同ASMDEX</td>
<td>同ASMDEX</td>
<td>同ASMDEX</td>
</tr>
<tr>
<td><strong>Cglib</strong></td>
<td>运行期生成子类拦截方法</td>
<td>字节码</td>
<td>没有接口也可以织入</td>
<td>1. 不能代理被final字段修饰的方法；2. 需要和 dexmaker 结合使用</td>
<td>–</td>
</tr>
<tr>
<td><strong>xposed</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>能hook自己应用进程的方法，能hook其他应用的方法，能hook系统的方法</td>
<td>依赖三方包的支持，兼容性差，手机需要root</td>
<td>–</td>
</tr>
<tr>
<td><strong>dexposed</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>只能hook自己应用进程的方法，但无需root</td>
<td>1. 依赖三方包的支持，兼容性差；2. 只能支持 Dalvik 虚拟机</td>
<td>–</td>
</tr>
<tr>
<td><strong>epic</strong></td>
<td>运行期hook</td>
<td>–</td>
<td>支持 Dalvik 和 Art 虚拟机</td>
<td>只适合在开发调试中使用，碎片化严重有兼容性问题</td>
<td>–</td>
</tr>
</tbody></table>
<h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><p>见<a href="/2021/12/02/tech-2021-12-02-AspectJ%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B/">AspectJ介绍和案例</a></p>
<h2 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2><p><strong>ASM 插桩工具 :</strong></p>
<p><strong>操作灵活 :</strong> 可以在字节码任何位置，自定义修改、插入、删除相关逻辑 ;</p>
<p><strong>上手很难 :</strong> 对 .class 字节码文件有比较深入的了解，编写过程较复杂</p>
<table>
<thead>
<tr>
<th>AOP技术</th>
<th>功能</th>
<th>性能</th>
<th>面向接口编程</th>
<th>编程难度</th>
</tr>
</thead>
<tbody><tr>
<td>直接改写class文件</td>
<td>完全控制类</td>
<td>无明显性能代价</td>
<td>不要求</td>
<td>高，要求对class文件结构和Java字节码有深入的了解</td>
</tr>
<tr>
<td>JDK Instrument</td>
<td>完全控制类</td>
<td>无论是否改写，每个类装入时都要执行 hook 程序</td>
<td>不要求</td>
<td>高，要求对 class 文件结构和 Java 字节码有深刻了解</td>
</tr>
<tr>
<td>JDK Proxy</td>
<td>只能改写 method</td>
<td>反射引入性能代价</td>
<td>要求</td>
<td>低</td>
</tr>
<tr>
<td>ASM</td>
<td>几乎能完全控制类</td>
<td>无明显性能代价</td>
<td>不要求</td>
<td>中，能操纵需要改写部分的 Java 字节码</td>
</tr>
<tr>
<td>AspectJ</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>基于ASM的字节码处理工具：<a href="https://github.com/Leaking/Hunter/blob/master/README_ch.md">Hunter</a>、<a href="https://github.com/BryanSharp/hibeaver">Hibeaver</a></p>
<p>基于Javassist的字节码处理工具：DroidAssist</p>
<p>ASM是一个框架/库，它为您提供了一个API来操作现有的字节码和/或轻松生成新的字节码。</p>
<p>另一方面，AspectJ是一种基于Java语言的语言扩展，具有自己的语法，专门用于通过面向方面的编程概念扩展Java运行时的功能。它包括一个编译器/编织器，可以在编译时或运行时运行。</p>
<p>它们的相似之处在于它们都通过现有字节码的字节码操作和/或生成新的字节码来实现其目标。</p>
<p>ASM更通用，因为它没有关于如何修改现有字节码的意见，它只是为您提供了一个API，您可以随心所欲地使用它。另一方面，AspectJ更具体，范围更窄，它只支持一些预定义的AOP结构，但它为您提供了一个界面（aspectj语言），如果您可以在这些结构中使用它，则更容易使用它为您提供。</p>
<p>对于我见过的大多数用例，AspectJ绰绰有余，但在极少数情况下，ASM可能是一个不错的选择，但是你需要更多的编程努力取得类似的成果。</p>
<h2 id="ASMDex"><a href="#ASMDex" class="headerlink" title="ASMDex"></a>ASMDex</h2><p>类似ASM的字节码操作库，运行在Android平台，操作dex字节码</p>
<h2 id="DexMaker"><a href="#DexMaker" class="headerlink" title="DexMaker"></a>DexMaker</h2><p>提供JavaAPI，用于编译期或运行时生成Dex字节码</p>
<h2 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h2><p>原理：使用Gradle Task或Transform，在dex文件生成之前，修改class字节码。不需要生成子类代理</p>
<p>框架：热修复HotFix</p>
<p>Javassist &amp; ASM 对比<br>Javassist抽象出源代码级的API，比ASM中实际的字节码操作更容易使用<br>Javassist使用反射机制，这使得它比运行时使用Classworking技术的ASM慢。<br>总的来说ASM比Javassist快得多，并且提供了更好的性能。Javassist使用Java源代码的简化版本，然后将其编译成字节码。这使得Javassist非常容易使用，但是它也将字节码的使用限制在Javassist源代码的限制之内。<br>总之，如果有人需要更简单的方法来动态操作或创建Java类，那么应该使用Javassist API 。如果需要注重性能地方，应该使用ASM库。</p>
<h2 id="Cglib（Code-Generation-Library）"><a href="#Cglib（Code-Generation-Library）" class="headerlink" title="Cglib（Code Generation Library）"></a>Cglib（Code Generation Library）</h2><p>原理：底层采用ASM字节码框架，运行期间类加载的时候为目标类创建一个字类，代理拦截父类方法调用。解决了JDK动态代理需要定义接口的问题</p>
<p>缺点：</p>
<ol>
<li>无法代理final类和方法：Cglib是通过子类代理实现的</li>
<li>无法在Android中使用，Android加载的是dex文件，而Cglib生成的是class文件：需要结合Dexmaker生成dex字节码文件。参考<a href="https://blog.csdn.net/zhangke3016/article/details/71437287">将cglib动态代理思想带入Android开发</a></li>
</ol>
<h1 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h1><ol>
<li>参数校验和判空</li>
<li>运行时权限验证或申请</li>
<li>运行时登录验证</li>
<li>检查网络连接</li>
<li>日志管理：输出调试日志。如打印代码行数、入参、出参等</li>
<li>重要生命周期添加打印</li>
<li>无侵入埋点</li>
<li>事件防抖</li>
<li>异常统一处理</li>
<li>事务处理</li>
<li>性能监控，如统计方法耗时</li>
<li>方法调用线程切换</li>
<li>对变量和方法返回值进行缓存和注入，内存缓存和持久缓存</li>
<li>对数据和常量加密</li>
<li>热修复：新方法替换旧方法</li>
</ol>
<p>AOP和字节码插桩的区别和联系</p>
<blockquote>
<ul>
<li>AOP：是一种编程思想，OOP的延续。将系统中非核心的业务提取出来，进行单独处理。AOP中用到了IoC和DI的思想</li>
<li>字节码插桩：即修改字节码，是实现AOP的一种技术。AOP除了修改字节码之外还可以修改源码、抽象语法树等。</li>
</ul>
<p>除了上面的场景之外，字节码插桩和修改还可以应用于：</p>
<ol>
<li>三方库Hook，不需要修改三方库源码</li>
<li>应用破解</li>
</ol>
</blockquote>
<p>AOP与IoC（控制反转）、DI（依赖注入）的区别和联系</p>
<blockquote>
<p>区别：AOP强调对代码运行过程进行修改。IoC和DI强调不同对象间的依赖关系，以及如何依赖。</p>
<p>联系：AOP和IoC用到的技术类似，例如AspectJ、APT、字节码修改等，既可用于AOP，也可以用于IoC</p>
<p>Tips：IoC和DI是同一个概念的不同描述，也可以说通过依赖注入来实现控制反转。</p>
</blockquote>
<h1 id="AOP实战"><a href="#AOP实战" class="headerlink" title="AOP实战"></a>AOP实战</h1><p>编写AOP思路：</p>
<ol>
<li>考虑注入代码的时机、以及注入是否有限制（如final、private限制），选择合适的AOP工具（使用场景、性能等）<ol>
<li>编译期：生成java、class、dex文件</li>
<li>运行期：类加载、运行时</li>
</ol>
</li>
<li>考虑要注入代码的地方：如方法调用、执行、类初始化等时机</li>
<li>考虑怎么找到要注入代码的地方<ol>
<li>匹配类名、方法名</li>
<li>使用注解标记</li>
</ol>
</li>
<li>考虑怎么处理代码<ol>
<li>在代码前后插入逻辑</li>
<li>替换目标代码</li>
</ol>
</li>
</ol>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><ol>
<li>Lancet轻量级的框架，编译速度快，支持增量编译</li>
<li>Lancet语法简单，易于上手。AspectJ需要学习的语法比较多。</li>
<li>Lancet仅支持hook具体的方法，不能像AspectJ一样根据自定义的注解来Hook一个类或者任意的方法。</li>
</ol>
<h2 id="使用场景建议"><a href="#使用场景建议" class="headerlink" title="使用场景建议"></a>使用场景建议</h2><ol>
<li>如果只是相对特定的函数，aar中函数、项目中的函数、Android系统源码中的函数进行Hook，可以选择使用Lancet。</li>
<li>如果需要使用注解对某一类操作进行Hook时，例如，权限检查、性能检测等函数，可以使用AspectJ。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考文章：</p>
<ul>
<li><a href="https://juejin.cn/post/6844903728525361165">一文读懂 AOP | 你想要的最全面 AOP 方法探讨</a></li>
<li><a href="https://juejin.cn/post/6844903741808705544">一文应用 AOP | 最全选型考量 + 边剖析经典开源库边实践，美滋滋</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础之自底向上设计</title>
    <url>/2021/11/28/basic-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="自底向上设计"><a href="#自底向上设计" class="headerlink" title="自底向上设计"></a>自底向上设计</h1><p>一台主机：不需要通信，不需要连接网络</p>
<p>问题：无法和其他电脑连接，通信，只有基础的运算功能</p>
<h2 id="网线直连"><a href="#网线直连" class="headerlink" title="网线直连"></a>网线直连</h2><p>两台主机：主机添加网口，使用一根网线连接通信</p>
<p>三台主机：每台主机开两个网口，分别连接两台主机</p>
<p>N台主机：….</p>
<p>问题：随着越来越多的人加入，网口越来越多，网线密密麻麻。</p>
<h2 id="集线器（Hub）"><a href="#集线器（Hub）" class="headerlink" title="集线器（Hub）"></a>集线器（Hub）</h2><p>使用集线器做转发：只有简单的收发功能，将电信号<strong>转发到所有出口</strong>，相当于广播。如图</p>
<p><img src="/2021/11/28/basic-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BA%BF%E5%99%A8.gif"></p>
<blockquote>
<ol>
<li>对接收到的信号进行再生整形放大，以扩大网络的传输距离</li>
<li>把所有节点集中在以它为中心的节点上。</li>
</ol>
</blockquote>
<p>我们把它定义在<strong>物理层</strong></p>
<p>问题：由于转发到了所有出口，接收方不知道数据包是不是发给自己的。</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>给每台设备起全局唯一的标识，使用6组8位数字表示，叫Mac地址。我们把它定义在<strong>数据链路层</strong></p>
<blockquote>
<p>MAC（Media Access Control，介质访问控制协议）</p>
<p>MAC地址可以重复，实际上只要不是同属一个数据链路就不会出现问题。</p>
</blockquote>
<p>如A设备的mac地址为<code>aa-aa-aa-aa-aa-aa</code>，B设备的mac地址为<code>bb-bb-bb-bb-bb-bb</code>。A给B发送数据的时候，带上地址，如图：</p>
<p><img src="/2021/11/28/basic-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/mac%E5%9C%B0%E5%9D%80%E6%95%B0%E6%8D%AE%E5%8C%85.png"></p>
<p>设备收到数据包后，判断是自己的就收下，不是自己的就丢弃，如图：</p>
<p><img src="/2021/11/28/basic-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BA%BF%E5%99%A8+Mac%E5%9C%B0%E5%9D%80.gif"></p>
<p>问题：本来只需要发送给一台设备，现在发了多台设备，既不安全，又浪费网络资源</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>使用交换机，将数据包转发给特定Mac地址的电脑。我们把它定义在<strong>数据链路层</strong></p>
<h1 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h1><p>ping过程发生了什么，输入网站url发生了什么</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h2><p>有不同的划分标准，一图以蔽之～</p>
<p><img src="/2021/11/28/basic-2021-11-28-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%BE%E8%AE%A1/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86.png"></p>
<ul>
<li>物理层（Physics Layer）</li>
<li>数据链路层（Data Link Layer）</li>
<li>网络层（Network Layer）</li>
<li>传输层（Transport Layer）</li>
<li>会话层（Session Layer）</li>
<li>表示层（Presentation Layer）</li>
<li>应用层（Application Layer）</li>
</ul>
<p>我们有两种网：1.分组交换 ；2.电路交换（电话）</p>
<p>在很久很久以前，你记不记着，有个“<strong>拨号连接</strong>”，有个叫做“猫”的东西？？？<br>没错，就是那个，一上网就打不了座机的时代<br>此时，我们还是<strong>电路交换</strong>哟</p>
<p>这样太蠢了！！！<br>如果我只是想上网看下小电影的简介，那我打开介绍小电影的网站，就暂时不会再通信了<br>所以，没必要一直给我连接着啊！</p>
<p>于是，我们用起了<strong>分组交换</strong><br>分组交换还有两种方式：<br>1.虚电路，如ATM（模拟电话线路）；2.<strong>数据报</strong>，如因特网</p>
<p>&gt;为啥因特网不用虚电路？<br>肯定是因为，大多数时候，虚电路没必要啊，而且麻烦不好用啊</p>
<p>&gt;为啥虚电路没必要&amp;不好用？<br>因为大多数时候，互联网没有实时要求啊，&amp;他的面向连接浪费资源啊</p>
<p>好嘞，现在我们知道了，因特网使用的是，数据报<br>我们先不管数据报是什么，我们<strong>先考虑下如何传输数据报</strong></p>
<p><strong>—————————————–</strong></p>
<p>我们的因特网，肯定是基于物理电路的，<br>因此，我们需要一个，将数据转化为物理信号的层，<br>于是，<strong>物理层诞生啦</strong></p>
<p><strong>—————————————-</strong></p>
<p>有了处理物理信号的物理层，可我们还得知道，<strong>信号发给谁啊<br><strong>你肯定知道，每个主机都有一个，全球唯一的MAC地址吧<br>所以，我们可以用MAC地址来寻址啊<br>恭喜你，</strong>链路层诞生啦</strong></p>
<p><strong>—————————————-</strong></p>
<p>别急，你知道MAC地址，是扁平化的吧<br>也就是说，MAC地址的空间分布，是无规律的！！！<br>如果你有十万台主机，要通过MAC地址来寻址<br><strong>无F**K可说**，<br>不管你设计什么样的算法，数据量都太大了！！！<br>所以，</strong>我们需要IP地址啊<br><strong>&lt;PS,IP里的有趣的东西太多啦，所以我补充在了最后&gt;<br>有了IP地址，恭喜你，</strong>网络层诞生啦**</p>
<p><strong>—————————————–</strong></p>
<p>然而，一台主机不能只和一台服务器通信啊，<br>毕竟下小电影，也要同时货比三家啊<br>那如何实现<strong>并行通信</strong>呢？<br>嘿嘿，我们有端口号啊</p>
<p>再基于不同需求：<br>有人想要连得快，不介意数据丢失，比如你的小电影<br>有人必须要数据可靠，比如发一个电子邮件<br>于是产生了UDP&amp;TCP<br>恭喜你，<strong>运输层诞生啦</strong></p>
<p><strong>—————————————–</strong></p>
<p>别急，你知道的吧，不同应用，有不同的传输需求<br>比如，请求网页，发送邮件，P2P…<br>而且，还有DHCP服务器啊<br>为了方便开发者，我们就对这些<strong>常用需求</strong>，进行了封装<br>恭喜你，<strong>应用层诞生啦</strong></p>
<p>至此，自底向上，讲述了计网。<br>待我考完试，我可以写一部，<strong>计算机网络·从下向顶方法</strong><br>（斜眼笑</p>
<p>====================</p>
<p><strong>&lt;细节补充&gt;</strong><br>&gt;来我们思考先一个问题：如果有四台电脑，要互相能通信，咋办？</p>
<p>&gt;每一台电脑都和另外三台连起来？<br>那我要是再来十台电脑，你在电脑上给我再加十个接口？</p>
<p>&gt;那，把他们连接到一个小盒子上，让小盒子帮着通信？<br>哎这个可以有啊，那如果我有一万台电脑，一个小盒子能够用？</p>
<p>&gt;嘿嘿，那让每一个小盒子连一百台，然后把一百台小盒子再连给一个小盒子</p>
<p>-———————————————-</p>
<p>我们可以用“电话线，宽带，和光纤”，把电脑接给小盒子，它们被称作“<strong>接入网</strong>”<br>而<strong>ISP</strong>就像小盒子，帮你在网络里做通信<br>而ISP的分层，无非就是，终端太多了，没办法不分层</p>
<p>好了，现在你已经明白了网络的<strong>层次化</strong></p>
<p>你肯定是知道，<br>为了在辣么多计算机里，找到目标，我们采用了，有规律的IP地址<br>而路由器，又叫<strong>分组交换机</strong>，就是帮我们在公网里，做IP寻址的</p>
<p>最初，IP地址是<strong>IPv4</strong><br>首先，IP地址是分成了五类（ABCDE）</p>
<p>奈何不够用啊，于是，我们是使用了<strong>子网划分</strong><br>然鹅，手动分配子网IP，会死人的！<br>于是，<strong>DHCP</strong>来了（斜眼笑</p>
<p>md还是不好用啊，于是，诞生了无分类编址（<strong>CIDR</strong>）<br>奈何，还是不够用啊<br>于是，<strong>NAT</strong>出现啦，于是专用网的IP不再占用公网IP</p>
<p>-————————————–</p>
<p>&gt;首先，啥是<strong>专用网</strong>啊<br>1.局域网，比如，公用一个路由器的宿舍啊，家啊<br>2.部分广域网，比如军队、铁路、交通、电力等部门，拥有自己专用的通信网和计算机网。然鹅，这些网络不对内部外的用户开放。这些网络覆盖的地理范围很广，因此，这些专用网都是广域网。</p>
<p>保密性质的广域网，通信要扯到VPN，宝宝没学到这里，先埋个坑</p>
<p>-————————————–</p>
<p>来我们先谈谈<strong>局域网内的通信</strong>：<br>如果哈，我们是一个大局域网，比如我们公司有一百台电脑，<br>首先，路由器没一百个接口让我插！<br>其次，如果我不想和公网通信，那我就没必要用路由器！<br>所以，<strong>链路交换机</strong>来了！！！</p>
<p>链路交换机是基于MAC寻址的，因为局域网没大到必须用IP寻址的地步啊<br>但更准确的说话，链路交换机采用了，跨越链路层和网络层边界的协议——<strong>ARP</strong><br>毕竟，ARP要做一个IP到MAC的映射，</p>
<p>-—————————————-</p>
<p>&gt;你问我，为啥ARP要做IP到MAC的映射<br>因为，你在应用层和运输层里，目的地址都写得是IP,<br>不把IP转化为MAC，咋寻址啊？</p>
<p>&gt;你问我，局域网为啥不用路由器，为啥要用链路交换机<br>交换机功能少，接口多，比路由器划算啊</p>
<p>&gt;那，局域网和公网怎么通信呢?<br>所以，<strong>NAT来了啊</strong>！！！</p>
<p>分组交换机，也就是路由器，用自己的公网IP，帮你们局域网里的人们，给公网发信息<br>然后把接受到的信息，再转发给，那个找他帮忙的人<br>这就是NAT技术啊混蛋！！！</p>
<p>-——————————————</p>
<p>这时一群人说，NAT bulabula不好，我们要拒绝NAT,使用<strong>IPv6</strong><br>那么就牵扯到了<strong>IPv4和IPv6间</strong>的通信（双栈||隧道）</p>
<p>还有啊，IP地址太丑啦，用户根本记不住 <a href="https://link.zhihu.com/?target=http://xxx.xxx.xxx.xxx">http://xxx.xxx.xxx.xxx</a><br>于是乎，<strong>域名</strong>千呼万唤始出来<br>顺便带出来了DNS服务器</p>
<p>1.网络应该分为：电路交换网络和分组交换网络（虚电路本质上是分组交换网络，也就是你说的数据报）。</p>
<p>2.互联网有实时性需求（比如直播）。</p>
<p>3.面向连接的协议（如TCP）需要比非面向连接的协议（如UDP）更多的资源，但是这是为了提供可靠到达等一系列服务所必须的资源。花更多的资源换取更好的服务，不是浪费。</p>
<p>4.专用网与局域网不同（了解一下虚拟专用网络VPN）。</p>
<p>5.局域网即使小，按照应用程序采用的协议，局域网内也可以采用TCP或者UDP等协议通信，所以也需要网络层的支撑，就需要IP。</p>
<p>6.局域网向公网建立连接需要采用“NAT”，公网想向局域网内的设备发起连接，需要“NAT穿透”。</p>
<p>7.DHCP是为了自动分配IP、子网掩码等设置，让新加入局域网的设备自动获得自己的网络配置。（NAT之前，需要DHCP分配给设备IP。但是DHCP分配给设备IP，并不是仅用于下一步的NAT，可能该设备仅需要局域网内通信，不NAT。此时仍然需要DHCP。所以DHCP和NAT是两个独立的概念，不是为了NAT方便才有了DHCP）。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>了解每一个协议、每一层设计的背景以及要解决的问题，多问为什么。</p>
<p>“如果没有操作系统，我们的手机和电脑可以说是废铁了，如果没有计算机网络，我们的手机和电脑就是一座孤岛。”</p>
<p>参考文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">低并发编程-如果让你来设计网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/372288743">小林coding-图解网络</a></li>
<li><a href="https://www.zhihu.com/column/c_1367181480708345856">知乎专栏-图解网络</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础之IP地址</title>
    <url>/2021/11/27/basic-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p>IPv4：使用32位（4字节）表示IP地址。</p>
<blockquote>
<p>可以用十六进制、十进制、八进制表示。也可以用点分格式表示，将IP地址分为4段，每段一个字节，中间用点分隔，包括点分十进制、点分十六进制、点分八进制</p>
<p>为了便于阅读和分析，通常写作点分十进制格式：将IP地址分为4段，每段1个字节，每段用十进制表示，中间用点分隔。</p>
<p>点分格式中每一段可以用不同的进制表示，合法但是不常用，如：192.0x00（16进制）.0002（八进制）.235（十进制）</p>
</blockquote>
<h2 id="私有地址和公有地址"><a href="#私有地址和公有地址" class="headerlink" title="私有地址和公有地址"></a>私有地址和公有地址</h2><p>公有地址：向InterNIC注册申请，可以直接访问互联网。</p>
<p>私有地址（专用地址）：非注册地址，供组织机构内部使用，自行分配和管理，无法被其他网络发现，因此可以重复。和互联网通信需要通过网关。</p>
<blockquote>
<p>IP地址类似家庭住址，一台主机向另一台主机发送数据，类似于寄信。</p>
<p>公有地址由组织统一分配注册，不可重复，如解放路44号。邮递员可以直接把信送到该地址。</p>
<p>私有地址相当于小区内的门牌号，如1栋101，其他小区也可以叫1栋101。邮递员只能找到注册的地址，因此只能送到小区门口的保卫处（网关），由保卫处送到具体的门牌号。同样的，发信也要经过保卫处。</p>
</blockquote>
<p>私有地址如果要连到Internet，需要将私有地址转换为公有地址，这个过程称为NAT（Network Address Translation，网络地址转换）。</p>
<h2 id="网关和路由"><a href="#网关和路由" class="headerlink" title="网关和路由"></a>网关和路由</h2><p>网关：将一个网络连接到另一个网络的关口。</p>
<p>设备会配置网关，如果两台主机不在同一个网络下，会将数据包发到网关，再转发给另一台主机。网关也有自己的IP地址，一般是本地网络下的第一个主机号。</p>
<p>一台主机可以有多个网关，如果找不到可用的网关，会将数据包发给默认网关</p>
<p>在windows上叫网关，在mac上叫路由器。路由器是网关的一种。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>将IP地址划分为网络地址和主机地址两部分。转换为2进制，为1的部分对应网络段，为0的部分对应主机段</p>
<p>如C类网络：子网掩码是255.255.255.0，也就是说前三段为网络号，最后一段为主机号。</p>
<p>用途：可以用于判断不同主机是否在同一个子网内：将两个IP分别与子网掩码进行与运算，如果相等则表示在同一个子网内。</p>
<p>表示方法：IP地址（子网掩码）、IP地址/子网掩码位数。如192.168.0.0（255.255.255.0）=192.168.0.0/24</p>
<h2 id="分类网络（有类网络）"><a href="#分类网络（有类网络）" class="headerlink" title="分类网络（有类网络）"></a>分类网络（有类网络）</h2><p><img src="/2021/11/27/basic-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%88%86%E7%B1%BBIP%E5%9C%B0%E5%9D%80.png"></p>
<p>对IP进行分类便于更好的路由，判断第一位为0则是A类地址，判断第二位为0则是B类地址…….</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>定义</th>
<th>默认子网掩码</th>
<th>IP地址范围</th>
<th>私有IP地址范围</th>
<th>最大网络数</th>
<th>单个网段最大主机数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>第1段为网络号，最高位固定为0，即1~127</td>
<td>255.0.0.0</td>
<td>0.0.0.0到127.255.255.255</td>
<td>10.0.0.0-10.255.255.255</td>
<td>126（减去0和127）</td>
<td>16777214</td>
<td>大型网络</td>
</tr>
<tr>
<td>B</td>
<td>前2段为网络号，最高位固定为10，即128~191</td>
<td>255.255.0.0</td>
<td>128.0.0.0到191.255.255.255</td>
<td>172.16.0.0-172.31.255.255</td>
<td>16384</td>
<td>65534</td>
<td>中型网络，一般用于大公司和政府机构</td>
</tr>
<tr>
<td>C</td>
<td>前3段为网络号，最高位固定为110，即192~223</td>
<td>255.255.255.0</td>
<td>192.0.0.0到223.255.255.255</td>
<td>192.168.0.0-192.168.255.255</td>
<td>2097152</td>
<td>254</td>
<td>小型网络，分配给任何有需要的人或组织，如校园网，小型办公网络</td>
</tr>
<tr>
<td>D</td>
<td>不分网络号和主机号，最高位固定为1110，即224~239</td>
<td></td>
<td>224.0.0.0到239.255.255.255</td>
<td></td>
<td></td>
<td></td>
<td>用于组播</td>
</tr>
<tr>
<td>E</td>
<td>不区分网络号和主机号，最高位为1111，即240~255</td>
<td></td>
<td>240.0.0.0到255.255.255.255</td>
<td></td>
<td></td>
<td></td>
<td>科研保留地址段</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li>其中D、E类为特殊地址，不能用于分配。<strong>D类用作组播地址，E类为科研保留地址段</strong>。</li>
<li>每个分类下还存在一些特殊用途的地址，不能用于主机分配，如环回地址（127开头，如127.0.0.1表示本机地址，一般用于测试），受限广播地址（255.255.255.255），本机地址（0.0.0.0）等</li>
<li>最大网络数：<ol>
<li>由于A类地址最高位固定为0，且用一个字节表示网络号，由于0和127不能使用，因此需要减去2，因此最大网络数=2^7-2，</li>
<li>由于B类地址最高位固定为10，且用两个字节表示网络号，因此最大网络数=2^14</li>
<li>由于C类地址最高位固定为110，且用三个字节表示网络号，因此最大网络数=2^21</li>
</ol>
</li>
<li>单个网段最大主机数=2^主机号位数-2，（减去头和尾，规定第一个主机号表示网络地址，最后一个主机号表示广播地址，已经被分配，无法再分配给主机）</li>
<li><strong>在分类网络中，子网掩码只有三种（A类：255.0.0.0、B类：255.255.0.0、C类：255.255.255.0）。在CIDR中使用可变长子网掩码（VLSM）</strong></li>
<li>以0或255结尾的地址不能分配给主机：<strong>只在子网掩码至少为24位（即C类地址或者CIDR中24-32位子网掩码）的前提下才成立</strong>。<ol>
<li><strong>以255结尾的地址不一定是广播地址</strong>（主机段全为1）：如B类地址172.16.0.0/255.255.0.0，后8位都是主机位，广播地址为172.16.255.255。172.16.1.255、172.16.2.255等不是广播地址，可以分配给主机</li>
<li><strong>广播地址不一定以255结尾</strong>：如192.168.1.0-63/26，子网掩码为26位，主机号为6位，192.168.1.63、192.168.127、192.168.1.191、192.168.1.255（即每个子网下最后一台主机号）主机位都为1，因此都是广播地址。</li>
</ol>
</li>
</ol>
<h3 id="分类网络面临的问题"><a href="#分类网络面临的问题" class="headerlink" title="分类网络面临的问题"></a>分类网络面临的问题</h3><blockquote>
<ol>
<li>对于企业来说，C类地址只有254个偏少（不够用），而B类地址包含65534个偏多（浪费）。—&gt;CIDR划分子网</li>
<li>B类地址很快将要分配完毕：最大网络数为16384。—&gt;CIDR划分子网</li>
<li>同一网络下没有地址层次：如一个公司用了B类地址，但是需要划分开发环境、测试环境、生产环境IP。—&gt;CIDR划分子网</li>
<li>路由表需要维护大量的表项：C类网络分散在不同地域，难以聚合。—&gt;CIDR将前缀相同的网络聚合成超网，分配给企业，此外还可以按世界地区进行分配</li>
<li>整个IPv4地址最终将会全部耗尽：总数为2^32个地址，去掉私有地址、多播地址、以及一些特殊保留地址，可分配的IP地址不多。—&gt;通过新版本IP协议（IPv6）解决</li>
</ol>
</blockquote>
<h2 id="子网划分与聚合"><a href="#子网划分与聚合" class="headerlink" title="子网划分与聚合"></a>子网划分与聚合</h2><p>意义：如上述，分类网络只有三种分配方式：C类2^8台主机、B类2^16台主机、A类2^24台主机。会造成大量浪费和不够用。因此在分类网络基础上，采用子网划分技术（<strong>VLSM和CIDR</strong>）得到更多类型大小的网络，提高IP地址利用率。</p>
<blockquote>
<ul>
<li>等长子网划分：将分类网络等分成多个网络，所有子网的子网掩码相同</li>
<li>变长子网划分：将分类网络分成多个网络，不同子网使用不同的子网掩码</li>
</ul>
</blockquote>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ol>
<li>主机：互联网中的一个设备</li>
<li>网络：多台机器组成一个网络，网络号相同则在一个网络下</li>
<li>网络地址：一般是该网络的第一个IP地址，不可分配给主机，<strong>主机号全为0</strong>。用于标识该网络。</li>
<li>广播地址：一般是该网络的最后一个IP地址，不可分配给主机，<strong>主机号全为1</strong>。用于向本地网络的所有机器发送广播。</li>
<li>可用主机地址：网络下所有IP地址减去第一个和最后一个IP地址，可用分配给主机的IP地址。用于标识主机</li>
<li>子网：将分类网络划分成更小后的网络，称为子网。其中第一个子网称为全0子网，最后一个子网为全1子网。<ol>
<li>全0子网对应子网号全为0，全1子网对应子网号全为1</li>
<li>旧标准（RFC950）里面全0和全1子网不可分配：为了避免全0子网网络地址（192.168.1.0）和全1子网的广播地址（192.168.1.255）分别与没有划分子网前的网络地址和广播地址冲突。</li>
<li>新标准（RFC1878）废弃，全0子网和全1子网也可用于分配</li>
</ol>
</li>
<li>超网：把多个小网络组成一个大网络。</li>
<li>分类网络：将IP地址分为A、B、C、D、E类，使用标准的默认子网掩码。只有三种（A类：255.0.0.0、B类：255.255.0.0、C类：255.255.255.0）</li>
<li>无类网络（CIDR）：基于VLSM可变长子网掩码，可以进行任意长度前缀分配，并且将多个前缀相同的地址块（CIDR地址块）组合到一个路由表项中，分配给企业使用，减少路由表项。</li>
</ol>
<blockquote>
<p>VLSM（Variable Length Subnet Mask，可变长子网掩码）：通过增加掩码位数，可以划分更多的子网。</p>
<p>CIDR（Classless Inter-Domain Routing，无类别域间路由）：基于VLSM，聚合超网。取代分类网络划分IP地址。</p>
</blockquote>
<h3 id="子网划分原理"><a href="#子网划分原理" class="headerlink" title="子网划分原理"></a>子网划分原理</h3><p>从主机位取出部分位用作子网位（借位），和原网络号合并为新的网络号，这样就可以将标准的IP网络划分成几个小的网络。</p>
<p><img src="/2021/11/27/basic-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91.png"></p>
<p>如将C类地址192.168.1.0/24，划分为2个子网：</p>
<ol>
<li>需要向主机位借1位作为子网位</li>
<li>子网掩码由255.255.255.0（/24）变为255.255.255.128（/25）</li>
<li>主机位数从8变为7</li>
<li>每个子网IP地址数从256变为128=2^7</li>
<li>每个子网可用主机数从254变为126=2^7-2</li>
<li>第一个子网段为192.168.1.0-127/25，其中192.168.1.0/25为网络地址，192.168.1.127/25为广播地址。</li>
<li>第二个子网段为192.168.1.128-255/25，其中192.168.1.128/25为网络地址，192.168.1.255/25为广播地址。</li>
</ol>
<p><strong>借1位可以划分两个子网0、1，借2位可以划分4个子网00、01、10、11….（可以看出第一个子网为全0子网、最后一个子网为全1子网）</strong></p>
<h2 id="各种概念换算"><a href="#各种概念换算" class="headerlink" title="各种概念换算"></a>各种概念换算</h2><p>以下全部转换为2进制计算，判断是否属于同一个网段，主要看他们的网络标识是否一样</p>
<ul>
<li><p>网络标识（网络号）：<strong>主机段全为0的IP地址</strong>，子网掩码和IP地址进行”与”操作。用于区分不同的网段</p>
</li>
<li><p>主机标识（主机号）：子网掩码取反和IP地址进行“与”操作，用于区分同一网段下的不同主机</p>
</li>
<li><p>广播地址：<strong>主机段全为1的IP地址</strong>，广播地址不一定是255结尾，以255结尾的也不一定是广播地址，需要结合子网掩码判断。</p>
</li>
<li><p>子网数量：2^子网段位数。</p>
<ul>
<li>C类网络下：主机段位数+子网段位数=8，即IP地址数量*子网数量=2^8</li>
<li>B类网络下，主机段位数+子网段位数=16，即IP地址数量*子网数量=2^16</li>
</ul>
</li>
<li><p>IP地址数量：2^主机段位数</p>
</li>
<li><p>可用主机数量（可分配IP地址数）：IP地址数量-2（减去头和尾，规定第一个主机号表示网络地址，最后一个主机号表示广播地址，已经被分配，无法再分配给主机）</p>
</li>
<li><p>该子网可用IP地址段：将网络地址下的所有主机分段，段数为子网数量，去掉头和尾，即为该子网可用IP地址段</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>如IP地址192.168.1.53</p>
<blockquote>
<ul>
<li>C类地址默认子网掩码为255.255.255.0</li>
<li>网络标识为192.168.1.0</li>
<li>主机标识为53</li>
<li>子网数量为1</li>
<li>广播地址为192.168.1.255，主机号全为1，即255</li>
<li>IP地址数量为256</li>
<li>可用主机数位254</li>
<li>该子网可用IP地址段为192.168.1.1-192.168.1.254</li>
</ul>
</blockquote>
<p>如IP地址192.168.1.53/27</p>
<blockquote>
<ol>
<li>27表示子网掩码有27个1，即：11111111 11111111 11111111 11100000。即子网掩码为255.255.255.224。</li>
<li>网络段有27位，主机段有5位，得一个子网IP地址数量为32，可用主机数为30，子网数量为8。</li>
<li>IP地址转换为二进制：11000000 10101000 00000001 00110101</li>
<li>和子网掩码进行与操作，得：11000000 10101000 00000001 00100000，即网络地址192.168.1.32。</li>
<li>和子网掩码取反后进行与操作，得：00000000 00000000 00000000 00010101，即主机标识为21，表示这个子网下的第21台主机</li>
<li>主机段全部置为1，得：11000000 10101000 00000001 00111111，即广播地址192.168.1.63</li>
<li>将网络分为8段：<ol>
<li>第一个子网：192.168.1.0-192.168.1.31</li>
<li>第二个子网：192.168.1.32-192.168.1.63</li>
<li>第三个子网：192.168.1.64-192.168.1.95</li>
<li>第四个子网：192.168.1.96-192.168.1.127</li>
<li>……</li>
</ol>
</li>
<li>53位于第二个子网，该子网的广播地址为192.168.1.63</li>
<li>该子网可用IP段为：192.168.1.33-192.168.1.62</li>
</ol>
</blockquote>
<p>将B类地址168.195.0.0划分为27个子网，求子网掩码和每个子网下IP地址数量？</p>
<blockquote>
<ol>
<li>27=11011，需要向主机位借5位。</li>
<li>借的是高位，即255.255.11111000.0</li>
<li>换算成10进制为255.255.248.0</li>
<li>主机号占11位，IP地址数量=2^11</li>
</ol>
</blockquote>
<p>将B类地址168.195.0.0划分成若干子网后，每个子网内有700台主机，求子网掩码和可划分子网数？</p>
<blockquote>
<ol>
<li>700=1010111100，主机号占10位，网络号占22位。</li>
<li>即向主机号借了6位。255.255.11111100.0</li>
<li>换算成10进制为255.255.252.0</li>
<li>借了6位，可划分2^6个子网</li>
</ol>
</blockquote>
<h1 id="单播、广播、组播（多播）"><a href="#单播、广播、组播（多播）" class="headerlink" title="单播、广播、组播（多播）"></a>单播、广播、组播（多播）</h1><p>这里的单播、广播、组播是针对网络层的说法，传输层TCP、UDP是对网络层的封装</p>
<h2 id="单播（一对一）"><a href="#单播（一对一）" class="headerlink" title="单播（一对一）"></a>单播（一对一）</h2><p>单播地址是IP网络中最常见的。包含单播目标地址的分组发送给特定主机。源地址-&gt;目标地址</p>
<ul>
<li>以太网帧报头中必须有目标IP地址和目标MAC地址。（目标IP地址+目标MAC地址）</li>
<li>如果目标地址属于另一个网络，则目标MAC地址为源地址所在网络的路由器的MAC地址。（目标IP地址+源地址的路由器MAC地址）</li>
</ul>
<p><img src="/2021/11/27/basic-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%8D%95%E6%92%AD.jpg" alt="单播"></p>
<p>缺点：服务器压力大，服务器流量＝客户机数量×客户机流量</p>
<p>优点：针对不同客户做出不同响应，容易实现个性化的服务</p>
<h2 id="广播（一对所有）"><a href="#广播（一对所有）" class="headerlink" title="广播（一对所有）"></a>广播（一对所有）</h2><p>广播分组的目标IP地址的主机部分全为1，这意味着本地网络（广播域）中的所有主机都将接收并查看该分组。</p>
<ul>
<li>以太网帧报头中必须有目标IP地址和广播MAC地址。（目标IP地址+广播MAC地址）</li>
<li>在以太网中，广播MAC地址长48位，其十六进制表示为FF-FF-FF-FF-FF-FF。</li>
</ul>
<p><img src="/2021/11/27/basic-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%B9%BF%E6%92%AD.jpg" alt="广播"></p>
<p>优点：网络设备简单，维护简单，布网成本低</p>
<p>缺点：无法针对不同客户做出不同响应。</p>
<h3 id="受限广播"><a href="#受限广播" class="headerlink" title="受限广播"></a>受限广播</h3><p>不会被路由器转发，但会被送到相同物理网络段上的所有主机，只能用于本地网络。</p>
<p>IP地址的网络字段和主机字段全为1，即地址：<strong>255.255.255.255</strong></p>
<h3 id="直接广播"><a href="#直接广播" class="headerlink" title="直接广播"></a>直接广播</h3><p>通过路由发送到该网络下的每台主机</p>
<p>IP地址的网络字段定义这个网络，<strong>主机字段</strong>通常全为1，如：</p>
<ul>
<li>C类网络192.168.1.0的默认子网掩码为255.255.255.0，其广播地址为192.168.1.255。</li>
<li>B类网络172.16.0.0的默认子网掩码为255.255.0.0，其广播地址为172.16.255.255。</li>
<li>A类网络10.0.0.0的默认子网掩码为255.0.0.0，其广播地址为10.255.255.255。</li>
</ul>
<h2 id="多播（一对多）"><a href="#多播（一对多）" class="headerlink" title="多播（一对多）"></a>多播（一对多）</h2><p>让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个多播组IP地址，多播地址范围为224.0.0.0～239.255.255.255。由于多播地址表示一组设备（有时被称为主机组），因此只能用作分组的目标地址。源地址总是为单播地址。</p>
<ol>
<li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域⽹中，路由器是不会进⾏转发的。</li>
<li>224.0.1.0 ~ 238.255.255.255 为⽤户可⽤的组播地址，可以⽤于 Internet 上。</li>
<li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部⽹在内部使⽤，仅在特定的本地范围内有效。</li>
</ol>
<ul>
<li>以太网帧报头中必须有目标IP地址和多播MAC地址。</li>
<li>多播MAC地址以十六进制值01-00-5E打头，余下的6个十六进制位是根据IP多播组地址的最后23位转换得到的。</li>
</ul>
<p><img src="/2021/11/27/basic-2021-11-27-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP%E5%9C%B0%E5%9D%80/%E5%A4%9A%E6%92%AD.jpg" alt="多播"></p>
<p>优点：多个客户端加入同一个组，共享一条数据流，节省服务器负载</p>
<p>缺点：丢包错包之后难以弥补</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Tips：</p>
<ul>
<li>DHCP：动态分配IP</li>
<li>HOST：<ul>
<li>Internet主机指互联网中的一台设备，有自己的IP地址，每台主机在互联网上的地位是平等的</li>
<li>指电脑主机</li>
</ul>
</li>
<li>PC：个人计算机</li>
<li>SERVER：服务器，指运行服务程序的计算机</li>
<li>InterNIC（Internet Network Information Center，因特网信息中心）：提供IP分配、域名管理等服务。此外还有ENIC（欧洲）、APNIC（亚太）等负责不同地区IP分配。在中国是由 CNNIC 的机构进⾏管理。</li>
<li>ISP（Internet Service Provider，互联网服务提供商）：如中国电信、中国移动等。</li>
</ul>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.51cto.com/u_6930123/2113151">IP地址和子网划分学习笔记之《子网划分详解》</a></li>
<li><a href="https://www.cnblogs.com/therock/articles/2798653.html">单播、广播和多播IP地址</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言、编译器和Android虚拟机</title>
    <url>/2021/11/05/basic-2021-11-05-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="芯片架构、操作系统、应用之间的关系"><a href="#芯片架构、操作系统、应用之间的关系" class="headerlink" title="芯片架构、操作系统、应用之间的关系"></a>芯片架构、操作系统、应用之间的关系</h1><p>操作系统：管理计算机硬件和软件资源的计算机程序，是多个程序的集合，一般可以分为几个部分</p>
<ol>
<li>控制程序，也叫内核（进程管理、存储管理、设备管理、文件管理、作业管理）</li>
<li>实用程序（文本编辑器、dump程序、shell、桌面程序等）</li>
<li>编译工具（汇编、编译、解析）</li>
</ol>
<p>操作系统封装了硬件接口，应用是在操作系统之上运行的程序，通过调用系统API来运行，由于不同系统提供的API存在差异，因此高级语言编写的应用程序一般无法跨平台。就算不调用系统API，也需要依赖对应系统的编译程序。</p>
<p>应用程序对系统的依赖体现在哪方面？</p>
<blockquote>
<ol>
<li>开发时应用依赖操作系统中的编译程序</li>
<li>运行时应用依赖操作系统提供的程序库（如网络库、线程库等）</li>
</ol>
</blockquote>
<p>不管是操作系统程序还是应用程序，其实都是由CPU运行的。而CPU只认识对应的机器语言（指令集），同时提供了汇编语法便于记忆，汇编语言是对机器语言的一种映射，因此汇编写的程序只适用于一种或者一系列的CPU。</p>
<p>不同CPU指的是架构不同（指令集不同），和厂商没有关系，例如AMD和Intel都使用x86架构，可能不同厂商会有各自的增强指令，但是不影响x86程序的执行。</p>
<p>一支编译程序只生成一种机器代码。不同架构使用的编译器不同，并且生成不同的目标代码，例如x86，x64架构的GCC是不一样的。要在一种CPU架构上生成另一个平台的目标代码，需要使用<strong>交叉编译</strong>。</p>
<p>同一个CPU架构可以运行不同的操作系统，同一个操作系统可以在不同CPU架构上运行，但是需要针对目标平台分别进行编译，使用不同的编译工具链。例如Linux for x86，Linux for arm，WindowsNT for x86。</p>
<p>现代的操作系统一般都是使用高级语言编写，需要针对目标平台分别进行编译，例如ubuntu系统，有桌面版、Server版、以及各种嵌入式、IoT版（如树莓派）</p>
<blockquote>
<p>之所以下载的windows系统可以运行在不同芯片上，主要是因为PC基本都是AMD和Intel的芯片，而两家都使用x86架构，指令集是通用的。</p>
</blockquote>
<p>为什么应用一般以操作系统来分类，如windows版、linux版、mac版，不以CPU架构分类？</p>
<blockquote>
<p>应用程序的运行需要CPU架构和操作系统都支持。例如x86_64位的目标程序无法在x86_32位机器上运行。</p>
<p>之所以Windows应用能够装在不同芯片的主机上，主要是因为PC基本都是AMD和Intel的芯片，两家都使用x86架构，指令集是通用的。如果应用编译的时候使用新的指令集，在老的机器还是无法运行。商业软件一般会先用基础指令集，再根据CPU判断是否使用扩展指令集</p>
</blockquote>
<p>应用跨平台兼容不同CPU架构一般有几种做法：</p>
<blockquote>
<ol>
<li>多套目标代码放到同一个执行文件中。</li>
<li>操作系统层面支持其他架构的目标代码。例如64位操作系统兼容32位CPU，并且可以运行32位的应用程序</li>
<li>CPU架构向下兼容，例如arm64-v8a兼容arm和armv7a指令集。应用目标平台为armv7a，可以运行到arm64-v8a的设备上，但是反过来不支持。</li>
<li>通过虚拟机运行，可执行程序不是目标平台代码，而是一种中间代码，通过虚拟机解释执行。例如Java、.Net等</li>
</ol>
</blockquote>
<p>为什么操作系统无法屏蔽CPU架构差异？</p>
<blockquote>
<p>有两种思路：</p>
<ol>
<li>由操作系统来编译生成目标代码，在程序安装时进行编译</li>
<li>由操作系统解释运行源代码或中间代码</li>
</ol>
<p>之所以不这么做有以下原因：</p>
<ol>
<li>理论上操作系统拿到源码之后可以编译成当前架构的代码，但是软件开发商不愿意公开源代码，因此往往会编译成目标代码之后再进行发布。</li>
<li>如果都交由操作系统来运行的话，程序运行会比较慢。例如Android系统，早期由虚拟机解释运行，后来改进通过应用安装时预编译成目标代码，提高了效率。</li>
<li>如果操作系统需要为不同语言、不同CPU架构提供编译器，会使操作系统变得越来越大，如果CPU架构更新操作系统也要更新</li>
</ol>
</blockquote>
<p>Java程序为什么不需要根据CPU架构编译？</p>
<blockquote>
<p>Java之所以不需要根据CPU架构进行编译，是因为Java程序是通过虚拟机运行的，VM屏蔽了CPU架构的差异。</p>
</blockquote>
<p>Android中的目标代码编译</p>
<blockquote>
<p>由于VM功能不完备（如串口通讯需要依赖C写的库）或者性能问题，有时候需要使用C/C++开发，因此Android开放了NDK编译。</p>
<p>这意味着不同CPU架构需要生成不同的目标代码，如arm、x86、mips等。（Android一般使用arm架构，模拟器运行在PC上，一般是x86架构）</p>
<p>NDK开发者需要针对不同架构进行编译，生成不同的so文件，Android打包的时候将多份目标代码一起打包，安装的时候根据设备选择对应的so安装。</p>
</blockquote>
<h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h1><p>本地编译（native compile）：本机编译出来的程序在本机上运行</p>
<p>交叉编译（cross compile）：在一个平台上生成另一个平台的可执行代码，即编译环境和运行环境不一样。常用于嵌入式开发</p>
<p>编译用的机器叫宿主机，软件运行的机器叫目标机。宿主机和目标机通过串口或网络通讯。</p>
<p>为何需要交叉编译？</p>
<blockquote>
<p>单片机或嵌入式设备功能较少，硬件资源和性能有限，只能供嵌入式系统运行，难以再提供编译资源。</p>
</blockquote>
<p>嵌入式系统一般也比PC系统要轻量，CPU种类更多（如x86、arm、armv7、arm64、mips等），各家的指令集也存在差异，因此嵌入式操作系统一般要针对芯片分别进行编译。应用软件也需要分别编译。</p>
<blockquote>
<ul>
<li>Android使用Java，运行在虚拟机上，因此不需要分别编译，但是如果使用了so库，则需要分别编译</li>
<li>iPhone不同版本使用不同CPU架构，编译的时候可以选择目标版本系统和目标架构。</li>
</ul>
</blockquote>
<p>交叉编译工具链（交叉编译器）：交叉编译用到的一系列工具。如<code>arm-linux-gcc</code>、<code>arm-linux-ld</code>等</p>
<p>编译包括多个步骤，形成链条</p>
<ol>
<li>预处理（pre-compile）：删除#define并展开宏定义，处理#include等。<code>gcc -E file.c -o file.i</code></li>
<li>编译（compile）：语法分析、词法分析、语义分析等，生成汇编代码.s文件。<code>gcc -S file.i -o file.s</code></li>
<li>汇编（assembly）：汇编代码转为机器指令.o文件。<code>gcc -c file.s -o file.o</code></li>
<li>链接（link）：处理各个模块之间的引用和依赖，将目标文件链接到可执行文件或其他目标文件。<ol>
<li>静态链接：目标文件直接进入可执行文件<ol>
<li>编译静态库源码，生成.o文件：<code>gcc -c lib.c -o lib.o</code></li>
<li>生成静态库文件，归档，生成.a文件：<code>ar -q lib.a lib.o</code></li>
<li>使用静态库编译，生成.out可执行文件：<code>gcc main.c lib.a -o main.out</code></li>
</ol>
</li>
<li>动态链接：可执行程序运行时加载目标文件<ol>
<li>编译动态库源码，生成.so文件：<code>gcc -shared dlib.c -o dlib.so</code></li>
<li>使用动态库编译：<code>gcc main -ldl -o main.out</code></li>
<li>代码调用<ol>
<li><code>dlopen</code>打开动态库文件</li>
<li><code>dlsym</code>查找动态库中的函数并返回调用地址</li>
<li><code>dlclose</code>关闭动态库文件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>反汇编：使用<code>objdump</code>反汇编，输出机器码和对应的汇编代码</li>
</ol>
<h1 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h1><h2 id="机器语言、汇编语言、高级语言"><a href="#机器语言、汇编语言、高级语言" class="headerlink" title="机器语言、汇编语言、高级语言"></a>机器语言、汇编语言、高级语言</h2><ol>
<li>机器语言（本地机器码，native code）：<ol>
<li>计算机执行的二进制命令，由0和1组成。</li>
<li>和CPU有关，不同计算机对应不同的机器语言指令集。</li>
<li>一条指令就是机器语言的一个语句，由操作码和操作数组成。</li>
<li>不便于阅读</li>
</ol>
</li>
<li>汇编语言（符号语言、伪机器语言）：<ol>
<li>汇编语言和机器语言一一对应。</li>
<li>用助记符替代机器指令的操作码，用地址符号或标号替代操作数的地址。（如用“ADD”代表逻辑加）</li>
<li>本质是一套语法规则和助记符的集合。</li>
<li>不同CPU指令集不同，因此需要不同的汇编器（汇编语言翻译成机器语言），对应不同的汇编语言。但汇编语言语法规则本身可能通用，也可能不通用，由厂商定义</li>
<li>不便于书写</li>
</ol>
</li>
<li>高级语言：相对于低级语言（<strong>机器语言和汇编语言都是低级语言</strong>）。<ol>
<li>和硬件结构及指令系统无关，可移植性更强。要操作硬件资源必须调用汇编程序的接口。</li>
<li>经过不同平台的编译器编译成目标平台的程序。高级语言和汇编语言不再是一一对应</li>
<li>高度封装的编程语言，更容易理解和修改</li>
</ol>
</li>
</ol>
<p>高级语言转为低级语言需要通过编译，编译器屏蔽了不同平台CPU架构的差异，开发者实际上是面向编译器编程。</p>
<p><strong>为了提升效率，编译器会分为前端和后端。前端将源代码生成统一的中间代码，后端将中间代码编译为不同目标架构下的汇编代码（中间代码隔开了编译前端和编译后端）。再交由这些架构下的汇编器汇编成机器码。</strong></p>
<h2 id="跨平台、程序可移植性"><a href="#跨平台、程序可移植性" class="headerlink" title="跨平台、程序可移植性"></a>跨平台、程序可移植性</h2><ul>
<li>write once, compile anywhere（一次编写，处处编译）：同样的代码在不同系统和开发环境中都可以编译运行，体现了代码的<strong>可移植性</strong>。</li>
<li>write once , run anywhere（一次编写，处处运行）：Java特性。编译出来的<code>.class</code>，只要在装了jre环境（java运行环境）的机器上就可以执行。</li>
</ul>
<blockquote>
<p>JVM是Java实现跨平台的核心，可以将Java编译的字节码解释成对应的机器码，不同系统有不同的JVM实现。</p>
<p>核心思想是定义了一层中间语言进行适配。</p>
</blockquote>
<p><strong>JDK&gt;JRE&gt;JVM</strong></p>
<ol>
<li>JDK（Java Development Kit）：Java 开发工具包，包含JRE和一些开发工具，如<code>javac、javap、jar</code>等</li>
<li>JRE（Java Runtime Environment）：Java 运行时环境，包含JVM和Java一些基本类库</li>
<li>JVM（Java Virtual Machine）：Java 虚拟机。将class字节码解释成机器码执行，是Java能够跨平台的核心</li>
</ol>
<p>观点总结：</p>
<ol>
<li>高级语言和硬件结构及指令系统无关，从这个角度来说，高级语言都是跨平台的（平台无关性）。</li>
<li>严格来说，高级语言只是语言规则，没有平台概念，语言本身也没法运行，运行的是编译后的本地代码。而本地代码是无法跨平台的。</li>
<li>程序的可移植性指的是源代码，而不是本地代码。</li>
<li>打包好的可执行程序要支持跨平台、移植，需要加一层中间代码，借助虚拟机或解释器将中间代码翻译成本地代码执行。</li>
</ol>
<h3 id="C-C-是否跨平台？"><a href="#C-C-是否跨平台？" class="headerlink" title="C/C++是否跨平台？"></a>C/C++是否跨平台？</h3><p>结论：C/C++语言本身是跨平台的，但是应用程序本身是否跨平台取决于该平台上有没有适用的库及编译器。C语言提供了不同CPU架构的编译器</p>
<p>为什么说C/C++无法跨平台？</p>
<blockquote>
<p>C++标准库的东西太少了，没有多线程没有界面，内存管理很弱。这些都依赖于具体平台的API，而系统接口API不统一。比如在Windows下有WIN32、MFC，在Linux和Unix系列下，有pthread。</p>
<p>想要用c进行跨平台开发，需要封装各个平台实现，添加判断，通过编译参数选择对应的平台。</p>
</blockquote>
<p>为什么说Java是跨平台的？</p>
<blockquote>
<p>将Java源代码编译成中间代码（字节码），由JVM解释执行。</p>
<p>Java虚拟机将不同平台的系统API统一封装了，并定义了一套规范，由JVM实现不同平台的调用。</p>
<p>JVM本身就是一个平台，JVM的目标代码就是JVM规范定义的Class字节码。</p>
</blockquote>
<h3 id="JVM语言无关性"><a href="#JVM语言无关性" class="headerlink" title="JVM语言无关性"></a>JVM语言无关性</h3><p><strong>JVM只认识Class文件，并不关心Class文件从哪来，是否是Java语言编写的程序</strong>。换句话说，Java虚拟机和Java语言没什么关系，其实更应该叫Class文件虚拟机。</p>
<blockquote>
<p>sun团队在设计之初就把Java规范分为了Java语言规范《The Java Language Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。</p>
</blockquote>
<p>其他语言只要有对应的编译器，能够输出Class文件，就能够在JVM上运行。如Groovy、JRuby、Jython、Scala等。</p>
<p><img src="/2021/11/05/basic-2021-11-05-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/JVM%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7.png"></p>
<h2 id="编译型语言-amp-解释型语言"><a href="#编译型语言-amp-解释型语言" class="headerlink" title="编译型语言 &amp; 解释型语言"></a>编译型语言 &amp; 解释型语言</h2><h3 id="什么是编译？"><a href="#什么是编译？" class="headerlink" title="什么是编译？"></a>什么是编译？</h3><p>编译就是高级语言转为低级语言的过程，将源代码转换为目标代码的过程。（目标代码可以是中间代码，也可以是本地代码）</p>
<p><img src="/2021/11/05/basic-2021-11-05-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/%E7%BB%8F%E5%85%B8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p>
<p><strong>编译和解释都是翻译，区别在于翻译的时机不同：编译在程序执行之前，解释在程序执行过程中。</strong></p>
<ul>
<li>编译型语言：程序执行之前，将源代码一次性转换成本地代码。C、C++、Delphi、Pascal、Fortran等</li>
<li>解释型语言：程序执行的时候。将代码逐条转换成本地代码运行。Java、Basic、JavaScript、Python、PHP等</li>
<li>脚本语言：也是解释型语言，不需要编译，代码即可执行文件，由解释器运行。</li>
</ul>
<p>编译型语言和解释型语言实现的关键在于有没有生成中间代码，由于CPU只认识特定的机器代码，要想可执行程序能够跨平台，需要由虚拟机或解释器来执行程序，由虚拟机或解释器将中间代码翻译成机器代码执行。</p>
<table>
<thead>
<tr>
<th></th>
<th>编译型程序</th>
<th>解释型程序</th>
</tr>
</thead>
<tbody><tr>
<td>执行速度</td>
<td>快</td>
<td>慢：运行时需要解释成机器码</td>
</tr>
<tr>
<td>内存和CPU资源占用</td>
<td>少</td>
<td>多：需要运行解释器，代码逐条解释运行，并且进行一些检查</td>
</tr>
<tr>
<td>目标代码大小</td>
<td>更大：编译后的程序多了很多东西。如C/C++的可执行文件比同样功能的字节码文件大很多</td>
<td>更小</td>
</tr>
<tr>
<td>调试难度</td>
<td>困难：难以定位到异常的源码位置</td>
<td>容易：JVM提供异常信息和堆栈跟踪</td>
</tr>
<tr>
<td>平台依赖性</td>
<td>需要针对不同平台进行编译，只能在特定平台运行</td>
<td>平台独立，只要机器支持jre即可</td>
</tr>
<tr>
<td>安全性</td>
<td>安全性较低：可以直接访问内存区域，如外挂、病毒等</td>
<td>安全性更高</td>
</tr>
<tr>
<td>编写难度</td>
<td>编译器实现难度更高</td>
<td>解释器更容易实现</td>
</tr>
<tr>
<td>适用领域</td>
<td>适合开发操作系统、数据库系统、对速度和内存要求高的库</td>
<td>适用于开发Web应用、脚本等</td>
</tr>
</tbody></table>
<h3 id="为什么说Java是解释型语言？"><a href="#为什么说Java是解释型语言？" class="headerlink" title="为什么说Java是解释型语言？"></a>为什么说Java是解释型语言？</h3><p>Java也有一个编译过程，但并不是将程序直接编译成本地机器语言，而是编译成<strong>中间语言（字节码）</strong>，运行的时候由JVM将字节码翻译成机器语言。</p>
<p>现在的JVM大部分使用了JIT、AOT技术，会在执行之前将字节码编译成本地代码缓存下来，直接运行。因此，也可以说Java是编译的。</p>
<blockquote>
<p>有一个有趣的趋势：编译型语言在越来越解释（追求目标程序跨平台），解释型语言在越来越编译（使用AOT等技术，追求性能）</p>
</blockquote>
<h1 id="Java编译器"><a href="#Java编译器" class="headerlink" title="Java编译器"></a>Java编译器</h1><p>在Java中，编译通常指Java文件转换为Class文件的过程，也被叫做<strong>编译前端</strong>，主要包括词法分析、语法分析、注解处理、语义分析等步骤。不依赖虚拟机。</p>
<p>除此之外编译也可以用来指即时编译（JIT）和提前编译（AOT），称为<strong>编译后端</strong>，主要用于生成更高效的机器码，提高运行效率。</p>
<p>java常见的编译器有以下类型：在JVM中一般是将几种方式结合，提高运行速度和效率。</p>
<ul>
<li><strong>前端编译器</strong>：把<code>.java</code>文件转变成<code>.class</code>文件。比如Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</li>
<li><strong>JIT编译器（Just In Time，即时编译）</strong>：运行时将<strong>热点代码</strong>编译成成本地代码。比如HotSpot VM的C1、C2编译器。<ul>
<li>将字节码编译成的机器码缓存下来，下次可以直接使用，提高运行效率。但是会牺牲一定的启动速度，占用更多的内存。</li>
<li>JIT会编译热点代码，而不是全部编译。非热点代码还是解释执行。监控收集热点代码会影响程序运行。</li>
<li>除了缓存之外，JIT还会对代码进行<strong>编译优化</strong>，提高执行效率</li>
</ul>
</li>
<li><strong>AOT编译器（Ahead Of Time，提前编译）</strong>：程序运行前，直接把java代码或字节码编译成本地机器代码，保存到磁盘中。 比如GNU Compiler for the Java（GCJ）、Excelsior JET、Android Runtime（ART）。<ul>
<li>提前预热，避免JIT运行时的消耗</li>
<li>一些动态代码无法在运行前得知，因此编译质量不如JIT</li>
</ul>
</li>
</ul>
<h2 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h2><p><strong>语法糖</strong> 指的是高级语言中的某种语法，编译前端进行语义分析的时候会进行脱糖（解语法糖），转换为无糖语法。</p>
<p>常用的语法糖如下：</p>
<ol>
<li>泛型（ParamterizedType，参数化类型）：类型擦除</li>
<li>自动拆装箱：基本数据类型与包装类互相转换</li>
<li>条件编译：条件分支剪支优化</li>
<li>for-each循环：转换为迭代器</li>
<li>枚举对象转换为普通对象</li>
<li>内部类：非静态内部类持有外部类的引用</li>
<li>可变长参数：转换为数组</li>
</ol>
<h2 id="JIT如何检测热点代码？"><a href="#JIT如何检测热点代码？" class="headerlink" title="JIT如何检测热点代码？"></a>JIT如何检测热点代码？</h2><ol>
<li>基于采样方式探测：周期性检查线程栈顶，如果某个方法经常在栈顶就认为是热点代码。</li>
<li>基于计数器探测：为方法或代码块建立计数器，统计执行次数，超过一定阈值就会触发JIT编译<ol>
<li>方法计数器：统计方法被调用次数</li>
<li>回边计数器：统计for或while循环的运行次数</li>
</ol>
</li>
</ol>
<h1 id="Android虚拟机优化历程"><a href="#Android虚拟机优化历程" class="headerlink" title="Android虚拟机优化历程"></a>Android虚拟机优化历程</h1><p><strong>Java之所以比C/C++慢（Android之所以比iOS慢），主要原因就在于前者是编译成字节码之后JVM解释执行，后者是编译成本地代码之后直接执行。</strong></p>
<h2 id="Android-1-0-Dalvik（DVM）-解释器"><a href="#Android-1-0-Dalvik（DVM）-解释器" class="headerlink" title="Android 1.0 Dalvik（DVM）+解释器"></a>Android 1.0 Dalvik（DVM）+解释器</h2><p>DVM中解释器边运行边解释，运行速度慢。</p>
<blockquote>
<p>DVM是Google为Android平台开发的虚拟机，而不使用Java提供的虚拟机。可读取<code>.dex</code>的字节码。</p>
</blockquote>
<h2 id="Android-2-2-DVM-JIT编译"><a href="#Android-2-2-DVM-JIT编译" class="headerlink" title="Android 2.2 DVM+JIT编译"></a>Android 2.2 DVM+JIT编译</h2><p>通过JIT缓存热点代码，提高运行速度。</p>
<p>缺点：启动速度慢，每次运行都要重新编译，非热点代码还是解释执行</p>
<h2 id="Android-5-0-ART-AOT"><a href="#Android-5-0-ART-AOT" class="headerlink" title="Android 5.0 ART+AOT"></a>Android 5.0 ART+AOT</h2><p>采用AOT技术，在应用安装的时候预编译成机器码（dex文件转为oat文件），避免每次运行进行JIT编译</p>
<p>缺点：应用安装APP时间变长。编译质量不如JIT，机器码需要的存储空间更大</p>
<h2 id="Android-7-0-ART-AOT-JIT混合编译"><a href="#Android-7-0-ART-AOT-JIT混合编译" class="headerlink" title="Android 7.0 ART+AOT+JIT混合编译"></a>Android 7.0 ART+AOT+JIT混合编译</h2><p>应用安装的时候不进行编译，快速启动，在执行的时候分析热点代码。在系统空闲的时候进行AOT，编译热点代码（不会编译所有代码）。</p>
<h2 id="Android-8-0-改进解释器"><a href="#Android-8-0-改进解释器" class="headerlink" title="Android 8.0 改进解释器"></a>Android 8.0 改进解释器</h2><p>提高解释执行效率</p>
<h2 id="Android-9-0-改进编译模版"><a href="#Android-9-0-改进编译模版" class="headerlink" title="Android 9.0 改进编译模版"></a>Android 9.0 改进编译模版</h2><p>开发阶段可以配置编译模版，指定热点代码，ART优先编译这部分代码。</p>
<h2 id="Dalvik和ART对比"><a href="#Dalvik和ART对比" class="headerlink" title="Dalvik和ART对比"></a>Dalvik和ART对比</h2><ol>
<li>Dalvik采用JIT。ART采用了AOT，并且在Android7.0加入了JIT，提高运行效率</li>
<li>DVM针对32位CPU设计，ART支持64位</li>
<li>ART优化了垃圾回收机制，和运行时内存空间分配：新增<code>Image Space</code>和<code>Large Object Space</code></li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结构有点乱，基本是想到哪写到哪，不断延伸扩展出来相关的一些知识点</p>
<p>经典语录：<strong>java和c++之间有一堵由动态内存分配和垃圾收集技术所围成的’高墙’，墙外的人想进去，墙内的人想出来</strong></p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/jmsjh/p/7808764.html">C为什么不能跨平台</a></li>
<li><a href="https://www.jianshu.com/p/b1d2608848dd">Java | 编译过程（编译前端 &amp; 编译后端）</a></li>
<li><a href="https://juejin.cn/post/6844903912206499853">9102年了，还不知道Android为什么卡？</a></li>
</ul>
]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>程序基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android打包和破解、应用安全</title>
    <url>/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="Android打包"><a href="#Android打包" class="headerlink" title="Android打包"></a>Android打包</h1><h2 id="APK文件结构"><a href="#APK文件结构" class="headerlink" title="APK文件结构"></a>APK文件结构</h2><ul>
<li><strong>classes.dex</strong>：Dalvik虚拟机的可执行文件，Google为Android平台定制了Dalvik虚拟机，而不是使用Java虚拟机。</li>
<li><strong>resources.arsc</strong>：将部分资源编译成二进制文件。记录资源名称、类型、值、ID等信息，用于快速索引找到资源。</li>
<li><strong>AndroidManifest.xml</strong>：声明应用信息和权限，四大组件注册等</li>
<li><strong>lib</strong>：存放的so动态链接库。</li>
<li><strong>META-INF</strong>：签名文件夹，里面存放三个文件，有两个是对资源文件做的SHA1 hash处理，一个是签名和公钥证书。</li>
<li><strong>res</strong>：资源文件夹。会被映射到<code>R.java</code>中，通过资源id访问</li>
<li><strong>assets</strong>：资源文件夹。不会被映射到<code>R.java</code>中，需要使用AssetManager访问</li>
</ul>
<p>构建安装流程：</p>
<img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/apk简单打包流程.png" style="zoom:100%;">

<h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/apk打包流程.png" style="zoom:100%;">

<h2 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h2><table>
<thead>
<tr>
<th align="left">工具名称</th>
<th align="left">功能介绍</th>
<th align="left">Sdk路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aapt</td>
<td align="left">Android资源打包工具：生成R.java、resources.asrc和res文件夹</td>
<td align="left">${ANDROID_SDK_HOME}/platform-tools/appt</td>
</tr>
<tr>
<td align="left">aidl</td>
<td align="left">Android接口描述语言转化为.java文件</td>
<td align="left">${ANDROID_SDK_HOME}/platform-tools/aidl</td>
</tr>
<tr>
<td align="left">javac</td>
<td align="left">Java Compiler：将java源代码编译为class文件</td>
<td align="left">${JDK_HOME}/javac或/usr/bin/javac</td>
</tr>
<tr>
<td align="left">dex</td>
<td align="left">将.class文件转化为.dex文件</td>
<td align="left">${ANDROID_SDK_HOME}/platform-tools/dx</td>
</tr>
<tr>
<td align="left">apkbuilder</td>
<td align="left">生成apk包</td>
<td align="left">${ANDROID_SDK_HOME}/tools/opkbuilder</td>
</tr>
<tr>
<td align="left">jarsigner</td>
<td align="left">.jar文件的签名工具</td>
<td align="left">${JDK_HOME}/jarsigner或/usr/bin/jarsigner</td>
</tr>
<tr>
<td align="left">zipalign</td>
<td align="left">字节码对齐工具，release模式下将apk中未压缩的数据进行4字节对齐。方便使用mmap访问，减少内存占用</td>
<td align="left">${ANDROID_SDK_HOME}/tools/zipalign</td>
</tr>
</tbody></table>
<p>class转dex命令：<code>dx --dex output=生成的dex文件 class文件路径</code></p>
<p>注：zipalign使用时机取决于签名工具：</p>
<blockquote>
<ul>
<li>如果使用 <code>apksigner</code>，只能在为 APK 文件签名<strong>之前</strong>执行 zipalign。否则会导致签名失效</li>
<li>如果使用 <code>jarsigner</code>，只能在为 APK 文件签名<strong>之后</strong>执行 zipalign。</li>
</ul>
</blockquote>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>详情见<a href="/2021/11/05/android-2021-11-05-Android%E7%AD%BE%E5%90%8D%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/">Android签名知识汇总</a></p>
<ol>
<li><p>生成keystore文件：<code>keytool -genkey -alias &lt;别名&gt; -keyalg &lt;加密算法，如RSA&gt; -validity &lt;有效天数&gt; -keystore &lt;输出文件&gt;</code></p>
</li>
<li><p>生成系统签名keystore文件：系统应用需要使用系统签名，拥有更高的权限</p>
<ol>
<li>获取Android源码签名文件：<code>platform.pk8 </code>和<code> platform.x509.pem</code>，位于`release/android/n-cn/build/target/product/security/``</li>
<li><code>openssl pkcs8 -in &lt;platform.pk8&gt; -inform DER -outform PEM -out shared.priv.pem -nocrypt</code></li>
<li><code>openssl pkcs12 -export -in &lt;platform.x509.pem&gt; -inkey shared.priv.pem -out shared.pk12 -name &lt;platform&gt;</code></li>
<li><code>keytool -importkeystore -deststorepass &lt;password&gt; -destkeypass &lt;password&gt; -destkeystore &lt;keystore文件名称&gt; -srckeystore shared.pk12 -srcstoretype PKCS12 -srcstorepass &lt;password&gt; -alias &lt;keystore别名&gt;</code></li>
</ol>
</li>
<li><p><code>jarsigner</code>签名：<code>jarsigner [-verbose -keystore &lt;keystore文件&gt; -signedjar &lt;输出文件名称&gt; -storepass &lt;口令&gt;] &lt;jar-file&gt; &lt;alias&gt;</code></p>
</li>
</ol>
<h1 id="混淆、压缩、优化"><a href="#混淆、压缩、优化" class="headerlink" title="混淆、压缩、优化"></a>混淆、压缩、优化</h1><p>参考<a href="/2018/11/24/android-2018-11-24-Android%E6%B7%B7%E6%B7%86/">另一篇文章</a></p>
<h1 id="Android反编译和破解"><a href="#Android反编译和破解" class="headerlink" title="Android反编译和破解"></a>Android反编译和破解</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="https://ibotpeaches.github.io/Apktool/"><code>apktool</code></a>：编译和反编译apk，从apk中提取图片和布局资源<ul>
<li>反编译：<code>apktool d -o &lt;output_dir&gt; test.apk</code>，得到资源文件和smali文件、或者dex文件</li>
<li>编译：<code>apktool b -o &lt;output.apk&gt; &lt;input_dir&gt;</code></li>
</ul>
</li>
<li><a href="https://github.com/pxb1988/dex2jar"><code>dex2jar</code></a>：将可运行文件classes.dex反编译为jar源码文件<ul>
<li><code>d2j-dex2jar.sh &lt;input.dex&gt; -o &lt;output-jarfile&gt;</code>将dex转为jar文件</li>
<li><code>d2j-jar2dex.sh &lt;input.jar&gt; -o &lt;output-dexfile&gt;</code>将jar转为dex文件</li>
</ul>
</li>
<li><a href="http://java-decompiler.github.io/"><code>jd-gui</code></a>：查看jar源码文件</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><pre class="mermaid">graph LR
apk--解压-->dex文件--dex2jar-->jar文件-->使用jd-gui查看java源代码
apk--apktool-->smali文件-->对照java源代码修改smali汇编代码-->apktool打包-->重签名
apk--apktool-->资源文件-->修改资源文件-->apktool打包
apk--解压-->二进制资源文件-->使用AXMLEditor修改二进制文件--压缩-->修改zip为apk-->重签名</pre>

<p>除了通过修改smail文件之外，也可以使用jbe修改class文件，如修改本地依赖的三方库，或者修改使用dex2jar生成的jar</p>
<pre class="mermaid">graph LR
dex文件--dex2jar-->jar文件--解压-->classs[class文件]-->jbe修改字节码--重新压缩-->jar文件--jar2dex-->dex文件
三方库-->jar文件</pre>



<blockquote>
<p>targetSdk版本为30（Android 11）时，apk需要按4字节边界对齐，否则应用无法安装，报错如下：</p>
<p><code>Failure [-124: Failed parse during installPackageLI: Targeting R+ (version 30 and above) requires the resources.arsc of installed APKs to be stored uncompressed and aligned on a 4-byte boundary]</code></p>
<p>需要用<code>zipalign</code>工具对齐之后，再使用apksigner签名</p>
</blockquote>
<p>其他工具：</p>
<ul>
<li><a href="https://github.com/skylot/jadx">jadx</a>：反编译dex、aar、aab、apk、资源等，可视化操作界面。支持导出Gradle工程。</li>
<li><a href="https://github.com/Jermic/Android-Crack-Tool">CrackTool</a>：反编译、签名、可视化工具</li>
<li><a href="http://set.ee/jbe/">jbe</a>：字节码编辑器，用于查看和修改class字节码文件</li>
<li><a href="https://github.com/fourbrother/AXMLEditor">AXMLEditor</a>：<code>AndroidManifest.xml</code>打包之后会被编译成二进制文件，使用apktool可以反编译回来，但是使用apktool有时候无法再编译回apk。可以直接解压apk，使用该工具直接修改二进制文件，再压缩回apk</li>
<li><a href="https://github.com/demitsuri/smali2java">smali2jar</a>：smali文件转jar文件</li>
</ul>
<h2 id="各类文件说明和转换"><a href="#各类文件说明和转换" class="headerlink" title="各类文件说明和转换"></a>各类文件说明和转换</h2><h3 id="安装前"><a href="#安装前" class="headerlink" title="安装前"></a>安装前</h3><ol>
<li>jar文件：Java归档文件，以zip格式构建，包含java和一些元数与资源文件</li>
<li>apk文件：安卓应用安装包，本质是一个压缩包，可以将后缀名改为zip直接解压，解压缩后会得到dex文件、资源文件、so文件等</li>
<li>class文件：Java字节码文件，JVM的可执行文件，可以对照JVM字节码规范修改，可读性差</li>
<li>dex文件：Dalvik字节码文件，DVM的可执行文件，，可以对照DVM字节码规范修改，可读性差</li>
<li>smali文件：Dalvik汇编文件，dex文件反编译得到，相当于dalvik虚拟机的汇编语言，便于阅读</li>
</ol>
<img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/Java和Android编译各类文件格式转换.png" style="zoom:40%;">

<blockquote>
<p>javap：将class字节码文件反汇编，用于查看java字节码，了解JVM指令执行过程。常用参数<code>-v -l -s -c</code>等。JVM汇编指令参考<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5">官方文档</a></p>
<p>有助于了解原理，如</p>
<ul>
<li>java枚举</li>
<li>java运行时栈</li>
<li>java泛型</li>
<li>非静态内部类持有外部类的引用</li>
</ul>
</blockquote>
<h3 id="安装后"><a href="#安装后" class="headerlink" title="安装后"></a>安装后</h3><p>除了上述文件外，不同版本的Android系统虚拟机会在应用安装之后进行JIT和AOT，生成另外一些文件，存在于系统中</p>
<ol>
<li>odex文件(optimized dex)：针对系统和平台优化过的dex。ART上AOT编译过的机器码也保存在odex文件中。<ol>
<li>DVM中使用<code>dexopt</code>对dex字节码进行优化，保存到<code>/data/dalvik-cache</code>目录。运行的时候JIT编译成本地代码。（JIT）</li>
<li>ART中使用<code>dex2oat</code>，将dex字节码转换为oat文件，包含原始dex和预编译生成的本地代码。（AOT）</li>
<li>ART中Android O之后，将oat中原始dex保存到.vdex中，从vdex中提取出部分代码进行AOT编译和优化，生成odex。<code>odex+vdex=apk源码</code>。（AOT+JIT）</li>
</ol>
</li>
<li>oat文件：本质是ELF格式文件。包含原始dex字节码(oatdata)和翻译过的本地代码(oatexec)</li>
<li>vdex文件：Android O新增，保存原始未压缩的dex。</li>
<li>art文件：odex优化生成的文件，主要是apk 启动的常用函数相关地址的记录，方便寻址相关；ART可以直接加载使用，避免解析耗时</li>
</ol>
<blockquote>
<p>JVM上的可执行文件是class文件，DVM上的可执行文件是odex，ART上的可执行文件是oat文件(odex)。</p>
</blockquote>
<p><img src="/2021/11/04/android-2021-11-04-Android%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/dex%E4%BC%98%E5%8C%96.png" alt="dex优化图片"></p>
<h1 id="防破解"><a href="#防破解" class="headerlink" title="防破解"></a>防破解</h1><ol>
<li>混淆</li>
<li>加固：加密dex和so，先运行壳dex代码，通过壳dex代码自定义DexClassLoader解析加密后的dex运行</li>
<li>敏感计算、数据、不要放客户端</li>
<li>核心方法使用Native</li>
<li>不要在代码中直接使用字符串，通过资源获取</li>
<li>签名校验：运行时在代码中对应用签名进行校验</li>
<li>插入代码花指令，使反编译工具报错：可以结合apt、asm插入，避免影响原代码阅读</li>
<li>…</li>
</ol>
<h1 id="应用安全CheckList"><a href="#应用安全CheckList" class="headerlink" title="应用安全CheckList"></a>应用安全CheckList</h1><p>引自：<a href="https://www.jianshu.com/p/4ff48b761ff6">Android应用加固原理</a></p>
<table>
<thead>
<tr>
<th>风险名称</th>
<th align="center">风险</th>
<th align="right">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>App防止反编译</td>
<td align="center">被反编译的暴露客户端逻辑，加密算法，密钥，等等</td>
<td align="right">加固</td>
</tr>
<tr>
<td>java层代码源代码反编译风险</td>
<td align="center">被反编译的暴露客户端逻辑，加密算法，密钥，等等</td>
<td align="right">加固 ，混淆</td>
</tr>
<tr>
<td>so文件破解风险</td>
<td align="center">导致核心代码泄漏。</td>
<td align="right">so文件加固</td>
</tr>
<tr>
<td>篡改和二次打包风险</td>
<td align="center">修改文件资源等，二次打包的添加病毒，广告，或者窃取支付密码，拦截短信等</td>
<td align="right">资源文件混淆和校验签名的hash值</td>
</tr>
<tr>
<td>资源文件泄露风险</td>
<td align="center">获取图片，js文件等文件，通过植入病毒，钓鱼页面获取用户敏感信息</td>
<td align="right">资源混淆，加固等等</td>
</tr>
<tr>
<td>应用签名未交验风险</td>
<td align="center">反编译或者二次打包，添加病毒代码，恶意代码，上传盗版App</td>
<td align="right">对App进行签名证书校验</td>
</tr>
<tr>
<td>代码为混淆风险</td>
<td align="center">业务逻辑暴露，加密算法，账号信息等等。</td>
<td align="right">混淆（中文混淆）</td>
</tr>
<tr>
<td>webview明文存储密码风险</td>
<td align="center">用户使用webview默认存储密码到databases/webview.db root的手机可以产看webview数据库，获取用户敏感信息</td>
<td align="right">关闭webview存储密码功能</td>
</tr>
<tr>
<td>明文数字证书风险</td>
<td align="center">APK使用的数字证书用来校验服务器的合法性，保证数据的保密性和完成性 明文存储的证书被篡改造成数据被获取等</td>
<td align="right">客户端校验服务器域名和数字证书等</td>
</tr>
<tr>
<td>调试日志函数调用风险</td>
<td align="center">日志信息里面含有用户敏感信息等</td>
<td align="right">关闭调试日志函数，删除打印的日志信息</td>
</tr>
<tr>
<td>AES/DES加密方法不安全使用风险</td>
<td align="center">在使用AES/DES加密使用了ECB或者OFB工作模式，加密数据被选择明文攻击破解等</td>
<td align="right">使用CBC和CFB工作模式等</td>
</tr>
<tr>
<td>RSA加密算法不安全风险</td>
<td align="center">密数据被选择明文攻击破解和中间人攻击等导致用户敏感信息泄露</td>
<td align="right">密码不要太短，使用正确的工作模式</td>
</tr>
<tr>
<td>密钥硬编码风险</td>
<td align="center">用户使用加密算法的密钥设置成一个固定值导致密钥泄漏</td>
<td align="right">动态生成加密密钥或者将密钥进程分段存储等</td>
</tr>
<tr>
<td>动态调试攻击风险</td>
<td align="center">攻击者使用GDB，IDA调试追踪目标程序，获取用户敏感信息等</td>
<td align="right">在so文件里面实现对调试进程的监听</td>
</tr>
<tr>
<td>应用数据任意备份风险</td>
<td align="center">AndroidMainfest中allowBackup=true 攻击者可以使用adb命令对APP应用数据进行备份造成用户数据泄露</td>
<td align="right">allowBackup=false</td>
</tr>
<tr>
<td>全局可读写内部文件风险。</td>
<td align="center">实现不同软件之间数据共享，设置内部文件全局可读写造成其他应用也可以读取或者修改文件等</td>
<td align="right">（1）.使用MODE_PRIVATE模式创建内部存储文件（2）.加密存储敏感数据3.避免在文件中存储明文和敏感信息</td>
</tr>
<tr>
<td>SharedPrefs全局可读写内部文件风险。</td>
<td align="center">被其他应用读取或者修改文件等</td>
<td align="right">使用正确的权限</td>
</tr>
<tr>
<td>Internal Storage数据全局可读写风险</td>
<td align="center">当设置MODE_WORLD_READBLE或者设置android:sharedUserId导致敏感信息被其他应用程序读取等</td>
<td align="right">设置正确的模式等</td>
</tr>
<tr>
<td>getDir数据全局可读写风险</td>
<td align="center">当设置MODE_WORLD_READBLE或者设置android:sharedUserId导致敏感信息被其他应用程序读取等</td>
<td align="right">设置正确的模式等</td>
</tr>
<tr>
<td>java层动态调试风险</td>
<td align="center">AndroidManifest中调试的标记可以使用jdb进行调试，窃取用户敏感信息。</td>
<td align="right">android：debuggable=“false”</td>
</tr>
<tr>
<td>内网测试信息残留风险</td>
<td align="center">通过测试的Url，测试账号等对正式服务器进行攻击等</td>
<td align="right">讲测试内网的日志清除，或者测试服务器和生产服务器不要使用同一个</td>
</tr>
<tr>
<td>随机数不安全使用风险</td>
<td align="center">在使用SecureRandom类来生成随机数，其实并不是随机，导致使用的随机数和加密算法被破解。</td>
<td align="right">（1）不使用setSeed方法（2）使用/dev/urandom或者/dev/random来初始化伪随机数生成器</td>
</tr>
<tr>
<td>Http传输数据风险</td>
<td align="center">未加密的数据被第三方获取，造成数据泄露</td>
<td align="right">使用Hpps</td>
</tr>
<tr>
<td>Htpps未校验服务器证书风险，Https未校验主机名风险，Https允许任意主机名风险</td>
<td align="center">客户端没有对服务器进行身份完整性校验，造成中间人攻击</td>
<td align="right">（1）.在X509TrustManager中的checkServerTrusted方法对服务器进行校验（2）.判断证书是否过期（3）.使用HostnameVerifier类检查证书中的主机名与使用证书的主机名是否一致</td>
</tr>
<tr>
<td>webview绕过证书校验风险</td>
<td align="center">webview使用https协议加密的url没有校验服务器导致中间人攻击</td>
<td align="right">校验服务器证书时候正确</td>
</tr>
<tr>
<td>界面劫持风险</td>
<td align="center">用户输入密码的时候被一个假冒的页面遮挡获取用户信息等</td>
<td align="right">（1）.使用第三方专业防界面劫持SDK（2）.校验当前是否是自己的页面</td>
</tr>
<tr>
<td>输入监听风险</td>
<td align="center">用户输入的信息被监听或者按键位置被监听造成用户信息泄露等</td>
<td align="right">自定义键盘</td>
</tr>
<tr>
<td>截屏攻击风险</td>
<td align="center">对APP运行中的界面进行截图或者录制来获取用户信息</td>
<td align="right">添加属性getWindow().setFlags(FLAG_SECURE)不让用户截图和录屏</td>
</tr>
<tr>
<td>动态注册Receiver风险</td>
<td align="center">当动态注册Receiver默认生命周期是可以导出的可以被任意应用访问</td>
<td align="right">使用带权限检验的registerReceiver API进行动态广播的注册</td>
</tr>
<tr>
<td>Content Provider数据泄露风险</td>
<td align="center">权限设置不当导致用户信息</td>
<td align="right">正确的使用权限</td>
</tr>
<tr>
<td>Service ，Activity，Broadcast,content provider组件导出风险</td>
<td align="center">Activity被第三方应用访问导致被任意应用恶意调用</td>
<td align="right">自定义权限</td>
</tr>
<tr>
<td>PendingIntent错误使用Intent风险</td>
<td align="center">使用PendingIntent的时候，如果使用了一个空Intent，会导致恶意用户劫持修改Intent的内容</td>
<td align="right">禁止使用一个空Intent去构造PendingIntent</td>
</tr>
<tr>
<td>Intent组件隐式调用风险</td>
<td align="center">使用隐式Intent没有对接收端进行限制导致敏感信息被劫持</td>
<td align="right">1.对接收端进行限制 2.建议使用显示调用方式发送Intent</td>
</tr>
<tr>
<td>Intent Scheme URL攻击风险</td>
<td align="center">webview恶意调用App</td>
<td align="right">对Intent做安全限制</td>
</tr>
<tr>
<td>Fragment注入攻击风险</td>
<td align="center">出的PreferenceActivity的子类中，没有加入isValidFragment方法，进行fragment名的合法性校验，攻击者可能会绕过限制，访问未授权的界面</td>
<td align="right">（1）.如果应用的Activity组件不必要导出，或者组件配置了intent filter标签，建议显示设置组件的“android:exported”属性为false（2）.重写isValidFragment方法，验证fragment来源的正确性</td>
</tr>
<tr>
<td>webview远程代码执行风险</td>
<td align="center">风险：WebView.addJavascriptInterface方法注册可供JavaScript调用的Java对象，通过反射调用其他java类等</td>
<td align="right">建议不使用addJavascriptInterface接口，对于Android API Level为17或者以上的Android系统，Google规定允许被调用的函数，必须在Java的远程方法上面声明一个@JavascriptInterface注解</td>
</tr>
<tr>
<td>zip文件解压目录遍历风险</td>
<td align="center">Java代码在解压ZIP文件时，会使用到ZipEntry类的getName()方法，如果ZIP文件中包含“../”的字符串，该方法返回值里面原样返回，如果没有过滤掉getName()返回值中的“../”字符串，继续解压缩操作，就会在其他目录中创建解压的文件</td>
<td align="right">（1）. 对重要的ZIP压缩包文件进行数字签名校验，校验通过才进行解压。 （2）. 检查Zip压缩包中使用ZipEntry.getName()获取的文件名中是否包含”../”或者”..”，检查”../”的时候不必进行URI Decode（以防通过URI编码”..%2F”来进行绕过），测试发现ZipEntry.getName()对于Zip包中有“..%2F”的文件路径不会进行处理。</td>
</tr>
<tr>
<td>Root设备运行风险</td>
<td align="center">已经root的手机通过获取应用的敏感信息等</td>
<td align="right">检测是否是root的手机禁止应用启动</td>
</tr>
<tr>
<td>模拟器运行风险</td>
<td align="center">刷单，模拟虚拟位置等</td>
<td align="right">禁止在虚拟器上运行</td>
</tr>
<tr>
<td>从sdcard加载Dex和so风险</td>
<td align="center">未对Dex和So文件进行安全，完整性及校验，导致被替换，造成用户敏感信息泄露</td>
<td align="right">（1）.放在APP的私有目录    （2）.对文件进行完成性校验。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>GitPage博客绑定域名</title>
    <url>/2021/10/01/blog-2021-10-01-GitPage%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<h1 id="GitPage如何绑定自定义域名"><a href="#GitPage如何绑定自定义域名" class="headerlink" title="GitPage如何绑定自定义域名"></a>GitPage如何绑定自定义域名</h1><h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>万网、阿里云、腾讯云都可以申请</p>
<h2 id="配置DNS解析"><a href="#配置DNS解析" class="headerlink" title="配置DNS解析"></a>配置DNS解析</h2><p>以阿里云为例</p>
<p><img src="/2021/10/01/blog-2021-10-01-GitPage%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/%E5%9F%9F%E5%90%8D%E6%B7%BB%E5%8A%A0DNS%E8%AE%B0%E5%BD%95.png" alt="域名添加DNS记录"></p>
<h2 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h2><p><strong>注：方式二会在远程仓库生成CNAME文件和新的提交，会产生分支冲突，导致本地发布博客失败，建议使用方式一</strong></p>
<blockquote>
<p>产生冲突的时候可以执行<code>hexo clean</code>再发布</p>
</blockquote>
<ol>
<li>方式一：博客站点<code>source</code>目录下添加<code>CNAME</code>文件，文件中填写域名地址。<code>hexo clean &amp; hexo g -d</code>重新发布</li>
<li>方式二：GitPage中配置自定义域名，会生成CNAME文件并发布</li>
</ol>
<p><img src="/2021/10/01/blog-2021-10-01-GitPage%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/GitPage%E9%85%8D%E7%BD%AECNAME.png" alt="GitPage配置CNAME"></p>
<h1 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h1><p>域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。</p>
<p>DNS服务器会存储记录，记录类型有多种类型，起到不同的作用，这里简单介绍下A记录、CNAME记录和NS记录</p>
<h2 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h2><p>Address记录。存储域名到对应IP的记录，将域名解析成IP</p>
<h2 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h2><p>别名记录，将一个域名解析成另一个域名。</p>
<h3 id="将多个域名映射到同一个域名"><a href="#将多个域名映射到同一个域名" class="headerlink" title="将多个域名映射到同一个域名"></a>将多个域名映射到同一个域名</h3><p>当需要多个域名指向同一个IP时，如果使用A记录，如下，一旦IP变更，需要修改多条A记录。</p>
<blockquote>
<ol>
<li><code>www.aaa.com--&gt;1.1.1.1</code></li>
<li><code>www.bbb.com--&gt;1.1.1.1</code></li>
</ol>
</blockquote>
<p>如果使用CNAME记录，如下，只需要修改A记录即可</p>
<blockquote>
<ol>
<li><code>www.aaa.com--&gt;www.xxx.com--&gt;1.1.1.1</code></li>
<li><code>www.bbb.com--&gt;www.xxx.com--&gt;1.1.1.1</code></li>
</ol>
</blockquote>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>使用CNAME将域名指向CDN服务器，由CDN服务器把最近的（或者负载较低的）服务器IP返回给本地DNS，让客户端能够快速访问</p>
<h2 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h2><p>域名服务器记录。指定域名由哪个DNS服务器解析</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>DNS解析流程：客户端–&gt;本地hosts查询–&gt;ISP本地运营商查询DNS缓存–&gt;权威DNS服务器解析</p>
<p>本地hosts文件：保存常用的网址域名与其对应IP地址的映射。</p>
<blockquote>
<p>当用户在浏览器中输入一个需要登录的网址域名时，系统会首先自动从hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会将网址提交DNS服务器进行IP地址的解析，再进行访问。</p>
</blockquote>
<p>可以使用<code>ipconfig /flushdns</code>命令清除DNS缓存</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/DD_orz/article/details/100034049">简单的解释下什么是CNAME？</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>曼德拉效应</title>
    <url>/2021/09/26/personal-2021-09-26-%E6%9B%BC%E5%BE%B7%E6%8B%89%E6%95%88%E5%BA%94/</url>
    <content><![CDATA[<h1 id="曼德拉效应"><a href="#曼德拉效应" class="headerlink" title="曼德拉效应"></a>曼德拉效应</h1><blockquote>
<p>指大众对历史的集体记忆与史实不符</p>
</blockquote>
<ol>
<li>许多人表示，在自己的记忆中，南非总统<strong>曼德拉</strong>应该在20世纪80年代已经在监狱中死亡”，但现实是曼德拉没有在20世纪80年代死去，后来还被释放，还当上南非总统，直至2010年时仍然在世（曼德拉在2013年才逝世）。</li>
<li>“真”和“直”这两个字在记忆中，方框里面的横线是两条，而且这么写非常顺手。然而，如果仔细观察，就会发现这两个字的方框里面其实是三横。</li>
<li>记忆中叮当是口字旁的，实际不是，并且也搜不到口字旁的当。</li>
<li>记忆中的皮卡丘尾巴有一条黑色条纹，实际是纯黄色</li>
<li>86版《西游记》中没有羊力大仙下油锅炸，但有很多人认为有这个情节。</li>
<li>86版《西游记》中没有虎力大仙砍头被狗叼走了，但有很多人认为有这个情节。</li>
<li>从小听的《爱我中华》歌词：“56个民族，56枝花”，实际上是“56个星座，56枝花”</li>
<li>台湾电影《那些年，我们一起追的女孩》，但是很多人认为是《那些年，我们一起追<strong>过</strong>的女孩》。</li>
<li>美国米老鼠穿什么衣服，很多人回忆是<strong>背带裤</strong>，但其实是上<strong>半裸的短裤</strong>，根本没有背带。同样，很多人认为米老鼠<strong>没有尾巴，或者尾巴画得极度不明显</strong>到可以忽略；但实际上迪士尼原版的米老鼠<strong>尾巴画得又显眼又长</strong>。</li>
<li>记忆中狮子是犬科动物，实际是猫科动物</li>
<li>法国著名雕塑思考者，原本记忆中应该是用手握拳，而现在的思考者却是把手张平。</li>
</ol>
<p>所以记忆这东西，到底是为了证明过去的存在，还是证明过去的虚幻呢？</p>
<p><strong>部分摘自百度百科</strong></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>线程同步的方式【转】</title>
    <url>/2021/09/15/kotlin-2021-09-15-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>引自：<a href="https://mp.weixin.qq.com/s/eLxDiOgUiOl9BWu7FrvR2A">建议收藏！Kotlin 线程同步的 N 种方法</a></p>
<h1 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h1><blockquote>
<p>问题： 现有 Task1、Task2 等多个并行任务，如何等待全部任务执行完成后，开始执行 Task3 ? </p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> task1: () -&gt; String = &#123;</span><br><span class="line">    sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="string">&quot;Hello&quot;</span>.also &#123; println(<span class="string">&quot;task1 finished: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> task2: () -&gt; String = &#123;</span><br><span class="line">    sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="string">&quot;World&quot;</span>.also &#123; println(<span class="string">&quot;task2 finished: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> task3: (String, String) -&gt; String = &#123; p1, p2 -&gt;</span><br><span class="line">    sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="string">&quot;<span class="variable">$p1</span> <span class="variable">$p2</span>&quot;</span>.also &#123; println(<span class="string">&quot;task3 finished: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join"></a>Thread.join</h2><p><code>join</code>方法：让当前所在线程挂起，让指定线程先执行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_join</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> t1 = Thread &#123; s1 = task1() &#125;</span><br><span class="line">    <span class="keyword">val</span> t2 = Thread &#123; s2 = task2() &#125;</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    </span><br><span class="line">    task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><code>synchronized</code>：锁住一个对象，使其他线程无法访问该对象的同步代码块，但可以访问该对象的非同步代码块。</p>
<ol>
<li>修饰代码块：<code>synchronized(this)&#123;&#125;</code>，锁住当前对象，作用范围是{}代码块</li>
<li>修饰方法：锁住当前对象，作用范围是整个方法</li>
<li>修饰静态方法：锁住当前类的所有对象，作用范围是整个静态方法</li>
<li>修饰类：<code>synchronized(XXX.class)&#123;&#125;</code>，锁住类的所有对象，作用范围是{}代码块</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_synchrnoized</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	Thread &#123;</span><br><span class="line">		synchronized(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">			s1 = task1()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;.start()</span><br><span class="line">	s2 = task2()</span><br><span class="line">  <span class="comment">//task3在task2之后执行，task1执行完之后释放锁，才能执行task3</span></span><br><span class="line">	synchronized(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">		task3(s1, s2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个并行任务写法比较复杂，需要嵌套synchronized</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code>是<code>JUC（java.util .concurrent，并发工具包）</code>提供的线程锁，可以替换Synchronized使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_ReentrantLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> lock = ReentrantLock()</span><br><span class="line">	Thread &#123;</span><br><span class="line">		lock.lock()</span><br><span class="line">		s1 = task1()</span><br><span class="line">		lock.unlock()</span><br><span class="line">	&#125;.start()</span><br><span class="line">  </span><br><span class="line">	s2 = task2()</span><br><span class="line">  </span><br><span class="line">	lock.lock()</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">	lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个并行任务需要创建多个Lock管理不同的任务</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列：阻塞队列内部也是通过 Lock 实现的。</p>
<p>阻塞队列更多是使用在生产/消费场景中的同步。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_blockingQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> queue = SynchronousQueue&lt;<span class="built_in">Unit</span>&gt;()</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		queue.put(<span class="built_in">Unit</span>)</span><br><span class="line">	&#125;.start()</span><br><span class="line">	s2 = task2()</span><br><span class="line">	queue.take()</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>JUC 中的锁大都基于 <code>AQS</code> 实现的，可以分为独享锁和共享锁。<code>ReentrantLock</code> 就是一种独享锁。相比之下，共享锁更适合本场景。例如 <code>CountDownLatch</code>，它可以让一个线程一直处于阻塞状态，直到其他线程的执行全部完成：</p>
<p>共享锁的好处是不必为了每个任务都创建单独的锁，即使再多并行任务写起来也很轻松</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_countdownlatch</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> cd = CountDownLatch(<span class="number">2</span>)</span><br><span class="line">	Thread() &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		cd.countDown()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	Thread() &#123;</span><br><span class="line">		s2 = task2()</span><br><span class="line">		cd.countDown()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	cd.await()</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code> 是 JUC 提供的另一种共享锁机制，它可以让一组线程到达一个同步点后再一起继续运行，其中任意一个线程未达到同步点，其他已到达的线程均会被阻塞。</p>
<p>与 <code>CountDownLatch</code> 的区别在于 <code>CountDownLatch</code> 是一次性的，而 <code>CyclicBarrier</code> 可以被重置后重复使用，这也正是 <code>Cyclic</code> 的命名由来，可以循环使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_CyclicBarrier</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> cb = CyclicBarrier(<span class="number">3</span>)</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		cb.await()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	Thread() &#123;</span><br><span class="line">		s2 = task1()</span><br><span class="line">		cb.await()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	cb.await()</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>AQS 内部通过自旋锁实现同步，自旋锁的本质是利用 <code>CompareAndSwap</code> 避免线程阻塞的开销。因此，我们可以使用基于 CAS 的原子类计数，达到实现无锁操作的目的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_cas</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	<span class="keyword">val</span> cas = AtomicInteger(<span class="number">2</span>)</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		cas.getAndDecrement()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s2 = task2()</span><br><span class="line">		cas.getAndDecrement()</span><br><span class="line">	&#125;.start()</span><br><span class="line">	<span class="keyword">while</span> (cas.<span class="keyword">get</span>() != <span class="number">0</span>) &#123;&#125;</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>while</code> 循环空转看起来有些浪费资源，但是自旋锁的本质就是这样，所以 CAS 仅仅适用于一些cpu密集型的短任务同步。</p>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_Volatile</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s1: String</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> s2: String</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s1 = task1()</span><br><span class="line">		cnt--</span><br><span class="line">	&#125;.start()</span><br><span class="line">	Thread &#123;</span><br><span class="line">		s2 = task2()</span><br><span class="line">		cnt--</span><br><span class="line">	&#125;.start()</span><br><span class="line">	<span class="keyword">while</span> (cnt != <span class="number">0</span>) &#123;&#125;</span><br><span class="line">	task3(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，这种写法是错误的<code>volatile</code> 能保证可见性，但是不能保证原子性，<code>cnt--</code> 并非线程安全，需要加锁操作</strong></p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>上面无论有锁操作还是无锁操作，都需要定义两个变量<code>s1</code>、<code>s2</code>记录结果非常不方便。Java 1.5 开始，提供了 <code>Callable</code> 和 <code>Future</code> ，可以在任务执行结束时返回结果。</p>
<p>通过 <code>future.get()</code>，可以同步等待结果返回，写起来非常方便</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_future</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> future1 = FutureTask(Callable(task1))</span><br><span class="line">	<span class="keyword">val</span> future2 = FutureTask(Callable(task2))</span><br><span class="line">	Executors.newCachedThreadPool().execute(future1)</span><br><span class="line">	Executors.newCachedThreadPool().execute(future2)</span><br><span class="line">	task3(future1.<span class="keyword">get</span>(), future2.<span class="keyword">get</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>future.get()</code> 虽然方便，但是会阻塞线程。Java 8 中引入了 <code>CompletableFuture</code> ，他实现了 Future 接口的同时实现了 <code>CompletionStage</code> 接口。<code>CompletableFuture</code> 可以针对多个 <code>CompletionStage</code> 进行逻辑组合、实现复杂的异步编程。这些逻辑组合的方法以回调的形式避免了线程阻塞：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_CompletableFuture</span><span class="params">()</span></span> &#123;</span><br><span class="line">	CompletableFuture.supplyAsync(task1)</span><br><span class="line">		.thenCombine(CompletableFuture.supplyAsync(task2)) &#123; p1, p2 -&gt;</span><br><span class="line">				task3(p1, p2)</span><br><span class="line">		&#125;.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p><code>RxJava</code> 提供的各种操作符以及线程切换能力同样可以帮助我们实现需求：<code>zip</code> 操作符可以组合两个 <code>Observable</code> 的结果；<code>subscribeOn</code> 用来启动异步任务</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_Rxjava</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Observable.zip(</span><br><span class="line">		Observable.fromCallable(Callable(task1))</span><br><span class="line">			.subscribeOn(Schedulers.newThread()),</span><br><span class="line">		Observable.fromCallable(Callable(task2))</span><br><span class="line">			.subscribeOn(Schedulers.newThread()),</span><br><span class="line">    BiFunction(task3)</span><br><span class="line">  ).test().awaitTerminalEvent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>协程：<code>kotlin</code>特有</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_coroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> c1 = async(Dispatchers.IO) &#123;</span><br><span class="line">      task1()</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">val</span> c2 = async(Dispatchers.IO) &#123;</span><br><span class="line">      task2()</span><br><span class="line">    &#125;</span><br><span class="line">    task3(c1.await(), c2.await())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_flow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> flow1 = flow&lt;String&gt; &#123; emit(task1()) &#125;</span><br><span class="line">	<span class="keyword">val</span> flow2 = flow&lt;String&gt; &#123; emit(task2()) &#125;    </span><br><span class="line">	runBlocking &#123;</span><br><span class="line">		flow1.zip(flow2) &#123; t1, t2 -&gt;</span><br><span class="line">			task3(t1, t2)</span><br><span class="line">		&#125;.flowOn(Dispatchers.IO)</span><br><span class="line">		.collect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flowOn</code> 使得 Task 在异步计算并发射结果。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖（debounce）和节流（throttle）</title>
    <url>/2021/09/14/tech-2021-09-14-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖（debounce）和节流（throttle）"><a href="#防抖（debounce）和节流（throttle）" class="headerlink" title="防抖（debounce）和节流（throttle）"></a>防抖（debounce）和节流（throttle）</h1><ol>
<li>防抖：一段时间，多次点击，只保留最后一次事件。</li>
<li>节流：一段时间，多次点击，只执行第一次事件，之后的几次事件都会被过滤。</li>
</ol>
<p>使用场景：</p>
<ol>
<li>防抖：输入框连续输入，停下来之后再触发搜索。连续点击收藏按钮，只请求最后一次的状态</li>
<li>节流：防止按钮连续点击，如页面跳转事件，可能会打开多个页面。</li>
</ol>
<p>其他说法：</p>
<ol>
<li>防抖：连续触发事件时，只执行一次动作。每次触发事件，重新设定周期。</li>
<li>节流：一段时间内，触发多次事件，只执行一次动作。周期固定，动作定期执行，响应平滑。</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonUtil</span> </span>&#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _defaultDuration = <span class="number">500</span>;</span><br><span class="line">  <span class="keyword">static</span> Timer? _timer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现：延时执行，持续触发时取消定时</span></span><br><span class="line">  <span class="keyword">static</span> debounce(<span class="built_in">Function</span> func, &#123;durationTime = _defaultDuration&#125;) &#123;</span><br><span class="line">    _timer?.cancel();</span><br><span class="line">    _timer = <span class="keyword">new</span> Timer(<span class="built_in">Duration</span>(milliseconds: durationTime), () &#123;</span><br><span class="line">      func.call();</span><br><span class="line">      _timer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">int</span> _lastTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现1：保存上一次点击时间，间隔时间内不重复触发</span></span><br><span class="line">  <span class="keyword">static</span> throttle(<span class="built_in">Function</span> func, &#123;durationTime = _defaultDuration&#125;) &#123;</span><br><span class="line">    <span class="built_in">int</span> currentTime = <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch;</span><br><span class="line">    <span class="keyword">if</span> (currentTime - _lastTime &gt; durationTime) &#123;</span><br><span class="line">      func.call();</span><br><span class="line">      _lastTime = <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonUtil</span> </span>&#123; </span><br><span class="line">  <span class="keyword">static</span> debounce(<span class="built_in">Function</span> func, &#123;durationTime = _defaultDuration&#125;) &#123;</span><br><span class="line">    Timer? timer;</span><br><span class="line">    <span class="built_in">Function</span> target = () &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer?.isActive ?? <span class="keyword">false</span>) &#123;</span><br><span class="line">        timer?.cancel();</span><br><span class="line">      &#125;</span><br><span class="line">      timer = Timer(<span class="built_in">Duration</span>(milliseconds: durationTime), () &#123;</span><br><span class="line">        func.call();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现2：添加enable标记，通过Future或者await等待上一次事件执行完成，再接收下一个事件。</span></span><br><span class="line">  <span class="keyword">static</span> throttle(Future <span class="built_in">Function</span>() func) &#123;</span><br><span class="line">    <span class="built_in">bool</span> enable = <span class="keyword">true</span>;</span><br><span class="line">    <span class="built_in">Function</span> target = () &#123;</span><br><span class="line">      <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        enable = <span class="keyword">false</span>;</span><br><span class="line">	    func().then((_) =&gt; enable = <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考文章：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/375076538">Android&amp;RN&amp;Flutter实战——防抖节流函数</a></li>
<li><a href="https://blog.csdn.net/sinat_17775997/article/details/107108687">Flutter中的节流与防抖</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>UML-统一建模语言</title>
    <url>/2021/09/13/note-2021-09-13-UML/</url>
    <content><![CDATA[<h1 id="UML-Unified-Modeling-Language，-统一建模语言"><a href="#UML-Unified-Modeling-Language，-统一建模语言" class="headerlink" title="UML(Unified Modeling Language， 统一建模语言)"></a>UML(Unified Modeling Language， 统一建模语言)</h1><h2 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h2><ol>
<li>功能模型：从用户的角度展示系统的功能，包含用例图；</li>
<li>对象模型： 采用对象，属性，操作，关联等概念展示系统的结构，包括类图、对象图。</li>
<li>动态模型： 展现系统的内部行为，包括时序图，活动图，状态图。</li>
</ol>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li>需求分析： 用例图，对外部的参与者以及其需要的系统功能建模，表示客户需求；</li>
<li>概要设计： 类图、状态图、协作图、活动图，描述系统的静态结构、动态特征；</li>
<li>详细设计：状态图、协作图、活动图、序列图，产生技术解决方案；</li>
<li>测试：类图、构件图、部署图，单元测试使用类图，集成测试使用构件图、部署图。</li>
</ul>
<h1 id="用例图（Use-Case-Diagram）"><a href="#用例图（Use-Case-Diagram）" class="headerlink" title="用例图（Use Case Diagram）"></a>用例图（Use Case Diagram）</h1><ol>
<li>静态图</li>
<li>表现了系统角色划分，角色和用例间的关系，用例和用例间的关系</li>
<li>用于<strong>描述软件功能和需求</strong></li>
</ol>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><ol>
<li>角色（Actor）：与应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。</li>
<li>用例（Use Case）：用例就是外部可见的系统功能，对系统提供的服务进行描述。用椭圆表示。</li>
<li>子系统（Sub System）：用来展示系统的一部分功能，这部分功能联系紧密。</li>
</ol>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ol>
<li>关联(Association)：对象和用例之间的联系。</li>
<li>泛化(Inheritance)：对象和对象间、用例和用例间的继承关系。</li>
<li>包含(Include)：基础用例的子用例</li>
<li>扩展(Extend)：对基础用例的扩展，子用例是一个可选的过程</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li>导游继承游客</li>
<li>导游可以办理团队手续</li>
<li>游客可以办理个人手续</li>
<li>团队手续包含个人手续</li>
<li>办理个人手续的时候可以选择是否需要行李托运</li>
</ol>
<p><img src="https://g.gravizo.com/svg?
@startuml;
left to right direction;
actor 导游;
actor 游客;
导游 --|> 游客;
(团队手续办理) as A;
(个人手续办理) as B;
(行李托运) as C;
导游--A;
A -.-> B: [《include》];
C -.-> B: [《extend》];
游客 -- B;
@enduml
"></p>
<h1 id="活动图（Activity-Diagram）"><a href="#活动图（Activity-Diagram）" class="headerlink" title="活动图（Activity Diagram）"></a>活动图（Activity Diagram）</h1><ol>
<li>动态图</li>
<li>可以用<strong>泳道</strong>区分用例归属的角色，体现角色间的交互关系</li>
<li>用于<strong>描述软件功能和需求</strong></li>
</ol>
<h2 id="元素-1"><a href="#元素-1" class="headerlink" title="元素"></a>元素</h2><ol>
<li>初始节点：只有一个。实心圆表示。</li>
<li>活动终点：<strong>可以有多个</strong>。圆圈内加一个实心圆表示。</li>
<li>转换：转换到下一个活动，箭头表示</li>
<li>决策：根据条件判断转换到不同活动。菱形表示</li>
<li>分叉和汇合：分叉用于将动作分为多个并行的分支，汇合用于同步这些分支。使用圆角矩形表示</li>
<li>泳道：将活动划分到不同对象进行</li>
</ol>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><img src="https://g.gravizo.com/svg?
@startuml;
title 考试活动;
|学生|;
start;
-进入考场;
fork;
-对号入座;
|监考老师|;
fork again;
if (检查证件) then (证件忘带);
|学生|;
stop;
note right: 退出考场;
else (证件正确);
|监考老师|;
-发考卷;
endif;
end fork;
|学生|;
-开始答题;
stop;
note right: 考试结束;
@enduml
"></p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><ol>
<li>描述的是系统的静态结构，表达期望的软件实现方案</li>
<li>描述系统中类、接口级别的设计，描述每个类的功能和关系</li>
</ol>
<h2 id="元素-2"><a href="#元素-2" class="headerlink" title="元素"></a>元素</h2><ul>
<li><code>+</code> public</li>
<li><code>-</code> private</li>
<li><code>#</code> protected</li>
<li><code>~</code> package/internal</li>
<li><code>*</code> abstract: <code>someAbstractMethod()*</code>，抽象方法，斜体</li>
<li><code>$</code> static: <code>someStaticMethod()$</code>，静态方法，下划线</li>
</ul>
<h2 id="关系-1"><a href="#关系-1" class="headerlink" title="关系"></a>关系</h2><ol>
<li>泛化：继承关系，空心三角实线表示</li>
<li>实现：接口实现，空心三角虚线表示</li>
<li>依赖：弱一点的关联，一般是局部变量、参数，虚线箭头表示</li>
<li>关联（单向关联、双向关联、自关联）：持有关系，一般是成员变量，自关联如链表节点，实线箭头表示。</li>
<li>组合：关联关系的一种，A组合B，B不可以脱离A单独存在，实心菱形直线表示</li>
<li>聚合：关联关系的一种，A聚合B，B可以脱离A单独存在，空心菱形直线表示</li>
</ol>
<p>关系强弱：泛化&gt;= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖</p>
<p>关联、组合、聚合在代码中的体现都是成员变量，需要结合语义上下文才能判断是什么关系。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><pre class="mermaid">classDiagram
class IName{
<<interface>>
+name()
}
class Person{
<<abstract>>
+name()
+say()
+drive(Car car)
}
class Car
class Student{
+say()
+name()
}
class Teacher{
+say()
+name()
+setCompany(Company company)
}
class Company{
- departments: Department[]
}
class Department

Person ..|> IName : 实现
Student --|> Person : 继承
Teacher --|> Person : 继承
Person ..> Car : 依赖
Company *--> Department : 1对多
Teacher o--> Company : 1对1</abstract></interface></pre>

<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><ol>
<li>动态图</li>
<li>描述对象之间的消息类型和交互顺序</li>
</ol>
<h2 id="元素-3"><a href="#元素-3" class="headerlink" title="元素"></a>元素</h2><ol>
<li>角色</li>
<li>对象：时序图顶部，矩形表示</li>
<li>生命线：表示对象的生命周期，垂直虚线表示</li>
<li>控制焦点：对象在某个时间段内执行的操作，控制焦点两端不要超过矩形</li>
<li>消息<ol>
<li>同步消息：消息发送者把控制传递给消息接受者，然后停止活动，等待接收者放弃或者返回控制，实心三角箭头实线表示</li>
<li>异步消息：消息发送者把控制传递给消息接受者，然后继续自己的活动，不等待接收者返回，实线箭头表示</li>
<li>返回消息：虚线箭头表示</li>
<li>自关联消息：对象调用自身方法，指向自身</li>
</ol>
</li>
<li>组合片段：指定条件或者子进程应用区域<ol>
<li>抉择（Alt）：片段包含多个备用消息序列，只发生一个消息序列，相当于if…else</li>
<li>选项（Opt）：片段包含一个可能发生或者不发生的消息序列，相当于if…</li>
<li>循环（Loop）：片段重复一定次数，可以指定片段重复条件，相当于for…</li>
<li>中断（Break）：如果执行此片段，则放弃序列中其余部分</li>
<li>并行（Par）：片段中的事件可以并行交错执行，相当于多线程</li>
<li>….</li>
</ol>
</li>
</ol>
<p>注：同步消息和返回消息不一定是成对的，返回为void时可省略</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><pre class="mermaid">sequenceDiagram
participant 用户
participant 系统
participant 后台
note right of 用户: 不支持异步消息画法，都使用实线三角
note right of 用户: 不支持控制焦点矩形
用户->>系统: 登录
系统-->>用户: 返回登陆页面
用户->>系统: 输入账号密码
系统->>后台: 提交用户信息
后台->>后台: 校验用户信息
后台-->>系统: 返回登录结果
alt 校验失败
系统->>用户: 显示登录失败
else 校验成功
系统->>用户: 显示登录成功
end</pre>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>只介绍了一部分常用的图和用法，其余的不展开介绍了</p>
<p>注：</p>
<p><code>mermaid</code>不支持用例图、活动图，可以使用<code>gravizo</code>生成<code>plantuml</code>图，不能空行，结尾要加分号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&#39;https:&#x2F;&#x2F;g.gravizo.com&#x2F;svg?</span><br><span class="line">@startuml;</span><br><span class="line">...</span><br><span class="line">@enduml;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参考文章</strong>：</p>
<ul>
<li><a href="https://g.gravizo.com/">gravizo</a></li>
<li><a href="https://plantuml.com/zh/">plantuml</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>CI——回首毕业论文</title>
    <url>/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文源于本人本科毕业论文—— 《面向Android项目的持续集成系统的设计与实现》，把论文内容整理成博客。</p>
<p>时隔两年多再看，当时整体的思想和系统设计还是比较领先的。当然经历了更多的项目，见识过了大团队的CI，也有了更多的感悟，发现一些功能和细节可以更加完善。</p>
<h1 id="论文内容"><a href="#论文内容" class="headerlink" title="论文内容"></a>论文内容</h1><p><strong>标题</strong>：面向Android项目的持续集成系统的设计与开发</p>
<p>DESIGN AND IMPLEMENTATION OF CONTINUOUS INTEGRATION SYSTEM FOR ANDROID PROJECT</p>
<p><strong>摘要</strong>: 本文结合Android组件化架构设计了一套基于Jenkins的持续集成方案，通过自动化构建、集成、打包等一系列环节，规范软件开发流程、缩短迭代周期、及时发现问题、减少发布风险、保证软件质量，能够快速地响应需求变化，随时提供可以运行的软件版本，提高了软件在开发过程中的可见性。</p>
<p>该系统主要由Web前端、Web后端、Jenkins服务、Maven私有仓库等多个部分组成。其中前端用于进行组件、项目的管理和构建以及日志查看；后端实现了请求响应、数据存储、WebSocket即时推送通知等功能；Jenkins服务提供了统一的开发环境，根据配置和脚本执行构建任务，并推送构建结果到后端和个人邮箱；Maven私有仓库用于存放依赖包。</p>
<p>本文前半部分介绍了持续集成的相关理论以及项目中所用到的技术，后半部分详细说明了持续集成方案的实施步骤和开发过程，并通过具体项目案例，验证了系统的可行性和意义。</p>
<p><strong>关键词</strong>：持续集成；敏捷开发；Jenkins；Android组件化</p>
<p><strong>DESIGN AND IMPLEMENTATION OF CONTINUOUS INTEGRATION SYSTEM FOR ANDROID PROJECT</strong></p>
<p><strong>Abstract:</strong> This paper desgin a Continuous Integration scheme based on Jenkins which is combined with Android Component-based Architecture. Through a series of links such as build, integrate and package automatically, it can standardize the process of software development, shorten the cycle of iteration, find the problem of project in time, reduce the risk of release and ensure the quality of software. What’s more, it can respond to the change of demand quickly and provide runnable software versions at any time which has improved the visibility of software in the development. </p>
<p>This system is mainly composed of Web front-end, Web back-end, Jenkins service and Maven repository. The front-end is used to manage and build components or project as well as checking log. The back-end can respond the request from front-end, save data and realize the instant push by WebSocket. Jenkins service provides a unified environment of development and execute the task according to the configuration and scripts. In addition, it can push the result of buildings to the back-end and the mailboxes. The Maven repository is used to store the dependency files. </p>
<p>The first part of this paper introduces the related theory of Continuous Integration and some technology used in the project. The second part describes the implementation steps and development process of my Continuous Integration scheme in detail. Moreover, it verifies the significance and feasibility of the system through a specific case. </p>
<p><strong>Keywords:</strong> Continuous Integration；Agile Development；Jenkins；Android Component-Based Architecture</p>
<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="1-1-课题背景"><a href="#1-1-课题背景" class="headerlink" title="1.1 课题背景"></a>1.1 课题背景</h2><p>随着互联网的飞速发展、软件架构日益复杂，传统的瀑布式开发、集中式软件测试已不能适应需求频繁变更、快速迭代的要求。如何应对频繁的需求变更，并且在缩短软件开发周期的同时保证产品质量[1]、减少发布风险，成了人们研究的问题。敏捷软件开发模式应运而生。</p>
<p>敏捷开发的概念源于Kent Beck在90年代初期提出的软件开发思想——极限编程（简称XP[2]），持续集成（简称CI）便是XP中提出的实践。</p>
<p>2000年，Martin Fowler定义了持续集成：持续集成是一种软件开发实践，项目成员需要频繁对他们的工作进行集成，每天至少集成一次，并且进行自动化测试，这样就能够及时地发现项目缺陷[3]。</p>
<p>国外团队对持续集成的探索和实践起步较早。相继出现了CruiseControl、Hudson、LuntBuild、QuickBuild和Bamboo，以及近几年发展起来的Jenkins等持续集成工具[4]。</p>
<p>近几年国内许多团队也开始引入到实际项目开发中，实现了快速迭代，提高了开发效率。如何选择持续集成方案需要根据团队、业务和项目情况等因素综合考虑。</p>
<h2 id="1-2-研究目标和内容"><a href="#1-2-研究目标和内容" class="headerlink" title="1.2 研究目标和内容"></a>1.2 研究目标和内容</h2><p>本课题在研究持续集成理论的基础上，利用Git（版本控制工具）、Gradle（构建工具）、Maven（构件仓库）、Jenkins（持续集成工具）等多种工具和技术，针对Android组件化项目的架构和存在的问题，实现了一套的持续集成系统。由Web前端、Web后端、Jenkins服务、代码仓库和构件仓库等各部分组成，实现了一条Android项目构建、集成到部署的流水线，用于规范开发流程、减少重复工作、及时发现问题、缩短迭代周期，方便对组件和项目进行管理，提高效率，快速迭代，真正达到敏捷开发。</p>
<p>本系统预期实现的目标如下：</p>
<p>（1）减少重复劳动，降低手动维护成本和出错概率，提高效率。</p>
<p>（2）避免构建环境不一致出现的问题，减少环境部署时间。</p>
<p>（3）通过版本控制系统统一管理代码。</p>
<p>（4）通过邮件和前端通知及时反馈问题，并可以通过链接查看和定位问题。</p>
<p>（5）实现代码质量检查、测试、构建、发布自动化，无需开发者手动执行脚本。</p>
<p>（6）Jenkins后台执行构建，避免开发者本地编译忙等，耗时费力，且无法保存构建记录，不便于事后追溯。</p>
<p>（7）能够随时提供可运行的软件供测试团队进行测试。</p>
<p>（8）项目进度可见可控，降低了沟通成本。</p>
<p>（9）避免软件最终集成时一次性暴露大量错误，难以定位等问题。</p>
<p>（10）前端统一对组件、项目进行管理，能够及时收到更新通知，能够查看组件和项目信息、构建历史、责任人等，易于追溯问题，并且可以在这一环节加入权限控制。</p>
<p>（11）后端实现响应请求、对数据进行存储、验证，与Jenkins服务交互，并实现主动推送等功能。</p>
<h2 id="1-3-论文结构安排"><a href="#1-3-论文结构安排" class="headerlink" title="1.3 论文结构安排"></a>1.3 论文结构安排</h2><p>第一章：介绍课题背景、研究目标和内容以及论文的结构。</p>
<p>第二章：对比传统的瀑布式开发模型，针对其问题和不足引出持续集成理论。研究和分析本课题相关技术，包括Android组件化架构和技术，Docker虚拟化技术等。</p>
<p>第三章：通过对比两种开发模式和流程分析了系统的需求和实现的意义。</p>
<p>第四章：设计持续集成系统功能和架构以及关键流程，能够进行Android组件和项目的可视化管理，执行Android组件和项目的构建、打包、部署等任务，将构建结果反馈到前端，并且通过邮件通知用户。</p>
<p>第五章：详细讲述了系统的实施步骤和流程，包括组件化方案设计和实现，Maven私服和Jenkins服务搭建，以及前后端的关键实现等。</p>
<p>第六章：搭建Android组件化架构，通过具体的项目案例演示了开发流程和系统的使用流程。</p>
<p>第七章：总结课题内容，提出系统下一步的优化方案。</p>
<p>致谢和参考文献。</p>
<h1 id="2-相关理论与技术"><a href="#2-相关理论与技术" class="headerlink" title="2 相关理论与技术"></a>2 相关理论与技术</h1><h2 id="2-1-瀑布式开发和敏捷开发"><a href="#2-1-瀑布式开发和敏捷开发" class="headerlink" title="2.1 瀑布式开发和敏捷开发"></a>2.1 瀑布式开发和敏捷开发</h2><p>传统软件开发流程采用“瀑布式”开发模型[5]，这种模式源于工业生产，它的开发过程包括市场调研、需求分析、产品设计、程序开发、软件测试、成品发布、后期维护等阶段，每个阶段都需要制定明确的目标，并且提供详尽的文档，按照计划一步步执行，步骤清晰明确，可预见性强，能够避免资源的无效投入，保证开发质量。但在这种开发模式下，只有项目初期的想法和建议允许加入开发计划中，在开发过程中不允许加入新的需求。而事实上，随着开发过程逐渐深入、技术架构的日新月异和市场的快速变化，好的想法和建议也会不断涌现[6]。因此，这种开发模式在需要快速产出、占领市场先机和需求不明的情况下基本是不可行的。同时在此期间，项目程序将长期不能运行[7]，需要等到所有分支开发结束后才能进行测试和集成的工作，并且一旦分支偏离主干太远，会造成项目集成困难、问题频发且不容易定位，导致项目发布前混乱紧张的局面甚至延期发布。</p>
<p>敏捷开发提倡拥抱变化，进行软件迭代开发，将大项目分为一个个子项目，每个子项目都可以独立的运行、测试、集成等，因此软件能够随时地集成使用和交付。敏捷开发借鉴了XP的思想，提出了12条原则[8]，并建立了以下价值观：</p>
<p>（1）个体和互动高于流程和工具</p>
<p>（2）可运行的软件高于详尽的文档</p>
<p>（3）客户合作高于合同谈判</p>
<p>（4）响应变化高于遵循计划</p>
<p>相比传统的瀑布开发，敏捷开发模式具有更强地适应性和灵活性，它强调“以人为本、目标导向、客户为先、拥抱变化”，要求快速迭代和及早测试，它的出现影响了团队开发的工作方式，也改变了软件发布的方式。</p>
<h2 id="2-2-持续集成"><a href="#2-2-持续集成" class="headerlink" title="2.2 持续集成"></a>2.2 持续集成</h2><p>为了验证开发者提交的最新代码能否编译成功，能否通过自动化测试用例，以及是否会影响项目集成等。可以通过频繁地进行集成，可以快速得到反馈，容易知道是哪次提交导致集成失败，易于开发者定位问题。我们将这种方法称为持续集成，也叫作每日构建[9]。</p>
<p>CI是敏捷开发最为成功的实践之一[10]，它最大的好处在于降低风险，它无法消除问题，但是可以帮助你快速发现问题，及时反馈。通过自动化构建、代码检查、测试和发布流水线[11]，能够减少开发人员手动编译、打包的时间，有效提高软件开发效率、及时发现项目缺陷，降低发布风险，保障软件开发质量，同时对团队所有成员来说整个开发过程可见，能够辅助项目负责人把控项目整体进度，帮助开发者定位问题，还能增强大家对产品的信心。</p>
<p>持续集成有以下几点原则：</p>
<p>（1）要求开发者控制好代码提交粒度，及时push，不然就失去了持续构建的意义。</p>
<p>（2）使用专门的机器进行每日构建。</p>
<p>（3）优先修复失败构建。</p>
<p>（4）保证每次构建都通过，能够生成可运行和发布的软件。</p>
<p>持续集成具体流程如图2-1所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="持续集成开发流程图"> </p>
<center> 图2-1 持续集成开发流程图[12]</center>

<h2 id="2-3-Android组件化架构和技术"><a href="#2-3-Android组件化架构和技术" class="headerlink" title="2.3 Android组件化架构和技术"></a>2.3 Android组件化架构和技术</h2><p>随着APP业务逐渐复杂，功能不断增加，项目工程会越来越庞大。为了减少代码间的耦合，通过Gradle的Module功能，将项目分成一个个子模块。每个模块能够单独进行开发、编译、打包、调试，可以拆卸和移植，通过依赖的方式进行管理，并且组件间可以相互通信。组件化架构能够很好地实现业务和代码的解耦，还便于控制代码权限。</p>
<p>Android组件化架构[13]利用了Gradle的这一特性，建议将模块分类进行管理，由上往下进行依赖，分为：</p>
<p>（1）壳组件：用于将整个项目进行打包，生成可安装的apk文件，即安卓安装包。</p>
<p>（2）业务组件：根据业务的不同进行划分，实现了完整的业务功能。</p>
<p>（3）功能组件：封装了一些常用功能，供业务组件使用。如网络、数据库、图片加载、日志、UI等框架。</p>
<p>（4）基础组件：封装了通用的工具类、基础类和资源等，供其他业务组件使用。</p>
<p>（5）三方库：一些开源的三方框架，由框架作者进行维护，存放在远程仓库中。</p>
<p>安卓组件化架构如图2-2。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Android组件化架构图"> </p>
<center>图2-2 Android组件化架构图</center>

<p>目前流行的组件化方案主要有两种，如下：</p>
<p>（1）Sub-Module方案：整个项目只有一个工程，所有模块共用一个仓库，或者每个module创建自己的仓库，通过Git的子仓库功能进行管理。缺点是仓库分支复杂，代码耦合度较高，团队协作的时候容易发生冲突，而且每次调试都需要对所有的模块进行编译，耗时费力。</p>
<p>Sub-Module架构如图2-3所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Sub-Module%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A8%A1%E5%BC%8F.png" alt="Sub-Module组件化模式"> </p>
<center>图2-3 Sub-Module组件化模式</center>

<p>（2）Multi-Project模式：根据业务拆分工程，每个工程都包含壳模块和业务模块，将业务模块编译打包成aar上传至构件仓库，通过修改壳工程的依赖配置集成项目，通过git仓库的权限管理，可以保证代码不被他人修改查看，并且项目编译的时候不需要编译其他组件。</p>
<p>Multi-Project架构如图2-4所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Multi-Project%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A8%A1%E5%BC%8F.png" alt="Multi-Project组件化模式"> </p>
<center>图2-4 Multi-Project组件化模式</center>

<p>两种模式需要根据项目情况选择，主要取决于业务特性、团队规模、组件化细分粒度等条件。对于小型且不需要频繁迭代的团队选择Submodule模式较合适。对于大型团队且迭代频繁的团队选择Multi-Project方案较合适。本毕业设计决定选择第二种方案实现组件化方架构，并针对Multi-Project模式设计软件开发流程、前端交互和数据库结构等。</p>
<h2 id="2-4-Docker虚拟化技术"><a href="#2-4-Docker虚拟化技术" class="headerlink" title="2.4 Docker虚拟化技术"></a>2.4 Docker虚拟化技术</h2><p>Docker有几个概念[14]：</p>
<p>（1）Image（镜像）：用于创建Docker容器的模板。</p>
<p>（2）Container（容器）：是独立运行的一个或一组应用。</p>
<p>（3）Registry（仓库）：用于保存镜像，类似代码仓库，Docker Hub是官方的镜像仓库，提供了大量的镜像。</p>
<p>Docker的基本架构如下图2-5：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="Docker架构图"> </p>
<center>图2-5 Docker架构图</center>

<p>开发者能够将他们的应用或服务打包成一个镜像，发布到镜像仓库上，用户可以从远程仓库中下载镜像，并且以镜像为模板创建具体的容器来运行软件。Docker使用操作系统虚拟化技术，为应用提供隔离的运行环境，不同容器之间没有任何关联。容器拥有独立的权限管理和资源管理，以及独立的网络环境，相当于一个独立的虚拟机，也就是说所有的程序开发环境都需要在容器内再安装一遍，并且需要配置环境变量。通过容器可移植的特性，可以实现一次构建、处处运行，而不需要针对不同系统重新进行构建和部署。</p>
<p>与虚拟机相比，它具有更轻量，启动更加快速等特点，并且同一台主机上可以运行多个Docker容器。Docker容器的原理是利用了Linux的命名空间、控制组等特性对容器进行隔离，降低了每个容器的系统开销。</p>
<p>另外容器删除后，容器内的数据会清空，因此需要使用类似Linux的挂载技术，将主机路径挂载到容器中，容器数据存放在主机目录下，重新创建容器时只需要指定数据挂载目录，即可实现持久化数据。</p>
<h1 id="3-系统需求分析"><a href="#3-系统需求分析" class="headerlink" title="3 系统需求分析"></a>3 系统需求分析</h1><p>本章将针对项目在接入持续集成平台前后的开发模式进行详细对比，来分析开发这套系统的必要性。</p>
<p>以Multi-Project组件化方案为例，在接入持续集成平台之前，整体的开发流程如图3-1所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%97%A9%E6%9C%9F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="早期项目开发流程图"> </p>
<center>图3-1 早期项目开发流程图</center>

<p>在上述流程中，存在以下几个缺陷：</p>
<p>（1）开发者需要手动在代码中定义构件名称并修改组件版本号，随源代码一起提交。可能会存在构件名称或版本命名不统一（包括版本前后命名不统一、不同成员间的不统一），测试版和正式版需要分别构建等，造成构件仓库混乱的问题。且Maven仓库限制除了snapshot的构件以外，其他构件不能拥有两个一样的版本号，因此可能会存在发布失败的情况。</p>
<p>（2）开发人员手动构建时间长，浪费了大部分开发时间，且开发者们的构建环境不一致，容易出现问题。</p>
<p>（3）管理员需要和多个开发者沟通、频繁进行重复性操作更新依赖配置，效率低下且容易出错。管理员每天都需要等待项目打包成功，将apk交付测试。</p>
<p>（4）集成操作复杂，需要各个组件负责人配合，可以合并为一个步骤。</p>
<p>在接入持续集成平台之后，整体的开发流程如图3-2所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%8E%A5%E5%85%A5%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="接入系统后项目开发流程图"> </p>
<center>图3-2 接入系统之后项目开发流程图</center>

<p>相比之前的方式，有了以下几点改进：</p>
<p>（1）平台可以对组件进行管理，组件创建需要指定代码仓库、分支等，由服务端记录和保存，并可以进行校验，如不允许添加重复组件等。且组件版本号按照一定规则递增，开发者不需要关心，只需要在平台上确认构建。避免了构件仓库混乱的现象。</p>
<p>（2）构建和集成的任务都在Jenkins服务中执行，减少了开发者编译和构建代码的时间，并且确保了构建环境统一。</p>
<p>（3）减少了管理员和开发者或者测试团队的沟通成本。所有组件和项目信息和构建历史记录都保存下来，所有人都能够随时查看，方便地定位错误，追溯问题。</p>
<p>（4）平台操作简便，学习成本低，可以供产品经理或者测试人员共同使用。</p>
<p>（5）平台可以实现自动化构建、质量检查、测试、集成、打包等功能，减少重复性操作，节约时间。</p>
<h1 id="4-系统概要设计"><a href="#4-系统概要设计" class="headerlink" title="4 系统概要设计"></a>4 系统概要设计</h1><p>如何合理的管理组件和项目，建立项目组件关联，方便用户使用是本系统要研究的最大的问题。并且需要结合团队和项目情况选择合适的方案，如构建时机选择手动触发、还是git自动触发或者定时触发。只有优化了管理和开发流程，本系统的意义才能真正体现出来。</p>
<h2 id="4-1-系统功能"><a href="#4-1-系统功能" class="headerlink" title="4.1 系统功能"></a>4.1 系统功能</h2><p>本系统主要分为五个部分：</p>
<p>（1）Android组件化项目：用于系统功能测试和演示。</p>
<p>（2）Maven私服：用于存放依赖包，通过Gradle插件可以进行软件包的上传和依赖库管理。</p>
<p>（3）前端网页：用于提供可视化的操作页面，供项目管理者、开发者、测试人员等使用。可以进行组件和项目的管理、构建，并且可以查看构建日志、应用下载地址等。并且实现表单检查、数据排序、筛选、查找等功能。简单易用，提高了项目开发过程的可见性。</p>
<p>（4）Web后端：用于响应前端请求，进行数据连接和CRUD操作，调用Jenkins API，接收Jenkins消息等，通过WebSocket实现主动推送。并且需要实现异常拦截、错误处理、日志记录等功能。</p>
<p>（5）Jenkins服务端：提供统一的构建环境，如git、python、gradle、java等，可以创建或执行后台自动化构建、发布等Job，并且实现版本控制和邮件通知功能。</p>
<p>由于Docker容器的隔离性，各容器之间系统、网络、端口等都是独立的，导致难以通信，包括宿主机访问容器，容器访问宿主机，容器访问公网，容器之间互相访问等存在问题。因此本系统实现的一个关键点在于系统间各个部分如何通信、连接，相互协作完成整个工作流程，以及如何进行事务控制，保证数据的正确性等。本系统最终采用以下方案：</p>
<p>（1）前后端使用http协议通信，前端发起http请求，后端进行业务处理，然后对请求进行响应，关闭连接。</p>
<p>（2）由于某些请求如后台构建，无法立即响应结果，因此需要实现后端主动向前端推送通知的功能。可以通过轮询、长连接、WebSocket实现，本系统采用WebSocket。</p>
<p>（3）后端与Jenkins之间可以通过http或者RPC协议进行通信，这里选择http，Jenkins服务提供了RESTFul API供后端调用。Jenkins在执行完任务之后可以通过python或者shell脚本发起http请求。</p>
<p>（4）Jenkins服务通过gradle插件上传应用包到Maven仓库。</p>
<p>（5）Jenkins服务使用Git工具对Android项目进行版本控制。</p>
<h2 id="4-2-架构设计"><a href="#4-2-架构设计" class="headerlink" title="4.2 架构设计"></a>4.2 架构设计</h2><p>系统架构设计如图4-1所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/CI%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="CI系统架构图"> </p>
<center>图4-1 CI系统架构图</center>

<h2 id="4-3-团队协作开发流程"><a href="#4-3-团队协作开发流程" class="headerlink" title="4.3 团队协作开发流程"></a>4.3 团队协作开发流程</h2><p>接入持续集成系统后大大地能够优化团队android组件化项目的开发流程，减化了开发者和管理员的部分重复性操作，降低了沟通成本，所有的构建都在远程执行，保证了构建环境的一致，并且开发人员不需要忙等。预期工作流程如图4-2所示，流程如下：</p>
<p>（1）开启新项目时由管理员在平台上创建并配置好项目信息。开发人员创建或更新各自的组件信息。</p>
<p>（2）开发人员拉取最新代码，进行开发或修复问题，提交代码到远程仓库，之后在平台上点击构建组件。</p>
<p>（3）管理员更新项目依赖的组件版本，通过邮件或者红点提示知道是否有新版本。</p>
<p>（4）管理人员在平台上手动点击构建项目，也可以设置定时自动构建，或者git触发构建。项目构建完成后自动上传apk到蒲公英应用托管仓库，并且返回下载地址。</p>
<p>（5）测试团队可以在平台上点击下载地址，进入下载页面，获取最新的应用包进行测试，并反馈测试结果给开发者。</p>
<p>（6）循环3-5步，直到项目开发完成，测试通过，管理员可以集成并发布项目。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A2%84%E6%9C%9F%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.jpg" alt="预期团队开发流程"> </p>
<center>图4-2 预期团队开发流程</center>

<h2 id="4-4-系统内部运行关键流程"><a href="#4-4-系统内部运行关键流程" class="headerlink" title="4.4 系统内部运行关键流程"></a>4.4 系统内部运行关键流程</h2><h3 id="4-4-1-创建组件流程"><a href="#4-4-1-创建组件流程" class="headerlink" title="4.4.1 创建组件流程"></a>4.4.1 创建组件流程</h3><p>创建组件需要填写组件基本信息，限制不允许出现同名组件，同时Jenkins服务端根据配置模板创建相应的Job，创建成功之后数据库会插入组件信息，创建失败则不插入，最后前端根据返回的结果弹出相应提示。具体流程如图4-3所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" alt="组件创建流程"> </p>
<center>图4-3 组件创建流程</center>

<h3 id="4-4-2-组件构建流程"><a href="#4-4-2-组件构建流程" class="headerlink" title="4.4.2 组件构建流程"></a>4.4.2 组件构建流程</h3><p>构建组件会在后台执行，前端请求成功之后更新组件状态为正在构建，同时Jenkins服务端开始执行Job，从远程仓库拉取代码，修改版本号，接着对组件源码进行编译和打包，上传aar包到Maven私服，然后提交代码。最后通知后端任务执行结果，后端保存构建记录并将结果发送到前端，前端更新组件信息和构建历史。同时任务执行结果还会以邮件形式通知到用户。具体流程如图4-4所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" alt="组件构建流程"> </p>
<center>图4-4 组件构建流程</center>

<h3 id="4-4-3-项目集成流程"><a href="#4-4-3-项目集成流程" class="headerlink" title="4.4.3 项目集成流程"></a>4.4.3 项目集成流程</h3><p>项目集成同样在后台执行，Jenkins Job会更新项目依赖，获取最新依赖包，进行项目编译和打包，将打出来的应用上传到应用托管仓库，并且提交代码。最后通知后端任务执行结果，后端保存记录并将结果发送到前端，前端更新项目信息和构建历史，并且能够链接到应用下载地址。同时任务执行结果会以邮件形式通知到用户。具体流程如图4-5所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E6%B5%81%E7%A8%8B.jpg" alt="项目集成流程"> </p>
<center>图4-5 项目集成流程</center>

<h1 id="5-系统实现"><a href="#5-系统实现" class="headerlink" title="5 系统实现"></a>5 系统实现</h1><p>整个系统实现步骤和流程如图5-1，首先研究相应的技术，各部分先单独实现和测试，再进行各个部分的联调测试。最终通过案例进行整体的流程测试，优化功能和代码结构。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%E5%92%8C%E6%B5%81%E7%A8%8B.jpg" alt="系统实现步骤和流程"> </p>
<center>图5-1 系统实现步骤和流程</center>

<h2 id="5-1-组件化方案实现"><a href="#5-1-组件化方案实现" class="headerlink" title="5.1 组件化方案实现"></a>5.1 组件化方案实现</h2><p>从GitHub下载了一个开源的Android项目作为演示项目，功能较简单，实现了主页、每日新闻，每日图片等功能[15]。案例效果图如5-2</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C.jpg" alt="组件化案例效果"> </p>
<center>图5-2 组件化案例效果</center>

<p>使用Multi-Project组件化方案对其进行改造，所有组件都包含壳模块，最终拆分为6个工程，分别为：</p>
<p>（1）壳模块：只包含Android工程中主模块的代码，用于管理依赖包、存放项目构建和打包等配置以及其他一些资源，如apk签名文件，多国语言包等。</p>
<p>（2）壳组件：不包含业务模块，只作为壳工程，用于打包apk。</p>
<p>（3）公共组件：属于基础组件，包含基础类、公共类等代码和公共资源，作为底层库供所有业务组件使用。</p>
<p>（4）主页组件：实现了应用的Home业务，由Home页面可以跳转到新闻页面和图片欣赏页面。</p>
<p>（5）新闻组件：实现了查看每日新闻业务。</p>
<p>（6）美女图片组件：实现了图片欣赏业务。</p>
<h3 id="5-1-1-代码版本控制工具"><a href="#5-1-1-代码版本控制工具" class="headerlink" title="5.1.1 代码版本控制工具"></a>5.1.1 代码版本控制工具</h3><p>本系统使用GitHub作为代码仓库，共建立了6个代码仓库，分别存放上述6个工程。其中壳模块使用Git工具的submodule功能，作为所有组件的子模块，存在于其他5个工程之中。子模块本质也是一个代码仓库，只不过通过submodule将其与其他工程关联起来。</p>
<p>本方案中壳模块只用于存放依赖配置和部分资源，由管理员或持续集成平台对其进行更新和提交代码，其他组件只能通过壳模块获取最新的配置，并用其进行打包，在其他组件中不建议直接修改壳模块文件，或者向壳模块提交代码，即使修改了也应该只用于本地临时使用，正式使用仍然需要拉取远程仓库的代码覆盖本地配置，可以对该仓库进行代码提交的权限控制。</p>
<p>Git的sumodule相关配置在.gitmodules文件中，如图5-3所示，声明了子模块的名称，仓库地址，分支等。在工程目录下可以通过git submodule update –remote命令拉取子模块的最新代码，或者进入子模块目录下使用git pull命令拉取代码。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Git%E5%AD%90%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="Git子模块配置文件"> </p>
<center>图5-3 Git子模块配置文件</center>

<h3 id="5-1-2-Gradle构建工具"><a href="#5-1-2-Gradle构建工具" class="headerlink" title="5.1.2 Gradle构建工具"></a>5.1.2 Gradle构建工具</h3><p>Gradle是一个类似Ant和Maven的开源项目构建工具，使用Groovy语言的DSL（领域特定语言）来配置项目。提供依赖管理、多工程管理和局部构建功能，并且对脚本和插件支持良好。</p>
<p>可以通过IDE或者使用Gradle命令行执行构建、打包等Task。此外，Android项目还支持使用Gradle包装命令的方式来构建、打包Android的组件和项目：</p>
<p>（1）构建组件：使用maven插件配置构件名称、版本等信息。如图5-4所示。然后在工程目录下执行gradlew :组件名:upload，即可自动构建组件，并上传aar包到依赖仓库。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E9%85%8D%E7%BD%AE.jpg" alt="组件打包上传配置"> </p>
<center>图5-4 组件打包上传配置</center>

<p>（2）打包项目：进行Android项目的相关配置，然后在工程目录下执行gradlew assembleDebug来打包Debug版apk，通过assembleRelease来打包正式版的apk。</p>
<h2 id="5-2-Docker搭建Maven私服"><a href="#5-2-Docker搭建Maven私服" class="headerlink" title="5.2 Docker搭建Maven私服"></a>5.2 Docker搭建Maven私服</h2><h3 id="5-2-1-Docker安装"><a href="#5-2-1-Docker安装" class="headerlink" title="5.2.1 Docker安装"></a>5.2.1 Docker安装</h3><p>本系统通过Docker部署Maven私有仓库，需要安装Docker，步骤如下：</p>
<p>首先需要开启Win10虚拟化技术：打开Windows程序和功能-&gt;启用或关闭Windows功能-&gt;选中Hyper-V。如图5-5所示。然后从官网下载Docker for windows并按照提示安装即可。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Win10%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.png" alt="Win10开启虚拟化技术"> </p>
<center>图5-5 Win10开启虚拟化技术</center>

<p>由于国内下载Docker镜像速度较慢，因此需要配置镜像加速器，这里使用官方中国区镜像地址，配置方式如图5-6所示：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F.jpg" alt="Docker配置国内镜像"> </p>
<center>图5-6 Docker国内镜像源地址</center>

<h3 id="5-2-2-Nexus服务搭建"><a href="#5-2-2-Nexus服务搭建" class="headerlink" title="5.2.2 Nexus服务搭建"></a>5.2.2 Nexus服务搭建</h3><p>首先通过【docker search nexus】命令查找Nexus镜像，如图5-7可以看到有很多镜像可以选择，这里选择第一个镜像：sonatype/nexus3。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E6%90%9C%E7%B4%A2Nexus%E9%95%9C%E5%83%8F.jpg" alt="Docker搜索Nexus镜像"> </p>
<center>图5-7 Docker搜索Nexus镜像</center>

<p>然后使用【docker run -d -p 8081:8081 –name nexus3 -v /d/Docker/Volume/Nexus3:/nexus-data sonatype/nexus3】命令运行nexus3容器。其中【docker run [OPTIONS] <IMAGE>】命令用来创建并运行容器，如果本地没有镜像，则会从Docker Hub获取。</IMAGE></p>
<p>运行成功后，可以访问8081端口，出现图5-8页面则表示Nexus服务成功运行。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Nexus%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="Nexus服务运行结果"> </p>
<center>图5-8 Nexus服务运行结果</center>

<p>可以使用docker ps命令查看正在运行的容器，如图5-9所示</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8.jpg" alt="Docker查看正在运行的容器"> </p>
<center>图5-9 Docker查看正在运行的容器</center>

<h2 id="5-3-持续集成服务器搭建"><a href="#5-3-持续集成服务器搭建" class="headerlink" title="5.3 持续集成服务器搭建"></a>5.3 持续集成服务器搭建</h2><h3 id="5-3-1-Jenkins持续集成工具"><a href="#5-3-1-Jenkins持续集成工具" class="headerlink" title="5.3.1 Jenkins持续集成工具"></a>5.3.1 Jenkins持续集成工具</h3><p>Jenkins是一款开源的持续集成工具[16]，具有丰富的插件系统，支持任何类型的构建或集成，并且提供自动化构建、分布式构建、邮件通知等功能。其本质上是一个服务，用户可以通过可视化的Web操作页面配置和执行任务，并且提供了RESTful Api的访问形式，开发者可以通过调用相应的Api来动态的配置任务、执行任务、获取任务信息和构建信息等。</p>
<h3 id="5-3-2-Jenkins安装与配置"><a href="#5-3-2-Jenkins安装与配置" class="headerlink" title="5.3.2 Jenkins安装与配置"></a>5.3.2 Jenkins安装与配置</h3><p>本系统使用Docker来安装和运行Jenkins。</p>
<p>（1）首先执行docker search jenkins命令查找Jenkins镜像，如图5-10，这里选择第二个镜像：jenkins/jenkins。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Docker%E6%90%9C%E7%B4%A2Jenkins%E9%95%9C%E5%83%8F.jpg" alt="Docker搜索Jenkins镜像"> </p>
<center>图5-10 Docker搜索Jenkins镜像</center>

<p>（2）运行docker pull jenkins/jenkins拉取镜像到本地。</p>
<p>（3）输入【docker run -p 8082:8080 -d –name myjenkins -v /e/ASproject:/var/as_project -v /d/android-sdk-windows:/var/android_sdk -v /d/Docker/Volume/Jenkins:/var/jenkins_home jenkins/jenkins:lts】命令运行Jenkins容器。</p>
<p>（4）浏览器访问8082端口，出现页面则表示Jenkins服务启动成功[17]，如图5-11。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="Jenkins服务运行结果"> </p>
<center>图5-11 Jenkins服务运行结果</center>

<p>（5）首次启动需要初始化密码，上图所示路径为Jenkins容器中的路径，无法直接通过宿主机访问，需要进入该容器内部访问，使用docker exec命令访问容器，然后进入/var/jenkins_home/secrets/文件夹下查看初始密码。如图5-12所示。输入密码进入下一步。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6.jpg" alt="Jenkins进入容器内部查看文件"> </p>
<center>图5-12 Jenkins进入容器内部查看文件</center>

<p>（6）根据提示安装插件，创建Jenkins用户，完成之后进入Jenkins主页，如图5-13所示</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%B8%BB%E9%A1%B5.jpg" alt="Jenkins主页"> </p>
<center>图5-13 Jenkins主页</center>

<p>（7）Jenkins的说明文档采用REST API样式，URL格式如Jenkins资源/api。常用的资源有主机名、Job和Build等。如：localhost:8082/api</p>
<h3 id="5-3-3-Jenkins容器内部环境搭建"><a href="#5-3-3-Jenkins容器内部环境搭建" class="headerlink" title="5.3.3 Jenkins容器内部环境搭建"></a>5.3.3 Jenkins容器内部环境搭建</h3><p>由于容器与宿主机是完全隔离的，因此容器内无法使用宿主机环境，需要在容器内部重新设置环境变量。在Docker容器中配置环境变量有以下方式：</p>
<p>（1）由于Docker基于Linux操作系统，因此可以通过【docker exec -it myjenkins /bin/bash】命令开启交互模式终端，进入容器内部，接着使用Linux的方式，如apt或者wget等工具安装软件即可。</p>
<p>（2）使用挂载的方式，将宿主机已经安装好的软件目录挂载到容器中的某个目录下，接着进入容器内部设置环境变量即可。</p>
<p>接下来介绍下本系统中Jenkins如何搭建需要的环境：</p>
<p>（1）Java环境：本版本的镜像自带了Java环境，因此不需要再次安装，可以进入容器内部，执行【java -version】命令查看java版本。如下图5-14所示</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%AA%8C%E8%AF%81Java%E7%8E%AF%E5%A2%83.jpg" alt="Jenkins验证Java环境"> </p>
<center>图5-14 Jenkins验证java环境</center>

<p>（2）Android环境：上面启动容器的时候已经将宿主机的Android SDK目录挂载到了Jenkins容器中，因此直接配置环境变量即可。在主页-&gt;系统管理-&gt;系统设置-&gt;找到环境变量，如下图5-15配置。注意这里的路径为挂载后容器内的路径。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%85%8D%E7%BD%AEAndroid%E7%8E%AF%E5%A2%83.jpg" alt="Jenkins配置Android环境"> </p>
<center>图5-15 Jenkins配置Android环境</center>

<p>（3）Gradle：同样地，将宿主机Gradle安装文件夹挂载到容器内部，在主页-&gt;系统管理-&gt;全局工具配置-&gt;找到Gradle，如下图5-16配置。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%85%8D%E7%BD%AEGradle.jpg" alt="Jenkins配置Gradle"> </p>
<center>图5-16 Jenkins配置Gradle</center>

<p>（4）Python环境：这个版本的Jenkins镜像自带了Python2的环境，可以进入容器内部，使用【python –v】命令查看Python版本。但是缺少Pip工具，同样地进入容器内，如图5-17完成安装。出现Pip版本号则表示安装成功。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E5%AE%89%E8%A3%85pip.jpg" alt="Jenkins安装pip"> </p>
<center>图5-17 Jenkins安装pip</center>

<p>（5）Git环境和SSH登录配置：这个版本的Jenkins镜像自带了Git环境，可以进入容器内部，使用git -v命令打印版本信息。GitHub支持以SSH协议访问Git仓库，避免每次输入用户名和密码。</p>
<p>首先进入容器内部，通过【ssh-keygen -t rsa -C 邮箱】生成密钥对，然后进入~/.ssh目录下，查看公钥信息，如图5-18所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%85%8D%E7%BD%AESSH%E7%99%BB%E9%99%86.jpg" alt="Jenkins配置SSH登录"> </p>
<center>图5-18 Jenkins配置SSH登录</center>

<p>将公钥拷贝到GitHub设置页面的如下图5-19的位置，然后点击添加。</p>
<p>![GitHub配置SSH keys](./2021-09-04-CI回首毕业论文/GitHub配置SSH Key.jpg) </p>
<center>图5-19 GitHub配置SSH keys</center>

<p>最后可以使用<code>ssh -T git@github.com</code>命令验证是否配置成功。</p>
<h3 id="5-3-4-Jenkins任务配置"><a href="#5-3-4-Jenkins任务配置" class="headerlink" title="5.3.4 Jenkins任务配置"></a>5.3.4 Jenkins任务配置</h3><p>在Jenkins主页点击新建任务-&gt;输入名称-&gt;选择任务类型-&gt;……，这几步较简单，创建完成后任务界面如图5-20所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E9%A1%B5%E9%9D%A2.jpg" alt="Jenkins任务页面"> </p>
<center>图5-20 Jenkins任务页面</center>

<p>从左侧Configure项进入任务配置页面，这里只介绍几项关键配置：</p>
<p>（1）参数和工作区配置：点开General-&gt;Advanced，定义构建任务需要传入的参数，参数可以有多种类型，如下图5-21所示，输入工作区路径，注意这里的路径是Jenkins容器内部路径。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2.jpg" alt="Jenkins任务配置页面"> </p>
<center>图5-21 Jenkins任务配置页面</center>

<p>（2）脚本配置：即任务执行的具体内容，可以执行多种类型的脚本，或者根据需要安装不同的插件来执行命令。如图5-22所示，</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE.jpg" alt="Jenkins任务脚本配置"> </p>
<center>图5-22 Jenkins任务脚本配置</center>

<p>（3）Jenkins的任务配置是以xml文件形式保存的，可以通过Jenkins的API接口查看指定任务的配置，如图5-23所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/JenkinsAPI%E5%BD%A2%E5%BC%8F%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE.jpg" alt="JenkinsAPI形式查看配置"> </p>
<center>图5-23 Jenkins API形式查看配置</center>

<p>（4）在任务界面点击Build With Parameters执行参数化构建-&gt;输入参数值-&gt;点击Build开始构建任务-&gt;点击任务界面左侧构建历史可以查看构建结果。如下图5-24</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E6%9E%84%E5%BB%BA%E7%BB%93%E6%9E%9C%E6%97%A5%E5%BF%97.jpg" alt="Jenkins构建结果日志"> </p>
<center>图5-24 Jenkins构建结果日志</center>

<h3 id="5-3-5-脚本实现"><a href="#5-3-5-脚本实现" class="headerlink" title="5.3.5 脚本实现"></a>5.3.5 脚本实现</h3><p>Jenkins自动化构建实质上就是定时执行各种任务脚本，如shell脚本、python脚本、gradle等，或者根据需要安装其他插件，本系统主要使用python语言，其中封装了shell命令、gradle命令，git命令等，由python统一运行。</p>
<h3 id="5-3-6-邮件通知"><a href="#5-3-6-邮件通知" class="headerlink" title="5.3.6 邮件通知"></a>5.3.6 邮件通知</h3><p>由于Jenkins是在后台执行，用户不用在任务执行的时候忙等，但是这样有可能造成用户因为某些原因没有及时查看构建记录或者及时修复失败构建。因此需要加入邮件通知的功能，及时推送构建结果到用户邮箱。</p>
<p>Jenkins集成了邮件通知功能，完成任务时可发送邮件通知指定用户，但是由于格式固定，不够灵活，因此本系统决定采用Email Extension插件实现邮件发送，配置如下：</p>
<p>（1）安装插件：在Jenkins主页面点击系统管理-&gt;插件管理-&gt;找到Email Extension Plugin并安装。安装完插件后在系统管理-&gt;系统设置中会显示Extended E-mail Notification配置项。</p>
<p>（2）邮件全局配置：用于定义邮件模板，邮件发送人等，并开启邮箱服务，邮箱服务可以有多种选择，这里使用腾讯邮箱提供的SMTP服务，如图5-25。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE.jpg" alt="Jenkins邮箱服务配置"> </p>
<center>图5-25 Jenkins邮箱服务配置</center>

<p>（3）任务添加邮件通知：配置了邮件模板之后还需要在具体的任务中添加邮箱通知功能。如图5-26所示，在任务配置-&gt;Post Build Actions-&gt;选择Editable Email Notification。出现邮件插件配置项。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE.jpg" alt="Jenkins任务邮件配置"> </p>
<center>图5-26 Jenkins任务邮件配置</center>

<p>（4）邮件具体配置：如图5-27所示，可以针对具体的任务修改邮件内容。并且提供了邮件触发条件的功能，如Always表示总是发送邮件，Success表示只在任务执行成功的时候才触发邮件通知等。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E4%BB%BB%E5%8A%A1%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE2.jpg" alt="Jenkins任务邮件配置2"> </p>
<center>图5-27 Jenkins任务邮件配置</center>

<p>（5）邮件通知结果：如图5-28为邮件内容，包含组件信息，构建编号，构建状态，构建结果地址等。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/Jenkins%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5%E7%BB%93%E6%9E%9C.jpg" alt="Jenkins邮件通知结果"> </p>
<center>图5-28 Jenkins邮件通知结果</center>

<h2 id="5-4-前端实现"><a href="#5-4-前端实现" class="headerlink" title="5.4 前端实现"></a>5.4 前端实现</h2><h3 id="5-4-1-Node-js环境安装"><a href="#5-4-1-Node-js环境安装" class="headerlink" title="5.4.1 Node.js环境安装"></a>5.4.1 Node.js环境安装</h3><p>Node提供了模块化功能，可以方便的引入模块，并且可以使得JavaScript能够进行服务端的开发。Node的出现影响着前端开发的模式，促进了前端工程化的发展。本系统使用Node中的Npm的包管理功能进行前端开发。</p>
<p>首先从官网上下载Node.js并安装，程序会自动设置好环境变量，安装成功后使用【node –v】和【npm –v】命令检查Node和Npm版本。Npm通过模块下的package.json来定义包的属性，包括包名、版本号、作者、依赖包信息等，可以使用【npm install <Module name>】命令安装Node模块。由于国内使用npm的官方镜像下载模块速度比较慢，因此使用其他镜像替代。以淘宝镜像源为例，主要有三种配置方式，本项目采用第三种配置方法，配置方式如下：</Module></p>
<p>（1）使用【npm config set registry <a href="http://registry.npm.taobao.org】命令设置镜像,使用npm/">http://registry.npm.taobao.org】命令设置镜像，使用npm</a> config get registry查看镜像。使用本方式可以持久使用，缺点是对当前机器的所有项目起作用。</p>
<p>（2）使用【npm –registry <a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a> install <Module name>】安装模块，本方式只适合临时使用，缺点是每次安装模块都需要指定镜像源。</Module></p>
<p>（3）在工程目录的.npmrc配置文件中写入镜像源地址，添加【registry=<a href="http://registry.npm.taobao.org】.这样做的好处是只针对当前项目起作用,并且只需要拷贝这份配置文件即可移植到新工程中./">http://registry.npm.taobao.org】。这样做的好处是只针对当前项目起作用，并且只需要拷贝这份配置文件即可移植到新工程中。</a></p>
<h3 id="5-4-2-前端工程化建立"><a href="#5-4-2-前端工程化建立" class="headerlink" title="5.4.2 前端工程化建立"></a>5.4.2 前端工程化建立</h3><p>随着前后端分离概念的流行，后端工程师不用再关注前端页面，前端工程师的职责越来越重，能做的事情更加多了，随之而来的是前端项目逐渐庞大，需要考虑开发效率和后期维护等问题，因此，势必走上前端工程化的道路。前端工程化简单的讲就是把复杂不可控的项目变成简单可控的流程，从而提供开发效率，降低风险，是软件工程化在Web前端开发实践中的应用。具体到实践则包含技术框架选型、应用脚手架、代码版本控制、UI组件化、代码质量检查、代码编译、应用构建、打包发布等流程。由此也产生了各种框架和工具。</p>
<p>本系统前端使用Next.js服务端渲染框架搭建，基于React框架，使用Redux框架实现React状态管理，使用TypeScript和Sass等预处理语言替代JS和CSS，UI框架主要使用蚂蚁金服的AntDesign，使用axios框架进行网络请求，WebSocket则利用socket.io框架实现。</p>
<p>本系统脚手架工具使用create-next-app，其中提供了Next.js+AntDesign方案。具体步骤如下：</p>
<p>（1）执行【npm install -g create-next-app】命令安装脚手架。</p>
<p>（2）执行【create-next-app next-ant-app】初始化工程。</p>
<p>（3）在package.json文件中配置依赖库、npm脚本、应用名、版本等信息，如图5-29所示，并运行【npm install】命令安装依赖库。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%89%8D%E7%AB%AFnpm%E9%85%8D%E7%BD%AE.png" alt="前端npm配置"> </p>
<center>图5-29 前端npm配置</center>

<p>（4）在.babelrc添加babel配置，如图5-30所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%89%8D%E7%AB%AFBabel%E9%85%8D%E7%BD%AE.png" alt="前端Babel配置"> </p>
<center>图5-30 前端babel插件配置</center>

<p>（5）在next.config.js文件中配置TypeScript、Sass处理以及图片、CSS资源等打包，如图5-31所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%89%8D%E7%AB%AFnextjs%E9%85%8D%E7%BD%AE.jpg" alt="前端nextjs配置"> </p>
<center>图5-31 前端next.js配置</center>

<p>（6）工程目录划分如图5-32。其中components目录可以存放ui组件，layouts存放公共布局，lib封装了http请求方法，pages存放页面代码，static存放静态资源，styles存放公共样式，utils存放工具类。.babelrc用于配置babel插件，tsconfig.json用于配置TypeScript处理等。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95.jpg" alt="前端工程目录"> </p>
<center>图5-32 前端工程目录</center>

<p>（7）配置完毕后执行npm run dev运行服务，默认端口号为3000，可以在浏览器上访问3000端口打开前端页面。</p>
<h3 id="5-4-3-前端部分页面展示"><a href="#5-4-3-前端部分页面展示" class="headerlink" title="5.4.3 前端部分页面展示"></a>5.4.3 前端部分页面展示</h3><p>前端页面布局主要分为侧边栏，右侧分为顶部导航、Breadcrumbs、内容、页脚。交互方面主要实现了全局消息提示、通知弹窗、确认弹窗以及表单对话框等。</p>
<p>（1）组件管理页面，实现了分页和排序功能，超过十条数据自动分页。请求成功后，顶部出现消息提示交互。效果如图5-33。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2.jpg" alt="组件管理页面"> </p>
<center>图5-33 组件管理页面</center>

<p>（2）表单对话框，实现了表单验证功能。效果如图5-34。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E9%A1%B5%E9%9D%A2.png" alt="创建组件页面"> </p>
<center>图5-34 创建组件页面</center>

<p>（3）构建历史页面，使用表格控件，倒序显示。效果如图5-35。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2%E9%A1%B5%E9%9D%A2.jpg" alt="构建历史页面"> </p>
<center>图5-35 构建历史页面</center>

<p>（4）项目详情页面，实现了下拉框联想功能，即根据条件自动更新下拉框选项。效果如图5-36。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2.jpg" alt="项目详情页面"> </p>
<center>图5-36 项目详情页面</center>

<p>（1）交互效果：通知弹窗和确认弹窗如图5-37所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%80%9A%E7%9F%A5%E5%BC%B9%E7%AA%97%E6%95%88%E6%9E%9C.png" alt="通知弹窗效果"> </p>
<center>图5-37 通知和确认弹窗效果</center>

<h2 id="5-5-后端实现"><a href="#5-5-后端实现" class="headerlink" title="5.5 后端实现"></a>5.5 后端实现</h2><h3 id="5-5-1-后端架构"><a href="#5-5-1-后端架构" class="headerlink" title="5.5.1 后端架构"></a>5.5.1 后端架构</h3><p>本系统采用前后端分离方式开发，后端只负责提供接口数据，不涉及View层，基于Springboot和Mybatis框架实现，共分为三层：</p>
<p>（1）Controller层（控制层）：负责接收前端请求，并调用相应的业务模块执行逻辑。同时可以在这一层对数据进行拆装，转换为前端和业务层需要的数据。</p>
<p>（2）Service层（业务层）：实现业务模块逻辑，包括任务执行，调度，事务控制和异常处理等。还负责调用Dao层操作数据。对外只暴露业务接口。</p>
<p>（3）Dao层（数据操作层）：实现数据库操作，在xml文件中定义数据库操作语句，通过mybatis框架解析和执行。</p>
<p>架构图如5-38所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="后端架构图"> </p>
<center>图5-38 Web后端架构图</center>

<h3 id="5-5-2-功能实现概述"><a href="#5-5-2-功能实现概述" class="headerlink" title="5.5.2 功能实现概述"></a>5.5.2 功能实现概述</h3><p>（1）组件管理业务：包含组件、组件构建记录、Jenkins组件任务的CRUD功能，以及组件构建和Jenkins组件任务的执行。</p>
<p>（2）项目管理业务：包含项目、项目构建记录、Jenkins项目任务的CRUD功能，以及项目构建、集成和Jenkins项目任务的执行。</p>
<p>（3）跨域问题解决：由于浏览器的同源策略限制导致不同源的前端页面请求服务端会被拒绝，也就是跨域问题，为了解决这一问题，需要服务端指定允许访问的源。建立CorsConfig.java文件，配置如图5-39所示</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.jpg" alt="跨域问题处理"> </p>
<center>图5-39 跨域问题处理</center>

<p>（4）全局异常处理：通过Springboot提供的@ControllerAdvice注解开启全局异常捕获，通过@ExceptionHandler注解捕获特定异常。如图5-40所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.jpg" alt="全局异常处理"> </p>
<center>图5-40全局异常处理</center>

<p>（5）正则匹配修改：Jenkins任务配置是以xml文件形式保存的，创建任务时需要上传配置，为了针对不同组件配置Job，需要修改模板配置文件，这里使用正则表达式修改文件，部分关键代码如图5-41和图5-42所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E8%AF%BB%E5%8F%96%E6%A8%A1%E7%89%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="读取模板配置文件"> </p>
<center>图5-41读取模板配置文件</center>

<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E4%BF%AE%E6%94%B9.jpg" alt="正则匹配修改"> </p>
<center>图5-42 正则匹配修改</center>

<h3 id="5-5-3-数据库设计"><a href="#5-5-3-数据库设计" class="headerlink" title="5.5.3 数据库设计"></a>5.5.3 数据库设计</h3><p>本系统使用MySQL进行数据存储，共有4个实体集，组件、项目、组件构建记录、项目构建记录。其中，一个组件或者项目可以有多条构建记录，每次构建都是一个版本，项目依赖组件的某个版本，一个项目依赖多个组件的某个版本，一个组件的某个版本可以被多个项目依赖。</p>
<p>（1）数据库实体关系图（ER图）设计如图5-43：</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%95%B0%E6%8D%AE%E5%BA%93ER%E5%9B%BE.jpg" alt="数据库ER图"> </p>
<center>图5-43 数据库ER图</center>

<p>（2）数据库关系模型如下：</p>
<p> 组件（组件id，组件名称，仓库地址，分支，目录，当前版本，构建状态，组件描述，创建时间，最近操作时间）</p>
<p>组件构建记录（组件构建id，组件id，组件名称，构建序号，构建状态，构建版本，构建信息，构建时间）</p>
<p>项目（项目id，项目名称，仓库地址，分支，当前版本，构建状态，集成状态，项目描述，创建时间，最近操作时间）</p>
<p>项目构建记录（项目构建id，项目id，项目名称，类型构建状态，构建序号，apk下载地址，构建信息，构建时间）</p>
<p>项目组件关系（id，项目id，组件构建id，关联类型）</p>
<p>（3）数据库表设计如下：</p>
<p>表1 组件表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_module</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>备注</td>
<td>中文名称</td>
</tr>
<tr>
<td>module_id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>组件id</td>
</tr>
<tr>
<td>name</td>
<td>varchar(30)</td>
<td>非空</td>
<td>唯一</td>
<td>组件名称</td>
</tr>
<tr>
<td>repo</td>
<td>varchar(70)</td>
<td>非空</td>
<td></td>
<td>仓库地址</td>
</tr>
<tr>
<td>branch</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>分支</td>
</tr>
<tr>
<td>catalog</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>目录</td>
</tr>
<tr>
<td>cur_version</td>
<td>varchar(10)</td>
<td></td>
<td></td>
<td>当前版本</td>
</tr>
<tr>
<td>build_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>构建状态</td>
</tr>
<tr>
<td>descr</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>组件描述</td>
</tr>
<tr>
<td>gmt_create</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>创建时间</td>
</tr>
<tr>
<td>gmt_update</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>最近操作时间</td>
</tr>
</tbody></table>
<p>表2 组件构建记录表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_module_build</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>约束条件</td>
<td>中文名称</td>
</tr>
<tr>
<td>module_build_id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>组件构建id</td>
</tr>
<tr>
<td>module_id</td>
<td>int</td>
<td>非空</td>
<td>外键</td>
<td>组件id</td>
</tr>
<tr>
<td>module_name</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>组件名称</td>
</tr>
<tr>
<td>build_num</td>
<td>int</td>
<td>非空</td>
<td></td>
<td>构建number</td>
</tr>
<tr>
<td>build_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>构建状态</td>
</tr>
<tr>
<td>version</td>
<td>varchar(10)</td>
<td>非空</td>
<td></td>
<td>构建版本</td>
</tr>
<tr>
<td>message</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>构建信息</td>
</tr>
<tr>
<td>gmt_create</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>构建时间</td>
</tr>
</tbody></table>
<p>表3 项目表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_project</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>约束条件</td>
<td>中文名称</td>
</tr>
<tr>
<td>project_id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>项目id</td>
</tr>
<tr>
<td>name</td>
<td>varchar(30)</td>
<td>非空</td>
<td>唯一</td>
<td>项目名称</td>
</tr>
<tr>
<td>repo</td>
<td>varchar(70)</td>
<td>非空</td>
<td></td>
<td>仓库地址</td>
</tr>
<tr>
<td>branch</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>分支</td>
</tr>
<tr>
<td>cur_version</td>
<td>varchar(10)</td>
<td></td>
<td></td>
<td>当前版本</td>
</tr>
<tr>
<td>build_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>构建状态</td>
</tr>
<tr>
<td>integrate_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>集成状态</td>
</tr>
<tr>
<td>descr</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>项目描述</td>
</tr>
<tr>
<td>gmt_create</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>创建时间</td>
</tr>
<tr>
<td>gmt_update</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>最近操作时间</td>
</tr>
</tbody></table>
<p>表4 项目构建记录表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_project_build</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>约束条件</td>
<td>中文名称</td>
</tr>
<tr>
<td>project_build_id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>项目构建id</td>
</tr>
<tr>
<td>project_id</td>
<td>int</td>
<td>非空</td>
<td>外键</td>
<td>项目id</td>
</tr>
<tr>
<td>project_name</td>
<td>varchar(30)</td>
<td>非空</td>
<td></td>
<td>项目名称</td>
</tr>
<tr>
<td>build_num</td>
<td>int</td>
<td></td>
<td></td>
<td>构建number</td>
</tr>
<tr>
<td>build_status</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>构建状态</td>
</tr>
<tr>
<td>type</td>
<td>int(1)</td>
<td></td>
<td>默认为1</td>
<td>类型</td>
</tr>
<tr>
<td>download_url</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>Apk下载地址</td>
</tr>
<tr>
<td>message</td>
<td>varchar(100)</td>
<td></td>
<td></td>
<td>构建信息</td>
</tr>
<tr>
<td>gmt_create</td>
<td>timestamp</td>
<td></td>
<td>默认，自动更新</td>
<td>构建时间</td>
</tr>
</tbody></table>
<p>表5 项目组件关系表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>t_project_module</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列名</td>
<td>数据类型</td>
<td>空/非空</td>
<td>约束条件</td>
<td>中文名称</td>
</tr>
<tr>
<td>id</td>
<td>int</td>
<td>非空</td>
<td>自增主键</td>
<td>关联关系id</td>
</tr>
<tr>
<td>project_id</td>
<td>int</td>
<td>非空</td>
<td>外键</td>
<td>项目id</td>
</tr>
<tr>
<td>module_build_id</td>
<td>int</td>
<td>非空</td>
<td>外键</td>
<td>组件构建id</td>
</tr>
<tr>
<td>type</td>
<td>int</td>
<td></td>
<td></td>
<td>关联类型</td>
</tr>
</tbody></table>
<h1 id="6-案例测试和演示"><a href="#6-案例测试和演示" class="headerlink" title="6 案例测试和演示"></a>6 案例测试和演示</h1><p>本章将以5.1节中实现的Android组件化项目作为案例，演示实际项目是如何结合本系统进行开发的。</p>
<p>（1）首先在平台项目管理中创建项目，输入项目基本信息，如图6-1。输入为空或项目已存在会出现错误提示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA.jpg" alt="项目创建"> </p>
<center>图6-1 项目创建</center>

<p>创建完成之后可以看到Jenkins页面成功创建了一个项目Job，如图6-2。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AEJob%E5%88%9B%E5%BB%BA.jpg" alt="项目Job创建"> </p>
<center>图6-2 项目Job创建</center>

<p>进入项目详情查看，项目组件为空，如图6-3。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E8%AF%A6%E6%83%85.jpg" alt="项目详情"> </p>
<center>图6-3 项目详情</center>

<p>进入项目构建历史查看，构建记录为空，如图6-4。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2.jpg" alt="项目构建历史"> </p>
<center>图6-4 项目构建历史</center>

<p>（2）在平台组件管理中创建组件，输入组件的基本信息，如图6-5。同样地，可以看到Jenkins页面成功创建了一个组件Job。组件构建历史为空。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA.jpg" alt="组件创建"> </p>
<center>图6-5 组件创建</center>

<p>（3）在组件的指定分支上开发完成，提交了代码之后，在平台组件管理中点击构建组件，第一次构建需要输入起始版本号，如图6-6，后面版本号会自动生成，不需要再次输入。开始构建之后，前端显示正在构建，Jenkins会在远程、后台执行该任务，不会影响开发者，可以查看构建进度，如图6-7和图6-8。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA.jpg" alt="组件构建"> </p>
<center>图6-6 组件构建</center>

<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E8%BF%9B%E5%BA%A6%E5%85%A5%E5%8F%A3.jpg" alt="组件构建进度入口"> </p>
<center>图6-7 组件构建进度入口</center>

<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E8%BF%9B%E5%BA%A6.jpg" alt="组件构建进度"> </p>
<center>图6-8 组件构建进度</center>

<p>（3）构建完成后前端会收到通知，如图6-9。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E9%80%9A%E7%9F%A5.jpg" alt="组件构建通知"> </p>
<center>图6-9 组件构建通知</center>

<p>可以查看构建历史和构建日志。如图6-10和图6-11。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2.jpg" alt="组件构建历史"> </p>
<center>图6-10 组件构建历史</center>

<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E6%97%A5%E5%BF%97.jpg" alt="组件构建日志"> </p>
<center>图6-11 组件构建日志</center>

<p>能够看到日志显示构建成功，并且发送构建结果的邮件到了配置的邮箱。如图6-12。可以点击超链接查看具体日志。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5.jpg" alt="组件构建邮件通知"> </p>
<center>图6-12 组件构建邮件通知</center>

<p>（4）依次构建好其他几个组件后，在项目详情页面中可以添加项目组件，只能搜索到构建成功的组件版本，且一个项目只能有一个同名组件，保存成功后会弹出提示，如图6-13。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%B7%BB%E5%8A%A0%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6.jpg" alt="添加项目组件"> </p>
<center>图6-13 添加项目组件</center>

<p>（5）配置完毕之后点击项目构建，即和组件构建一样开始后台执行Job，可以在Jenkins后台查看构建进度等。构建完成之后同样会收到消息通知和邮件通知，内容有所区别。可以查看项目构建历史。如图6-14。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.jpg" alt="项目构建历史记录"> </p>
<center>图6-14 项目构建历史记录</center>

<p>能够看到出现了安装包地址，跳转到apk下载地址，供用户下载最新应用，如图6-15。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/apk%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80.jpg" alt="apk下载地址"> </p>
<center>图6-15 apk下载地址</center>

<p>（6）至此完成了一次集成，根据持续集成的定义，每天都要进行构建，通过平台简化了一系列重复繁琐的操作，实现了远程构建，提高了效率，能够及时暴露和反馈问题，增强项目开发过程的可见性，并且能够随时随地提供可以运行的软件。安装并运行应用，效果如图6-16所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%BA%94%E7%94%A8%E6%95%88%E6%9E%9C%E5%89%8D.jpg" alt="应用效果前"> </p>
<center>图6-16 应用效果前</center>

<p>（7）假设提出了测试bug或者新增了需求，如要求在首页新增一个入口，跳转到其他页面。首页组件的开发者实现了该功能，并且将源码推送到远程仓库。如图6-17。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%BC%80%E5%8F%91%E5%85%B6%E4%BB%96%E9%A1%B5%E9%9D%A2.jpg" alt="开发其他页面"> </p>
<center>图6-17 开发其他页面</center>

<p>按照上述流程在平台上构建首页组件，修改项目依赖组件版本，进行集成，即可打出新的apk包，供其他角色进行验收测试等。同样地进行下载和安装。运行效果如图6-18所示。</p>
<p><img src="/2021/09/04/tech-2021-09-04-CI%E5%9B%9E%E9%A6%96%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%BA%94%E7%94%A8%E6%95%88%E6%9E%9C%E5%90%8E.jpg" alt="应用效果后"> </p>
<center>图6-18 应用效果后</center>

<p>（8）循环上述步骤，直到应用开发完成，进行项目最终集成和发布应用。通过案例可以看到持续集成与瀑布式开发流程的明显区别，在开发过程中可以不断提出新建议或者问题，开发者可以快速实现，并且提交测试，而不用分阶段完成任务，等到最终集成之后才进行测试，这也就是敏捷的来源。</p>
<h1 id="7-总结与展望"><a href="#7-总结与展望" class="headerlink" title="7 总结与展望"></a>7 总结与展望</h1><p>通过平台可视化界面对组件化项目进行管理和构建，可以减少重复、耗时的操作，降低沟通成本，大大地提高了开发效率，增强了开发过程的可见性和可控性，开发者不需要手动的构建、测试、发布等。通过每日构建和频繁集成能够及时发现项目缺陷，降低发布风险，提高软件质量，快速迭代软件产品。</p>
<p>本文提出和设计了一套持续集成方案，并实现了一套简易版的持续集成生态。目前已实现基本功能，各端联调通信，能够正常走完所有流程，需要在使用过程中通过实际大量的数据和测试暴露问题，改进方案。目前本系统还有一些可以优化的点，如下：</p>
<p>（1）加入用户管理系统和用户权限系统：项目和组件可以有各自的负责人，负责人拥有所有的权限，对其他成员只保持可见权限，提高系统的安全性，减少风险，团队成员各司其职。同时平台的每次操作都会记录用户，便于事后追溯问题。</p>
<p>（2）前端优化数据筛选、搜索、排序等功能：目前只实现了部分功能，由于数据量较少，因此功能暂时用处不大，当数据量大的时候，这些用户友好功能就能体现出相应的价值。丰富反馈机制如红点提示等，报错标红等UI效果。</p>
<p>（3）Jenkins添加静态代码质量检查任务：可以在构建之前执行检查任务，执行完成之后会生成检查报告，展示到平台，提醒开发者优化代码，并且可是设置分数低于合格值构建不通过。</p>
<p>（4）Jenkins添加自动化测试任务：可以在项目构建完毕之后执行自动化测试任务，执行完后生成测试日志，一定程度上减少手动重复测试，避免测试人员反复测试同一个问题并且提交。</p>
<p>（5）优化组件管理和项目管理的流程：如通过平台直接创建项目分支，不需要手动创建分支，项目集成之后自动打TAG、优化版本变化流程等。</p>
<p>（6）增加看板功能：即类似jira等敏捷开发工具，产品或测试人员可以通过平台针对某个开发者发布问题或者任务，把项目的进度、个人完成率、超时完成等数据统计显示在看板上，开发者完成任务或者修复问题之后在平台上修改状态，测试人员测试通过之后关闭问题，形成一个闭环。看板数据还可以作为绩效管理等的有力依据。</p>
<p>新的感悟：</p>
<ol>
<li>根据项目类型配置不同Jenkins任务模板</li>
<li>应用可以发布到构件仓库，不需要上传蒲公英</li>
<li>应用配置管理或者配置分发</li>
<li>版本号不写死在代码里面，生成提交：可以通过gradle读取外部变量</li>
<li>系统组件化：将系统构建作为项目，组件可能是应用、配置等</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]Paul M D,Steve Matyas,Andrew Glover.持续集成：软件质量改进和降低风险之道[M].王海鹏译.北京：电子工业出版社，2013.</p>
<p>[2]Kent Beck,Cynthia Andres. Extreme Programming Explained: Embrace Change[M].</p>
<p>[3]Fowler M. Continuous Integration[EB/OL]. <a href="https://martinfowler.com/articles/continuousIntegration.html,2006-5-1/2018-12-20">https://martinfowler.com/articles/continuousIntegration.html,2006-5-1/2018-12-20</a>.</p>
<p>[4]<a href="http://yuanjian.cnki.com.cn/Search/Result?author=%E6%9C%B1%E7%BA%A2">朱红</a>,<a href="http://yuanjian.cnki.com.cn/Search/Result?author=%E4%BB%87%E6%B6%A6%E9%B9%A4">仇润鹤</a>.基于Jenkins的移动通信业务自动化测试平台的设计与测试[J].科技与创新，2016,(7).</p>
<p>[5]陈松乔,任胜兵,王国军.现代软件工程[M].北方交通大学出版社，2002-11-13.</p>
<p>[6]张力文.基于Jenkins的项目持续集成方案研究与实现[D].西南交通大学，2017.</p>
<p>[7]Jez Humble,David Farley.持续交付：发布可靠软件的系统方法.乔梁译[M].北京：人民邮电出版社，2011.</p>
<p>[8]Kent Beck,Fowler M,et al. Manifesto for Agile Software Development [EB/OL]. <a href="http://agilemanifesto.org/,2001/2018-12-30">http://agilemanifesto.org/,2001/2018-12-30</a>.</p>
<p>[9]inter_peng.持续集成（Continuous Integration）基本概念与实践[EB/OL]. <a href="https://blog.csdn.net/inter_peng/article/details/53131831%EF%BC%8C2016-11-11/2019-5-5">https://blog.csdn.net/inter_peng/article/details/53131831，2016-11-11/2019-5-5</a>.</p>
<p>[10]王宁.基于Jenkins的持续集成系统的设计与实现[D].北京邮电大学，2014.</p>
<p>[11]Swartout P. Continuous Deliver and DevOps-A Quickstart Guide[M]. Birmingham:Packt Publishing Ltd，2014:3.</p>
<p>[12]Ekaterina Novoseltseva. <a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/">Top benefits of continuous integration</a>[EB/OL]. <a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/%EF%BC%8C2015-12-28/2018-11-22">https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/，2015-12-28/2018-11-22</a>.</p>
<p>[13]曾家乐.Android组件化架构[M].电子工业出版社，2018-03-01.</p>
<p>[14] runoob.Docker架构[EB/OL]. <a href="https://www.runoob.com/docker/docker-architecture.html%EF%BC%8C2019-5-5">https://www.runoob.com/docker/docker-architecture.html，2019-5-5</a>.</p>
<p>[15]guiying712.Android组件化方案[EB/OL]. <a href="https://blog.csdn.net/guiying712/article/details/55213884%EF%BC%8C2017-2-15/2019-5-5">https://blog.csdn.net/guiying712/article/details/55213884，2017-2-15/2019-5-5</a>.</p>
<p>[16]Jonhn Ferguson Smart. Jenkins:The Definitive Guide[M]. O’REILLY,2011.</p>
<p>[17]dnsliu.基于Jenkins实现Android项目的持续集成[EB/OL].<a href="https://blog.csdn.net/dnsliu/article/details/81019086%EF%BC%8C2018-7-12/2019-5-5">https://blog.csdn.net/dnsliu/article/details/81019086，2018-7-12/2019-5-5</a>.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>持续集成</tag>
        <tag>组件化</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的MVC、MVP、MVVM</title>
    <url>/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/</url>
    <content><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="MVC基础"><a href="#MVC基础" class="headerlink" title="MVC基础"></a>MVC基础</h2><p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVC%E6%A8%A1%E5%BC%8F.png"></p>
<blockquote>
<p>Tips：箭头可以理解为引用、依赖，也可以理解为调用，因为引用了必然要调用。</p>
<p>有的MVC模式图包含了虚线和实线：虚线一般表现为临时变量，参数回调，实线表现为成员变量</p>
</blockquote>
<ol>
<li>Model：数据模型，负责数据获取、修改。代码中表现为Model、Repository（对数据进行隔离）、ApiService（访问网络）、Dao（访问数据库）、数据实体Entity等。</li>
<li>View：视图，负责视图显示和视图控制。代码中表现为Layout+Activity，如findViewById，setText、动画等。</li>
<li>Controller：控制器，负责所有的行为逻辑。代码中表现为Activity+各种管理类，如网络请求、SP存储、数据库访问、电量信息、网络状态等。除了对Model的调用外，还包含一些逻辑处理，如调用登录接口之前，对账号密码进行合法校验，加密等。</li>
</ol>
<p>样例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mModel = LoginModel()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">      	<span class="comment">//账号密码校验，加密等逻辑</span></span><br><span class="line">        mModel.login(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="keyword">object</span> : ResultCallback&lt;String?&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                <span class="comment">//回调方式返回数据</span></span><br><span class="line">                onLogin(result)</span><br><span class="line">                <span class="comment">//View直接从Model层获取数据显示</span></span><br><span class="line">                <span class="comment">//setText(mModel.user)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(errorCode: <span class="type">String</span>?, errorMsg: <span class="type">String</span>?)</span></span> &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLogin</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//runOnUIThread...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>?, password: <span class="type">String</span>?, callback: <span class="type">ResultCallback</span>&lt;<span class="type">String</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//runOnIOThread...</span></span><br><span class="line">        callback.onSuccess(<span class="string">&quot;Afauria&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ResultCallback</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(errorCode: <span class="type">String</span>?, errorMsg: <span class="type">String</span>?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大家常说的缺点："><a href="#大家常说的缺点：" class="headerlink" title="大家常说的缺点："></a>大家常说的缺点：</h2><ol>
<li>Activity负责View和Controller的工作，较臃肿，违背单一职责原则</li>
<li>View和Model可以直接交互，存在耦合，违背最小知识原则</li>
</ol>
<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><h3 id="何为Model？"><a href="#何为Model？" class="headerlink" title="何为Model？"></a>何为Model？</h3><blockquote>
<p>Model指数据模型。</p>
<ul>
<li>狭义的Model指API接口、数据库、文件存储等数据。</li>
<li>广义的Model不止是业务数据对象，还包含外部对象，如定位信息、网络状态、电量等。这些都属于Model层数据交互部分。</li>
</ul>
<p>因此，从这个角度讲，可以把电量管理、定位管理、网络管理等认为是Controller，命名可能叫<code>LocationManager</code>、<code>NetwrokHelper</code>、<code>BatteryManager</code>…</p>
<p>在MVC中，View需要对接各种管理器。</p>
<p>在MVP中，View只关心自己的Presenter，由Presenter对接不同的Model。</p>
</blockquote>
<h3 id="何为Controller？"><a href="#何为Controller？" class="headerlink" title="何为Controller？"></a>何为Controller？</h3><ul>
<li>狭义的Controller：即Controller类</li>
<li>广义的Controller：Controller不具体指哪一个类，而是指逻辑行为代码，可能是一个类（有的时候命名为Controller、Helper、Manager）、可能是一个方法或者代码块。</li>
</ul>
<h3 id="怎么理解View和Model关联？"><a href="#怎么理解View和Model关联？" class="headerlink" title="怎么理解View和Model关联？"></a>怎么理解View和Model关联？</h3><p>Android MVC中Activity既包含了视图、又包含了逻辑，View和Controller没有分离。</p>
<ul>
<li>站在Activity类的角度讲，可以说View和Model有交互，也可以说Controller和Model有交互。</li>
<li>站在代码逻辑上讲，调用Model方法本身也是行为逻辑，因此和Model交互的永远是Controller，不会是View。</li>
</ul>
<p>将MVC原本的图改为下图，实际是M&lt;-&gt;V/C：</p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVC%E8%A7%A3%E8%AF%BB.png"></p>
<p>注：<strong>这里的MVC不是标准的MVC模式，严格来说只能算M&lt;-&gt;V/C</strong>。在传统Web开发中，Model、Controller、View（JSP）是分离的。</p>
<h2 id="MVC的其他理解"><a href="#MVC的其他理解" class="headerlink" title="MVC的其他理解"></a>MVC的其他理解</h2><p>网上有很多MVC的关系图，箭头关系表示都不一样，到底哪种是正确的呢？</p>
<ol>
<li>将Activity中逻辑处理部分抽到Controller中，避免Activity包含逻辑处理，并转发Callback。</li>
</ol>
<p>代码见<a href="https://github.com/Afauria/ArchitectureSample">MVCSample1</a></p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVC%E7%9A%84%E5%85%B6%E4%BB%96%E7%90%86%E8%A7%A31.png"></p>
<ol start="2">
<li>将Activity中逻辑处理部分抽到Controller中，View可以直接调用Model获取数据</li>
</ol>
<p>代码见<a href="https://github.com/Afauria/ArchitectureSample">MVCSample2</a></p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVC%E7%9A%84%E5%85%B6%E4%BB%96%E7%90%86%E8%A7%A32.png"></p>
<p>View调用Model获取数据，包括直接获取、回调获取，此时Activity既是View，又包含了一部分Controller的逻辑，和Model层直接交互</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>MVC有多种理解和实现，核心的点在于将代码划分为Model、View、Controller三个部分，至于三个部分怎么通信耦合、Activity究竟是属于View还是Controller没有严格规定。</li>
<li>我们一直在说“Activity既包含了视图逻辑，又包含了业务逻辑，导致臃肿，违背单一职责原则”。实际上这只是MVC的其中一种理解，上述两种实现，即使把业务逻辑抽出去，创建一个Controller类，但实际上还是MVC。</li>
</ol>
<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><h2 id="MVP基础"><a href="#MVP基础" class="headerlink" title="MVP基础"></a>MVP基础</h2><p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVP%E6%A8%A1%E5%BC%8F.png"></p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVP%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p>
<p>除了Model之外，Presenter还和其他外部对象交互，只需要保证View不包含逻辑代码</p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVP%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9D%97.png" alt="MVP架构模块"></p>
<p>以登录业务为例，MVP类图如下</p>
<p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVP%E7%B1%BB%E5%9B%BE.png"></p>
<p><strong>注：Callback可以通过异步框架替换，见<a href="/2021/07/15/basic-2021-07-15-%E5%BC%82%E6%AD%A5%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0/">异步概念和常见实现</a></strong></p>
<p>样例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 定义Contract接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginContract</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IView</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onLogin</span><span class="params">(name: <span class="type">String</span>?)</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IPresenter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>?, password: <span class="type">String</span>?)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Activity、Fragment实现IView接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> : <span class="type">LoginContract.IView &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> mPresenter: LoginContract.IPresenter = LoginPresenter(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mPresenter.login(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLogin</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//runOnUIThread...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. Presenter实现IPresenter接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> mView: LoginContract.IView) : LoginContract.IPresenter &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mModel = LoginModel()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>?, password: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        mModel.login(username, password, <span class="keyword">object</span> : ResultCallback&lt;String?&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                mView.onLogin(result)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(errorCode: <span class="type">String</span>?, errorMsg: <span class="type">String</span>?)</span></span> &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ResultCallback</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(errorCode: <span class="type">String</span>?, errorMsg: <span class="type">String</span>?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>?, password: <span class="type">String</span>?, callback: <span class="type">ResultCallback</span>&lt;<span class="type">String</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//runOnIOThread...</span></span><br><span class="line">        callback.onSuccess(<span class="string">&quot;Afauria&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大家常说的缺点"><a href="#大家常说的缺点" class="headerlink" title="大家常说的缺点"></a>大家常说的缺点</h2><ol>
<li>Presenter持有View的引用，需要及时释放</li>
<li>需要定义大量的接口</li>
</ol>
<h2 id="MVP改造"><a href="#MVP改造" class="headerlink" title="MVP改造"></a>MVP改造</h2><ol>
<li>重复代码、公共接口：使用基类+泛型抽取公共接口和实现<ol>
<li>BasePresenter绑定和释放View、SafeHandler创建和释放等</li>
<li>BaseView公共进度条、弹窗、getContext等</li>
</ol>
</li>
<li>Presenter直接创建具体Model。<ol>
<li>替换的时候需要修改Presenter类。</li>
<li>单元测试中，不方便mock Model。</li>
</ol>
</li>
</ol>
<blockquote>
<p>可以通过依赖注入的方式进行解耦，变量初始化放到外部，可以随时替换，方便单元测试。</p>
<p>代码见<a href="https://github.com/Afauria/ArchitectureSample/tree/master/app/src/main/java/com/afauria/sample/architecture/injectmvp">InjectMVP和InjectMVPTest</a></p>
</blockquote>
<ol start="3">
<li>结合Dagger框架：实现Model、Presenter、View依赖注入</li>
<li>结合RxJava框架：通过Observable包装Model实现可观察数据源，和线程切换</li>
</ol>
<h2 id="提问-1"><a href="#提问-1" class="headerlink" title="提问"></a>提问</h2><h3 id="MVP如何定义接口？"><a href="#MVP如何定义接口？" class="headerlink" title="MVP如何定义接口？"></a>MVP如何定义接口？</h3><p>最常见的MVP实现是P和V定义接口，Model不抽。</p>
<p>反过来问，Presenter、View、Model是否可以不定义接口？</p>
<blockquote>
<p>可以抽，也可以不抽，看实际需要。不要为了抽接口而抽接口，明确抽接口的目的和意义。</p>
<p>“如果抽象没有带来显著的好处，应该避免抽象”——<a href="https://developer.android.com/topic/performance/memory?hl=zh-cn#Abstractions">谷歌开发者文档</a></p>
</blockquote>
<h3 id="为什么抽接口，抽接口和抽基类有什么区别？"><a href="#为什么抽接口，抽接口和抽基类有什么区别？" class="headerlink" title="为什么抽接口，抽接口和抽基类有什么区别？"></a>为什么抽接口，抽接口和抽基类有什么区别？</h3><blockquote>
<p>抽接口目的</p>
<ol>
<li>实现多态：便于替换不同实现</li>
<li>屏蔽实现细节，迪米特法则</li>
<li>依赖倒置：Presenter修改实现，View不需要修改。View修改实现，Presenter不需要修改</li>
<li>代码逻辑清晰，可读性强：都在Contract中</li>
</ol>
<p>抽Base类是为了抽取公共逻辑，Base类是后续衍生出来的，不在架构模式定义中</p>
</blockquote>
<h3 id="MVP中V层可以是Fragment吗？一个Activity有多个Fragment呢？"><a href="#MVP中V层可以是Fragment吗？一个Activity有多个Fragment呢？" class="headerlink" title="MVP中V层可以是Fragment吗？一个Activity有多个Fragment呢？"></a>MVP中V层可以是Fragment吗？一个Activity有多个Fragment呢？</h3><blockquote>
<p>可以，每个Fragment实现不同的View接口，对应不同的Presenter。</p>
</blockquote>
<h3 id="如果两个Fragment需要用到一个Presenter中的数据该怎么做"><a href="#如果两个Fragment需要用到一个Presenter中的数据该怎么做" class="headerlink" title="如果两个Fragment需要用到一个Presenter中的数据该怎么做"></a>如果两个Fragment需要用到一个Presenter中的数据该怎么做</h3><ol>
<li>将Activity作为View，对应一个Presenter，Activity拿到数据之后调用Fragment更新</li>
<li>两个Fragment分别对应两个Presenter，两个Presenter共用一个Model，都从该Model中获取数据</li>
<li>将该功能拆分出来：Activity中创建Presenter2对象，两个Fragment除了依赖自己的Presenter之外，再依赖一个共同的Presenter2</li>
</ol>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p><img src="/2021/07/31/architecture-2021-07-31-Android%E4%B8%AD%E7%9A%84MVC%E3%80%81MVP%E3%80%81MVVM/MVVM%E6%9E%B6%E6%9E%84.png"></p>
<p>MVVM核心：可观察数据驱动UI。</p>
<p>优势：</p>
<ol>
<li>ViewModel不持有View引用</li>
<li>消除了MVP的样板代码，不需要定义大量接口</li>
</ol>
<h2 id="提问-2"><a href="#提问-2" class="headerlink" title="提问"></a>提问</h2><h3 id="如何理解ViewModel？"><a href="#如何理解ViewModel？" class="headerlink" title="如何理解ViewModel？"></a>如何理解ViewModel？</h3><blockquote>
<p>Model实际指DataModel，通常对应数据库或网络返回的数据结构。有的时候还会拆分业务层Model，持久层Model等，参考<a href="/2021/07/29/architecture-2021-07-29-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/">软件设计中的三层架构</a>。</p>
<p>而ViewModel即视图的Model，对应View的对象，对应UI上的控件。</p>
<p>例如：网络返回User数据对象包含很多信息，可以持久化存储到本地。而UI上需要显示用户名，可以用户名包装成可观察对象，保存到ViewModel中</p>
</blockquote>
<h1 id="MVC和MVP对比解读"><a href="#MVC和MVP对比解读" class="headerlink" title="MVC和MVP对比解读"></a>MVC和MVP对比解读</h1><h2 id="MVC-gt-MVP"><a href="#MVC-gt-MVP" class="headerlink" title="MVC-&gt;MVP?"></a>MVC-&gt;MVP?</h2><p>有的人说MVC中Activity承担Controller的功能，MVP将Controller逻辑抽离出去，Activity只负责视图控制。那么</p>
<ol>
<li>把Activity中的逻辑处理抽出去，就是MVP了吗?</li>
</ol>
<blockquote>
<p>上面讲了几种MVC的实现，即使抽出了Controller，还是MVC</p>
</blockquote>
<p>有的人会说MVP相比MVC需要定义接口</p>
<ol start="2">
<li><p>把Activity中的逻辑处理抽出去，再定义View和Controller的接口，就是MVP了吗？</p>
<blockquote>
<p>反过来问，MVP中是否可以不定义View和Presenter接口？</p>
<p>上面讲了MVP接口是根据需要定义的。</p>
</blockquote>
</li>
</ol>
<p>有的人会说MVP中View和Model不能直接依赖</p>
<ol start="3">
<li>View层定义一个Callback，Controller定义一个Callback，避免View和Model直接耦合，就是MVP了吗？</li>
</ol>
<h2 id="MVP和MVC区别"><a href="#MVP和MVC区别" class="headerlink" title="MVP和MVC区别"></a>MVP和MVC区别</h2><ol>
<li>MVP在MVC的基础上，增加了一些限定规则，使得代码更加的模版化、统一、一致。MVC可以有多种实现，没有太大约束，可以使用工具类、静态方法等抽取逻辑，不和View绑定。</li>
<li>Controller和Presenter作用不一样<ol>
<li>Presenter：展示器。Controller：控制器。</li>
<li>Presenter决定页面的逻辑，包括显示逻辑、事件逻辑。Controller是基于行为的，不和页面绑定，负责处理事件行为。</li>
<li>View和Presenter一般情况下是一对一。View和Controller是多对多，一个页面可以包含多个控制器，一个控制器可以被多个页面使用。</li>
</ol>
</li>
<li>MVC做到了视图和数据的<strong>分离</strong>，MVP做到了视图和逻辑的<strong>分离</strong>，数据和视图的<strong>隔离</strong></li>
</ol>
<h1 id="Android架构模式演变：MVC-gt-MVP-gt-MVVM"><a href="#Android架构模式演变：MVC-gt-MVP-gt-MVVM" class="headerlink" title="Android架构模式演变：MVC-&gt;MVP-&gt;MVVM"></a>Android架构模式演变：MVC-&gt;MVP-&gt;MVVM</h1><ol>
<li>MVC问题：Activity承担了View和Controller的职责，同时View和Model存在耦合</li>
<li>MVP：抽取业务逻辑放到Presenter中，隔离了View和Model，View只能和Presenter交互</li>
<li>MVP问题：存在大量样板代码（接口），Presenter持有View引用</li>
<li>MVVM：消除样板代码，避免定义大量接口，通过可观察数据主动刷新UI。ViewModel不持有View的引用</li>
<li>MVVM问题：ViewModel和视图绑定，不利于代码重用。</li>
</ol>
<p>这些是大家通用的理解和说法，但如上文所说，MVC、MVP都存在各式各样的变种和理解。这些架构模式的边界是模糊的，没有一个明确的定义，也不是固定的模版。</p>
<p>MVC和MVP存在的问题也可以通过其他方式、变种来解决，不一定要通过“升级”架构解决。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ol>
<li>没有最好的架构，只有最合适的架构</li>
<li>架构模式不是固定的模版，不要单纯的套模板，而要理解其精髓，掌握基本设计原则之后可以灵活转换、变通。</li>
</ol>
]]></content>
      <categories>
        <category>架构和设计模式</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计中的Clean架构</title>
    <url>/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Clean架构"><a href="#Clean架构" class="headerlink" title="Clean架构"></a>Clean架构</h1><p><img src="/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/Clean%E6%9E%B6%E6%9E%84.png"></p>
<h2 id="层级解释"><a href="#层级解释" class="headerlink" title="层级解释"></a>层级解释</h2><ol>
<li>框架和驱动层：一般由一些框架和工具组成，如UI、DB、Web、Device，包含具体实现，可以随时替换。</li>
<li>接口适配层：如Presenter、Controller、ViewModel等，用于数据转换。</li>
<li>UseCase：用例、业务逻辑。纯Java，不依赖Android</li>
<li>Entity：业务对象</li>
</ol>
<blockquote>
<p> Tips：</p>
<ul>
<li>Flow of control：数据流向</li>
<li>Gateways：架构模式中的入口模式，用于封装访问外部资源接口，方便替换测试资源。如数据源为DB、XML、JSON等</li>
</ul>
</blockquote>
<p>入口模式和外观模式区别？</p>
<blockquote>
<p>设计思想是一样的，都是屏蔽细节，符合迪米特原则（最少知道）。</p>
<p>外观模式一般由服务内部提供，入口模式由调用方自行封装。</p>
<p>Gateway、Repository主要针对数据访问，可以说是外观模式的一种应用。</p>
</blockquote>
<p>入口模式和仓储模式（Repository）区别？</p>
<blockquote>
<p>相同点：都是对业务逻辑屏蔽数据获取细节，方便替换测试数据。</p>
</blockquote>
<h2 id="依赖规则"><a href="#依赖规则" class="headerlink" title="依赖规则"></a>依赖规则</h2><p>外层依赖内层，内层不能依赖外层：指外层定义的函数、变量、类不能被内层引用。</p>
<p>抽象：外层是具体实现，可以随时替换，越往内抽象层次越高，内层不知道外层实现细节</p>
<h2 id="层间通信"><a href="#层间通信" class="headerlink" title="层间通信"></a>层间通信</h2><p><img src="/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/Clean%E6%9E%B6%E6%9E%84%E5%B1%82%E9%97%B4%E9%80%9A%E4%BF%A1.png"></p>
<p>Presenter调用UseCase，传入Callback，UseCase调用Repository接口获取数据，通过Callback返回数据。伪代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> <span class="title">implements</span> <span class="title">UseCase</span>.<span class="title">Callback</span>&lt;<span class="type">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mUserUseCase.getUser(userId, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCallback</span><span class="params">(result : <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">        println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserUseCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mRepository: IUserRepository</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId : <span class="type">String</span>, callback : <span class="type">UseCase</span>.<span class="type">Callback</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        mRepository.getUser(userId, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUserRepository</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId : <span class="type">String</span>, callback : <span class="type">UseCase</span>.<span class="type">Callback</span>&lt;<span class="type">User</span>&gt;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="title">implements</span> <span class="title">IUserRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId : <span class="type">String</span>, callback : <span class="type">UseCase</span>.<span class="type">Callback</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        mService.getUser(userId, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：Callback可以通过异步框架替换，见<a href="/2021/07/15/basic-2021-07-15-%E5%BC%82%E6%AD%A5%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0/">异步概念和常见实现</a></strong></p>
<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><h3 id="UseCase调用外层获取数据是否破坏了依赖规则？"><a href="#UseCase调用外层获取数据是否破坏了依赖规则？" class="headerlink" title="UseCase调用外层获取数据是否破坏了依赖规则？"></a>UseCase调用外层获取数据是否破坏了依赖规则？</h3><blockquote>
<p>可以通过依赖倒置原则解决：内层定义接口，外层实现接口。内层业务逻辑制定抽象规则，不关心外层实现。</p>
</blockquote>
<p>Presenter调用View刷新页面同理：Presenter层定义IView接口，View层实现。获取到数据之后Presenter层调用IView接口刷新数据</p>
<h3 id="Clean架构只需要四层吗？"><a href="#Clean架构只需要四层吗？" class="headerlink" title="Clean架构只需要四层吗？"></a>Clean架构只需要四层吗？</h3><blockquote>
<p>可以根据实际情况增删，只要满足依赖规则</p>
</blockquote>
<h3 id="数据对象如何跨越边界？"><a href="#数据对象如何跨越边界？" class="headerlink" title="数据对象如何跨越边界？"></a>数据对象如何跨越边界？</h3><blockquote>
<p>各层可能有自己定义的数据对象：如DB的数据对象为数据库行，Presenter数据对象为Model</p>
<p>跨边界传递数据时，应该使用内层的数据对象，在外层进行数据Mapper。避免内层依赖外层数据对象，违背依赖规则。</p>
</blockquote>
<h3 id="Clean和MVP"><a href="#Clean和MVP" class="headerlink" title="Clean和MVP"></a>Clean和MVP</h3><p>Clean比MVP多了一层Domain业务层，一般适用于大型项目，业务较复杂的情况。</p>
<p><img src="/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/MVP%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9D%97.png" alt="MVP架构模块"><br><img src="/2021/07/30/architecture-2021-07-30-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84Clean%E6%9E%B6%E6%9E%84/Clean%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9D%97.png" alt="Clean架构模块"></p>
<h3 id="什么是业务逻辑？"><a href="#什么是业务逻辑？" class="headerlink" title="什么是业务逻辑？"></a>什么是业务逻辑？</h3><p><a href="http://www.uml.org.cn/zjjs/201008021.asp">细说业务逻辑</a></p>
<blockquote>
<ul>
<li>狭义：三层架构中的业务层（Domain），Clean架构中的Use Case层</li>
<li>广义：软件产品=界面和交互+业务逻辑，非界面和交互部分，数据也属于业务。某些业务为数据操作集中型，因此抽取出数据访问层。</li>
<li>从空间上讲，数据属于业务的一部分。</li>
<li>从时间上讲，先有业务，再有数据对象。</li>
<li>一个APP可以没有数据，如计算器等，但不能没有业务逻辑。</li>
</ul>
</blockquote>
<p>由于大部分业务只是简单的CRUD，因此业务逻辑层看起来只是简单的封装了一下数据访问层的操作，尤其在客户端业务层被无限弱化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="架构设计目标"><a href="#架构设计目标" class="headerlink" title="架构设计目标"></a>架构设计目标</h3><ul>
<li>框架无关：不依赖于外层框架，如UseCase不需要模拟器、数据库也可以运行</li>
<li>外部类库无关：不依赖于三方库功能</li>
<li>可测试性：每个模块可以独立测试。</li>
<li>UI无关：系统可以任意更换UI，不需要更改业务逻辑</li>
<li>数据源无关：可以修改任意数据来源，如Web、文件、不同数据库</li>
</ul>
<h3 id="Clean架构优缺点"><a href="#Clean架构优缺点" class="headerlink" title="Clean架构优缺点"></a>Clean架构优缺点</h3><p>优点：</p>
<ul>
<li>业务逻辑易于测试</li>
<li>漏洞更容易被隔离</li>
<li>易于功能扩展和添加</li>
<li>代码更易读和可维护</li>
<li>单向依赖、数据驱动编程</li>
</ul>
<p>缺点</p>
<ul>
<li>结构复杂</li>
<li>粒度太细</li>
<li>Usecase 的复用率极低</li>
<li>急剧的增加类和重复代码</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/u014644594/article/details/87858315">Clean架构探讨</a></li>
<li><a href="http://www.uml.org.cn/zjjs/201008021.asp">细说业务逻辑</a></li>
</ul>
<blockquote>
<p>Tips: Robert C. Martin：被称为Uncle Bob，Clean架构提出者，著有《代码整洁之道》、《架构整洁之道》等书</p>
</blockquote>
]]></content>
      <categories>
        <category>架构和设计模式</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计中的三层架构</title>
    <url>/2021/07/29/architecture-2021-07-29-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><h2 id="表示层、业务层、数据访问层"><a href="#表示层、业务层、数据访问层" class="headerlink" title="表示层、业务层、数据访问层"></a>表示层、业务层、数据访问层</h2><ol>
<li>表示层（User Interface Layer，UI）：也叫视图层，视图层常用架构如MVC、MVP、MVVM等，可以有自己的数据对象</li>
<li>业务层（Business Logic Layer，BLL）：包含业务逻辑，数据对象等，有不同的叫法如Domain、Use Case、Service、Bussiness</li>
<li>数据访问层（Data Access Layer，DAL）：封装数据访问逻辑。</li>
<li>持久层（Persistent Layer）：数据物理存储空间，有时候会指代数据访问层。实际不属于三层架构。</li>
</ol>
<p><img src="/2021/07/29/architecture-2021-07-29-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="三层架构"></p>
<blockquote>
<p>Tips：从上往下表示代码调用顺序，从下往上表示数据传输顺序</p>
<p>理解为抽屉结构，框架不变，可以随时抽取替换某一层实现</p>
</blockquote>
<p>三层架构中各层通信通过接口，不依赖具体实现，符合依赖倒置原则</p>
<blockquote>
<p>Tips：依赖倒置原则（DIP）：高层模块不应该依赖低层模块，两者都依赖于抽象，抽象不应该依赖细节，细节应该依赖抽象。——面向接口</p>
</blockquote>
<p>依赖倒置的理解：</p>
<ol>
<li>倒置的是顺序，不是对象：正常情况下，业务层依赖数据层，我们要写业务层之前要先写数据层，数据层修改，业务层要跟着修改。倒置之后可以先写好业务层，再去实现数据层。</li>
<li>依赖关系倒置：原先A直接依赖B，现在A依赖接口，B再实现接口。B不再被A依赖，B反过来依赖接口</li>
</ol>
<h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><h3 id="PO、BO、DTO、VO、POJO、DAO"><a href="#PO、BO、DTO、VO、POJO、DAO" class="headerlink" title="PO、BO、DTO、VO、POJO、DAO"></a>PO、BO、DTO、VO、POJO、DAO</h3><ul>
<li>PO（Persistent Object）：持久对象，数据库中的字段ORM映射，一个PO就是一条数据库记录。可能包含主键、时间戳等信息</li>
<li>BO（Bussiness Object）：业务对象，某个领域内的实体，可以包含业务逻辑。可能由多个PO组成，通常需要把BO转换成PO才能进行数据的持久化</li>
<li>DO（Domain Object）：领域对象，类似BO</li>
<li>DTO（Data Transfer Object）：数据传输对象，BO抽取组装而成，一般用于跨进程或者网络数据传输。</li>
<li>VO（View Object）：视图对象，对应页面上显示的数据。DTO抽取组装而成，例如接口返回通用数据，某个页面只需要特定字段，需要转换成视图对象，一般出现在使用三方接口的情况。</li>
<li>DAO（Data Access Object）：数据访问对象，封装对数据库的访问</li>
<li>Entity：接近原始数据</li>
<li>Model：接近业务对象</li>
<li>POJO（Plain Ordinary Java Object）：简单Java对象。上面的对象其实都是Java对象，是POJO在不同架构层级或者不同场景中的体现</li>
</ul>
<p><strong>根据业务复杂度进行删减</strong>，如客户端中一般直接使用后台返回DTO作为视图对象、持久对象</p>
<h3 id="架构模式和设计模式"><a href="#架构模式和设计模式" class="headerlink" title="架构模式和设计模式"></a>架构模式和设计模式</h3><ul>
<li>架构模式：软件架构设计中的模式，如分层架构模式、MVC架构模式、ORM映射等</li>
<li>设计模式：具体代码实现的模式</li>
</ul>
<p>一般来说：框架 &gt; 架构模式 &gt; 设计模式 &gt; 设计原则</p>
<p>参考《企业应用架构模式》</p>
<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><h3 id="三层架构与MVC"><a href="#三层架构与MVC" class="headerlink" title="三层架构与MVC"></a>三层架构与MVC</h3><blockquote>
<p>两者有一定联系，不完全相同。</p>
<p>三层架构符合依赖倒置原则，面向接口编程，上层调用下层接口，下层定义抽象接口，上层负责实现细节，下层业务逻辑执行完后回调抽象接口。</p>
<p>MVC常用于表现层的的架构模式，MVC三个模块之间没有层级关系。</p>
<p>在业务较简单的情况下，Controller可以取代业务层逻辑，Model可以取代数据访问层功能，看起来MVC就是三层架构</p>
</blockquote>
<h3 id="持久层属不属于三层架构？"><a href="#持久层属不属于三层架构？" class="headerlink" title="持久层属不属于三层架构？"></a>持久层属不属于三层架构？</h3><blockquote>
<p>不属于。</p>
<ul>
<li>三层架构属于逻辑层面的分层，持久层是物理上的分层。</li>
<li>三层架构是代码层面的，持久层不在代码逻辑中</li>
</ul>
</blockquote>
<h3 id="为什么要有数据访问层，业务层直接获取数据？"><a href="#为什么要有数据访问层，业务层直接获取数据？" class="headerlink" title="为什么要有数据访问层，业务层直接获取数据？"></a>为什么要有数据访问层，业务层直接获取数据？</h3><blockquote>
<p>当有多个数据源的时候，业务层直接获取看起来比较乱，因此抽一层专门获取数据</p>
</blockquote>
<h3 id="三层架构中每一层都定义Model对象（UserModel、User、UserEntity），并且提供对应的Mapper，是否有必要？"><a href="#三层架构中每一层都定义Model对象（UserModel、User、UserEntity），并且提供对应的Mapper，是否有必要？" class="headerlink" title="三层架构中每一层都定义Model对象（UserModel、User、UserEntity），并且提供对应的Mapper，是否有必要？"></a>三层架构中每一层都定义Model对象（UserModel、User、UserEntity），并且提供对应的Mapper，是否有必要？</h3><blockquote>
<p>复杂的设计可以通过增加中间层来简化，反过来一样，如果设计很简单，那压根就不需要中间层。自己要掌握这个度。</p>
<p>每一层的数据传递都有对象的丰富和隐藏，用不同的Model对象指代更容易解耦。</p>
<p>更具体的说主要是因为手机端的use case基本上都是CRUD，Domain层没有发挥太大作用，因此可以删掉Model层，Presenter直接获取业务对象。没有破坏依赖规则。</p>
</blockquote>
<h3 id="什么是业务逻辑？"><a href="#什么是业务逻辑？" class="headerlink" title="什么是业务逻辑？"></a>什么是业务逻辑？</h3><p><a href="http://www.uml.org.cn/zjjs/201008021.asp">细说业务逻辑</a></p>
<blockquote>
<ul>
<li>狭义：三层架构中的业务层（Domain），Clean架构中的Use Case层</li>
<li>广义：软件产品=界面和交互+业务逻辑，非界面和交互部分，数据也属于业务。某些业务为数据操作集中型，因此抽取出数据访问层。</li>
<li>从空间上讲，数据属于业务的一部分。</li>
<li>从时间上讲，先有业务，再有数据对象。</li>
<li>一个APP可以没有数据，如计算器等，但不能没有业务逻辑。</li>
</ul>
</blockquote>
<p>由于大部分业务只是简单的CRUD，因此业务逻辑层看起来只是简单的封装了一下数据访问层的操作，尤其在客户端业务层被无限弱化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>架构层次取决于业务复杂度</strong></p>
<p>在C/S、B/S软件中，表示层指的客户端（前端）、业务层和数据访问层在服务端，随着客户端功能的增多，客户端也可以抽取业务层和数据访问层。</p>
<p>传统Web应用中，表示层也在服务端，后来做了前后端分离</p>
<p>前端发展历程：</p>
<ol>
<li>前后端未分离：前端负责写UI模版，后端往模版填数据和逻辑。后端开发完之后统一打包部署。<ol>
<li>后端MVC模式：JSP、PHP、ASP等：后端收到浏览器请求，生成静态页面返回，根据url地址和参数返回不同页面</li>
</ol>
</li>
<li>前后端分离：前端和后端单独开发、分开部署（前端服务、后端服务）。<ol>
<li>SPA单页应用：Ajax，返回不带数据的网页，JS使用Ajax请求数据，局部动态刷新页面。</li>
<li>前端模块化：NodeJS，NPM包管理。前端可以</li>
<li>前端工程化：webpack，编译打包、压缩、优化等</li>
<li>前端MV*架构：Vue、React、Angular等</li>
<li>服务端渲染：把一部分网络请求放到前端的服务端，返回带数据的页面给浏览器，优化首屏体验。后续页面更新通过浏览器请求后端数据</li>
</ol>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/u014644594/article/details/87858315">Clean架构探讨</a></li>
<li><a href="http://www.uml.org.cn/zjjs/201008021.asp">细说业务逻辑</a></li>
<li>《企业应用架构模式》-Martin Flower.</li>
</ul>
<blockquote>
<p>Tips：Martin Flower.：敏捷开发提出者。著有《重构》和《企业应用架构模式》等书</p>
</blockquote>
]]></content>
      <categories>
        <category>架构和设计模式</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>异步概念和常见实现</title>
    <url>/2021/07/15/basic-2021-07-15-%E5%BC%82%E6%AD%A5%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p>
<ul>
<li>同步：就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。</li>
<li>异步：调用在发出之后，方法立即返回，但是结果还没返回。等待计算完结果后被调用者通过状态、消息通知来通知调用者，或通过回调函数处理这个调用。</li>
</ul>
<p><strong>注：这里的同步指的是同步调用，和java的线程同步不一样，线程同步是为了防止多个线程修改共有资源时导致的资源不同步的问题</strong></p>
<h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</p>
<ul>
<li>阻塞调用：指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>
<li>非阻塞调用：指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<p>区别：阻塞代码不继续往下执行，不占用cpu，同步的话代码会继续执行（进入方法里面执行），占用cpu</p>
<h1 id="异步和回调"><a href="#异步和回调" class="headerlink" title="异步和回调"></a>异步和回调</h1><p>异步：调用在发出之后，方法立即返回，但是结果还没返回。等待计算完结果后被调用者通过状态、消息通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>回调：回头调用，将一个函数/接口作为参数传入，在特定时候调用参数方法。</p>
<p>我们常说的回调，按我的理解，包含三个含义：</p>
<ol>
<li>回调是异步过程中的一个环节：调用–&gt;等待结果–&gt;回调结果</li>
<li>回调是异步的一种实现方式：这里指开发者自行实现的回调</li>
<li>异步的本质就是回调：从定义上看，异步和回调都是延迟执行某个方法，异步指这个过程，回调指的是实现。下面提到的异步实现其实都用到了回调，区别只在于框架实现、OS实现、自行实现</li>
</ol>
<p><strong>注：异步可以是单线程，也可以是多线程。但有的异步框架可以方便的切换线程，实现跨线程通信。如Handler、协程、RxJava、EventBus等</strong></p>
<h1 id="常见异步实现方法"><a href="#常见异步实现方法" class="headerlink" title="常见异步实现方法"></a>常见异步实现方法</h1><p>实现异步方式：</p>
<ol>
<li>接口回调</li>
<li>消息通知：Handler、EventBus</li>
<li>Future、Promise</li>
<li>可观察对象：LiveData、Observable</li>
<li>协程</li>
<li>…</li>
</ol>
<p>写法上分为：嵌套写法、链式写法、同步写法</p>
<p>下面列举一些常见异步的实现方法，通过伪代码示例：延时1s模拟请求用户名称返回结果</p>
<h2 id="自定义Callback接口回调"><a href="#自定义Callback接口回调" class="headerlink" title="自定义Callback接口回调"></a>自定义Callback接口回调</h2><p><strong>Callback在代码中可以是匿名内部类，也可以直接继承Callback接口去实现</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onResult</span><span class="params">(result: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">(userId: <span class="type">Int</span>, callback: <span class="type">Callback</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">		thread &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>)  </span><br><span class="line">	  	callback.onResult(<span class="string">&quot;Afauria&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//匿名内部类</span></span><br><span class="line">      <span class="comment">//实现接口</span></span><br><span class="line">        UserModel().getUserName(<span class="number">0</span>, <span class="keyword">object</span>: Callback&lt;String&gt;&#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResult</span><span class="params">(result: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">              println(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Android的Handler"><a href="#Android的Handler" class="headerlink" title="Android的Handler"></a>Android的Handler</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> mHandler: Handler) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">(userId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            mHandler.sendMessage(Message.obtain().apply &#123;</span><br><span class="line">                what = <span class="number">0x1</span></span><br><span class="line">                obj = <span class="string">&quot;Afauria&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> : <span class="type">Handler.Callback &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mHandler = Handler(Looper.getMainLooper(), <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (msg.what) &#123;</span><br><span class="line">            <span class="number">0x1</span> -&gt; &#123;</span><br><span class="line">                println(msg.obj)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        UserModel(mHandler).getUserName(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RxJava的Observable、Flowable"><a href="#RxJava的Observable、Flowable" class="headerlink" title="RxJava的Observable、Flowable"></a>RxJava的Observable、Flowable</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">(userId: <span class="type">Int</span>)</span></span>: Observable&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create &#123; e -&gt;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            e.onNext(<span class="string">&quot;Afauria&quot;</span>)</span><br><span class="line">            e.onComplete()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> disposable = UserModel().getUserName(<span class="number">0</span>)</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe &#123; name -&gt; println(name) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kotlin的协程"><a href="#kotlin的协程" class="headerlink" title="kotlin的协程"></a>kotlin的协程</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">(userId: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Afauria&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> userName = UserModel().getUserName(<span class="number">0</span>)</span><br><span class="line">            withContext(Dispatcher.Main) &#123;</span><br><span class="line">            	print(userName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Flutter的Future对象"><a href="#Flutter的Future对象" class="headerlink" title="Flutter的Future对象"></a>Flutter的Future对象</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; getUser() &#123;</span><br><span class="line">    <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>), () =&gt; <span class="string">&quot;Afauria&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> </span>&#123;</span><br><span class="line">  getUser() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//使用async + await</span></span><br><span class="line">    <span class="keyword">final</span> username = <span class="keyword">await</span> UserModel().getUser();</span><br><span class="line">    <span class="built_in">print</span>(username);</span><br><span class="line">    <span class="comment">//使用Future</span></span><br><span class="line">    UserModel().getUser().then((value) =&gt; <span class="built_in">print</span>(value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EventBus事件总线"><a href="#EventBus事件总线" class="headerlink" title="EventBus事件总线"></a>EventBus事件总线</h2><h2 id="JS-Promise"><a href="#JS-Promise" class="headerlink" title="JS Promise"></a>JS Promise</h2><h2 id="Android-LiveData"><a href="#Android-LiveData" class="headerlink" title="Android LiveData"></a>Android LiveData</h2>]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>程序基础</tag>
      </tags>
  </entry>
  <entry>
    <title>VR技术分类</title>
    <url>/2021/06/11/tech-2021-06-11-VR%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="VR介绍"><a href="#VR介绍" class="headerlink" title="VR介绍"></a>VR介绍</h1><p>VR：综合利用计算机图形系统和各种现实及控制等接口设备，在计算机上生成的、可交互的三维环境中提供沉浸感觉的技术。其中，计算机生成的、可交互的三维环境成为虚拟环境(即Virtual Environment，简称VE)。</p>
<p>人眼双眼看到画面不一样，这种差别让我们能够感知到深度，使事物看起来立体。VR借助了这一原理，给双眼传输不同的画面。</p>
<p>相关技术：头部追踪、空间定位、3D建模、眼球追踪等</p>
<h1 id="VR分类"><a href="#VR分类" class="headerlink" title="VR分类"></a>VR分类</h1><p>VR头盔、VR眼镜这些只是形态上的叫法，这里根据原理进行分类</p>
<table>
<thead>
<tr>
<th></th>
<th>移动端VR</th>
<th>PC端VR</th>
<th>VR一体机</th>
</tr>
</thead>
<tbody><tr>
<td>相同概念</td>
<td>VR盒子、VR眼镜</td>
<td>VR头显、VR头盔、VR眼镜</td>
<td>VR眼镜、VR头盔</td>
</tr>
<tr>
<td>举例</td>
<td>CardBoard、DayDream</td>
<td>HTC Vive、Oculus Rift</td>
<td>三星Gear VR、大鹏一体机、Pico NeoVR</td>
</tr>
<tr>
<td>原理</td>
<td>由两块透镜加盒子组成，将手机放到盒子中，屏蔽外界感知。手机充当屏幕和运算硬件</td>
<td>VR头盔内有两块显示器，借助高性能PC运算能力，将画面传输到VR眼镜中显示。只具备显示和传感、定位功能</td>
<td>具备独立处理器、wifi、蓝牙等的头显。也可以接收HDMI外部输入。</td>
</tr>
<tr>
<td>设备要求</td>
<td>高端手机</td>
<td>高性能PC、高端显卡</td>
<td>可定制软硬件，不需要外部设备</td>
</tr>
<tr>
<td>操作系统</td>
<td>无操作系统</td>
<td>以PC系统Windows 为主</td>
<td>以Android移动系统为主</td>
</tr>
<tr>
<td>交互能力</td>
<td>低。借助手机传感，也可以配备控制器</td>
<td>高。可以搭配各种外设（如手柄、跑道、机车、手枪等），具备空间定位能力</td>
<td>中。带传感、按键、控制器等</td>
</tr>
<tr>
<td>沉浸式体验</td>
<td>低</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>便携性</td>
<td>中</td>
<td>低，需要连HDMI线传输画面，以及各种外设，手柄、定位设备等</td>
<td>中</td>
</tr>
<tr>
<td>价格</td>
<td>便宜</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p>清晰度由屏幕分辨率决定。</p>
<p>画面延迟和刷新率由GPU运算能力和网速决定。</p>
<h1 id="VR视频和全景视频"><a href="#VR视频和全景视频" class="headerlink" title="VR视频和全景视频"></a>VR视频和全景视频</h1><p>全景视频：通过360°全景摄像机拍摄，将一定范围内的某个时间段，记录周围所发生的一切，经过后期的剪辑拼接，将静态的全景图片转化为动态的视频图像展现出来。用户在观看视频的时候，可以随意调节视频上下左右进行观看。</p>
<p>VR视频是用彼此分开的多个摄像机进行拍摄，这样可以捕获左眼和右眼之间的差异。然后再将视频拼合在一起，从而创建出更接近于现实世界的影像，用户在视频中可以获得更具沉浸感的体验。VR视频可以允许用户在同一时间，站在不同的位置观看；</p>
<p>区别：</p>
<ol>
<li>全景视频有别于传统视频单一的观看视角，让人们可以360度自由观看；而VR视频在此基础上，还允许人们在视频场景中任意位置的360度自由观看。</li>
<li>全景视频可以是3D的，也可以是2D的；而VR视频必须是3D的；</li>
<li>全景视频可以通过屏幕观看，也可以带上眼镜观看；而VR视频必须带上头显（即VR眼镜）观看。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>远程服务器操作</title>
    <url>/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h1><h2 id="ssh登录远程主机"><a href="#ssh登录远程主机" class="headerlink" title="ssh登录远程主机"></a>ssh登录远程主机</h2><p>登录远程主机：<code>ssh -p 端口号 远程主机用户名@远程主机域名或ip</code>，输入远程主机密码</p>
<p>ssh（Secure Shell）： Linux下实现远程登录功能的服务，默认 ssh 服务端口号为 22。</p>
<h2 id="堡垒机登录远程主机"><a href="#堡垒机登录远程主机" class="headerlink" title="堡垒机登录远程主机"></a>堡垒机登录远程主机</h2><p>有的公司会采用堡垒机来访问服务器，堡垒机用于多台服务器统一监控和管理、身份认证、账号管理、登录等。</p>
<p>使用堡垒机登录不需要知道主机用户名和密码，而是输入统一4A账号。堡垒机验证之后选择该账号下的主机登录</p>
<p><img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/%E5%A0%A1%E5%9E%92%E6%9C%BA%E7%99%BB%E5%BD%95.png"></p>
<h1 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h1><p>如何将本地文件拷贝到远程主机上？</p>
<h2 id="SMB连接：知道主机用户名和密码"><a href="#SMB连接：知道主机用户名和密码" class="headerlink" title="SMB连接：知道主机用户名和密码"></a>SMB连接：知道主机用户名和密码</h2><p>SMB（Server Message Block）：可以用于跨平台文件传输</p>
<p>Mac电脑连接步骤：Finder-&gt;前往-&gt;连接服务器-&gt;输入<code>smb:username@host</code>-&gt;输入远程主机密码</p>
<img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/连接smb1.png" width="200">

<img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/连接smb2.png" width="500">

<p>连接成功之后可以通过Finder访问或者拷贝文件夹</p>
<img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/连接smb3.png" width="700">

<h2 id="SCP：不知道主机用户名和密码"><a href="#SCP：不知道主机用户名和密码" class="headerlink" title="SCP：不知道主机用户名和密码"></a>SCP：不知道主机用户名和密码</h2><p>scp（secure copy）：scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p>
<p>如果使用堡垒机登录，不知道用户名和密码，无法通过SMB传输文件。此时可以使用SCP命令。步骤如下</p>
<ol>
<li>打开本机ssh服务，让远程主机能够通过ssh登录到本机。没打开的话ssh登录本机会报错<code>ssh: connect to host localhost port 22: Connection refused</code><ol>
<li>打开系统偏好设置-&gt;共享-&gt;远程登录</li>
<li>或者使用命令<code>sudo systemsetup -f -setremotelogin on</code></li>
</ol>
</li>
</ol>
<img src="/2021/05/16/webdev-2021-05-16-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/mac允许远程登录.png" width="600">

<ol start="2">
<li>通过堡垒机登录远程主机</li>
<li>通过scp命令拷贝文件<code>scp -r 用户名@本地主机:本地文件路径 ./</code>，输入本机密码：-r表示拷贝文件夹，<code>./</code>表示拷贝到远程主机当前目录</li>
</ol>
<h2 id="通过远程仓库获取文件"><a href="#通过远程仓库获取文件" class="headerlink" title="通过远程仓库获取文件"></a>通过远程仓库获取文件</h2><p>一种取巧的方式</p>
<ol>
<li>将本地文件push到远程仓库如git仓库、docker仓库等。</li>
<li>登录远程主机，使用pull获取文件。</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>前端网站部署</title>
    <url>/2021/05/16/webdev-2021-05-16-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="虚拟主机、VPS、云服务器"><a href="#虚拟主机、VPS、云服务器" class="headerlink" title="虚拟主机、VPS、云服务器"></a>虚拟主机、VPS、云服务器</h1><p>不用分的很清楚，简单记几个区别：</p>
<ol>
<li>VPS（Virtual Private Server）和虚拟主机没有root权限，云服务器有root权限</li>
<li>VPS是对单台服务器通过虚拟化成多个虚拟服务器，受限于单台服务器性能和资源，主机宕机之后VPS也宕机。云服务器是对多台服务器资源进行虚拟化，具有更好的容灾能力和伸缩性。</li>
</ol>
<h1 id="http-server部署"><a href="#http-server部署" class="headerlink" title="http server部署"></a>http server部署</h1><p><code>npm run build</code>打包出dist之后通过http服务部署，浏览器限制无法直接访问本地html文件</p>
<img src="/2021/05/16/webdev-2021-05-16-%E5%89%8D%E7%AB%AF%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/dist部署.png">

<ol>
<li>使用python内置服务器开启端口访问文件<ol>
<li>Python2：<code>python -m SimpleHTTPServer 8081 </code>，指定端口8081，默认端口8080</li>
<li>Python3：<code>python -m http.server 8081</code></li>
</ol>
</li>
<li>使用node的http server<ol>
<li>安装http server：<code>npm install http-server -g</code></li>
<li>进入dist目录，启动服务端口：<code>http-server -p 3000</code></li>
</ol>
</li>
</ol>
<h1 id="开发脚手架部署"><a href="#开发脚手架部署" class="headerlink" title="开发脚手架部署"></a>开发脚手架部署</h1><p>vite、next等脚手架框架本质也是起了个服务端口。内部使用nodejs实现。</p>
<p>可以把代码拷到云服务器上，直接<code>npm run dev</code>或者<code>npm run build &amp; npm run serve</code>在远程运行，通过ip或者域名+端口访问。</p>
<p>vite和nginx都可以作为Web服务器运行前端页面，也支持配置代理服务。</p>
<p>在我看来，他们的区别只在于<strong>nginx是专业的服务器，性能更好。而vite是一个开发工具</strong>。（PS：如负载均衡、并发强、支持反向代理等，这一块没接触过不懂）</p>
<p>一般情况下vite只在开发时使用，正式环境需要编译打包代码，部署到nginx之类的专业服务器，这个时候vite的配置就不生效了，因此需要使用nginx做反向代理。</p>
<h1 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h1><p><code>npm run build</code>打包出dist之后部署到Nginx服务器上，Nginx服务器支持反向代理，域名，内网穿透等。（Nginx配置不是很熟悉）</p>
<h1 id="结合Docker部署"><a href="#结合Docker部署" class="headerlink" title="结合Docker部署"></a>结合Docker部署</h1><ol>
<li>Docker下载Nginx镜像或者Node镜像：<code>docker pull 镜像名称[:版本号]</code></li>
<li>将代码或者静态资源打包拷贝或者挂载到Docker容器中：<code>docker run</code>的时候加<code>-v  主机路径:容器路径</code></li>
<li>主机端口映射到容器端口：<code>docker run</code>的时候加<code>-p 主机端口:容器端口</code></li>
<li>在容器中启动相应的服务：<code>docker exec</code>进入容器，按照前面提到的几种方式启动服务</li>
</ol>
<h2 id="Dockerfile打包Docker镜像"><a href="#Dockerfile打包Docker镜像" class="headerlink" title="Dockerfile打包Docker镜像"></a>Dockerfile打包Docker镜像</h2><h3 id="使用Nginx镜像"><a href="#使用Nginx镜像" class="headerlink" title="使用Nginx镜像"></a>使用Nginx镜像</h3><ol>
<li>编写Dockerfile</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据nginx镜像创建新的镜像(可以加上:tag)</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="comment"># 将dist文件拷贝到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dist/ /usr/share/nginx/html/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打包Docker镜像<code>docker build -t 镜像名称[:镜像版本] .</code>，<code>.</code>表示当前路径</li>
<li>启动容器：<code>docker run -itd --name 容器名称 -p 主机端口:容器端口 镜像名称</code></li>
<li>进入容器：<code>docker exec -it 容器名称 /bin/bash</code></li>
<li>启动nginx服务：<code>/usr/sbin/nginx</code>命令开启nginx服务</li>
</ol>
<p>如果有其他配置，可以进入容器下载vi工具编辑。也可以将宿主机上的配置文件挂载到容器中。</p>
<p>可能会出现<code>403 forbidden</code>或者<code>open() failed (13 permission denied)</code>：</p>
<ol>
<li>使用<code>chmod -R 777</code>修改读写权限</li>
<li>Nginx用户配置</li>
<li>Nginx文件路径和网页入口配置</li>
<li>关闭SELinux：修改<code>/etc/selinux/config</code>文件，将SELINUX的值设置为disabled。重启生效。<ol>
<li>临时关闭：<code>setenforce 0</code>，重启失效</li>
</ol>
</li>
</ol>
<p>参考文章：<a href="https://blog.csdn.net/onlysunnyboy/article/details/75270533">解决Nginx出现403 forbidden (13: Permission denied)报错的四种方法</a></p>
<h3 id="使用Node镜像"><a href="#使用Node镜像" class="headerlink" title="使用Node镜像"></a>使用Node镜像</h3><ol>
<li>编写Dockerfile</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据node镜像创建新的镜像(可以加上:tag)</span></span><br><span class="line"><span class="keyword">FROM</span> node</span><br><span class="line"><span class="comment"># 创建容器目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /home/myservice</span></span><br><span class="line"><span class="comment"># 容器工作区，进入容器的时候默认进入该目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home/myservice</span></span><br><span class="line"><span class="comment"># 将文件拷贝到工作区中</span></span><br><span class="line"><span class="comment"># 为了避免node_modules里面的文件也copy，可以配置.dockerignore</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /home/myservice</span></span><br><span class="line"><span class="comment"># npm安装依赖，RUN指令会在构建image的时候执行</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="comment"># 启动npm服务，CMD指令会在容器启动的时候执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> npm run serve</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打包Docker镜像</li>
<li>启动容器</li>
<li>由于配置了CMD指令，启动的时候就会执行<code>npm run serve</code></li>
</ol>
<p>除了拷贝文件到容器中，还可以使用挂载，将文件挂载到容器工作区中。</p>
<blockquote>
<p>挂载不能在Dockerfile中编写，需要启动容器的时候指定，因为镜像可以下载到不同宿主机，宿主机可能会变导致路径不正确</p>
</blockquote>
<h2 id="Docker-Compose运行容器"><a href="#Docker-Compose运行容器" class="headerlink" title="Docker Compose运行容器"></a>Docker Compose运行容器</h2><ol>
<li>每次创建容器都需要指定挂载路径、端口映射等较麻烦。</li>
<li>多个容器启动需要一个一个执行<code>docker run</code>不方便。</li>
</ol>
<p>可以使用docker compose+yml配置文件创建和启动容器</p>
<ol>
<li>安装docker compose工具</li>
<li>编写yml配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">recruit-front:</span>  <span class="comment"># 指定服务名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">recruit-front</span> <span class="comment"># 镜像名称</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">recruit-front</span> <span class="comment"># 容器名称</span></span><br><span class="line">    <span class="attr">ports:</span>    <span class="comment"># 指定端口映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 指定挂载路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/cloud/recruit:/home/recruit</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动服务：<code>docker-compose up</code>，-d表示后台执行<ol>
<li>启动指定服务：<code>docker-compose up SERVICE_NAME</code>，如该服务依赖了其他服务，会自动启动依赖项。</li>
<li>停止服务：<code>docker-compose stop [SERVICE_NAME]</code></li>
</ol>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>简单的网站使用http server部署即可。如果需要配置代理服务等使用下面的方式</li>
<li>内部网站使用vite或者node等开发工具部署。</li>
<li>公共网站打包部署到nginx或者其他专业服务器上。</li>
<li>结合Docker部署，可以使用现成的环境，并且打包镜像可以移植到不同平台，保证环境一致</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何把A网站的数据爬到B网站显示</title>
    <url>/2021/05/16/tech-2021-05-16-%E5%A6%82%E4%BD%95%E6%8A%8AA%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%88%B0B%E7%BD%91%E7%AB%99%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="爬虫介绍"><a href="#爬虫介绍" class="headerlink" title="爬虫介绍"></a>爬虫介绍</h1><p>主要有两种方式</p>
<ol>
<li>通过网站提供的API进行爬取<ol>
<li>有的网站不提供API。</li>
<li>API可能收费。</li>
<li>API可能有速率限制</li>
<li>API可能不会公开部分数据</li>
</ol>
</li>
<li>基于HTML的数据抓取：通过访问网页的HTML代码，并从中抓取到所需节点上的数据。网页结构一旦变化，抓取代码可能需要重写。<ol>
<li>全网爬虫：主要用于搜索引擎。深度优先策略、广度优先策略。</li>
<li>聚焦网络爬虫：爬取特定主题页面。</li>
<li>增量式网络爬虫：只爬取新产生或者发生变化的页面。</li>
<li>Deep Web爬虫：需要提交表单才能获取到页面</li>
</ol>
</li>
</ol>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>大体有两种思路</p>
<ol>
<li>使用python定期抓取数据，写入自己的数据库，再自己写个后端服务，前端请求自己的后端数据</li>
</ol>
<pre class="mermaid">graph TB
A网站--定期拉取数据-->python脚本
B网站--请求数据-->后台服务
subgraph 后端
python脚本--保存数据-->数据库
后台服务-->数据库
end</pre>

<ol start="2">
<li>不需要搭建后端和数据库，直接前端请求A网站后端接口数据</li>
</ol>
<p>这里采用第二种方式，坑有点多，下面一一介绍。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="找到请求URL并模拟请求获取数据"><a href="#找到请求URL并模拟请求获取数据" class="headerlink" title="找到请求URL并模拟请求获取数据"></a>找到请求URL并模拟请求获取数据</h2><ol>
<li>控制台找到接口url和请求头等，postman模拟请求</li>
<li>由于后端有做校验，请求会失败，返回403或者500</li>
<li>从控制台中找到<code>Request Header</code>和<code>Cookie</code>等，复制到postman中模拟请求，成功说明爬数据可行。<ol>
<li>大部分header信息是没用的，可以一个一个删除，尝试请求，最后只留下关键的请求头和cookie。</li>
</ol>
</li>
<li>这里发现主要有两个信息，一个是csrfToken，一个是loginToken（实际名称不是这个）。<ol>
<li>csrfToken为自定义请求头，保存在headers中，错误服务端会返回500，并提示<code>invalid csrf token</code></li>
<li>loginToken保存在headers的cookie字段中，错误会返回200，提示登录失效，请重新登录</li>
<li>还有两个koa字段，用来配合csrfToken做校验，这三个值需要对应。由于保存在cookie中，获取方式和loginToken类似，因此不做详细说明</li>
</ol>
</li>
</ol>
<p><code>RequestHeader</code>关键信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Cookie为浏览器自带的Header</span></span><br><span class="line">Cookie: loginToken=***; koa.xxx=***; koa.xxx.sig=***;</span><br><span class="line"><span class="meta">#</span><span class="bash"> csrf-token为服务端自定义Header</span></span><br><span class="line">csrf-token: *** </span><br></pre></td></tr></table></figure>

<p><strong>这里token可能会过期，我们不可能每次都去手动复制、粘贴请求头。因此需要动态抓取csrfToken和loginToken。</strong></p>
<p>控制台中可以查到在登录页面，后端返回的<code>Response Header</code>中的<code>Set-Cookie</code>字段带了loginToken，设置到了浏览器</p>
<p>csrfToken找了半天发现嵌在网页的body中。</p>
<p>我们的目标就是获取到该页面，通过正则从html中提取csrfToken。</p>
<img src="/2021/05/16/tech-2021-05-16-%E5%A6%82%E4%BD%95%E6%8A%8AA%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E7%88%AC%E5%88%B0B%E7%BD%91%E7%AB%99%E6%98%BE%E7%A4%BA/csrfToken获取.png" width="800">

<h2 id="Python模拟登录获取Cookie和Token等信息"><a href="#Python模拟登录获取Cookie和Token等信息" class="headerlink" title="Python模拟登录获取Cookie和Token等信息"></a>Python模拟登录获取Cookie和Token等信息</h2><blockquote>
<p><strong>可以先用postman模拟，验证可行性。</strong></p>
</blockquote>
<h3 id="获取loginToken"><a href="#获取loginToken" class="headerlink" title="获取loginToken"></a>获取loginToken</h3><ol>
<li>使用python请求登录页面url：需要设置相应的登录信息，如用户名和密码等。<ol>
<li>这里看到请求数据也是保存在cookie，而不是在<code>RequestBody</code>中，不过这一部分基本是不变的，因此可以直接复制粘贴cookie到<code>RequestHeader</code>中。</li>
</ol>
</li>
<li>登录成功后从<code>Response Header</code>中获取到相应的cookie，代码如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    <span class="keyword">global</span> loginToken</span><br><span class="line">    url = <span class="string">&quot;登录url&quot;</span></span><br><span class="line">    cookie = http.cookiejar.CookieJar()</span><br><span class="line">    handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">    opener = urllib.request.build_opener(handler)</span><br><span class="line">    opener.addheaders = [</span><br><span class="line">    		<span class="comment">#...</span></span><br><span class="line">      	<span class="comment"># 直接拷贝该url的cookie到Header中即可</span></span><br><span class="line">        (<span class="string">&#x27;Cookie&#x27;</span>, <span class="string">&#x27;...包含用户名之类的信息&#x27;</span>),</span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">    ]</span><br><span class="line">    request = urllib.request.Request(method=<span class="string">&quot;GET&quot;</span>, url=url)</span><br><span class="line">    response = opener.<span class="built_in">open</span>(request)</span><br><span class="line">    <span class="comment"># 获取ResponseHeader中的Cookie</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cookies: %s = %s&#x27;</span> % (item.name, item.value))</span><br><span class="line">        <span class="keyword">if</span> item.name == <span class="string">&quot;loginToken&quot;</span>:</span><br><span class="line">            loginToken = item.value</span><br></pre></td></tr></table></figure>

<p>这里使用python的<code>requests</code>包请求会失败，原因应该是登录url有几次重定向。</p>
<blockquote>
<p> 使用<code>urllib.request + http.cookiejar</code>这两个包请求并获取cookie</p>
</blockquote>
<h3 id="获取csrfToken"><a href="#获取csrfToken" class="headerlink" title="获取csrfToken"></a>获取csrfToken</h3><p>请求html网页，使用正则提取csrfToken的值，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKey</span>():</span></span><br><span class="line">    <span class="keyword">global</span> csrfToken</span><br><span class="line">    <span class="keyword">global</span> koa1</span><br><span class="line">    <span class="keyword">global</span> koa2</span><br><span class="line">    cookie = http.cookiejar.CookieJar()</span><br><span class="line">    handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">    opener = urllib.request.build_opener(handler)</span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">&#x27;请求url&#x27;</span>)</span><br><span class="line">    <span class="comment"># read读取结果</span></span><br><span class="line">    code_of_html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">		<span class="comment"># 正则提取CSRFToken字段的值</span></span><br><span class="line">    csrfToken = re.search(<span class="string">&#x27;&#x27;&#x27;(?&lt;=CSRFToken&amp;quot;:&amp;quot;).*?(?=&amp;quot;)&#x27;&#x27;&#x27;</span>, code_of_html).group()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;csrfToken: &quot;</span> + csrfToken)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">      	<span class="comment"># 这里其实除了csrfToken之外还有两个保存在cookie字段，是用来配合csrfToken做校验的。由于获取方式和loginToken类似，因此不做详细说明</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cookies: %s = %s&#x27;</span> % (item.name, item.value))</span><br><span class="line">        <span class="keyword">if</span> item.name == <span class="string">&quot;koa.***&quot;</span>:</span><br><span class="line">            koa1 = item.value</span><br><span class="line">        <span class="keyword">if</span> item.name == <span class="string">&quot;koa.***.sig&quot;</span>:</span><br><span class="line">            koa2 = item.value</span><br></pre></td></tr></table></figure>

<h2 id="python请求接口数据"><a href="#python请求接口数据" class="headerlink" title="python请求接口数据"></a>python请求接口数据</h2><p>获取到token信息之后，添加到相应的请求头中即可，模拟请求成功，结果同postman。</p>
<p>走到这一步方案一和方案二还是一样的。用python请求数据先验证可行性，后面实在走不通也可以切换到方案一，将python爬到的数据保存到数据库。</p>
<p>事实上，由于前端浏览器环境和直接用python有很大的不同，后面会有很多坑。</p>
<h2 id="前端请求接口数据"><a href="#前端请求接口数据" class="headerlink" title="前端请求接口数据"></a>前端请求接口数据</h2><p>这里先不管请求头怎么设置，直接请求数据，可以使用Chrome ModHeader插件手动填写请求头。</p>
<h3 id="浏览器跨域请求问题"><a href="#浏览器跨域请求问题" class="headerlink" title="浏览器跨域请求问题"></a>浏览器跨域请求问题</h3><ol>
<li>方法1：服务器设置允许跨域。由于是爬别人的数据，没有后端，因此走不通。</li>
<li>方法2：使用代理，将请求转发到代理服务，由代理服务拿到结果后返回给浏览器。</li>
</ol>
<p>以vue+vite配置为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vite.config.js配置代理</span></span><br><span class="line">server: &#123;</span><br><span class="line">	<span class="comment">//配置代理解决跨域问题</span></span><br><span class="line">	proxy: &#123;</span><br><span class="line">		<span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">			target: <span class="string">&quot;https://hostname.com/&quot;</span>, <span class="comment">// 你请求的第三方接口</span></span><br><span class="line">			changeOrigin: <span class="literal">true</span>, <span class="comment">// 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题</span></span><br><span class="line">			rewrite: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/api/</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="vite和nginx部署"><a href="#vite和nginx部署" class="headerlink" title="vite和nginx部署"></a>vite和nginx部署</h4><p>vite和nginx都可以作为Web服务器运行前端页面，也支持配置代理服务。vite内部还是通过nodejs启动服务器</p>
<p>在我看来，他们的区别只在于<strong>nginx是专业的服务器，性能更好。而vite是一个开发工具</strong>。（PS：如负载均衡、并发强、支持反向代理等，这一块没接触过不懂）</p>
<p>一般情况下vite只在开发时使用，正式环境需要编译打包代码，部署到nginx之类的专业服务器，这个时候vite的配置就不生效了，因此再使用nginx做反向代理。</p>
<p>考虑到内部使用的小型网站，直接使用vite部署即可。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vite build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vite preview&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//npm run build &amp; npm run serve运行</span></span><br></pre></td></tr></table></figure>

<h3 id="Axios设置请求头问题"><a href="#Axios设置请求头问题" class="headerlink" title="Axios设置请求头问题"></a>Axios设置请求头问题</h3><h4 id="Refused-to-set-unsafe-header-“Cookie”"><a href="#Refused-to-set-unsafe-header-“Cookie”" class="headerlink" title="Refused to set unsafe header “Cookie”"></a>Refused to set unsafe header “Cookie”</h4><p>axios请求配置headers报错： Refused to set unsafe header “Cookie”。</p>
<blockquote>
<p>w3c规定，添加以下不安全的请求头，浏览器会终止请求。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Charset</span><br><span class="line">Accept-Encoding</span><br><span class="line">Connection</span><br><span class="line">Content-Length</span><br><span class="line">Cookie</span><br><span class="line">Cookie2</span><br><span class="line">Content-Transfer-Encoding</span><br><span class="line">Date</span><br><span class="line">Expect</span><br><span class="line">Host</span><br><span class="line">Keep-Alive</span><br><span class="line">Referer</span><br><span class="line">TE</span><br><span class="line">Trailer</span><br><span class="line">Transfer-Encoding</span><br><span class="line">Upgrade</span><br><span class="line">User-Agent</span><br><span class="line">Via</span><br></pre></td></tr></table></figure>

<p>服务端自定义的请求头csrfToken不会有问题。因此关键信息只有cookie。</p>
<p>解决方案：</p>
<blockquote>
<p>js使用document.cookie给浏览器设置cookie，请求的时候浏览器会自动带上</p>
</blockquote>
<p><strong>如果还有其他不安全的Header需要设置，暂时不知道怎么解决，这取决于服务端</strong></p>
<p>实在走不通就只能换回方案一，或者通过Mod Header手动填写Headers。由于token会过期，因此隔一段时间就要改很麻烦</p>
<h4 id="带Http-Only的cookie，无法通过document-cookie获取和设置"><a href="#带Http-Only的cookie，无法通过document-cookie获取和设置" class="headerlink" title="带Http Only的cookie，无法通过document.cookie获取和设置"></a>带Http Only的cookie，无法通过document.cookie获取和设置</h4><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/36197012">浅谈Js 操作Cookie，以及HttpOnly 的限制</a></p>
<p>简单来说，后端通过<code>ResponseHeader</code>的<code>Set-Cookie</code>字段设置浏览器Cookie，如果带了httponly标志，表示该cookie只能通过服务端修改，客户端浏览器无法通过JS的document.cookie获取和设置该cookie。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set-Cookie: loginToken=***; path=/; httponly</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HttpOnly是包含在Set-Cookie HTTP响应头文件中的附加标志。生成cookie时使用HttpOnly标志有助于降低客户端脚本访问受保护cookie的风险（如果浏览器支持）</p>
</blockquote>
<p>解决方案：</p>
<blockquote>
<p>浏览器设置退出的时候清除该网站cookie。</p>
<p>原因：网页首次加载的时候可以设置该Cookie，因为该httponly的标志是服务端Response的时候设置的。只要清除该Cookie，每次打开网页通过document.cookie设置即可。</p>
</blockquote>
<h2 id="前端模拟登录动态获取请求头和Token"><a href="#前端模拟登录动态获取请求头和Token" class="headerlink" title="前端模拟登录动态获取请求头和Token"></a>前端模拟登录动态获取请求头和Token</h2><p>这里存在很多问题：</p>
<ol>
<li>跨域问题</li>
<li>登录url重定向：前端请求不知道支不支持处理重定向后的结果</li>
<li>用户信息加密：如果不知道加密算法，即使输入了账号密码也不行</li>
<li>4A登录：大部分公司有单点登录的门户，单点登录返回的token，不是实际业务网站的token，因此即使登录了也没法通过这个token请求接口数据。</li>
</ol>
<p>这些问题前端比较难解决，除非知道正式的登录接口如何请求。因此最终选了其他方案。</p>
<blockquote>
<p>前面通过python模拟登录，可以拿到token等信息，只要自己写个接口，返回token信息的json即可。</p>
<p>取巧的方式：不需要写代码和接口，直接把token写到一个文件中，使用python内置的http服务器开启服务端口，访问该文件即可。</p>
<ul>
<li>Python2：<code>python -m SimpleHTTPServer 8081 </code>，指定端口8081，默认端口8080</li>
<li>Python3：<code>python -m http.server 8081</code></li>
</ul>
</blockquote>
<h2 id="python定期更新token"><a href="#python定期更新token" class="headerlink" title="python定期更新token"></a>python定期更新token</h2><p>token隔一段时间会更新，通过python的schedule定期执行脚本，更新token</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span>():</span></span><br><span class="line">    os.system(<span class="string">&quot;python3 generate_cookie.py&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    schedule.every(<span class="number">4</span>).hours.do(job)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Press Ctrl+&#123;0&#125; to exit&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Break&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    os.system(<span class="string">&quot;python start.py &amp;&quot;</span>)</span><br><span class="line">    job()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        schedule.run_pending()</span><br></pre></td></tr></table></figure>



<h2 id="python-http服务器跨域问题"><a href="#python-http服务器跨域问题" class="headerlink" title="python http服务器跨域问题"></a>python http服务器跨域问题</h2><p>使用python服务器开放cookie文件之后，前端请求cookie文件，提示跨域（域名相同，端口号不一样也会跨域）</p>
<blockquote>
<p>python服务器设置允许跨域。代码如下</p>
<p>通过该脚本启动服务<code>python start.py &amp;</code>，替代<code>python -m http.server 8080</code>。&amp;表示后台执行脚本</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Python 3</span></span><br><span class="line">    <span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, SimpleHTTPRequestHandler, test <span class="keyword">as</span> test_orig</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span> (<span class="params">*args</span>):</span></span><br><span class="line">        test_orig(*args, port=<span class="built_in">int</span>(sys.argv[<span class="number">1</span>]) <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">8080</span>)</span><br><span class="line"><span class="keyword">except</span> ImportError: <span class="comment"># Python 2</span></span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer, test</span><br><span class="line">    <span class="keyword">from</span> SimpleHTTPServer <span class="keyword">import</span> SimpleHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORSRequestHandler</span> (<span class="params">SimpleHTTPRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end_headers</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.send_header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        SimpleHTTPRequestHandler.end_headers(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test(CORSRequestHandler, HTTPServer)</span><br></pre></td></tr></table></figure>

<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里前端网页已经能够拿到其他网站的数据了，具体拿到这个数据怎么处理，怎么组装就要写逻辑了。</p>
<p>别人网站的接口数据格式一般情况下就只适用于自身的UI和业务，放到我们自己的网站UI肯定需要组装和适配。</p>
<p>总结：一步一个坑</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown生成目录结构树</title>
    <url>/2021/04/12/tool-2021-4-12-FileTree/</url>
    <content><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>全局安装tree：<code>npm install tree-node-cli -g</code></li>
<li>查看帮助：<code>tree --help</code>，-L 确定目录层级，-I排除某个文件夹</li>
<li>进入文件夹：示例输入<code>tree -L 4 -I node_modules</code>，效果如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sample-shopping</span><br><span class="line">├── index.html</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   └── favicon.ico</span><br><span class="line">├── README.md</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   ├── assets</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   └── HelloWorld.vue</span><br><span class="line">│   ├── main.ts</span><br><span class="line">│   └── shims-vue.d.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── vite.config.ts</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>Windows下系统自带了一个tree命令，直接输入tree会调用系统的命令</p>
<blockquote>
<p>可以使用treee命令，如上示例改为<code>treee -L 4 -I node_modules</code></p>
<p>npm帮我们创建了两个cmd文件</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>NPM笔记</title>
    <url>/2021/04/12/note-2021-04-12-NPM/</url>
    <content><![CDATA[<h2 id="npm包版本规则"><a href="#npm包版本规则" class="headerlink" title="npm包版本规则"></a>npm包版本规则</h2><p>范围语法：版本号表示<code>[major, minor, patch]</code>即<code>[大版本, 小版本, 补丁版本]</code></p>
<ol>
<li><code>-</code>：匹配两个版本之间的范围。<code>X.Y.Z - A.B.C</code>表示版本号<code>X.Y.Z &lt;= version &lt;= A.B.C</code><ul>
<li>省略的版本位只需要满足开头部分：如<code>1.2 - 2.3</code>表示<code>1.2.0 &lt;= version &lt; 2.4.0</code>。即匹配<code>1.2</code>和<code>2.3</code>开头的版本</li>
</ul>
</li>
<li><code>*</code>或者<code>X</code>、<code>x</code>：通配符，表示该位可以是任意版本。也可以省略不写<ul>
<li><code>*</code>：表示<code>&gt;=0.0.0</code>，即任意版本。<code>&quot;*&quot; == &quot;&quot;</code></li>
<li><code>1.x</code>：表示<code>1.0.0 &lt;= version &lt; 2.0.0</code>，即只匹配major位，minor和patch位可以是任意版本。<code>&quot;1.x&quot; == &quot;1&quot;</code></li>
</ul>
</li>
<li><code>~</code>：如果指定了次要版本，则允许更新补丁版本，次要版本号不变。如果没有指定次要版本，则允许次要版本更改<ul>
<li><code>~1.2.3</code>：表示<code>1.2.3 &lt;= version &lt; 1.3.0</code></li>
<li><code>~1.2</code>：表示<code>1.2.0 &lt;= version &lt; 1.3.0</code></li>
<li><code>~0.2.3</code>：表示<code>0.2.3 &lt;= version &lt; 0.3.0</code></li>
<li><code>~0</code>：表示<code>0.0.0 &lt;= version &lt; 1.0.0</code>。（允许次要版本更改）</li>
<li><code>~1</code>：表示<code>1.0.0 &lt;= version &lt; 2.0.0</code>。（允许次要版本更改）</li>
</ul>
</li>
<li><code>^</code>：不会修改最左侧的第一个非0数字。第一个非0位后边才可修改。<ul>
<li><code>^1.2.3</code>：表示<code>1.2.3 &lt;= version &lt; 2.0.0</code>。第一个非0位是大版本，大版本不变，允许更新小版本和次要版本</li>
<li><code>^0.2.3</code>：表示<code>0.2.3 &lt;= version &lt; 0.3.0</code>。第一个非0位是小版本，小版本不变，允许更新补丁版本</li>
<li><code>^0.0.3</code>：表示<code>0.0.3 &lt;= version &lt; 0.0.4</code>。第一个非0位是补丁版本，补丁版本不变，可能有beta版本，如<code>0.0.3-beta</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Github访问不稳定解决</title>
    <url>/2021/04/12/note-2021-04-12-GithubConnection/</url>
    <content><![CDATA[<h1 id="GitHub访问不稳定"><a href="#GitHub访问不稳定" class="headerlink" title="GitHub访问不稳定"></a>GitHub访问不稳定</h1><h2 id="访问慢的原因"><a href="#访问慢的原因" class="headerlink" title="访问慢的原因"></a>访问慢的原因</h2><p>DNS解析耗时。</p>
<ul>
<li>DNS（域名系统，Domain Name System）：将<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D">域名</a>和<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>相互映射的一个分布式数据库。</li>
<li>DNS（域名服务器，Domain Name Server）：将域名转换为IP地址的服务器。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>手动修改系统hosts文件，将github域名对应的ip保存到hosts文件中，访问github的时候可以直接访问该ip，不需要dns解析。</p>
<ul>
<li>windows系统在<code>C:\Windows\System32\drivers\etc\hosts</code>，打开普通用户读写权限<code>右键-属性-安全-选择当前用户-编辑-修改权限-确认</code></li>
<li>mac系统在<code>/etc/hosts</code>，sudo申请权限</li>
</ul>
<blockquote>
<p>Hosts是一个没有扩展名的系统文件，其作用就是保存常用的网址域名与其对应IP地址的映射，当用户在浏览器中输入一个需要登录的网址域名时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会将网址提交DNS服务器进行IP地址的解析，再进行访问。</p>
</blockquote>
<p>步骤如下：</p>
<ol>
<li><p><a href="https://github.com.ipaddress.com/">查询github网站IP</a></p>
</li>
<li><p><a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">查询github域名IP</a></p>
</li>
<li><p><a href="https://github.com.ipaddress.com/assets-cdn.github.com">查询github静态资源IP</a></p>
</li>
<li><p>修改hosts文件，添加如下映射。前三个步骤如果查到多个IP的话可以配置多个</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure></li>
<li><p>cmd执行命令，刷新DNS缓存：<code>ipconfig /flushdns</code></p>
</li>
<li><p>隔一段时间ip可能会变，需要重新配置</p>
</li>
<li><p>Github上有牛人提供了脚本，一键获取github最新的IP，并更新hosts文件，clone下来，执行index.cmd即可。<a href="https://github.com/luozheao/setHost">https://github.com/luozheao/setHost</a></p>
</li>
</ol>
<p>附：查询ip地址的网站：<a href="https://www.ipaddress.com/">ipaddress网站</a>、<a href="http://tool.chinaz.com/dns">站长工具</a></p>
<h2 id="GitPage博客无法访问"><a href="#GitPage博客无法访问" class="headerlink" title="GitPage博客无法访问"></a>GitPage博客无法访问</h2><p>同理，只需要查询博客地址对应的IP，配置hosts就可以解决了。</p>
<p>困扰已久的问题，一直以为是需要翻墙vpn，原来是DNS服务器限制。</p>
<p>当然有时候也确实和网络有关。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>FCM推送</title>
    <url>/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<h1 id="FCM（Firebase-Cloud-Message）推送"><a href="#FCM（Firebase-Cloud-Message）推送" class="headerlink" title="FCM（Firebase Cloud Message）推送"></a>FCM（Firebase Cloud Message）推送</h1><h2 id="Firebase介绍"><a href="#Firebase介绍" class="headerlink" title="Firebase介绍"></a>Firebase介绍</h2><p>Firebase是一家实时后端数据库公司，提供多种产品帮助开发者快速构建App功能。2014年被Google收购。</p>
<ul>
<li>IaaS（Infrastructure as a Service）基础设施即服务：提供基础设施。如阿里云</li>
<li>PaaS（Platform as a Service）平台即服务：提供软件开发能力的平台，如涂鸦开发者平台</li>
<li>SaaS（Software as a Service）软件即服务：提供软件开发，俗称软件外包</li>
<li>BaaS（Backend as a Service）后端即服务：提供后台云服务、云存储，简化移动应用开发，如Firebase、七牛云、友盟等</li>
</ul>
<p>支持的功能：有免费和付费</p>
<ul>
<li><a href="https://firebase.google.com/docs">Firebase开发文档</a></li>
<li><a href="https://console.firebase.google.com/project/smarthome-8684b/features?hl=zh_cn">Firebase产品和功能</a></li>
<li><a href="https://firebase.google.com/docs/android/setup#available-libraries">Firebase依赖库</a></li>
</ul>
<p><img src="/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/Firebase-Function.png" alt="Firebase产品和功能"></p>
<p>相关概念：<a href="https://firebase.google.com/docs/projects/learn-more">Firebase说明</a>、<a href="https://firebase.google.com/docs/android/learn-more">Android和Firebase更多说明</a></p>
<ul>
<li>Firebase产品：Firebase提供的功能或服务</li>
<li>Firebase项目：一个项目中可以有多个应用（iOS、Android、Web等），同一项目中的资源共享</li>
<li>Firebase应用：不同平台应用，同一平台不同包名应用</li>
<li>Google Cloud：Firebase项目实际是Google Cloud项目，具有Firebase特定配置和服务。GCM-&gt;FCM</li>
<li>Firebase控制台：管理Firebase项目、应用、产品等</li>
<li>谷歌三件套，功能边界<ul>
<li>Google Play服务框架：Android的后台服务，提供常用的Google API调用，如Google登录服务、Google地图服务等</li>
<li>Google Play商店：Google应用商店，依赖Google Play服务</li>
<li>Google Play游戏服务：提供手机游戏开发的API，不安装的话可能无法正常运行Google Play商店的游戏</li>
</ul>
</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/diagram-FCM.png" alt="架构"></p>
<p><img src="/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/push_flow.jpeg"></p>
<p><img src="/2020/12/14/android-2020-12-14-FCM%E6%8E%A8%E9%80%81/push_flow.png"></p>
<h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><table>
<thead>
<tr>
<th></th>
<th>通知消息</th>
<th>数据消息（透传消息）</th>
<th>通知+数据</th>
</tr>
</thead>
<tbody><tr>
<td>接收方式</td>
<td>由SDK处理</td>
<td>由应用自行处理</td>
<td></td>
</tr>
<tr>
<td>数据格式</td>
<td>通知title、body</td>
<td>自定义键值对</td>
<td>通知内容+数据内容</td>
</tr>
<tr>
<td>发送方式</td>
<td>控制台发送、服务器发送</td>
<td>服务器发送</td>
<td>控制台发送、服务器发送</td>
</tr>
</tbody></table>
<p>客户端接收消息</p>
<table>
<thead>
<tr>
<th align="left">应用状态</th>
<th align="left">通知</th>
<th align="left">数据</th>
<th align="left">通知+数据</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前台</td>
<td align="left"><code>onMessageReceived</code></td>
<td align="left"><code>onMessageReceived</code></td>
<td align="left"><code>onMessageReceived</code></td>
</tr>
<tr>
<td align="left">后台</td>
<td align="left">系统任务栏显示</td>
<td align="left"><code>onMessageReceived</code></td>
<td align="left">通知：系统任务栏显示，数据：通知栏跳转intent的extras属性。</td>
</tr>
</tbody></table>
<h2 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h2><p><strong>要系统带GMS，国内手机厂商一般做了阉割</strong></p>
<p><a href="//todo">实操Demo</a></p>
<h3 id="手动添加Firebase"><a href="#手动添加Firebase" class="headerlink" title="手动添加Firebase"></a>手动添加Firebase</h3><ol>
<li><p>控制台创建Firebase项目</p>
</li>
<li><p>Firebase项目添加应用，填入应用包名</p>
</li>
<li><p>下载<code>google-services.json</code>文件，添加到application模块中</p>
</li>
<li><p>Gradle添加google服务插件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//项目build.gradle</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    google()  <span class="comment">// Google&#x27;s Maven repository</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath <span class="string">&#x27;com.google.gms:google-services:4.3.4&#x27;</span>  <span class="comment">// Google Services plugin</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    google()  <span class="comment">// Google&#x27;s Maven repository</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模块引入插件（<code>app/build.gradle</code>）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.google.gms.google-services&#x27;</span>  <span class="comment">// Google Services plugin</span></span><br></pre></td></tr></table></figure></li>
<li><p>模块添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用BoM，可以通过仅指定一个版本（BoM的版本）来管理所有Firebase库版本。</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Import the BoM for the Firebase platform</span></span><br><span class="line">    implementation platform(<span class="string">&#x27;com.google.firebase:firebase-bom:26.2.0&#x27;</span>)</span><br><span class="line">    implementation <span class="string">&#x27;com.google.firebase:firebase-messaging-ktx&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.firebase:firebase-analytics-ktx&#x27;</span><span class="comment">//analytic可以移除，用于演示BoM作用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.不使用BoM</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.google.firebase:firebase-messaging-ktx:21.0.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.firebase:firebase-analytics-ktx:18.0.0&#x27;</span><span class="comment">//analytic可以移除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个Service继承<code>FirebaseMessagingService</code>，Manifest注册服务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.MyFirebaseMessagingService&quot;</span><br><span class="line">    android:exported=&quot;false&quot;&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.google.firebase.MESSAGING_EVENT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取令牌：</p>
<ul>
<li>主动获取：<code>FirebaseMessaging.getInstance().getToken()</code></li>
<li>Token刷新回调：onNewToken，应用卸载安装等会触发token刷新</li>
</ul>
</li>
<li><p>模拟发送下行消息（下发给客户端，上行消息：客户端发给服务端）：可以指定应用、指定主题、指定设备组、指定设备token等将消息发送给特定用户或群体</p>
<ul>
<li>控制台发送</li>
<li>REST API调用</li>
<li>后台应用不同语言接入服务端SDK，调用SDK方法</li>
</ul>
</li>
</ol>
<h3 id="使用Android-Studio-Firebase-Assistant添加"><a href="#使用Android-Studio-Firebase-Assistant添加" class="headerlink" title="使用Android Studio Firebase Assistant添加"></a>使用Android Studio Firebase Assistant添加</h3><p>FIrebase Assistant是一个Android Studio插件，可创建并关联到Firebase项目，自动添加配置</p>
<p>使用方式：<code>AndroidStudio-&gt;Tools-&gt;Firebase</code>打开Assistant工具，按照工具流程添加</p>
<p>存在问题：导入库版本不一定是最新的，可能和Android Studio版本有关。低版本库getToken方式不一样，需要手动更新版本。</p>
<h2 id="获取Firebase服务授权"><a href="#获取Firebase服务授权" class="headerlink" title="获取Firebase服务授权"></a>获取Firebase服务授权</h2><p>服务器向Firebase服务发送请求需要获取授权。<a href="https://firebase.google.com/docs/cloud-messaging/auth-server">有三种方式</a></p>
<ul>
<li>Google 应用默认凭据（ADC，Google Cloud Application Default Credentials）：在Google服务器环境运行，可以直接使用默认凭据</li>
<li>服务帐号 JSON 文件：在非Google服务器环境运行，需要下载服务账号JSON文件。<ol>
<li>配置到服务器环境变量中。</li>
<li>通过代码读取Json文件路径，可能存在凭据泄漏风险，推荐方式一</li>
</ol>
</li>
<li>源自服务帐号的短期有效的 OAuth 2.0 访问令牌：根据服务账号JSON文件，生成临时访问令牌，添加到发送请求中。如果使用Admin SDK，SDK内部会自行处理，不需要手动生成。</li>
</ul>
<p>生成访问令牌：</p>
<ul>
<li>下载服务账号json文件</li>
<li>下载脚本，修改脚本</li>
<li>脚本和json文件放在同一目录，进入目录执行脚本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip install oauth2client</span></span><br><span class="line"><span class="keyword">from</span> oauth2client.service_account <span class="keyword">import</span> ServiceAccountCredentials</span><br><span class="line"></span><br><span class="line">PROJECT_ID = <span class="string">&#x27;smarthome-8684b&#x27;</span></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://fcm.googleapis.com&#x27;</span></span><br><span class="line">FCM_ENDPOINT = <span class="string">&#x27;v1/projects/&#x27;</span> + PROJECT_ID + <span class="string">&#x27;/messages:send&#x27;</span></span><br><span class="line">FCM_URL = BASE_URL + <span class="string">&#x27;/&#x27;</span> + FCM_ENDPOINT</span><br><span class="line">SCOPES = [<span class="string">&#x27;https://www.googleapis.com/auth/firebase.messaging&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [START retrieve_access_token]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_access_token</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Retrieve a valid access token that can be used to authorize requests.</span></span><br><span class="line"><span class="string">    :return: Access token.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    credentials = ServiceAccountCredentials.from_json_keyfile_name(</span><br><span class="line">        <span class="string">&#x27;service-account.json&#x27;</span>, SCOPES)</span><br><span class="line">    access_token_info = credentials.get_access_token()</span><br><span class="line">    <span class="built_in">print</span> access_token_info.access_token</span><br><span class="line">    <span class="keyword">return</span> access_token_info.access_token</span><br><span class="line"><span class="comment"># [END retrieve_access_token]</span></span><br><span class="line"></span><br><span class="line">_get_access_token()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="REST-API调用模拟发送消息"><a href="#REST-API调用模拟发送消息" class="headerlink" title="REST API调用模拟发送消息"></a>REST API调用模拟发送消息</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Postman请求</span></span><br><span class="line">POST https://fcm.googleapis.com/v1/projects/myproject-b5ae1/messages:send HTTP/1.1</span><br><span class="line"></span><br><span class="line">Content-Type: application/json</span><br><span class="line">Authorization: Bearer ya29.ElqKBGN2Ri_Uz...HnS_uNreA</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;message&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>:<span class="string">&quot;bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;notification&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>:<span class="string">&quot;This is an FCM notification message!&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;FCM Message&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">     		<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span></span><br><span class="line">   		&#125;</span><br><span class="line">    <span class="comment">//针对特定平台</span></span><br><span class="line">  	<span class="string">&quot;android&quot;</span>:&#123;</span><br><span class="line">       <span class="attr">&quot;notification&quot;</span>:&#123;</span><br><span class="line">         <span class="attr">&quot;icon&quot;</span>:<span class="string">&quot;stock_ticker_update&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;color&quot;</span>:<span class="string">&quot;#7e55c3&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;Authorization: Bearer ya29.ElqKBGN2Ri_Uz...HnS_uNreA&quot; -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line">&quot;message&quot;:&#123;</span><br><span class="line">   &quot;notification&quot;:&#123;</span><br><span class="line">     &quot;title&quot;:&quot;FCM Message&quot;,</span><br><span class="line">     &quot;body&quot;:&quot;This is an FCM Message&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;token&quot;:&quot;bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...&quot;</span><br><span class="line">&#125;&#125;&#x27; https://fcm.googleapis.com/v1/projects/myproject-b5ae1/messages:send</span><br></pre></td></tr></table></figure>



<h2 id="Firebase-SDK初始化方式"><a href="#Firebase-SDK初始化方式" class="headerlink" title="Firebase SDK初始化方式"></a>Firebase SDK初始化方式</h2><p><a href="https://firebase.googleblog.com/2016/12/how-does-firebase-initialize-on-android.html">Firebase初始化原理</a></p>
<p>多进程初始化问题：（Demo演示）Application调用Firebase</p>
<p>原因：Firebase通过ContentProvider初始化SDk，由于ContentProvider只在主进程运行，因此子进程如果调用Firebase方法，会报没有初始化SDK异常。</p>
<blockquote>
<p>解决方案1：自定义ContentProvider，指定子进程，初始化Firebase</p>
</blockquote>
<blockquote>
<p>解决方案2：子进程如果不需要Firebase服务的时候，不要在Application中调用Firebase方法。</p>
<ul>
<li>判断当前进程名为主进程名才调用Firebase方法</li>
<li>在主进程Activity中调用Firebase方法。—&gt;Activity可能被创建多次<ul>
<li>添加flag判断是否已经调用过Firebase方法</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="TV上遇到的问题"><a href="#TV上遇到的问题" class="headerlink" title="TV上遇到的问题"></a>TV上遇到的问题</h2><h3 id="TV没有通知栏，后台无法收到通知消息、通知-数据消息"><a href="#TV没有通知栏，后台无法收到通知消息、通知-数据消息" class="headerlink" title="TV没有通知栏，后台无法收到通知消息、通知+数据消息"></a>TV没有通知栏，后台无法收到通知消息、通知+数据消息</h3><p>通知流程：</p>
<pre class="mermaid">graph TB

onStartCommand-->processIntent
processIntent-->handleIntentOnMainThread
handleIntentOnMainThread-->handleNotificationOpen{是否是打开通知栏Action}
handleNotificationOpen--是-->跳转Activity
handleNotificationOpen--否-->handleIntent
handleIntent-->action{Intent类型}
action--token刷新-->onNewToken
action--消息接收-->handleMessageIntent
handleMessageIntent-->alreadyReceivedMessage{是否接收过该消息}
alreadyReceivedMessage--是-->END((结束))
alreadyReceivedMessage--否-->passMessageIntentToSdk
passMessageIntentToSdk-->dispatchMessage
dispatchMessage-->判断是否是通知消息
判断是否是通知消息--是-->return
判断是否是通知消息--否-->onMessageReceived</pre>

<ul>
<li><a href="https://firebase.google.com/docs/libraries/">查看源码</a>，发现判断条件在bundle参数中，可以修改Bundle参数。</li>
<li>onStartCommand、onStart等声明为final，无法重写。</li>
<li>handleIntent和handleIntentOnMainThread都可重写，保险写到handleIntentOnMainThread。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleIntentOnMainThread</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">	Log.e(TAG, <span class="string">&quot;handleIntentOnMainThread before&quot;</span> + intent?.extras)</span><br><span class="line">	<span class="comment">//问题1: intent.extras拿到的是拷贝过的Bundle</span></span><br><span class="line">  	<span class="comment">//需要直接修改intent的extras</span></span><br><span class="line">	<span class="keyword">val</span> key = Constants.MessageNotificationKeys.ENABLE_NOTIFICATION</span><br><span class="line">	<span class="keyword">val</span> oldKey = Constants.MessageNotificationKeys.ENABLE_NOTIFICATION.replace(</span><br><span class="line">		Constants.MessageNotificationKeys.NOTIFICATION_PREFIX,</span><br><span class="line">    	Constants.MessageNotificationKeys.NOTIFICATION_PREFIX_OLD</span><br><span class="line">	)</span><br><span class="line">	intent?.removeExtra(key)</span><br><span class="line">	intent?.removeExtra(oldKey)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.handleIntentOnMainThread(intent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMessageReceived</span><span class="params">(remoteMessage: <span class="type">RemoteMessage</span>)</span></span> &#123;</span><br><span class="line">	Log.d(TAG, <span class="string">&quot;onMessageReceived, From: &quot;</span> + remoteMessage.from + remoteMessage.messageType)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (remoteMessage.<span class="keyword">data</span>.isNotEmpty()) &#123;</span><br><span class="line">		Log.d(TAG, <span class="string">&quot;onMessageReceived, Message data payload: &quot;</span> + remoteMessage.<span class="keyword">data</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//问题2: remoteMessage.notification为空，notification使用懒加载</span></span><br><span class="line">  <span class="comment">//需要重新包装回来.</span></span><br><span class="line">  <span class="comment">//1.重新把remove的key put进去再访问</span></span><br><span class="line">  <span class="comment">//2.手动构造notification。构造方法私有</span></span><br><span class="line">  <span class="comment">//3.不构造notification，只拿想要的值：title和body</span></span><br><span class="line">	<span class="keyword">val</span> intent = remoteMessage.toIntent()</span><br><span class="line">	<span class="keyword">val</span> key = Constants.MessageNotificationKeys.ENABLE_NOTIFICATION</span><br><span class="line">	intent.putExtra(key, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">	RemoteMessage(intent.extras).notification?.let &#123;</span><br><span class="line">		Log.d(TAG, <span class="string">&quot;onMessageReceived, Message Notification Body: &quot;</span> + remoteMessage.notification!!.body)</span><br><span class="line">    Handler(Looper.getMainLooper()).post &#123;</span><br><span class="line">            Toast(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">                view = LayoutInflater.from(<span class="keyword">this</span><span class="symbol">@FCMTestService</span>)</span><br><span class="line">                    .inflate(R.layout.layout_notification, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line">                setGravity(Gravity.END or Gravity.BOTTOM, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">                duration = Toast.LENGTH_LONG</span><br><span class="line">            &#125;.show()</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li>模拟器有时候收不到通知，可以随便打开一下google应用，触发gms。怀疑是模拟器save state导致</li>
<li>am force-stop 退出的应用，不会收到notification</li>
<li>kill杀掉的进程，可以收到notification</li>
<li>后台弹窗问题：使用Toast，并且target sdk version小于26（弹窗问题小结）</li>
</ul>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>gitbook介绍：<a href="https://chrisniael.gitbooks.io/gitbook-documentation/content/index.html">GitBook文档</a>、<a href="http://www.chengweiyang.cn/gitbook/basic-usage/README.html">GitBook简明教程</a>、mermaid插件</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Firebase</tag>
        <tag>推送</tag>
      </tags>
  </entry>
  <entry>
    <title>爱丽丝漫游奇境记【转】</title>
    <url>/2020/11/20/reader-2020-11-20-%E7%88%B1%E4%B8%BD%E4%B8%9D%E6%BC%AB%E6%B8%B8%E5%A5%87%E5%A2%83%E8%AE%B0%E3%80%90%E8%BD%AC%E3%80%91/</url>
    <content><![CDATA[<h1 id="爱丽丝漫游奇境记【转】"><a href="#爱丽丝漫游奇境记【转】" class="headerlink" title="爱丽丝漫游奇境记【转】"></a>爱丽丝漫游奇境记【转】</h1><p>红桃皇后其实是个长得头特别大，人特别丑，完全得不到老爸老妈优秀遗传的长女，天天忍受长得漂亮得尽人心的做作妹妹，得不到人爱的可怜姑娘。 　　<br>　　她乖戾的性格下，其实就只是一个可爱傻女孩善良率直的心。<br>　　说她善良。你看爱丽丝说她因为长太高大被人当成怪人的时候，马上引来她的同情。别人不欢迎你，我欢迎。她身边的宠臣,一个两个不是这个鼻子长歪了,就是那个肚子特别大。<br>　　她就是同情和她自身一样，因为某样东西特别大（头），而遭到他人歧视的人。<br>　　她统治了wonderland，也没有将她做作妹妹怎样。<br>　　她亲爱的美丽妹妹还是有座开满鲜花的美丽宫殿以及一群忠心的白色骑士。<br>　　而她妹妹重获政权之后，却要把她流放到一个没有人烟的地方，而且不允许任何人和她说话。这对害怕孤独的红桃皇后来说，比杀了她更致命。 　　<br>　　可怕比可爱更强。<br>　　可以的情况下，谁想变成可怕的那个？<br>　　人人都喜欢不是更好吗？<br>　　可是万一你像红桃皇后那样顶着一个会被嘲笑，不具好感的头怎么办？ 　　<br>　　所以我觉得红桃皇后才真正像一个皇后，而白皇后充其量是个无能公主而已。<br>　　她坚强有魄力。<br>　　她心里的无助和害怕也只讲给骑士听而已。当然遗憾的是，这是个无情的迎合的家伙。<br>　　红桃皇后对外有多么坚强啊，以至于那么地讨人厌。<br>　　请看白皇后，遇到困难，只是指望一个外来者爱丽丝帮她砍掉恶龙。<br>　　明明自己有能力而不行动，以一个誓言为借口。<br>　　谁又想去杀生？<br>　　爱丽丝也已说过，自己坚决不杀生。<br>　　捂着鼻子取药材。<br>　　明明自己调药的时候，拿着死人油脂调得轻柔而快乐。<br>　　这样装模作样而伪善皇后，我一点都不喜欢。<br>　　相比之下，红桃皇后，嘟着嘴巴嚷嚷说，砍到他的头。真实而可爱多了。 　　<br>　　有天生的美丽，和优雅善良的举止少精弱精 ，自然更讨人喜欢。妹妹是这样获得国土大部分人的支持的。<br>　　而红桃皇后呢?<br>　　后面我发现效忠她的都是些满脸凶相的可怕怪兽之后,就想,也是,同类人才能理解同类人的寂寞。<br>　　其实这种人才特别容易为对向他们和善的人感动，甚至赴汤蹈火。<br>　　你看那只掌管钥匙的恶兽，只是因为爱丽丝还给了他眼睛。<br>　　也就甘心成为了她的坐骑。 　　<br>　　这些看似的恶人，其实就是缺乏爱的孩子而已。<br>　　内心异常的善良。<br>　　最怕别人欺骗她，背叛她，所以只好以一脸凶恶来保护自己。 　　<br>　　不过，童话是童话，红桃皇后扮演恶人，自然要输的。 </p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>小说</title>
    <url>/2019/09/01/reader-2019-09-01-Novel/</url>
    <content><![CDATA[<h2 id="雪中悍刀行"><a href="#雪中悍刀行" class="headerlink" title="雪中悍刀行"></a>雪中悍刀行</h2><ul>
<li>这一日，武当年轻掌教骑鹤至江南，与徐脂虎骑鹤远离江湖。仙人骑鹤下江南，才入江湖，便出江湖——武当年轻掌教洪洗象</li>
<li>江南好，最好是红衣。北凉苦，最苦是白衣</li>
<li>折剑断臂弃江湖，我以手足换手足</li>
<li>一杯酒，敬温华，折剑断臂木剑侠。</li>
<li>“不练剑了”——温华，温不胜</li>
<li>一剑仙人跪，两袖青蛇来</li>
<li>天不生我李淳罡，剑道万古如长夜。（天不生仲尼，万古如长夜）</li>
<li>大雪坪剑来</li>
<li>小僧如果真的可以成佛，今日起却也不想成佛了</li>
<li>风紧、扯呼。来，给少爷上酒呐</li>
<li>徐婴，你怎么可以如此好看，以至于我在神武城外，在借出春秋剑之前那一刻就想啊，跟你死在一起也不错。</li>
<li>若不回头、谁替你救苦救难。如能转念，何须我大慈大悲（采石山）</li>
<li>试问天上仙人，谁敢来此人间</li>
<li>古人说：世上没有不散的宴席。可还有古人说：人生何处不相逢</li>
<li>什么天下第一，还不是揉着腰出去的</li>
<li>徐骁嫡长子徐凤年在此求死</li>
<li>容我徐凤年今日只做一回徐凤年</li>
<li>我愿大秦无风，北凉不战。大秦，风起</li>
<li>这技术活，本世子没法赏啊</li>
<li>定要教你满城尽挂北凉刀</li>
<li>儒以文乱法，侠以武犯禁——韩非子</li>
<li>世上纵有千场雪，无奈再无悍刀行</li>
<li>读书人多是负心人</li>
<li>君只见，北凉铁骑甲天下，却不见北凉人家，家家皆缟素</li>
<li>战后细数，墓碑三十二万啊。世人皆知北凉铁骑战无双，不知北凉十家九户无儿郎</li>
<li>北凉军30万，人人皆向北而死</li>
<li>吃了多少苦，这个不能说，说了别人也只当你猪油蒙心不知足，是在跟饥汉说荤菜油腻。所以遇人只能说享了多大的福。</li>
<li>飞剑一日不养，百日功夫俱废，三日不养，飞剑彻底失去灵气，与废铜烂铁无异，再无希望飞剑取头颅</li>
<li>年轻人离家十年不算久，上了年纪的人，那就是出门一步即远行。</li>
<li>读书人比常人有着更多的感触，读书识字越多，认得历史越多，心思就难免越重，才学越高，往往分寸感越弱，不喜欢拿捏火候，准确说来，是不屑，懒得与人与事去虚与委蛇。看人和做事，就容易非黑即白，也就是你所谓的意气用事了。所以历史上那些才高八斗的文豪，往往做官不大，这种奇怪现象，不光光是眼高手低四个字就可以全部解释的，好在这对他们来说也没有关系，帝王将相终是一抔土，唯有饮者诗者留其名，借酒浇愁写名篇，岂不快哉。千百年后，自然比那些帝王将相和达官显贵更容易让人记住。</li>
<li>积善之家，必有余庆。积恶之家，必有余殃</li>
<li>如一棵西北黄沙最常见地胡杨木，生而不死有千年，死而不倒再千年，倒而不朽又千年</li>
<li>文章本天成，妙手偶得之</li>
<li>紫微斗数，八卦六爻，尚可。面相手相，奇门遁甲，还行。——赵长陵</li>
<li>自皈依佛，不受一切轮回苦。自皈依法，得享十方三世福。自皈依僧，不堕往生诸恶道……</li>
<li>青草明年生，大雁去又回。春风今年吹，公子归不归？青石板青草绿，青石桥上青衣郎，哼着金陵调。谁家女儿低头笑？黄叶今年落，一岁又一岁。秋风明年起，娘子在不在？黄河流黄花黄，黄河城里黄花娘，扑着黄碟翘，谁家儿郎刀在鞘？</li>
<li>情深不寿，慧极必伤</li>
<li>君只见，君只见听潮湖万鲤跳龙门。独不见清凉山，有名石碑不计数。君只见，君只见葫芦口头颅筑京观。独不见高墙下，死人骸骨相撑住。君只见，君只见凉州北策马啸西风。独不见边关南，朗朗书声出破庐。君只见，君只见三十万铁骑甲天下，独不见北凉人，家家户户皆缟素。</li>
<li>东西南北，南北东西，只愿相随无别离。今生来世，来世今生，谁能聚首再相逢</li>
<li>我褚禄山有洁癖，每天都要换一身华贵衣衫，喜豪奢，每天都要换乘骏马，嗜美食，每天都要厨子做出新花样，什么都换，唯独不换主子，褚禄山恨不得所有受恩于徐家的白眼狼，都知道一个简单的道理，人生两苦，想要却不得，拥有却失去，只要殿下让褚禄山掌权一日，褚禄山就一日见不得有人站着说话不腰疼。</li>
<li>那朝堂清流嘴里的话可要比屠夫手里的刀要利害，现在没多少人是文盲了，但人人都是那清流。</li>
<li>人生当苦无妨，良人当归即好</li>
</ul>
<h2 id="剑来"><a href="#剑来" class="headerlink" title="剑来"></a>剑来</h2><ul>
<li>寺庙不在僧人在，僧人不在佛经在，佛经不在佛组在，佛组不在佛法在</li>
<li>一心二意，不三不四，人五人六，乱七八糟，八九不离十，是个怂蛋</li>
<li>我听说不修行的寻常读书人，学问不小，就是都不太吃得住痛，有句话怎么说来着？家里没刀后院没水井，上吊死相太难看，廊柱太硬水太凉</li>
<li>让好人觉得此人是好人，让与之为敌之人，无论好坏，不管各自立场，都在内心深处，愿意认可此人是好人。这还不是最可怕的。更可怕的，是此人当真是好人。</li>
<li>有心为善，虽善不赏，无心为恶，虽恶不罚。</li>
</ul>
<h2 id="大奉打更人"><a href="#大奉打更人" class="headerlink" title="大奉打更人"></a>大奉打更人</h2><ul>
<li>原文：我许七安，从未在教坊司花过银子<ul>
<li>二叔：大郎，请问人生中最快乐的事是什么？</li>
<li>大郎抓了一只七星瓢虫，放到面粉里裹一圈后送给二叔。</li>
<li>二叔：大郎，你的意思是人虽微小如虫，在凡尘中摸爬滚打一生，但也必能遇到快乐之事</li>
<li>大郎：不对，白嫖</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统路径</title>
    <url>/2019/04/04/android-2019-04-04-Android%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>可以通过<code>find . -name &lt;文件名&gt;</code>查找文件</p>
<ol>
<li>appops权限路径：<code>/data/system/appops.xml</code></li>
<li>运行时权限：<code>/data/system/users/0/runtime-permissions.xml</code></li>
<li><code>/system/etc/permissions</code>、<code>/vendor/etc/permissions</code></li>
<li><code>/system/etc/default_permissions/default-permissions.xml</code>、<code>/system/etc/default_permissions/open app-permissions.xml</code></li>
<li>settings provider属性：<code>/data/system/users/0/settings_global.xml</code></li>
<li>所有应用权限：<code>/data/system/packages.xml</code></li>
<li><code>/system/etc/sysconfig/hiddenapi-package-whitelist.xml</code>：无法调用hidden api，添加白名单</li>
<li>uri访问权限：<code>/data/system/urigrants.xml</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uri-grants</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uri-grant</span> <span class="attr">sourceUserId</span>=<span class="string">&quot;0&quot;</span> <span class="attr">targetUserId</span>=<span class="string">&quot;0&quot;</span> <span class="attr">sourcePkg</span>=<span class="string">&quot;com.cvte.tv.media&quot;</span> <span class="attr">targetPkg</span>=<span class="string">&quot;com.android.htmlviewer&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;content://com.cvte.tv.media.fileProvider&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;true&quot;</span> <span class="attr">modeFlags</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uri-grants</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="异常文件"><a href="#异常文件" class="headerlink" title="异常文件"></a>异常文件</h1><p>墓碑文件：/data/tombstones</p>
<p>anr文件：/data/anr</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发工具（占坑）</title>
    <url>/2019/03/01/android-2019-03-01-Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h1><h2 id="Windows运行Android模拟器"><a href="#Windows运行Android模拟器" class="headerlink" title="Windows运行Android模拟器"></a>Windows运行Android模拟器</h2><h3 id="Intel-CPU"><a href="#Intel-CPU" class="headerlink" title="Intel CPU"></a>Intel CPU</h3><p>Intel CPU使用HAXM（Hardware Accelerated Execution Manager）技术，使用基于 Intel(R) Virtualization Technology (VT) 的硬件加速，实现 Android 模拟器加速。</p>
<p>需要在BIOS中开启硬件支持VT，并且Android sdk需要安装Intel x86 Emulator Accelerator（HAXM）扩展。</p>
<h3 id="AMD-CPU"><a href="#AMD-CPU" class="headerlink" title="AMD CPU"></a>AMD CPU</h3><p>AMD通过Android Studio运行模拟器会报错，如“提示CPU不支持“，或者”建议使用x86模拟器”。在BIOS中开启虚拟化也没用。</p>
<p>解决办法：</p>
<ul>
<li>使用GenyMotion模拟器，并且在Android Studio上安装GenyMotion插件。<ul>
<li>问题：GenyMotion使用Virtual Box虚拟化技术，而我的电脑运行了Docker，Docker在Windows上使用的是Hyper-V虚拟化技术，两个一起开会出问题。</li>
</ul>
</li>
<li>官方在Android Emulator 27.3.1上给出了解决方案，结合了Win10的Hyper-V技术。<ul>
<li>Win10系统</li>
<li>在Android sdk中安装Android Emulator 27.3.1以上的版本</li>
<li>安装x86的镜像，x86_64（打开很慢）和armeabi-v7a（更慢）</li>
<li>在控制面板-&gt;程序-&gt;启用或关闭Windows功能中，打开<strong>indows虚拟机监控程序平台（Windows Hypervisor Platform）</strong></li>
<li>重启电脑</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果是IntelCPU还是建议使用HAXM，支持硬件加速。</li>
<li>如果是AMD CPU建议使用Win10的Hyper-V技术</li>
<li>建议使用x86模拟器，速度能快很多倍</li>
</ul>
<p>参考<a href="https://android-developers.googleblog.com/2018/07/android-emulator-amd-processor-hyper-v.html">Android模拟器安装</a>k</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android常见异常及解决方案</title>
    <url>/2019/02/27/android-2019-02-27-AndroidError/</url>
    <content><![CDATA[<p>关于Java异常，可以参考<a href="/KnowledgeTree/">知识体系</a></p>
<h1 id="常见编译错误"><a href="#常见编译错误" class="headerlink" title="常见编译错误"></a>常见编译错误</h1><h2 id="内存不足，无法启动虚拟机"><a href="#内存不足，无法启动虚拟机" class="headerlink" title="内存不足，无法启动虚拟机"></a>内存不足，无法启动虚拟机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of VM</span><br><span class="line">Could not reserve enough space <span class="keyword">for</span> 1572864KB object heap</span><br></pre></td></tr></table></figure>

<p><img src="/2019/02/27/android-2019-02-27-AndroidError/error01.png" alt="内存不足"></p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>修改<code>gradle.properties</code>文件，将虚拟机内存改小</li>
<li>关掉部分无用的进程，腾出空间</li>
</ol>
</blockquote>
<p>附上查看系统内存方法：</p>
<blockquote>
<ol>
<li>打开任务管理器-&gt;性能-&gt;内存。或者任务管理器-&gt;性能-&gt;资源监视器-&gt;内存</li>
<li>使用命令行</li>
</ol>
</blockquote>
<p>补充：Java工程可能也会遇到类似的错误，也可以通过设置虚拟机参数解决</p>
<p>Java虚拟机监控命令/工具：</p>
<ul>
<li><a href="https://www.cnblogs.com/lemon-pomelo/p/9285840.html">Java虚拟机–常用Java命令(一)</a></li>
<li><a href="https://www.cnblogs.com/xmzJava/p/8524949.html">Java虚拟机监控命令</a></li>
</ul>
<p>Android查看内存、CPU、电量等信息：</p>
<ul>
<li><a href="https://www.cnblogs.com/flyingcode/p/6113368.html">Android 通过adb shell命令查看内存，CPU，启动时间，电量等信息</a></li>
</ul>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p><code>java.lang.OutOfMemoryError: Metaspace</code></p>
<blockquote>
<p>有可能是电脑内存不足，</p>
<ol>
<li>重启Android Studio</li>
<li>查看内存，杀进程（活动监视器，或者命令行）</li>
<li>重新开机</li>
</ol>
</blockquote>
<h2 id="sdk版本不正确"><a href="#sdk版本不正确" class="headerlink" title="sdk版本不正确"></a>sdk版本不正确</h2><p><img src="/2019/02/27/android-2019-02-27-AndroidError/error02.png" alt="sdk版本"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &#x27;:girls:compileReleaseRenderscript&#x27;.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> llvm-rs-cc is missing</span></span><br></pre></td></tr></table></figure>

<p>解决方案：修改<code>build.gradle</code>中的版本号为下载过的sdk版本</p>
<h1 id="常见运行异常"><a href="#常见运行异常" class="headerlink" title="常见运行异常"></a>常见运行异常</h1><h2 id="Dialog-amp-AlertDialog，WindowManager不能正确使用"><a href="#Dialog-amp-AlertDialog，WindowManager不能正确使用" class="headerlink" title="Dialog&amp;AlertDialog，WindowManager不能正确使用"></a>Dialog&amp;AlertDialog，WindowManager不能正确使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">20715 android.view.WindowManager<span class="variable">$BadTokenException</span></span></span><br><span class="line">Unable to add window -- token android.os.BinderProxy@caaa709 is not valid; is your activity running?</span><br></pre></td></tr></table></figure>

<p>分析：该异常表示不能添加窗口，通常是所要依附的view已经不存在导致的。</p>
<p>常见场景：</p>
<blockquote>
<ol>
<li>上一个页面没有destroy的时候，之前的Activity已经接收到了广播。如果此时之前的Activity进行UI层面的操作处理，就会造成crash。UI层面的刷新，一定要注意时机，建议使用set_result来代替广播的形式进行刷新操作，避免使用广播的方式，代码不直观且容易出错。</li>
<li>Dialog在Actitivty退出后弹出。在Dialog调用show方法进行显示时，必须要有一个Activity作为窗口的载体，如果Activity被销毁，那么导致Dialog的窗口载体找不到。建议在Dialog调用show方法之前先判断Activity是否已经被销毁。</li>
<li>Service&amp;Application弹出对话框或WindowManager添加view时，没有设置window type为TYPE_SYSTEM_ALERT。需要在调用dialog.show()方法前添加dialog.getWindow().SetType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT)。</li>
<li>6.0的系统上, (非定制 rom 行为)若没有给予悬浮窗权限, 会弹出该问题, 可以通过Settings.canDrawOverlays来判断是否有该权限.</li>
<li>某些不稳定的MIUI系统bug引起的权限问题，系统把Toast也当成了系统级弹窗，android6.0的系统Dialog弹窗需要用户手动授权，若果app没有加入SYSTEM_ALERT_WINDOW权限就会报这个错。需要加入给app加系统Dialog弹窗权限，并动态申请权限，不满足第一条会出现没权限闪退，不满足第二条会出现没有Toast的情况。</li>
</ol>
</blockquote>
<h2 id="Context启动Activity"><a href="#Context启动Activity" class="headerlink" title="Context启动Activity"></a>Context启动Activity</h2><p>在 Android P 中，无法通过非 Activity 的 Context（如 Service）启动 Activity，除非在 Intent 中添加 FLAG_ACTIVITY_NEW_TASK，否则该 Activity 不会启动，并抛异常。</p>
<p>解决方案：启动 Activity 的地方判断Context是否<code>instanceof Activity</code></p>
<h2 id="参数不匹配"><a href="#参数不匹配" class="headerlink" title="参数不匹配"></a>参数不匹配</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">50220 java.lang.IllegalArgumentException</span></span><br><span class="line">Unknown color</span><br></pre></td></tr></table></figure>

<p>传入了不正确的参数导致。</p>
<p>常见场景：</p>
<blockquote>
<ol>
<li>Activity、Service状态异常；</li>
<li>非法URL；</li>
<li>UI线程操作。</li>
<li>Fragment中嵌套了子Fragment，Fragment被销毁，而内部Fragment未被销毁，所以导致再次加载时重复，在onDestroyView() 中将内部Fragment销毁即可</li>
<li>在请求网络的回调中使用了Glide.into(view),view已经被销毁会导致该错误</li>
</ol>
</blockquote>
<h2 id="空指针异常（NPE）"><a href="#空指针异常（NPE）" class="headerlink" title="空指针异常（NPE）"></a>空指针异常（NPE）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">2002 java.lang.NullPointerException</span></span><br><span class="line">SimpleDraweeView was not initialized!</span><br></pre></td></tr></table></figure>

<p>空指针最为常见，也最容易规避，使用的时候一定要进行<code>null check</code>或者<code>try-catch</code>，采取不信任原则。</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>方法形参要判空后才使用；</li>
<li>全局变量容易被系统回收或者更改，使用全局变量前建议判空；</li>
<li>第三方接口的调用，对返回值进行判空。</li>
<li>请注意线程安全</li>
</ol>
</blockquote>
<h2 id="数组存储异常"><a href="#数组存储异常" class="headerlink" title="数组存储异常"></a>数组存储异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">28916 java.lang.ArrayStoreException</span></span><br><span class="line">source[0] of type com.google.android.gms.internal.zzcek cannot be stored in destination array of type com.google.android.gms.common.api.internal.BasePendingResult[]</span><br></pre></td></tr></table></figure>

<p>当向数组中存放非数组声明类型对象时抛出</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>进行类型判断</li>
<li>重新声明数组类型</li>
</ol>
</blockquote>
<h2 id="Bitmap异常"><a href="#Bitmap异常" class="headerlink" title="Bitmap异常"></a>Bitmap异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">4230 java.lang.RuntimeException</span></span><br><span class="line">Canvas: trying to use a recycled bitmap android.graphics.Bitmap@1d515bf2</span><br><span class="line"></span><br><span class="line">android.graphics.Canvas.throwIfCannotDraw(Canvas.java:1282)</span><br></pre></td></tr></table></figure>

<p>画布尝试去使用一个已回收的位图对象，建议解除一切与Bitmap的绑定。通常由于bitmap比较占用内存，为避免oom习惯使用bitmap.recycle()来回收，当再次使用这个被回收的bitmap时就会产生发生异常。</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>在使用前先判断bitmap是否被回收；</li>
<li>在不确定图片是否还有其他引用时，不要调用recycle()。</li>
</ol>
</blockquote>
<p>RuntimeException（运行时异常），是所有Java虚拟机正常操作期间可以被抛出的异常的父类。通常需要关注cause by以下部分的堆栈。</p>
<h2 id="找不到指定方法"><a href="#找不到指定方法" class="headerlink" title="找不到指定方法"></a>找不到指定方法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">13623 java.lang.NoSuchMethodError</span></span><br><span class="line">no non-static method &quot;Lcom/**/**/**;.&lt;init&gt;(Ljava/lang/String;Ljava/l</span><br></pre></td></tr></table></figure>

<p>该异常表示找不到指定方法。主要是由于Android系统和Rom厂商定制化导致的碎片化问题，很难根治，建议做好机型适配，解决top机型问题：</p>
<blockquote>
<ol>
<li>如果是机型相关问题，则看下是否添加了该崩溃机型cpu架构的so库；</li>
<li>如果是系统API方法，使用时要注意API Level，如果设置的target version过高，调用低于设置版本的API方法将会报错。</li>
<li>setBackground方法在API &gt;= 16才生效</li>
</ol>
</blockquote>
<h2 id="安全异常、权限异常"><a href="#安全异常、权限异常" class="headerlink" title="安全异常、权限异常"></a>安全异常、权限异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">4523 java.lang.SecurityException</span></span><br><span class="line">Client must have ACCESS_FINE_LOCATION permission to request PRIORITY_HIGH_ACCURACY locations.</span><br><span class="line"></span><br><span class="line">com.google.android.gms.internal.zzeu.zzb(Unknown Source:10)</span><br></pre></td></tr></table></figure>

<p>权限异常或者称为安全异常，由安全管理器抛出，用于指示违反安全情况的异常，通常由于没有获取对应的权限。</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li>android6.0以下需要在manifest中声明相应的权限；</li>
<li>android6.0及以上，在使用时需要动态申请权限。</li>
</ol>
</blockquote>
<h2 id="不支持的操作"><a href="#不支持的操作" class="headerlink" title="不支持的操作"></a>不支持的操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">11210 java.lang.UnsupportedOperationException</span></span><br><span class="line">Failed to resolve attribute at index 13: TypedValue&#123;t=0x2/d=0x7f040210 a=3&#125;</span><br></pre></td></tr></table></figure>

<p>常见场景：xml中</p>
<blockquote>
<ol>
<li>Android 4.x及以下的设备使用Android 5.0 以后MaterialDesign设计引入的colorPrimary等属性造成的异常；</li>
<li>有些基于Android原生系统再次开发的系统、Rom不支持Start、End，简易更改为Left、Right（例如，layout_alignParentStart和layout_alignParentEnd属性）；<br>总体来说就是，该属性在某些奇葩设备下不兼容，尽量使用兼容的属性。</li>
<li>还有一种情况是build目录下的文件没有清除干净，导致失败的。</li>
</ol>
</blockquote>
<h2 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#17553 java.lang.OutOfMemoryError</span><br><span class="line">pthread_create (1040KB stack) failed: Out of memory</span><br><span class="line">com.facebook.imagepipeline.core.PriorityThreadFactory1.run(PriorityThreadFactory.java:<span class="number">43</span>)</span><br></pre></td></tr></table></figure>

<p>该异常表示内存不足导致线程创建失败。pthread_create默认创建的线程是非detached的。如果使用不当，确实会造成内存泄漏。</p>
<p>预防方案：</p>
<blockquote>
<ol>
<li>创建detached的线程；</li>
<li>线程的start_routine结束之前detached；</li>
<li>主线程中使用pthread_join。</li>
</ol>
</blockquote>
<h2 id="迭代器异常"><a href="#迭代器异常" class="headerlink" title="迭代器异常"></a>迭代器异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">7707 java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>

<p>该异常表示迭代器迭代过程中，迭代的对象发生了改变，如数据项增加或删除。由于迭代对象不是线程安全，在迭代的过程中，会检查modCount是否和初始modCount即expectedModCount一致，如果不一致，则认为数据有变化，迭代终止并抛出异常。</p>
<p>常见场景：两个线程同时对集合进行操作，线程1对集合进行遍历，而线程2对集合进行增加、删除操作。</p>
<p>解决方案：多线程访问时要增加同步锁，或者建议使用线程安全的集合：</p>
<blockquote>
<ol>
<li>使用ConcurrentHashMap替换HashMap，CopyOnWriteArrayList替换ArrayList；</li>
<li>或者使用使用Vector替换ArrayList，Vector是线程安全的。Vector的缺点：大量数据操作时，由于线程安全，性能比ArrayList低.</li>
</ol>
</blockquote>
<h2 id="通知异常"><a href="#通知异常" class="headerlink" title="通知异常"></a>通知异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android.app.RemoteServiceException</span><br><span class="line">Context.startForegroundService() did not then call Service.startForeground()</span><br><span class="line"></span><br><span class="line">android.app.ActivityThreadH.handleMessage(ActivityThread.java:1768)</span><br></pre></td></tr></table></figure>

<p>该异常表示从Package发布通知时存在异常，主要出现在通知栏更新。</p>
<p>使用通知需要注意以下几点：</p>
<blockquote>
<ol>
<li>每次更新时都需要实例化Notification；</li>
<li>设置Notification的ContentView之后记得设置ContentIntent；</li>
<li>如果使用了RemoteViews时，需要保证包名的正确性；</li>
<li>注意各个系统版本对于Notification使用方法的差异性。</li>
</ol>
</blockquote>
<h2 id="Native方法没找到"><a href="#Native方法没找到" class="headerlink" title="Native方法没找到"></a>Native方法没找到</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError</span><br><span class="line">Native method not found: com.tutk.IOTC.AVAPIs.avInitialize:(I)I</span><br></pre></td></tr></table></figure>

<p>该异常表示native方法没有找到。报这个错误通常是so库加载失败，或者找不到准备执行的JNI方法，可能是因为method的signature或命名有误，建议使用javah命令行来生成JNI头文件来避免这个问题。</p>
<h2 id="状态异常"><a href="#状态异常" class="headerlink" title="状态异常"></a>状态异常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">37812 java.lang.IllegalStateException</span></span><br></pre></td></tr></table></figure>

<p>常见类型</p>
<blockquote>
<p><code>IllegalStateException: Can not perform this action after onSaveInstanceState：</code></p>
<p>onSaveInstanceState方法是在该Activity即将被销毁前调用，来保存Activity数据的，如果在保存完状态后<br>再给它添加Fragment就会出错。解决办法就是把commit（）方法替换成 commitAllowingStateLoss()</p>
</blockquote>
<blockquote>
<p> <code>java.lang.IllegalStateException：Cannot   forward   a   response   that   is   already   committed  IllegalStateException：response already commited  IllegalStateException：getOutputStream() has already been called for this request</code></p>
<p><a href="http://my.oschina.net/guhai2004/blog/187041">参考java.lang.IllegalStateException异常产生的原因及解决办法</a></p>
<p>该异常表示，当前对客户端的响应已经结束，不能在响应已经结束（或说消亡）后再向客户端（实际上是缓冲区）输出任何内容。</p>
<p>具体分析：首先解释下flush()，我们知道在使用读写流的时候数据先被读入内存这个缓冲区中， 然后再写入文件，但是当数据读完时不代表数据已经写入文件完毕，因为可能还有一部分仍未写入文件而留在内存中，这时调用flush()方法就会把缓冲区的数据强行清空输出，因此flush()的作用就是保证缓存清空输出。response是服务端对客户端请求的一个响应，其中封装了响应头、状态码、内容等，服务端在把response提交到客户端之前，会向缓冲区内写入响应头和状态码，然后将所有内容flush。这就标志着该次响应已经committed(提交)。对于当前页面中已经committed(提交)的response，就不能再使用这个response向缓冲区写任何东西（注：同一个页面中的response.XXX()是同一个response的不同方法，只要其中一个已经导致了committed，那么其它类似方式的调用都会导致 IllegalStateException异常）。</p>
<p>注：能够导致响应已经committed的操作包括：forward, redirect, flushBuffer。</p>
</blockquote>
<blockquote>
<p><code>java.lang.IllegalStateException: Illegal State: Row/Object is no longer valid to operate on. Was it deleted?</code><a href="https://github.com/realm/realm-java/issues/1206">参考realm</a></p>
<p>realmObject对象在其他线程已被删除，在这个线程中使用的时候抛出的异常。</p>
</blockquote>
<blockquote>
<p><code>java.lang.IllegalStateException Can&#39;t change tag of fragment d&#123;e183845 #0 d&#123;e183845&#125;&#125;: was d&#123;e183845&#125; now d&#123;e183845 #0 d&#123;e183845&#125;&#125;</code></p>
<p>显示fragment的代码中使用了：fragment.show(getSupportFragmentManager, fragment.toString());<br>而这里是因为两次toString()结果不同，导致不同的tag指向的是同一个fragment。<br>获取fragment的tag的正确方法应该是使用其提供的fragment.getTag()方法。</p>
</blockquote>
<blockquote>
<p><code>java.lang.IllegalStateException Expected BEGIN_ARRAY but was BEGIN_OBJECT at line 1 column 37 path .data</code></p>
<p>该异常是由于服务器错误返回的JSON字符串和服务器正常下时返回的JSON字符串结构不同,导致利用Gson解析的时候报了一个异常:本该去解析集合却强制去解析对象所致.</p>
<p>解决方案：在使用Gson解析JSON时try cash一下,不报错按照正常逻辑继续解析,报异常则处理为请求失败逻辑即可.</p>
</blockquote>
<h2 id="Fresco图片加载"><a href="#Fresco图片加载" class="headerlink" title="Fresco图片加载"></a>Fresco图片加载</h2><p>使用FrescoManager 的时候默认使用的是可轻易被回收的bitmap，如果不在当前页面使用可能会被回收报错。如果报这个错，可以使用FrescoManager.load(String url, ImageView view, boolean canBeRecycled), 传入false，或者直接使用Fresco的SimpleDraweeView,这个是官方推荐的做法。</p>
<h1 id="版本适配问题"><a href="#版本适配问题" class="headerlink" title="版本适配问题"></a>版本适配问题</h1><h2 id="Android-P使用http明文传输"><a href="#Android-P使用http明文传输" class="headerlink" title="Android P使用http明文传输"></a>Android P使用http明文传输</h2><p>报错：<code>java.io.IOException: Cleartext HTTP traffic to  not permitted</code></p>
<p>解决方案：</p>
<ol>
<li>APP改用https请求</li>
<li>targetSdkVersion 降到27以下</li>
<li>更改网络安全配置</li>
</ol>
<p>方式一：</p>
<p>manifest文件中<code>&lt;application&gt;</code>标签添加：<code>android:usesCleartextTraffic=&quot;true&quot;</code></p>
<p>方式二：</p>
<ol>
<li>创建<code>res/xml/network_security_config.xml</code>文件，配置如下</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改manifest文件，引入配置</li>
</ol>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">	android:networkSecurityConfig=&quot;@xml/network_security_config&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker for windows+Jenkins+gradle配置</title>
    <url>/2019/01/14/tool-2019-1-14-Docker-Jenkins/</url>
    <content><![CDATA[<h1 id="docker运行jenkins"><a href="#docker运行jenkins" class="headerlink" title="docker运行jenkins"></a>docker运行jenkins</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里使用的docker是windows版的，路径和linux或mac不一样，坑也更多一点。主要就是因为容器的特性，搞明白了之后大部分的问题都可以解决了，具体总结为下面两个原因：</p>
<ul>
<li><strong>使用docker配置jenkins路径有很大的不同，原因是容器内无法访问主机目录，因此需要将主机目录挂载到容器中，Jenkins配置都要使用容器中的目录</strong>，</li>
<li><strong>容器内的各种环境也是隔离的，相当于一个独立的系统（类似Win10内置的Linux子系统功能）。也就是说需要的环境都得在容器内再安装一遍。也可以使用挂载，将主机的安装路径挂载到容器中，然后容器中再像Linux一样配置环境变量，这样的好处是和主机版本一致，而且不会增加容器大小。</strong><ul>
<li>如java、python、gradle、android sdk等环境</li>
</ul>
</li>
</ul>
<p>还有一点要注意的：</p>
<p><strong>docker容器删掉之后下次再运行，所有的数据都会清空，再创建一个新的容器。因此需要持久化数据</strong>：方法和上面一样，将主机上的目录挂载到docker容器中，对容器目录的读写操作即是对主机的读写，删除容器不会删除主机上的数据，重新创建容器的时候只需要再次挂载主机目录。</p>
<p>我的主机存储路径是这样的（根据需要自行替换）：</p>
<ul>
<li><code>E:\ASproject</code>：存放android项目</li>
<li><code>D:\Docker\Volume\Jenkins</code>：用于持久化容器</li>
<li><code>D:\android-sdk-windows</code>：存放安卓sdk</li>
</ul>
<h2 id="docker安装jenkins"><a href="#docker安装jenkins" class="headerlink" title="docker安装jenkins"></a>docker安装jenkins</h2><ul>
<li><code>docker search jenkins</code>：在docker hub查找jenkins镜像</li>
</ul>
<p>搜到的第一个jenkins镜像（Official Jenkins Docker iage）版本太老了，会有很多问题，这里使用jenkins/jenkins镜像。</p>
<ul>
<li><code>docker pull jenkins/jenkins</code>：拉取镜像</li>
<li><code>docker run -d -p 8082:8080 -p 50000:50000 --name myjenkins -v /d/Docker/Volume/Jenkins:/var/jenkins_home -v /e/ASproject:/var/as_project -v /d/android-sdk-windows:/var/android_sdk jenkins/jenkins:lts</code>：运行jenkins，<ul>
<li><code>-v 主机目录:容器目录</code>：主机目录挂载到容器目录</li>
<li><code>-p 主机端口:容器端口</code>：容器端口映射到主机端口</li>
<li><code>-d</code>：后台运行</li>
<li><code>--name</code>：容器命名，这里命名为<code>myjenkins</code>，可自行替换，后面用到的也替换</li>
</ul>
</li>
<li>浏览器访问<code>localhost:8082</code>：能够访问即成功了</li>
</ul>
<p>挂载目录解释：</p>
<p>Jenkins的很多配置需要设置路径（如jdk、gradle、android sdk、项目workspace等），而容器内无法访问主机的目录，使用主机目录会配置失败，因此需要将主机目录挂载到容器中</p>
<p><code>-v /d/Docker/Volume/Jenkins:/var/jenkins_home</code>：将主机<code>D:\Docker\Volume\Jenkins</code>挂载到容器的<code>/var/jenkins_home</code>，即访问<code>/var/jenkins_home</code>就是访问主机<code>D:\Docker\Volume\Jenkins</code>。这样做是为了容器持久化，否则删除容器之后所有的配置都会消失。重新运行容器之后只要再次挂载这个目录就能恢复配置。</p>
<p><code>-v /e/ASproject:/var/as_project</code>：这样做是为了把项目工作区挂载到容器中，不然访问不到安卓的项目，也可以把项目复制到刚才挂载的<code>D:\Docker\Volume\Jenkins</code>这个目录下，让容器能够访问到，不推荐这么做，因为会改变原先项目的路径，而且太大了，所以单独挂载到容器的一个新的目录作为工作区，原先项目路径也不用改变。</p>
<p><code>-v /d/android-sdk-windows:/var/android_sdk</code>：同样的道理，把本机的sdk挂载到容器的新目录中，不用在容器中再装一次sdk</p>
<h2 id="Jenkins初始化"><a href="#Jenkins初始化" class="headerlink" title="Jenkins初始化"></a>Jenkins初始化</h2><h3 id="第一次进入需要初始密码"><a href="#第一次进入需要初始密码" class="headerlink" title="第一次进入需要初始密码"></a>第一次进入需要初始密码</h3><ul>
<li><p>可以直接访问刚才挂载的主机目录：<code>D:\Docker\Volume\Jenkins\secrets\initialAdminPassword</code></p>
</li>
<li><p>或者使用命令行</p>
<ul>
<li><code>docker exec -it myjenkins /bin/bash</code>进入容器。</li>
<li><code>cd var/jenkins_home/secrets</code>进入目录</li>
<li><code>cat initialAdminPassword</code>：查看密码，复制到浏览器</li>
</ul>
</li>
<li><p>设置了用户密码之后这个文件就没了</p>
</li>
</ul>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>上一步输入密码之后提示安装插件，使用推荐安装，或者自行选择插件</p>
<p>失败了没关系，进去之后可以到系统管理–插件管理中再安装</p>
<h3 id="设置用户名、密码"><a href="#设置用户名、密码" class="headerlink" title="设置用户名、密码"></a>设置用户名、密码</h3><h2 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h2><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>进入系统管理–系统设置，如下，这里使用刚才挂载的容器内的路径，不能直接用<code>D:\android-sdk-windows</code></p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins01.png" alt="Jenkins环境变量配置"></p>
<p>注：这个版本的Jenkins镜像好像自带了java环境，因此不用再配置java环境变量，也不用将主机jdk目录挂载到容器内</p>
<h3 id="全局工具配置"><a href="#全局工具配置" class="headerlink" title="全局工具配置"></a>全局工具配置</h3><p>配置gradle路径，将安装的gradle整个拷贝到<code>D:\Docker\Volume\Jenkins</code>中，对应容器中的<code>/var/jenkins_home</code>（当然也可以按照上面的挂载方法，将主机安装的gradle挂载到容器新的目录）,这里配置如下</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins02.png" alt="Jenkins环境变量配置"></p>
<p>注：</p>
<ul>
<li>android studio安装的gradle一般是在<code>C:\Users\XXX\.gradle\wrapper\dists\gradle-4.6-all\bcst21l2brirad8k2ben1letg\gradle-4.6</code>，将这个文件夹复制到容器能够访问到的主机目录即可</li>
<li>jdk不需要配置，这个版本的jenkins镜像自带了java环境</li>
</ul>
<h2 id="任务配置"><a href="#任务配置" class="headerlink" title="任务配置"></a>任务配置</h2><p>任务就是每次执行任务的模板，可以查看执行日志，第几次执行等</p>
<p>创建任务、填写名字、描述、这些较简单，跳过，这里只讲关键的配置</p>
<h3 id="工作区配置"><a href="#工作区配置" class="headerlink" title="工作区配置"></a>工作区配置</h3><p>点击advanced展开配置</p>
<p>刚才我们使用<code>-v /e/ASproject:/var/as_project</code>，把主机的android项目目录挂载到了容器的中，因此可以通过容器路径访问主机上的TestProject项目，因此配置如下</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins03.png" alt="Jenkins环境变量配置"></p>
<h3 id="Build配置"><a href="#Build配置" class="headerlink" title="Build配置"></a>Build配置</h3><p>会在上面配置的工作区上执行脚本，有多种脚本可以执行，如gradle，shell等。可以写一些简单的脚本进行测试，比如打印java版本，查看当前目录文件等。gradle脚本选择刚才在全局工具配置中的名称</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins04.png" alt="Jenkins环境变量配置"></p>
<p>点开左边的构建历史，查看某次构建，如下</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins05.png" alt="Jenkins环境变量配置"></p>
<p>注：我们的docker内部是使用linux环境的（也可以切换成windows的），因此能够选择<code>执行shell</code>，而不能选择<code>执行Windows批处理命令</code></p>
<h3 id="代码远程仓库配置"><a href="#代码远程仓库配置" class="headerlink" title="代码远程仓库配置"></a>代码远程仓库配置</h3><p>留坑</p>
<p>配置ssh访问github：使用docker exec命令进入容器，然后参考linux配置，参考文章：<a href="https://blog.csdn.net/m0_38139979/article/details/82820972">Linux   ssh访问Github相关配置</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="python环境安装"><a href="#python环境安装" class="headerlink" title="python环境安装"></a>python环境安装</h3><p>Job配置的时候可以配置python脚本，也可以配置shell，通过shell命令来执行python脚本。如 <code>python /var/jenkins_home/scripts/***.py</code>。</p>
<p><strong>注：脚本路径要用容器内路径，不能用主机上的路径</strong></p>
<p>docker版的jenkins自带了python2的环境，但是没有pip，因此需要再安装pip：</p>
<ul>
<li>使用<code>docker exec -it &lt;容器名/容器id&gt; /bin/bash</code>进入容器内，然后就当Linux环境进行安装就可以了</li>
</ul>
<p>参考<a href="https://www.cnblogs.com/technologylife/p/5870576.html"><a href="https://www.cnblogs.com/technologylife/p/5870576.html">Linux 下安装pip</a></a>，输入以下命令（安装的是python2的pip）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://bootstrap.pypa.io/get-pip.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python get-pip.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip -V　　<span class="comment">#查看pip版本</span></span></span><br></pre></td></tr></table></figure>

<p><strong>不过这样安装有个问题，就是删除容器之后下次需要再次安装模块</strong>：解决思路应该是把主机上的python安装目录整个挂载到容器中，然后再<code>run</code>的时候通过<code>--env</code>设置环境变量，替换掉jenkins自带的python。<strong>没试过，应该可行。有知道的大佬可以联系我</strong></p>
<p>保存一下需要安装的模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install gitpython</span><br></pre></td></tr></table></figure>



<h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h2 id="docker-for-windows重启电脑"><a href="#docker-for-windows重启电脑" class="headerlink" title="docker for windows重启电脑"></a>docker for windows重启电脑</h2><p>每次电脑重启，容器显示在运行，但是已经不能用了，执行restart重启容器会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error response from daemon: Cannot restart container myjenkins: </span><br><span class="line">driver failed programming external connectivity on endpoint myjenkins </span><br><span class="line">(0e1a94a2783d0ff6acc8a8580652692a27bd5dea24bfa2d45d329bb5764bfaa0): </span><br><span class="line">Error starting userland proxy: mkdir /port/tcp:0.0.0.0:8082:tcp:172.26.0.2:8080: input/output error</span><br></pre></td></tr></table></figure>

<p>解决：不知道什么原因，将docker服务整个重启即可</p>
<h2 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h2><p>将gradle复制到jenkins容器映射目录（即主机的<code>d:\Docker\Volume\Jenkins</code>），在系统管理–全局工具配置-Gradle中的<code>GRALDE_HOME</code>使用路径<code>/var/jenkins_home/gradle-4.6</code>。gradle-wrapper不知道怎么弄，没成功过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//gradle路径不正确</span><br><span class="line">Started by user unknown or anonymous</span><br><span class="line">Building in workspace E:\ASproject\FireSecure</span><br><span class="line">[Gradle] - Launching build.</span><br><span class="line">[Gradle] - [ERROR] Can&#x27;t retrieve the Gradle executable.</span><br><span class="line">Build step &#x27;Invoke Gradle script&#x27; marked build as failure</span><br><span class="line">Finished: FAILURE</span><br></pre></td></tr></table></figure>

<h2 id="java环境配置"><a href="#java环境配置" class="headerlink" title="java环境配置"></a>java环境配置</h2><p>docker里面有个java环境（docker-java-home），不知道是装docker就有的，还是装jenkins才弄上去的，<br>（猜测应该是jenkins自带的，我看了一下其他容器（nginx）没有java环境。nexus也有一个java环境，路径和jenkins不一样，不过版本一模一样，让我有点怀疑）<br>（网上说需要在系统管理–系统设置里设置Jenkins的JAVA_HOME环境变量，docker版的好像不需要，默认设置了docker-java-home）</p>
<h2 id="java-version（注意：不是–）"><a href="#java-version（注意：不是–）" class="headerlink" title="java -version（注意：不是–）"></a>java -version（注意：不是–）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br><span class="line">Build step &#x27;Execute shell&#x27; marked build as failure</span><br></pre></td></tr></table></figure>

<h2 id="docker内的容器找不到主机路径，需要Volume挂载"><a href="#docker内的容器找不到主机路径，需要Volume挂载" class="headerlink" title="docker内的容器找不到主机路径，需要Volume挂载"></a>docker内的容器找不到主机路径，需要Volume挂载</h2><p><strong>这个是最常见的，可能会以各种各样的形式出现</strong></p>
<h3 id="容器访问主机上的工程"><a href="#容器访问主机上的工程" class="headerlink" title="容器访问主机上的工程"></a>容器访问主机上的工程</h3><p>默认workspace在容器内的var/jenkins_home路径，上面我们已经通过<code>-v /d/Docker/Volume/Jenkins:/var/jenkins_home</code> 把主机的<code>d:\Docker\Volume\Jenkins</code>挂载到该目录下面了，访问<code>var/jenkins_home</code>就是访问<code>d:\Docker\Volume\Jenkins</code>。</p>
<p>也就是说需要将Android工程都复制到<code>d:\Docker\Volume\Jenkins</code>里面，然后通过<code>/var/jenkins_home</code>去访问具体的项目。</p>
<p>这样做的坏处显而易见，主机上的文件和docker容器文件混在一起，结构不清晰（强迫症受不了，目录和命名都要清清楚楚），要删除也不方便（我们要做的是随时可拆卸）。</p>
<p>解决办法很简单，还是挂载，将工程目录挂载到容器中一个新的目录下，单独存放工程。在run的时候使用<code>-v /e/ASproject:/var/as_project</code>挂载一个新的目录，<code>e:\ASproject</code>是放我的android项目，然后挂载到容器内的<code>/var/as_project</code>，访问<code>/var/as_project</code>就是访问<code>e:\ASproject</code>。</p>
<p>如果有java工程或者前端工程的话，可以按这种方式再挂载一个新的目录，然后在job里面需要配置Custom Workspace</p>
<h3 id="容器内Android-Sdk路径"><a href="#容器内Android-Sdk路径" class="headerlink" title="容器内Android Sdk路径"></a>容器内Android Sdk路径</h3><p>同理，Android项目的local.properties文件中用来指定sdk路径，一般是主机sdk路径。</p>
<p>这里也要修改成容器内的路径，否则执行编译的时候会找不到sdk路径，本地开发的时候再调成主机sdk路径。如图</p>
<p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins09.png" alt="Android Sdk路径"></p>
<p><strong>注：这里还有一个坑</strong></p>
<p>执行gradle的upload命令时一直报<code>llvm-rs-cc is missing</code>，在主机上运行没问题，容器中执行就报这个错。找了很久，发现是sdk的build_tools出了问题。</p>
<p>原因：主机是windows环境，下载的是windows版本的sdk，容器内是linux环境，通过上面的方法挂载主机的sdk，在容器中使用会出错。</p>
<p>解决办法：下载linux版本的android sdk，sdk比较大，有些文件是通用的，可以不用重复下载（build-tools刚好是不通用的，因此报了上面的错误）</p>
<p>具体方法可以看这篇文章：<a href="https://www.kafan.cn/edu/84098914.html">windows和linux下androidSDK</a></p>
<p>顺便学下linux下安装android sdk：<a href="https://blog.csdn.net/u011974797/article/details/78973012">Linux – 安装配置Android SDK</a></p>
<h2 id="Force-GRADLE-USER-HOME-to-use-workspace"><a href="#Force-GRADLE-USER-HOME-to-use-workspace" class="headerlink" title="Force GRADLE_USER_HOME to use workspace"></a>Force GRADLE_USER_HOME to use workspace</h2><p>这个选项是把gradle缓存之类的（就是平时用户目录下的.gradle/下的东西）都放到workspace里，网上说勾上，但这里我不建议勾选，不勾选他会下到<code>/root</code>目录下，所有项目共用（和平时一样）。</p>
<h2 id="job左边的workspace里面有一个清扫工作空间，看到一篇文章说"><a href="#job左边的workspace里面有一个清扫工作空间，看到一篇文章说" class="headerlink" title="job左边的workspace里面有一个清扫工作空间，看到一篇文章说"></a>job左边的workspace里面有一个清扫工作空间，看到一篇文章说</h2><p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins08.png" alt="Jenkins成功图"></p>
<p><strong>这里提醒一下，删除job不会删除项目，但是点击了清理工作空间，整个项目都会被删掉（慎用！！！！！）</strong></p>
<h2 id="docker中使用vim，有的容器有（nexus），有的容器没有（nginx、jenkins）"><a href="#docker中使用vim，有的容器有（nexus），有的容器没有（nginx、jenkins）" class="headerlink" title="docker中使用vim，有的容器有（nexus），有的容器没有（nginx、jenkins）"></a>docker中使用vim，有的容器有（nexus），有的容器没有（nginx、jenkins）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">更新来源</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash">安装vim</span></span><br><span class="line">apt-get install -y vim</span><br></pre></td></tr></table></figure>

<h2 id="执行compileDebug-stacktrace-出错，改为gradlew-compileDebugJavaWithJavac-stacktrace"><a href="#执行compileDebug-stacktrace-出错，改为gradlew-compileDebugJavaWithJavac-stacktrace" class="headerlink" title="执行compileDebug --stacktrace 出错，改为gradlew compileDebugJavaWithJavac --stacktrace"></a>执行<code>compileDebug --stacktrace </code>出错，改为<code>gradlew compileDebugJavaWithJavac --stacktrace</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.gradle.execution.TaskSelectionException: Task ‘compileDebug’ is ambiguous in root project ‘NJCitizenCardApp’. Candidates are: ‘compileDebugAidl’, ‘compileDebugAndroidTestAidl’, ‘compileDebugAndroidTestJavaWithJavac’, ‘compileDebugAndroidTestNdk’, ‘compileDebugAndroidTestRend</span><br><span class="line">erscript’, ‘compileDebugAndroidTestShaders’, ‘compileDebugAndroidTestSources’, ‘compileDebugJavaWithJavac’, ‘compileDebugNdk’, ‘compileDebugRenderscript’, ‘compileDebugShaders’, ‘compileDebugSources’, ‘compileDebugUnitTestJavaWithJavac’, ‘compileDebugUnitTestSources’.</span><br><span class="line">at org.gradle.execution.TaskSelector.getSelection(TaskSelector.java:116)</span><br><span class="line">at org.gradle.execution.TaskSelector.getSelection(TaskSelector.java:81)</span><br><span class="line">at org.gradle.execution.commandline.CommandLineTaskParser.parseTasks(CommandLineTaskParser.java:42)</span><br><span class="line">at org.gradle.execution.TaskNameResolvingBuildConfigurationAction.configure(TaskNameResolvingBuildConfigurationAction.java:44)</span><br><span class="line">at org.gradle.execution.DefaultBuildConfigurationActionExecuter.configure(DefaultBuildConfigurationActionExecuter.java:48)</span><br></pre></td></tr></table></figure>

<h2 id="执行build命令的时候出现这个"><a href="#执行build命令的时候出现这个" class="headerlink" title="执行build命令的时候出现这个"></a>执行<code>build</code>命令的时候出现这个</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: llvm-rs-cc is missing </span><br><span class="line">at com.android.builder.core.AndroidBuilder.compileAllRenderscriptFiles(AndroidBuilder.java:1194) </span><br><span class="line">at com.android.build.gradle.tasks.RenderscriptCompile.taskAction(RenderscriptCompile.java:</span><br></pre></td></tr></table></figure>

<p>我这里是因为buildToolsVersion（没加）、compileSdkVersion（27）和targetSdkVersion（27）不一致引起的，把buildToolsVersion加上这个问题就消失了。</p>
<p>然而最后正常之后，又提示：（也就是说白加了，问题不出在这里）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING: The specified Android SDK Build Tools version (27.0.3) is ignored, as it is below the minimum supported version (28.0.3) for Android Gradle Plugin 3.2.1.</span><br><span class="line">Android SDK Build Tools 28.0.3 will be used.</span><br><span class="line">To suppress this warning, remove &quot;buildToolsVersion &#39;27.0.3&#39;&quot; from your build.gradle file, as each version of the Android Gradle Plugin now has a default version of the build tools.</span><br></pre></td></tr></table></figure>

<h2 id="共用缓存报错（Jenkins执行任务，本地使用IDE也在执行）"><a href="#共用缓存报错（Jenkins执行任务，本地使用IDE也在执行）" class="headerlink" title="共用缓存报错（Jenkins执行任务，本地使用IDE也在执行）"></a>共用缓存报错（Jenkins执行任务，本地使用IDE也在执行）</h2><p> 这是因为在跑job的时候，手贱在android studio里面也点了一下。最后搜到是共用缓存被锁住的问题<a href="https://stackoverflow.com/questions/53186389/gradle-build-on-gitlab-ci-could-not-create-service-of-type-scriptpluginfactory">参考</a>，再跑一下就好了（不。是换了个错误）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Could not create service of type ScriptPluginFactory using BuildScopeServices.createScriptPluginFactory().</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Could not create service of <span class="built_in">type</span> FileHasher using BuildSessionScopeServices.createFileSnapshotter().</span></span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Exception is:</span><br><span class="line">org.gradle.internal.service.ServiceCreationException: Could not create service of type ScriptPluginFactory using BuildScopeServices.createScriptPluginFactory().</span><br><span class="line">	at org.gradle.internal.service.DefaultServiceRegistry$FactoryMethodService.invokeMethod(DefaultServiceRegistry.java:857)</span><br><span class="line">	at org.gradle.internal.service.DefaultServiceRegistry$FactoryService.create(DefaultServiceRegistry.java:808)</span><br><span class="line">	</span><br><span class="line">	........ more</span><br><span class="line">	</span><br><span class="line">Caused by: org.gradle.api.UncheckedIOException: java.io.IOException: Input/output error</span><br><span class="line">	at org.gradle.internal.UncheckedException.throwAsUncheckedException(UncheckedException.java:57)</span><br><span class="line">	at org.gradle.internal.UncheckedException.throwAsUncheckedException(UncheckedException.java:40)</span><br><span class="line">	at org.gradle.cache.internal.DefaultFileLockManager.lock(DefaultFileLockManager.java:103)</span><br><span class="line">	at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.incrementLockCount(LockOnDemandCrossProcessCacheAccess.java:105)</span><br><span class="line">	at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.acquireFileLock(LockOnDemandCrossProcessCacheAccess.java:161)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.onStartWork(DefaultCacheAccess.java:368)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:213)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:203)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.newCache(DefaultCacheAccess.java:298)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheAccess.newCache(DefaultCacheAccess.java:57)</span><br><span class="line">	at org.gradle.cache.internal.DefaultPersistentDirectoryStore.createCache(DefaultPersistentDirectoryStore.java:148)</span><br><span class="line">	at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.createCache(DefaultCacheFactory.java:177)</span><br><span class="line">	at org.gradle.api.internal.changedetection.state.CrossBuildFileHashCache.createCache(CrossBuildFileHashCache.java:51)</span><br><span class="line">	at org.gradle.api.internal.changedetection.state.CachingFileHasher.&lt;init&gt;(CachingFileHasher.java:44)</span><br><span class="line">	at org.gradle.internal.service.scopes.BuildSessionScopeServices.createFileSnapshotter(BuildSessionScopeServices.java:198)</span><br><span class="line">	at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)</span><br><span class="line">	at org.gradle.internal.service.ReflectionBasedServiceMethod.invoke(ReflectionBasedServiceMethod.java:35)</span><br><span class="line">	at org.gradle.internal.service.DefaultServiceRegistry$FactoryMethodService.invokeMethod(DefaultServiceRegistry.java:855)</span><br><span class="line">	... 82 more</span><br><span class="line">Caused by: java.io.IOException: Input/output error</span><br><span class="line">	at org.gradle.cache.internal.filelock.LockStateAccess.readState(LockStateAccess.java:69)</span><br><span class="line">	at org.gradle.cache.internal.filelock.LockStateAccess.ensureLockState(LockStateAccess.java:46)</span><br><span class="line">	at org.gradle.cache.internal.filelock.LockFileAccess.ensureLockState(LockFileAccess.java:59)</span><br><span class="line">	at org.gradle.cache.internal.DefaultFileLockManager$DefaultFileLock.lock(DefaultFileLockManager.java:293)</span><br><span class="line">	at org.gradle.cache.internal.DefaultFileLockManager$DefaultFileLock.&lt;init&gt;(DefaultFileLockManager.java:154)</span><br><span class="line">	at org.gradle.cache.internal.DefaultFileLockManager.lock(DefaultFileLockManager.java:100)</span><br><span class="line">	... 97 more</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Docker容器内无法访问主机网络"><a href="#Docker容器内无法访问主机网络" class="headerlink" title="Docker容器内无法访问主机网络"></a>Docker容器内无法访问主机网络</h2><p>背景：执行Jenkins打包aar到maven仓库的时候，提示无法连接到Nexus服务。</p>
<p>原因：Docker容器内无法访问主机网络</p>
<p>我运行了Docker的Nexus容器，主机使用<code>localhost:8081</code>访问Nexus服务，Docker的Jenkins容器无法访问<code>localhost</code>地址。（可以使用<code>exec</code>命令进入容器内，在容器中使用curl或者telnet工具尝试访问端口）</p>
<p>解决办法：</p>
<ul>
<li>使用主机IP访问<ul>
<li>在容器内使用<code>ip addr</code>命令查看ip地址</li>
<li>在容器外使用<code>ipconfig</code>命令查看ip地址</li>
</ul>
</li>
<li>运行容器的时候可以配置容器网络：默认有三种网络：host、bridge、none，可以使用<code>docker network ls</code>命令查看，可以使用<code>docker network create</code>命令自行创建网络。使用<code>docker run --network 网络名</code>命令配置容器网络<ul>
<li>容器使用宿主机网络：使用<code>docker run --network host</code>命令。（有坑：这种模式只适用于Linux主机，不适合windows和mac）</li>
<li>容器以桥接模式连接到宿主机：使用<code>docker run --network bridge</code>命令（不设置的话使用默认的bridge网络）</li>
</ul>
</li>
</ul>
<p>参考<a href="https://www.jb51.net/article/149173.htm">Docker容器访问宿主机网络的方法</a></p>
<p>这里碰到了一个问题，我对网络不太了解，不过经过测试之后得出来了一些结论，有知道的可以联系我。</p>
<p>我主机总共监听了3个端口：</p>
<ul>
<li>使用docker运行了Nexus容器，映射到主机的8081端口，原端口也是8081</li>
<li>使用docker运行了Jenkins容器，映射到主机的8082端口，原端口是8080</li>
<li>主机上运行了springboot的服务，监听8083端口</li>
</ul>
<p>这里不设置桥接网络，即用默认的Bridge网络，使用<code>docker inspect &lt;容器名&gt;</code>可以查看到Networks的配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//截取其中网关和ip地址</span></span><br><span class="line"><span class="comment">//Jenkins配置如下</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看Nexus的配置，这个ip是按容器创建顺序自动分配的</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进入Jenkins容器中使用curl测试下能否访问地址和端口，测试结果如下</p>
<ul>
<li>在主机浏览器上使用<code>localhost</code>都能访问这三个端口，没问题。</li>
<li>主机上访问172.17.0.1:8081，超时，但不是被拒绝了</li>
<li>Jenkins容器内访问：</li>
</ul>
<table>
<thead>
<tr>
<th>主机:端口</th>
<th>Jenkins</th>
</tr>
</thead>
<tbody><tr>
<td>localhost</td>
<td>三个端口都访问不到</td>
</tr>
<tr>
<td>172.17.0.1:8081（网关+Nexus映射端口）</td>
<td>可以</td>
</tr>
<tr>
<td>172.17.0.1:8082（网关+Jenkins映射端口）</td>
<td>可以</td>
</tr>
<tr>
<td>172.17.0.1:8083（网关+主机服务端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.2:8081（NexusIP+Nexus原/映射端口）</td>
<td>可以</td>
</tr>
<tr>
<td>172.17.0.2:8082（NexusIP+Jenkins映射端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.2:8083（NexusIP+主机服务端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.3:8081（JenkinsIP+Nexus映原/映射端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.3:8082（JenkinsIP+Jenkins映射端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.3:8083（JenkinsIP+主机服务端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>主机动态ip:8081</td>
<td>可以</td>
</tr>
<tr>
<td>主机动态ip:8082</td>
<td>可以</td>
</tr>
<tr>
<td>主机动态ip:8083</td>
<td>可以</td>
</tr>
<tr>
<td>主机动态ip:8080</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.1:8080（网关+Jenkins原端口）</td>
<td>不可以</td>
</tr>
<tr>
<td>172.17.0.3:8080（JenkinsIP+Jenkins原端口）</td>
<td>可以</td>
</tr>
</tbody></table>
<p>得出结论如下（对网络不太了解，凭自己感觉得出来结论，有错误的地方可以联系我）：</p>
<ul>
<li>docker使用bridge网络，即是一个虚拟的网关：172.17.0.1，或者叫子网？（可以使用<code>docker network create</code>命令自行创建网络），容器在这个子网下创建，会分配到一个虚拟的ip地址</li>
<li>在子网内的容器互相访问可以使用<code>网关+容器映射端口</code>，或者使用<code>容器的ip+该容器的原端口号</code><ul>
<li>这里的原端口指的是没有映射过的端口，如Jenkins是8080，Nexus是8081</li>
<li>Nexus可以使用172.17.0.3:8080访问Jenkins，使用8082则不可以</li>
</ul>
</li>
<li>主机访问容器，直接访问<code>主机IP+容器映射端口</code>。理论上应该是可以通过网关（172.17.0.1）访问到容器内部的，这里只是提示超时了，不知道应该怎么设置。</li>
</ul>
<p>按我的理解就是docker给每个容器分配了一个虚拟的网关和虚拟的ip地址。把每个容器看作一台机器，同一个网关下的容器看作一个子网下的机器。（真实的网络我不了解，但是应该能够得出和虚拟的一样的结论）</p>
<ul>
<li>容器映射出去的端口到网关那里，因此可以通过<code>网关+容器映射端口</code>访问到容器。同样也映射到了主机那里，可以通过<code>主机ip+容器映射端口</code>访问</li>
<li>知道容器ip的情况下，可以直接访问容器监听的端口，即<code>容器ip+容器原端口</code>（和主机服务类似，也可以通过localhost访问自己的端口），不能使用映射出去的端口了</li>
<li>但是容器要访问外部（主机）的话就只有通过主机ip访问（不过这个ip是动态在变的，每次都要换，也可以通过域名，或者设置固定ip）</li>
</ul>
<p>win10固定ip设置：</p>
<ul>
<li>命令行<code>ipconfig/all</code>查看IPv4、子网掩码、网关、首选DNS、备用DNS。（或者网络和Internet-&gt;状态-&gt;查看网络属性）</li>
<li>找到IP设置-&gt;IPv4，选择手动，一个个填上去就好了。</li>
<li>就不放图了</li>
</ul>
<h3 id="docker容器内无法访问公网"><a href="#docker容器内无法访问公网" class="headerlink" title="docker容器内无法访问公网"></a>docker容器内无法访问公网</h3><p>Temporary failure in name resolution</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br><span class="line"><span class="meta">#</span><span class="bash">报错</span></span><br><span class="line">ping: www.baidu.com: Temporary failure in name resolution</span><br><span class="line"><span class="meta">#</span><span class="bash">或者：ping: www.bing.com: Name or service not known</span></span><br></pre></td></tr></table></figure>

<p>原因：DNS设置有问题</p>
<p>解决办法：windows下打开docker设置，如下图，选择固定DNS（具体原因不太懂，自己尝试了这样改就OK了）</p>
<p><img src="/images/Docker/docker07.png" alt="docker容器访问公网"></p>
<h2 id="python编码错误"><a href="#python编码错误" class="headerlink" title="python编码错误"></a>python编码错误</h2><h3 id="编码错误1"><a href="#编码错误1" class="headerlink" title="编码错误1"></a>编码错误1</h3><p>背景：http请求返回值中含有中文，在容器内使用命令行运行没报错，使用jenkins job运行就报编码错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 84-87: ordinal not in range(128)</span><br></pre></td></tr></table></figure>

<p>原因：python默认编码是ascii。</p>
<p>解决办法：</p>
<p>（1）加上这三句，设置编码。（本文件有效）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>（2）设置python默认编码（全局python环境）,#在Python的Lib\site-packages文件夹下新建一个sitecustomize.py文件，内容为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>（3）使用命令行运行不会报错。。。</p>
<h3 id="编码错误2"><a href="#编码错误2" class="headerlink" title="编码错误2"></a>编码错误2</h3><p>还有一种情况，python文件中出现中文，包括中文注释，运行的时候也会报错（而且使用命令行也会报错）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character &#x27;\xe5&#x27; in file E:/CiProject/jenkins_workspace/ci_scripts/util/http_util.py on line 11, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details</span><br></pre></td></tr></table></figure>

<p>原因：python文件默认是以ascii保存的</p>
<p>解决办法：需要声明文件编码格式，在文件头加上声明，下面几种方式都可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=&lt;encoding name&gt;</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: &lt;encoding name&gt; -*-</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># vim: set fileencoding=&lt;encoding name&gt; :</span></span><br></pre></td></tr></table></figure>

<h2 id="其他Android错误"><a href="#其他Android错误" class="headerlink" title="其他Android错误"></a>其他Android错误</h2><p>运行Gradle脚本可能会出现各种各样的Android或者Gradle错误，只能一个个排查了，比如遇到内存不足，sdk版本不对等</p>
<h2 id="docker容器时区和宿主机不一致"><a href="#docker容器时区和宿主机不一致" class="headerlink" title="docker容器时区和宿主机不一致"></a>docker容器时区和宿主机不一致</h2><ul>
<li>docker容器内时区为UTC：国际协调时间，即0时区</li>
<li>宿主机时区为CST：中国标准时间，即东八区</li>
</ul>
<p>解决办法：</p>
<ol>
<li><p>启动容器的时候通过挂载共享主机的localtime：<code>docker run --name &lt;name&gt; -v /etc/localtime:/etc/localtime</code></p>
</li>
<li><p>将主机的配置文件拷贝到容器中：<code>docker cp /etc/localtime:【容器ID或者NAME】/etc/localtime</code></p>
</li>
<li><p>使用<code>docker exec -it &lt;容器名/id&gt; /bin/bash</code>进去容器内部进行修改。（当作一个linux系统即可）</p>
</li>
<li><p>创建自定义的Dockerfile，如下。保存后使用docker build生成镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM redis</span><br><span class="line">FROM tomcat</span><br><span class="line">ENV CATALINA_HOME /usr/local/tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash">设置时区</span></span><br><span class="line">RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">  &amp;&amp; echo &#x27;Asia/Shanghai&#x27; &gt;/etc/timezone \</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>对于Windows版的docker，时区配置不知道在哪，上面的方法不知道有没有用，因为暂时不影响，所以没尝试</strong></p>
<h2 id="使用shell执行gradlew命令"><a href="#使用shell执行gradlew命令" class="headerlink" title="使用shell执行gradlew命令"></a>使用shell执行gradlew命令</h2><ul>
<li>使用gradle命令：在容器内下载gradle，并且在<strong>容器内部（不是宿主机）</strong>配置环境变量。（或者直接挂载主机的gradle路径）</li>
<li>使用gradlew命令：gradlew对gradle进行了封装，并且会自动下载对应版本的gradlew。</li>
</ul>
<p><strong>使用gradlew注意：</strong></p>
<ul>
<li><p>修改Android工程的.gitignore，下面三行去掉</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/gradle/</span><br><span class="line">/gradlew</span><br><span class="line">/gradlew.bat</span><br></pre></td></tr></table></figure></li>
<li><p>脚本需要使用<code>./gradlew ***</code>执行，而不是<code>gradlew</code>，因为容器是linux环境，和宿主机（windows）不同</p>
</li>
<li><p>会自动下载相应版本到用户目录的<code>.gradle</code>文件夹下</p>
</li>
</ul>
<h2 id="切换task为assembleDebug终于成功打出apk了，折腾了一晚上天快亮了，"><a href="#切换task为assembleDebug终于成功打出apk了，折腾了一晚上天快亮了，" class="headerlink" title="切换task为assembleDebug终于成功打出apk了，折腾了一晚上天快亮了，"></a>切换task为<code>assembleDebug</code>终于成功打出apk了，折腾了一晚上天快亮了，</h2><p><img src="/2019/01/14/tool-2019-1-14-Docker-Jenkins/jenkins14.png" alt="Jenkins成功图"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative学习</title>
    <url>/2019/01/01/android-2019-01-01-ReactNative/</url>
    <content><![CDATA[<h1 id="和传统前端的区别【转】"><a href="#和传统前端的区别【转】" class="headerlink" title="和传统前端的区别【转】"></a>和传统前端的区别<a href="https://www.jianshu.com/p/91dd6ae96a26">【转】</a></h1><h2 id="标签不同"><a href="#标签不同" class="headerlink" title="标签不同"></a>标签不同</h2><ul>
<li>容器：div——View</li>
<li>图片    img——Image</li>
<li>文字    所有双标签——Text</li>
<li>背景    background——ImageBackground</li>
</ul>
<p><strong>注意:</strong></p>
<ol>
<li><p>react native中所有的标签首字母必须大写，而html标签标准都是小写</p>
</li>
<li><p>react native中所有需要输出的文字必须使用<code>&lt;Text&gt;&lt;/Text&gt;</code>包裹,而HTML里面的双标签都可以包裹文字</p>
</li>
<li><p>react native的style中不支持使用background来定义背景，如果想要用图片做背景，必须使用<code>&lt;ImageBackground source=&#123;require(&quot;bg.png&quot;)&#125;&gt;&lt;/ImageBackground&gt;</code>标签包裹，而html中的css中可以使用：<code>background:url(&quot;../images/bg.png&quot;)</code>。</p>
</li>
<li><p>HTML中的图片：<code>&lt;img src=&quot;a.jpg&quot;/&gt;</code>，react native中的图片必须指定宽高：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Image source&#x3D;&quot;&#123;&#123; uri: thumb &#125;&#125;&quot; style&#x3D;&quot;&#123;&#123; width:100, height:100 &#125;&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="布局样式不同"><a href="#布局样式不同" class="headerlink" title="布局样式不同"></a>布局样式不同</h2><p>react native中不存在float，也不支持position:fixed，而是采用的flex布局，虽然react native支持position中的absolute和realative以及flex,都是和html中css有所不同:</p>
<ul>
<li>react native中的absolute默认相对于父级，就算父级没有定位，而css中的absolute是向上寻找的相对点，如果父级没有定位，一直往上找定位参考点</li>
<li>react native中的flex的flexDirection默认值是:column而css中的默认值是row</li>
<li>react native中的高度等于父级高度使用flex:1 ，而web的css中使用height:100%，react native中没有百分比的概念</li>
</ul>
<p><em>react native支持的属性：参考<a href="https://reactnative.cn/docs/0.49/layout-props.html#content">属性</a></em></p>
<h2 id="结构不同"><a href="#结构不同" class="headerlink" title="结构不同"></a>结构不同</h2><p>html加载的时候是自上而下的阻塞式加载，而react native根据生命周期来渲染，跟写的位置无关，而且react native文件一切皆js，无论是结构还是css还是JS逻辑，下面是react native的生命周期:</p>
<ul>
<li>constructor:组件被创建之前初始化数据</li>
<li>componentWillMount组件已创建但是未被渲染，可以在这里面请求数据</li>
<li>render:组件渲染，组件结构都写在这里</li>
<li>componentDidMount:组件已渲染完,可以在这里请求数据并使用setState改变数据来触发视图自动更新</li>
<li>componentWillReceiveProps:如果组件收到新的属性（props），就会调用此函数,并使用setState改变数据来触发视图自动更新</li>
<li>shouldComponentUpdate当组件接收到新的属性和状态改变的话，都会触发调用 shouldComponentUpdate来判断组件是否应该更新</li>
<li>componentWillUpdate如果组件状态或者属性改变，并且上的 shouldComponentUpdate(…) 返回为 true，就会开始准更新组件，并调用 componentWillUpdate()</li>
<li>componentDidUpdate调用了 render() 更新完成界面之后，会调用 componentDidUpdate() 来得到通知</li>
<li>componentWillUnmount当组件要被从界面上移除的时候，就会调用此函数，一般在这里取消定时器，remove监听事件</li>
</ul>
<h2 id="页面跳转不同"><a href="#页面跳转不同" class="headerlink" title="页面跳转不同"></a>页面跳转不同</h2><p>html中使用a标签或者window.location.href来跳转页面，react native的路由跳转有多种方案,可以根据自身选择，官方推荐react-navigation，还有react-native-router-flux,navigator等</p>
<h2 id="js运行环境不同"><a href="#js运行环境不同" class="headerlink" title="js运行环境不同"></a>js运行环境不同</h2><p>web中的js运行在浏览器，最上级是window，而react native里没有window的概念,组件化最上级是global,挂在global下面是跨组件的，例如global.a=1，那么在所有组件都能使用a，所以一般登录成功后把token挂在global上面，在其他任何页面请求数据的时候可以直接使用token，注销登录就清除token</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="React-Native-Error-Cannot-find-module-‘asap-raw’"><a href="#React-Native-Error-Cannot-find-module-‘asap-raw’" class="headerlink" title="React Native:Error: Cannot find module ‘asap/raw’"></a>React Native:Error: Cannot find module ‘asap/raw’</h2><p>安装<code>react-native-navigation</code>后出错</p>
<p>解决办法：重新安装依赖，执行<code>npm install</code></p>
<h2 id="setting-gradle路径问题"><a href="#setting-gradle路径问题" class="headerlink" title="setting.gradle路径问题"></a>setting.gradle路径问题</h2><p>使用react-navigation：</p>
<ul>
<li>yarn add react-navigation</li>
<li>yarn add react-native-gesture-handler</li>
<li>react-native link react-native-gesture-handler （会修改setting.gradle，引入react-native-gesture-handler作为project module）</li>
</ul>
<p>问题：路径使用<code>\</code>分割，不正确，应该修改为<code>/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Settings file &#x27;E:\AndroidStudioProjects\Demo\android\settings.gradle&#x27; line: 3</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Could not compile settings file &#x27;E:\AndroidStudioProjects\Demo\android\settings.gradle&#x27;.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> startup failed:</span></span><br><span class="line">  settings file &#x27;E:\AndroidStudioProjects\Demo\android\settings.gradle&#x27;: 3: unexpected char: &#x27;\&#x27; @ line 3, column 133.</span><br><span class="line">     s\react-native-gesture-handler\android&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="VsCode格式化代码"><a href="#VsCode格式化代码" class="headerlink" title="VsCode格式化代码"></a>VsCode格式化代码</h2><p>VsCode格式化ReactNative代码的时候，标签尖括号会换行</p>
<p>解决办法：如果是js文件，下面不要选择JavaScript，而是JavaScript React，如图</p>
<p><img src="/2019/01/01/android-2019-01-01-ReactNative/vscode_format.png" alt="VsCode格式化ReactNative代码"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmder——Windows下好用的命令行工具</title>
    <url>/2018/12/14/tool-2018-12-14-Cmder/</url>
    <content><![CDATA[<h2 id="Cmder"><a href="#Cmder" class="headerlink" title="Cmder"></a>Cmder</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Cmder是windows下的命令行工具，支持大部分Linux命令，使用方便，可以替代原来的cmd，并且界面美观简洁，相比PowerShell、cmd不忍直视。</p>
<p>先上效果图</p>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder.png"></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>直接去<a href="http://cmder.net/">官网</a>下载，解压即可</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li><p>配置环境变量</p>
<p>把解压后的目录加到系统环境变量，然后使用<code>win +R</code>，输入<code>cmder</code>，即可快捷打开cmder</p>
</li>
<li><p>加入右键菜单（类似git bash）：打开命令行工具输入<code>cmder /register all</code></p>
<p>如果遇到拒绝访问，如下，可以通过”右键，以管理员方式运行”</p>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder01.png"></p>
</li>
<li><p>添加语言环境，否则会出现中文乱码</p>
<p>在Settings -&gt;Startup -&gt; Environment中添加一行：<code>set LC_ALL=zh_CN.UTF-8</code>，注意后面的分号</p>
</li>
</ol>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder02.png"></p>
<ol start="4">
<li><p>修改命令提示符号</p>
<p>cmder默认提示符号是λ，可以改成$：打开cmder安装目录下的\vendor\clink.lua文件，搜索<code>$&#123;lamb&#125;</code>改成想要的符号，如下</p>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder03.png"></p>
</li>
<li><p>设置命令别名</p>
<p>cmder原生不支持如<strong>ll</strong> 等命令，可以通过设置别名来实现</p>
<p>打开cmder安装目录下的\config\user-aliases.cmd文件，加入下面设置，也可以自定义</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l&#x3D;ls --show-control-chars -F --color $*</span><br><span class="line">la&#x3D;ls -aF --show-control-chars -F --color $*</span><br><span class="line">ll&#x3D;ls -alF --show-control-chars -F --color $*</span><br></pre></td></tr></table></figure>

<p>​    使用<code>&amp;</code>连接执行多条命令，<code>$1、$2、$*</code>表示命令后面添加的参数。</p>
<p>可以通过命令别名设置快速进入常用文件夹，如<code>project = e: &amp; cd MyProject\$*</code>，输入<code>project</code>则切换到e盘，并进入<code>MyProject</code>目录，输入<code>project subproject\hhh</code>则表示进入<code>e:\MyProject\subproject\hhh</code></p>
<ol>
<li><p>指定命令执行环境</p>
<p><img src="/2018/12/14/tool-2018-12-14-Cmder/cmder04.png"></p>
</li>
<li><p>快捷键</p>
<p><code>Ctrl+U</code>：清除当前行</p>
<p><code>Ctrl+L</code>：清屏</p>
<p><code>Ctrl+T</code>：新建标签页</p>
<p><code>Ctrl+W</code>：关闭标签页</p>
<p><code>鼠标右键</code>：粘贴</p>
<p><code>Ctrl+鼠标滚轮</code>：放大缩小字体</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/mynamepg/article/details/81233120">推荐一款超好用的工具cmder</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js或ts语法笔记</title>
    <url>/2018/12/12/webdev-2018-12-12-SyntaxSugarNote/</url>
    <content><![CDATA[<h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><ul>
<li><p><code>==</code>和<code>===</code></p>
<ul>
<li>==会自动转换类型比较</li>
<li>===严格比较，类型需要相同</li>
<li>!=和!==同理</li>
</ul>
</li>
<li><p><code>success?.() </code>相当于<code>success &amp;&amp; success()</code>，判断不为空再执行</p>
</li>
<li><p>(+”1”)把字符串转换成整数</p>
</li>
</ul>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>prototype 属性允许您向对象添加属性和方法</p>
<p><strong>注意：</strong> Prototype 是全局属性，适用于所有的Javascript对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">employee</span>(<span class="params">name,jobtitle,born</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name=name;</span><br><span class="line">	<span class="built_in">this</span>.jobtitle=jobtitle;</span><br><span class="line">	<span class="built_in">this</span>.born=born;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fred=<span class="keyword">new</span> employee(<span class="string">&quot;Fred Flintstone&quot;</span>,<span class="string">&quot;Caveman&quot;</span>,<span class="number">1970</span>);</span><br><span class="line">employee.prototype.salary=<span class="literal">null</span>;</span><br><span class="line">fred.salary=<span class="number">20000</span>;</span><br><span class="line"><span class="built_in">document</span>.write(fred.salary);</span><br></pre></td></tr></table></figure>

<p>给employee函数添加了salary属性，可以.出来</p>
<h2 id="argument"><a href="#argument" class="headerlink" title="argument"></a>argument</h2><p>在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function howManyArgs() &#123;</span><br><span class="line">  alert(arguments.length);</span><br><span class="line">&#125;</span><br><span class="line">howManyArgs(&quot;string&quot;, 45);    &#x2F;&#x2F;2</span><br><span class="line">howManyArgs();    &#x2F;&#x2F;0</span><br><span class="line">howManyArgs(12);    &#x2F;&#x2F;1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：与其他程序设计语言不同，ECMAScript 不会验证传递给函数的参数个数是否等于函数定义的参数个数。开发者定义的函数都可以接受任意个数的参数（根据 Netscape 的文档，最多可接受 255 个），而不会引发任何错误。任何遗漏的参数都会以 undefined 传递给函数，多余的函数将忽略。</p>
<h2 id="pipeline写法"><a href="#pipeline写法" class="headerlink" title="pipeline写法"></a>pipeline写法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data </span><br><span class="line">|&gt; fnx</span><br><span class="line">|&gt; fny</span><br><span class="line">|&gt; fnz</span><br></pre></td></tr></table></figure>

<p>相当于fnz(fny(fnx(data)))，pipeline写法</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> func=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;&#125;</span><br><span class="line"> <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connect（a,b）=func（c）</p>
<p>connect(mapStateToProps,mapDispatchToProps)(MainPage)</p>
<p>实际上是这样func(c)(MainPage);</p>
<p>MainPage是赋值给里面的c，而不是对应a，b</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB工具（Android Debug Bridge）</title>
    <url>/2018/12/11/android-2018-12-11-ADBTool/</url>
    <content><![CDATA[<h1 id="adb（Android-Debug-Bridge）安卓调试工具"><a href="#adb（Android-Debug-Bridge）安卓调试工具" class="headerlink" title="adb（Android Debug Bridge）安卓调试工具"></a>adb（Android Debug Bridge）安卓调试工具</h1><p>ADB是连接Android手机与PC端的桥梁,通过adb可以管理、操作模拟器和设备，如安装软件、查看设备软硬件参数、系统升级等</p>
<h2 id="Mac配置环境变量"><a href="#Mac配置环境变量" class="headerlink" title="Mac配置环境变量"></a>Mac配置环境变量</h2><ol>
<li>修改<code>~/.bash_profile</code>文件如下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/name/Library/Android/sdk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/tools`</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;ANDROID_HOME&#125;</span>/platform-tools</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行<code>source .bash_profile</code>生效，如果使用了<code>zsh</code>，在<code>~/.zshrc</code>文件末尾添加<code>source ~/.bash_profile</code></li>
</ol>
<h2 id="常用adb命令"><a href="#常用adb命令" class="headerlink" title="常用adb命令"></a>常用adb命令</h2><ul>
<li><code>adb connect &lt;手机ip[:端口号]&gt;</code>：连接adb，默认端口号为5555</li>
<li><code>adb disconnect</code>：断开连接</li>
<li><code>adb devices</code>：查看连接的设备</li>
<li><code>adb [command] --help</code>：查看某个命令的帮助</li>
<li><code>adb install 电脑路径/xxx.apk</code>：安装apk到手机。-r覆盖安装，-t安装测试包，-d忽略版本大小</li>
<li><code>adb pull 手机存储路径 电脑路径</code>：从手机拷贝到电脑</li>
<li><code>adb push 电脑路径 手机存储路径</code>：从电脑拷贝到手机</li>
<li><code>adb shell</code>：进入Android终端。<code>-s</code>：如果连接了多个设备，使用-s指定设备</li>
<li><code>adb root</code>：开启root，大部分系统无法直接root</li>
<li><code>adb remount</code>：挂载目录，设置为可读写（需先root），或者进入终端输入<code>mount -o remount,rw [路径]</code></li>
<li>开启无线adb（需先root）：连接串口或USB，进入终端输入<ul>
<li><code>stop adbd</code></li>
<li><code>setprop service.adb.tcp.port 5555</code></li>
<li><code>start adbd</code></li>
</ul>
</li>
<li><code>adb kill-server</code>：杀死adb服务</li>
<li><code>adb start-server</code>：启动adb服务</li>
</ul>
<h2 id="输出设备日志"><a href="#输出设备日志" class="headerlink" title="输出设备日志"></a>输出设备日志</h2><ul>
<li><code>adb logcat &gt; logcat.log</code>：输出日志到logcat.log文件夹，如果没有则新建</li>
<li><code>adb logcat &gt; &quot;%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%时%time:~3,2%分%time:~6,2%.log&quot;</code>：以日期时间命名文件</li>
<li><code>logcat -d -f &lt;文件名&gt;</code>：输出日志，-d表示将缓存日志全部输出</li>
<li><code>dmesg</code>：查看linux kernel开机日志</li>
</ul>
<p>adb logcat [选项] [过滤项]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选项</span><br><span class="line">&quot;-s&quot;: 设置输出日志的标签, 只显示该标签的日志;</span><br><span class="line">&quot;-f&quot;: 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;</span><br><span class="line">&quot;-r&quot;: 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;</span><br><span class="line">&quot;-n&quot;: 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;</span><br><span class="line">&quot;-v&quot;: 设置日志的输出格式, 注意只能设置一项;</span><br><span class="line">&quot;-c&quot;: 清空所有的日志缓存信息;</span><br><span class="line">&quot;-d&quot;: 将缓存的日志输出到屏幕上, 并且不会阻塞;</span><br><span class="line">&quot;-t&quot;: 输出最近的几行日志, 输出完退出, 不阻塞;</span><br><span class="line">&quot;-g&quot;: 查看日志缓冲区信息;</span><br><span class="line">&quot;-b&quot;: 加载一个日志缓冲区, 默认是 main, 下面详解;</span><br><span class="line">&quot;-B&quot;: 以二进制形式输出日志;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">过滤项格式 : &lt;tag&gt;[:priority] , 标签：日志等级, 默认的日志过滤项是&quot;*:I&quot;;如&quot;*:E&quot;表示过滤Error以上。</span><br><span class="line">-- V : Verbose (明细);</span><br><span class="line">-- D : Debug (调试);</span><br><span class="line">-- I : Info (信息);</span><br><span class="line">-- W : Warn (警告);</span><br><span class="line">-- E : Error (错误);</span><br><span class="line">-- F: Fatal (严重错误);</span><br><span class="line">-- S : Silent(Super all output) (最高的优先级, 可能不会记载东西);</span><br></pre></td></tr></table></figure>

<h1 id="常用android调试命令手册"><a href="#常用android调试命令手册" class="headerlink" title="常用android调试命令手册"></a>常用android调试命令手册</h1><p>可以结合<code>grep</code>命令过滤关键信息。</p>
<blockquote>
<p><code>grep [options] PATTERN FILE</code>：<code>grep -inR enable_global_input *</code></p>
<ul>
<li>-i：忽略大小写</li>
<li>-n：输出匹配的行号</li>
<li>-R：递归遍历文件夹</li>
<li>-E：可以输入多个：<code>grep -E &quot;word1|word2|word3&quot; file.txt </code></li>
</ul>
</blockquote>
<p><strong><code>dumpsys、pm、am、wm</code>等命令本质也是通过执行代码运行的，可以在framework中搜索到相关代码，了解原理</strong></p>
<h2 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h2><ul>
<li><code>dumpsys activity</code>：输出Android组件信息，可以加上a[ctivities]、b[roadcasts]、s[ervices]、prov[iders]等过滤特定信息</li>
<li><code>dumpsys window windows</code>：获取窗口信息，结合<code>grep mFocus</code>获取当前窗口</li>
<li><code>dumpsys package &lt;packagename&gt;</code>：输出应用包信息，结合<code>grep version</code>查看应用版本，结合<code>grep path</code>查看应用路径</li>
<li><code>dumpsys meminfo</code>：查看内存信息</li>
<li><code>dumpsys cpuinfo</code>：查看cpu信息</li>
</ul>
<h2 id="pm"><a href="#pm" class="headerlink" title="pm"></a>pm</h2><ul>
<li><p><code>pm list package -f </code>：输出所有已安装apk</p>
<ul>
<li>-f：输出安装路径</li>
<li>-3：过滤出第三方应用</li>
<li>-s：过滤出系统应用</li>
<li>-d：过滤disable应用</li>
<li>-U：显示应用uid</li>
<li>–uid UID：过滤指定uid应用</li>
<li>–user USER_ID：过滤指定userid应用</li>
</ul>
</li>
<li><p><code>pm install/uninstall &lt;apk文件&gt;</code>：安装应用，-r覆盖安装，-t安装测试包，-d忽略版本大小</p>
</li>
<li><p><code>pm path [package_name]</code>：查看应用安装路径</p>
</li>
<li><p><code>pm dump &lt;packagename&gt;</code>：查看应用信息</p>
</li>
<li><p><code>pm clear</code>：清除应用缓存数据</p>
</li>
<li><p><code>pm enable/disable &lt;包名/组件名&gt;</code>：启用/禁用组件，设置为disable之后组件无法运行。如开机向导应用，运行完毕之后禁用，下次开机就会直接进入桌面</p>
</li>
</ul>
<h2 id="am"><a href="#am" class="headerlink" title="am"></a>am</h2><ul>
<li><code>am start</code>、<code>am startservice</code>、<code>am broadcast</code>：启动组件<ul>
<li>-p：包名</li>
<li>-n：包名/Manifest注册组件名。</li>
<li>-a：action启动</li>
<li>-c：category</li>
<li>-d：data，uri启动</li>
</ul>
</li>
<li><code>am force-stop &lt;包名&gt;</code>：退出应用</li>
</ul>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><ul>
<li><code>input</code>：输入事件<ul>
<li><code>input keyevent &lt;keycode&gt;</code>：输入按键事件</li>
<li><code>input text xxx</code>：输入文本</li>
<li><code>input tap &lt;x&gt; &lt;y&gt;</code>：输入点击事件</li>
<li><code>input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;</code>：输入滑动事件</li>
<li>…</li>
</ul>
</li>
<li><code>getevent</code>：获取按键键值</li>
<li><code>sendevent &lt;device：设备&gt; &lt;type：事件类型&gt; &lt;scanCode：linux键值&gt; &lt;value：键值&gt;</code>：发送按键事件<ul>
<li>scanCode是linux层的键值和android keycode不一样。红外按键是从底层驱动传入，转换为Linux层scanCode，再转换为Android的KeyCode。</li>
<li>1为按下，0为松开</li>
<li>如<code>sendevent /dev/input/event0 1 658 1 &amp;&amp; sendevent /dev/input/event0 0 0 0 &amp;&amp; sendevent /dev/input/event0 1 658 0 &amp;&amp; sendevent /dev/input/event0 0 0 0</code></li>
</ul>
</li>
</ul>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><ul>
<li><code>dumpsys meminfo</code>：查看内存信息</li>
<li><code>dumpsys cpuinfo</code>：查看cpu信息</li>
<li><code>cat /proc/meminfo</code>：查看设备内存</li>
<li><code>free</code>：查看可用内存</li>
<li><code>showmap -a [pid]</code>：查看虚拟地址区域内存</li>
<li><code>procrank</code>：查看所有进程内存使用</li>
<li><code>vmstat</code>：查看进程状态</li>
<li><code>cat /proc/进程号/oom_adj</code>：查看当前进程adj值</li>
<li><code>cat /proc/进程号/oom_score_adj</code>：查看真正有效的adj值</li>
<li><code>top</code>：查看进程信息<ul>
<li><code>-m &lt;num&gt;</code>：显示多少个进程</li>
<li><code>-n &lt;num&gt;</code>：刷新次数</li>
<li><code>-d &lt;num&gt;</code>：刷新间隔</li>
<li><code>-s &lt;col&gt;</code>：按列排序，如cpu、vss、rss、thr等</li>
<li><code>-t</code>：显示线程信息</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><code>uiautomator dump [file]</code>：输出layout结构层级</li>
<li><code>logcat -d -f &lt;文件名&gt;</code>：输出日志，-d表示将缓存日志全部输出</li>
<li><code>dmesg</code>：查看内核日志</li>
<li><code>cat /sys/class/net/wlan0/address</code>：查看mac地址</li>
<li><code>svc wifi enable/disable</code>：开启/关闭wifi</li>
<li><code>getprop</code>、<code>setprop</code>：查看、设置系统属性，结合grep过滤可以查看系统信息，如内存大小、版本等</li>
<li><code>settings get/put &lt;namespace：system/global/secure&gt; &lt;key&gt; [value]</code>：查看Settings Provider属性<ul>
<li><code>settings get system date_format</code>、<code>settings put system date_format dd-MM-yyyy</code>：设置日期格式</li>
<li><code>settings put global http_proxy 127.0.0.1:8888</code>：设置代理，用于fiddle抓包</li>
<li><code>settings put global adb_enabled 0</code>：关闭USB调试</li>
</ul>
</li>
<li><code>wm size [如1920x1080]</code>、<code>wm density [如240]</code>：查看和设置设备分辨率和dpi</li>
<li><code>reboot</code>：重启设备</li>
<li><code>screencap 1.png</code>：截屏</li>
<li><code>screenrecord 1.mp4</code>：录屏</li>
<li><code>cmd overlay list</code>：查看overlay apk</li>
<li><code>tcpdump -p -vv -s 0 -w /mnt/sdcard/capture.pcap</code>：抓包，使用wireshark分析。系统需要root</li>
<li><code>busybox vi &lt;file&gt;</code>：busybox集成了linux常用工具和命令，短小精悍，适合嵌入式平台。系统不支持vi等命令时可以使用busybox。</li>
<li><code>find ./ -name runtime-permissions.xml</code>：查找文件</li>
<li><code>ifconfig</code>：查看ip地址和mac地址</li>
<li><code>pwd</code>：输出当前路径</li>
<li><code>ping</code>：尝试连接ip或域名</li>
<li><code>chmod [权限数字] [路径]</code>：修改文件权限，777表示任何用户可读可写</li>
<li><code>md5 [文件]</code>：获取文件md5值</li>
</ul>
<h1 id="终端登录工具"><a href="#终端登录工具" class="headerlink" title="终端登录工具"></a>终端登录工具</h1><ol>
<li>adb shell</li>
<li>windows上使用MobaXterm：支持SSH、FTP、串口、VNC等</li>
<li>mac上通过<code>screen &lt;串口名称，如tty.usbserial-gggggggg1&gt; &lt;波特率，如115200&gt;</code>连接串口</li>
</ol>
<blockquote>
<p>tty（Teletypes，或者teletypewriters）：终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。</p>
<p>tty也是一个Unix命令，用来给出当前终端设备的名称。</p>
<p>在Linux系统的设备特殊文件目录/dev/下，TTY设备包括虚拟控制台，串口以及伪终端设备</p>
<p>/dev/tty代表当前tty设备，在当前的终端中输入 echo “hello” &gt; /dev/tty ，都会直接显示在当前的终端中。</p>
</blockquote>
<h1 id="Prop属性"><a href="#Prop属性" class="headerlink" title="Prop属性"></a>Prop属性</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>系统开机后会从以下系统文件中读取默认的属性，并写入共享内存中。按顺序读取，后面的会覆盖前面的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bionic/libc/include/sys/_system_properties.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_PATH_RAMDISK_DEFAULT  <span class="meta-string">&quot;/default.prop&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_PATH_SYSTEM_BUILD     <span class="meta-string">&quot;/system/build.prop&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_PATH_SYSTEM_DEFAULT   <span class="meta-string">&quot;/system/default.prop&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_PATH_LOCAL_OVERRIDE   <span class="meta-string">&quot;/data/local.prop&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system/core/init/property_service.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">    load_properties_from_file(PROP_PATH_SYSTEM_BUILD);</span><br><span class="line">    load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ALLOW_LOCAL_PROP_OVERRIDE</span></span><br><span class="line">    load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ALLOW_LOCAL_PROP_OVERRIDE */</span></span></span><br><span class="line">    <span class="comment">/* Read persistent properties after all default values have been loaded. */</span></span><br><span class="line">    load_persistent_properties();</span><br><span class="line">    update_legacy_atvc_properties();</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h2><ol>
<li>setprop、getprop命令</li>
<li>修改prop系统文件：需要root</li>
<li>java调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java API</span></span><br><span class="line"><span class="keyword">import</span> android.os.SystemProperties;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key, String def)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String val)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>ro.开头的属性只读</li>
<li>persist.开头的属性名永久保存。其他属性开机之后清除：<ol>
<li>设置persist属性的时候会写入<code>/data/property/persistent_properties</code>文件中</li>
<li>加载属性的时候会从该文件读取</li>
</ol>
</li>
<li>直接编辑prop文件修改属性，会永久保存</li>
<li>属性名最大长度是32，属性值最大长度是92</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bionic/libc/include/sys/system_properties.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_NAME_MAX   32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROP_VALUE_MAX  92</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Lint工具和自定义Lint规则</title>
    <url>/2018/12/04/android-2018-12-04-LintTools/</url>
    <content><![CDATA[<h1 id="Lint介绍"><a href="#Lint介绍" class="headerlink" title="Lint介绍"></a>Lint介绍</h1><h2 id="Lint简介"><a href="#Lint简介" class="headerlink" title="Lint简介"></a>Lint简介</h2><p>静态代码质量检查（分析、扫描）工具</p>
<p>Android Lint 是 SDK Tools 16（ADT 16）开始引入的一个代码扫描工具（在sdk目录/tools/bin下可以找到lint工具），通过对代码进行静态分析，可以检查代码规范问题和质量问题，并提出一些改进建议。可以规范团队代码风格，提高代码质量，指导开发者正确使用sdk等。</p>
<p>原生lint规则已经很全面了，不过有时候在团队开发中我们得根据需求定制自己的lint规则</p>
<p>举例：</p>
<ul>
<li>提醒使用自己的log工具，不用原生的log</li>
<li>提醒try-catch代码块后记得加finally</li>
<li>提醒资源文件，资源id命名规范，加模块名前缀</li>
<li>……</li>
</ul>
<h2 id="lint原理"><a href="#lint原理" class="headerlink" title="lint原理"></a>lint原理</h2><p>lint规则是在AST（抽象语法树，类似dom树）上进行解析。可以将项目里的一切视为对象，如目录、文件，java类、方法，xml元素、属性、值等，针对这些对象进行分析处理，并上报问题。</p>
<ul>
<li>推荐一个Android Studio的插件：PsiViewer，可以查看语法树</li>
</ul>
<h2 id="有几种使用方式"><a href="#有几种使用方式" class="headerlink" title="有几种使用方式"></a>有几种使用方式</h2><ul>
<li>使用lint命令行执行</li>
<li>使用android studio提供的可视化工具</li>
<li>结合gradle命令，如<code>./gradlew lint</code> （推荐）</li>
</ul>
<h2 id="Lint过程"><a href="#Lint过程" class="headerlink" title="Lint过程"></a>Lint过程</h2><p><img src="/2018/12/04/android-2018-12-04-LintTools/lint_process.png" alt="lint过程"></p>
<h1 id="Android-Lint使用"><a href="#Android-Lint使用" class="headerlink" title="Android Lint使用"></a>Android Lint使用</h1><h2 id="使用Android-Studio提供的工具运行lint"><a href="#使用Android-Studio提供的工具运行lint" class="headerlink" title="使用Android Studio提供的工具运行lint"></a>使用Android Studio提供的工具运行lint</h2><ul>
<li>在Android Studio菜单栏Analyze&gt;Inspect code，选择要扫描的范围（也可以在右键菜单中打开）<br><img src="/2018/12/04/android-2018-12-04-LintTools/android_inspect01.png" alt="android studio lint"></li>
<li>配置检查规则：<br><img src="/2018/12/04/android-2018-12-04-LintTools/android_inspect02.png" alt="android studio lint"></li>
<li>检查结果示例<br><img src="/2018/12/04/android-2018-12-04-LintTools/android_inspect03.png" alt="android studio lint"></li>
</ul>
<p>除此之外，还可以通过配置lint.xml文件进行配置，参考<a href="https://developer.android.google.cn/studio/write/lint">开发者文档</a></p>
<h2 id="推荐使用gradle命令运行lint"><a href="#推荐使用gradle命令运行lint" class="headerlink" title="推荐使用gradle命令运行lint"></a>推荐使用gradle命令运行lint</h2><ul>
<li>可以导出html、xml文件到模块下的build/reports目录下，使用浏览器打开，查看lint结果</li>
</ul>
<p><code>./gradlew -p 模块名 lint</code>或<code>./gradlew 模块名:lint</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="lint-xml配置"><a href="#lint-xml配置" class="headerlink" title="lint.xml配置"></a>lint.xml配置</h3><ul>
<li>官方文档说要放到项目根目录，试了一下不行，需要放到相应的module目录下</li>
<li>更新lint.xml配置有时候应用可能不及时，需要sync一下或者重启Android Studio</li>
<li>鼠标移到问题代码处，点开more，可以看到issue id</li>
</ul>
<p>举例</p>
<ul>
<li>配置规则<br><img src="/2018/12/04/android-2018-12-04-LintTools/lint_config.png" alt="配置规则"></li>
<li>前后对比<ul>
<li>编辑器里的提示对比<br><img src="/2018/12/04/android-2018-12-04-LintTools/lint_config01.png" alt="配置前后对比"></li>
<li>导出结果对比<br><img src="/2018/12/04/android-2018-12-04-LintTools/lint_config02.png" alt="配置前后对比"></li>
</ul>
</li>
</ul>
<h3 id="Java代码配置"><a href="#Java代码配置" class="headerlink" title="Java代码配置"></a>Java代码配置</h3><p>添加 <code>@SuppressLint</code> 注解，禁止Lint 检查某个 Java 类或方法。<br>如：<code>@SuppressLint(&quot;all&quot;)</code> ，禁止检查所有lint问题</p>
<h3 id="xml文件配置"><a href="#xml文件配置" class="headerlink" title="xml文件配置"></a>xml文件配置</h3><ul>
<li>添加命名空间：<code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></li>
<li>添加属性：配置禁止检查无用资源lint，该属性会继承到子元素：<code>tools:ignore=&quot;UnusedResources&quot;</code></li>
</ul>
<h3 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h3><p>在构建时执行</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123; </span><br><span class="line"> lintOptions &#123;</span><br><span class="line">    <span class="comment">// true--关闭lint报告的分析进度</span></span><br><span class="line">    quiet <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--错误发生后停止gradle构建</span></span><br><span class="line">    abortOnError <span class="literal">false</span></span><br><span class="line">    <span class="comment">// true--只报告error</span></span><br><span class="line">    ignoreWarnings <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--忽略有错误的文件的全/绝对路径(默认是true)</span></span><br><span class="line">    absolutePaths <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--检查所有问题点，包含其他默认关闭项</span></span><br><span class="line">    checkAllWarnings <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--所有warning当做error</span></span><br><span class="line">    warningsAsErrors <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 关闭指定问题检查</span></span><br><span class="line">    disable <span class="string">&#x27;TypographyFractions&#x27;</span>, <span class="string">&#x27;TypographyQuotes&#x27;</span></span><br><span class="line">    <span class="comment">// 打开指定问题检查</span></span><br><span class="line">    enable <span class="string">&#x27;RtlHardcoded&#x27;</span>, <span class="string">&#x27;RtlCompat&#x27;</span>, <span class="string">&#x27;RtlEnabled&#x27;</span></span><br><span class="line">    <span class="comment">// 仅检查指定问题 check &#x27;NewApi&#x27;, &#x27;InlinedApi&#x27;</span></span><br><span class="line">    <span class="comment">// true--error输出文件不包含源码行号</span></span><br><span class="line">    noLines <span class="literal">true</span></span><br><span class="line">    <span class="comment">// true--显示错误的所有发生位置，不截取</span></span><br><span class="line">    showAll <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 回退lint设置(默认规则)</span></span><br><span class="line">    lintConfig file(<span class="string">&quot;default-lint.xml&quot;</span>)</span><br><span class="line">    <span class="comment">// true--生成txt格式报告(默认false)</span></span><br><span class="line">    textReport <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 重定向输出；可以是文件或&#x27;stdout&#x27;</span></span><br><span class="line">    textOutput <span class="string">&#x27;stdout&#x27;</span></span><br><span class="line">    <span class="comment">// true--生成XML格式报告</span></span><br><span class="line">    xmlReport <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 指定xml报告文档(默认lint-results.xml)</span></span><br><span class="line">    xmlOutput file(<span class="string">&quot;lint-report.xml&quot;</span>)</span><br><span class="line">    <span class="comment">// true--生成HTML报告(带问题解释，源码位置，等)</span></span><br><span class="line">    htmlReport <span class="literal">true</span></span><br><span class="line">    <span class="comment">// html报告可选路径(构建器默认是lint-results.html )</span></span><br><span class="line">    htmlOutput file(<span class="string">&quot;lint-report.html&quot;</span>)</span><br><span class="line">    <span class="comment">// true--所有正式版构建执行规则生成崩溃的lint检查，如果有崩溃问题将停止构建</span></span><br><span class="line">    checkReleaseBuilds <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 在发布版本编译时检查(即使不包含lint目标)，指定问题的规则生成崩溃</span></span><br><span class="line">    fatal <span class="string">&#x27;NewApi&#x27;</span>, <span class="string">&#x27;InlineApi&#x27;</span></span><br><span class="line">    <span class="comment">// 指定问题的规则生成错误</span></span><br><span class="line">    error <span class="string">&#x27;Wakelock&#x27;</span>, <span class="string">&#x27;TextViewEdits&#x27;</span></span><br><span class="line">    <span class="comment">// 指定问题的规则生成警告</span></span><br><span class="line">    warning <span class="string">&#x27;ResourceAsColor&#x27;</span></span><br><span class="line">    <span class="comment">// 忽略指定问题的规则(同关闭检查)</span></span><br><span class="line">    ignore <span class="string">&#x27;TypographyQuotes&#x27;</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义Lint流程"><a href="#自定义Lint流程" class="headerlink" title="自定义Lint流程"></a>自定义Lint流程</h1><h2 id="自定义lint规则"><a href="#自定义lint规则" class="headerlink" title="自定义lint规则"></a>自定义lint规则</h2><ul>
<li><p>根目录<code>build.gradle</code>中添加gradle插件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">classpath <span class="string">&quot;com.android.tools.build:gradle:$gradlePluginVersion&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>新建一个模块，如checks，用于编写自定义lint规则</p>
</li>
<li><p>修改build.gradle如下<br><img src="/2018/12/04/android-2018-12-04-LintTools/custom_lint01.png" alt="自定义lint规则gradle配置"></p>
<p>– 添加java plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;java-library&#39;</span><br></pre></td></tr></table></figure>

<p>– 添加依赖，版本号根据需要填</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &quot;com.android.tools.lint:lint-api:$lintVersion&quot; &#x2F;&#x2F;Lint Api</span><br><span class="line">compile &quot;com.android.tools.lint:lint-checks:$lintVersion&quot; &#x2F;&#x2F;android lint原生规则</span><br><span class="line">testCompile &quot;com.android.tools.lint:lint:$lintVersion&quot; &#x2F;&#x2F;用于运行Lint检查</span><br></pre></td></tr></table></figure>

<p>– 配置jar打包，Lint-Registry是透露给lint工具的注册类的方法，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes(&quot;Lint-Registry&quot;: &quot;com.my.smart.lint.checks.MyIssueRegistry&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写自定义Lint规则，下面介绍</p>
</li>
<li><p>编译生成jar，路径为<code>/checks/build/libs/checks.jar</code></p>
</li>
</ul>
<h2 id="应用lint规则"><a href="#应用lint规则" class="headerlink" title="应用lint规则"></a>应用lint规则</h2><p>有以下几种方式</p>
<ol>
<li>将jar放到~/.android/lint/下，对所有本地项目生效。  </li>
<li>将jar放到模块libs目录，使用lintChecks方式引入<br><img src="/2018/12/04/android-2018-12-04-LintTools/lintchecks.png" alt="lintChecks解释"></li>
<li>将jar打包成aar，使用implementation引入（推荐）</li>
</ol>
<p>使用第三种方式引入</p>
<ul>
<li><p>新建一个library模块，用于打包aar </p>
</li>
<li><p>在library的dependencies中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lintChecks project(&#39;:checks&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>打包上传到maven</p>
</li>
</ul>
<h2 id="编写lint规则"><a href="#编写lint规则" class="headerlink" title="编写lint规则"></a>编写lint规则</h2><p>可以通过看<a href="https://android.googlesource.com/platform/tools/base/+/master/lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks">已有的Lint规则源码</a>，<a href="https://www.javadoc.io/doc/com.android.tools.lint/lint-api/25.3.0">LintApi文档</a>来学习</p>
<p>主要使用<code>lint-api</code>提供的接口进行开发</p>
<h3 id="常用api如下"><a href="#常用api如下" class="headerlink" title="常用api如下"></a>常用api如下</h3><ul>
<li>Issue：表示一个Lint规则。例如调用 Toast.makeText() 方法后，没有调用 Toast.show() 方法将其显示。</li>
<li>IssueRegistry：用于注册要检查的Issue列表。自定义Lint需要生成一个jar文件，其Manifest指向IssueRegistry类。</li>
<li>Detector：用于检测并报告代码中的Issue。每个Issue包含一个Detector。</li>
<li>Scope：声明Detector要扫描的代码范围，例如Java源文件、XML资源文件、Gradle文件等。每个Issue可包含多个Scope。</li>
<li>Scanner：用于扫描并发现代码中的Issue。每个Detector可以实现一到多个Scanner。<ul>
<li>JavaScanner（最早） / JavaPsiScanner / UastScanner（最新、推荐）：扫描Java源文件</li>
<li>XmlScanner：扫描XML文件</li>
<li>ClassScanner：扫描class文件</li>
<li>BinaryResourceScanner：扫描二进制资源文件</li>
<li>ResourceFolderScanner：扫描资源文件夹</li>
<li>GradleScanner：扫描Gradle脚本</li>
<li>OtherFileScanner：扫描其他类型文件</li>
<li>……</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>AST（Abstract Syntax Tree，抽象语法树）</li>
<li>PSI（Program Structure Interface）：是一个框架，用于访问抽象语法树，<code>com.intellij.psi</code></li>
<li>UAST（Unified AST）：是一个框架，用于访问抽象语法树，<code>org.jetbrains.uast</code></li>
</ul>
</blockquote>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>检查控件id命名前缀，如ImageView以iv_开头，Button以btn开头</p>
<ol>
<li>实现Detector</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 继承ResourceXmlDetector，该类实现了XmlScanner，表示检查xml文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfauriaResIdDetector</span> <span class="keyword">extends</span> <span class="title">ResourceXmlDetector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Implementation IMPLEMENTATION_RES_ONLY = <span class="keyword">new</span> Implementation(</span><br><span class="line">            AfauriaResIdDetector.class,</span><br><span class="line">            Scope.RESOURCE_FILE_SCOPE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 定义Issue，包括id，描述，解释，分类，优先级，严重级别，作用域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Issue RES_ID_ISSUE = Issue.create(</span><br><span class="line">            <span class="string">&quot;AfauriaResId&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Id命名不规范&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Id 命名以控件缩写为前缀&quot;</span>,</span><br><span class="line">            Category.SECURITY,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            Severity.ERROR,</span><br><span class="line">            IMPLEMENTATION_RES_ONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 过滤文件夹</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appliesTo</span><span class="params">(ResourceFolderType folderType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResourceFolderType.LAYOUT == folderType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 过滤tag</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">getApplicableElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        elements.add(LINEAR_LAYOUT);</span><br><span class="line">        elements.add(RELATIVE_LAYOUT);</span><br><span class="line">        elements.add(FRAME_LAYOUT);</span><br><span class="line">        elements.add(CONSTRAINT_LAYOUT);</span><br><span class="line">        elements.add(LIST_VIEW);</span><br><span class="line">        elements.add(SCROLL_VIEW);</span><br><span class="line">        elements.add(TEXT_VIEW);</span><br><span class="line">        elements.add(IMAGE_VIEW);</span><br><span class="line">        elements.add(CHECK_BOX);</span><br><span class="line">        elements.add(RADIO_BUTTON);</span><br><span class="line">        elements.add(EDIT_TEXT);</span><br><span class="line">        elements.add(RECYCLER_VIEW);</span><br><span class="line">        elements.add(BUTTON);</span><br><span class="line"><span class="comment">//        elements.add(PROGRESS_BAR);</span></span><br><span class="line"><span class="comment">//        elements.add(FQCN_DATE_PICKER);</span></span><br><span class="line"><span class="comment">//        elements.add(FQCN_TIME_PICKER);</span></span><br><span class="line"><span class="comment">//        elements.add(RADIO_GROUP);</span></span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 过滤属性，这里有坑，下面解释</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public Collection&lt;String&gt; getApplicableAttributes() &#123;</span></span><br><span class="line"><span class="comment">//        return Collections.singletonList(&quot;id&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//6. 已经定位到对象，对其进行解析，若不符合规则，则报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitElement</span><span class="params">(XmlContext context, Element element)</span> </span>&#123;</span><br><span class="line">        checkIdAttr(context,element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIdAttr</span><span class="params">(XmlContext context, Element element)</span></span>&#123;</span><br><span class="line">    <span class="comment">//7. 对象解析</span></span><br><span class="line">        Attr attributeNode = element.getAttributeNode(<span class="string">&quot;android:id&quot;</span>);</span><br><span class="line">        String tag = element.getTagName();</span><br><span class="line">        System.out.println(<span class="string">&quot;ResId Tag Name：&quot;</span> + tag);</span><br><span class="line">        <span class="keyword">if</span> (tag.equals(BUTTON)) &#123;</span><br><span class="line">            tag = <span class="string">&quot;btn&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tag = tag.replaceAll(<span class="string">&quot;[a-z\\d.]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            tag = tag.toLowerCase();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;ResId Tag Prefix：&quot;</span> + tag);</span><br><span class="line">        <span class="keyword">if</span> (attributeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String value = attributeNode.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!value.startsWith(ANDROID_ID_PREFIX)</span><br><span class="line">                    &amp;&amp; !value.startsWith(ANDROID_NEW_ID_PREFIX)</span><br><span class="line">                    &amp;&amp; !value.startsWith(NEW_ID_PREFIX + tag)) &#123;</span><br><span class="line">                <span class="comment">//8. 报告错误，参数：Issue，Node（对象节点），Location（报错位置），Message（提示信息），LintFix（解决方案）</span></span><br><span class="line">                context.report(RES_ID_ISSUE,</span><br><span class="line">                        attributeNode,</span><br><span class="line">                        context.getLocation(attributeNode),</span><br><span class="line">                        String.format(<span class="string">&quot; id 命名以 %s_ 开头&quot;</span>, tag));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：</p>
<p><code>getApplicableElements</code>和<code>visitElement</code>，<code>getApplicableAttributes </code>和<code>visitAttribute</code>是成对使用的，一开始以为是链式的，先过滤元素，再过滤元素属性，最后只要实现visitAttribute。结果发现visitElement也会被调用。实现了返回反而会多执行visit方法。</p>
<ol start="2">
<li>注册规则</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfauriaIssueRegistry</span> <span class="keyword">extends</span> <span class="title">IssueRegistry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Issue&gt; <span class="title">getIssues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">                AfauriaResIdDetector.RES_ID_ISSUE</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><code>Issue</code>:Lint规则<ul>
<li><code>Id</code>: 规则标识，唯一</li>
<li><code>Description</code>: 规则描述</li>
<li><code>Explanation</code>: 规则说明，解决方案</li>
<li><code>Severity</code>: 规则严重程度，由高到低<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFORMATIONAL</li>
<li>IGNORE</li>
</ul>
</li>
<li><code>Priority</code>: 规则优先级，1-10，10最高</li>
<li><code>Category</code>: 规则分类（部分），可自定义<ul>
<li>Lint</li>
<li>Correctness (子分类 Messages):正确性</li>
<li>Security：安全性</li>
<li>Performance:性能</li>
<li>Usability (子分类 Typography, Icons):易用性</li>
<li>A11Y (Accessibility):无障碍</li>
<li>I18N (Internationalization，子分类 Rtl)：国际化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>由于缓存或者其他原因，有时候需要重启Android Studio才能应用自定义lint规则</li>
<li>推荐使用gradle命令执行lint</li>
<li>除了手动运行Lint外，大部分问题在编写代码时Android Studio就会给出提醒</li>
<li>自定义的规则使用Android Studio的Inspect检查不出来，不过在代码编写的时候会有提示，需要将规则放到<code>~/.android/lint/</code>目录下才会生效，建议用gradle命令运行导出Issue</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/u010360371/article/details/50189171">android lint check的学习和自定义以及lint语法</a></li>
<li><a href="https://www.jianshu.com/p/cbd9a643a6b7">使用Lint</a></li>
<li><a href="https://www.jianshu.com/p/a0f28fbef73f">Android Studio 工具：Lint 代码扫描工具（含自定义lint）</a></li>
<li><a href="https://blog.csdn.net/ouyang_peng/article/details/80374867">【我的Android进阶之旅】Android自定义Lint实践</a></li>
<li><a href="http://www.cnblogs.com/oneapm/p/5221072.html">自定义 Lint 规则简介</a></li>
<li><a href="https://www.colabug.com/2109876.html">Android Lint：自定义Lint调试与开发</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓混淆</title>
    <url>/2018/11/24/android-2018-11-24-Android%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ProGuard是一个压缩、优化和混淆Java<a href="https://baike.so.com/doc/6261423-6474843.html">字节码</a>文件的开源工具，它可以删除无用的类、字段、方法和属性。可以删除没用的注释，最大限度地优化字节码文件。它还可以使用<a href="https://baike.so.com/doc/1649095-1743070.html">简短</a>的无意义的名称来重命名已经存在的类、字段、方法和属性。常常用于Android开发用于混淆最终的项目，增加项目被反编译的难度。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>压缩: 移除无效的类、属性、方法等</li>
<li>优化: 优化字节码，并删除未使用的结构</li>
<li>混淆: 将类名、属性名、方法名混淆为难以读懂的字母，比如a,b,c</li>
</ul>
<h2 id="混淆注意事项"><a href="#混淆注意事项" class="headerlink" title="混淆注意事项"></a>混淆注意事项</h2><h3 id="不能混淆"><a href="#不能混淆" class="headerlink" title="不能混淆"></a>不能混淆</h3><ul>
<li>在AndroidManifest中配置的类，比如四大组件</li>
<li>JNI调用的方法</li>
<li>用了反射的类</li>
<li>WebView中JavaScript调用的方法</li>
<li>Layout文件引用到的自定义View</li>
<li>一些引入的第三方库（一般都会有混淆说明的）</li>
<li>Parcelable 的子类和 Creator 静态成员变量不混淆，否则会产生 Android.os.BadParcelableException 异常</li>
<li>使用了枚举要保证枚举不被混淆 </li>
</ul>
<blockquote>
<p>因为混淆之后，类名会变成a,b,c这，通过包名+类名就找不到该类了，会出现ClassNotFoundException异常。</p>
</blockquote>
<h3 id="保留java-bean"><a href="#保留java-bean" class="headerlink" title="保留java bean"></a>保留java bean</h3><p>使用了 Gson 之类的工具要使 JavaBean 类即实体类不被混淆，混淆后属性名改变，变成了没有意思的名称，json转换就会出错</p>
<h3 id="注解不能混淆"><a href="#注解不能混淆" class="headerlink" title="注解不能混淆"></a>注解不能混淆</h3><p>注解在Android平台中使用的越来越多,常用的有ButterKnife和Otto。很多场景下注解被用作在运行时反射确定一些元素的特征.</p>
<p>为了保证注解正常工作,我们不应该对注解进行混淆.Android工程默认的混淆配置已经包含了下面保留注解的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br></pre></td></tr></table></figure>

<h3 id="Crash信息处理"><a href="#Crash信息处理" class="headerlink" title="Crash信息处理"></a>Crash信息处理</h3><p>代码混淆的时候记得加上在混淆文件里面记得加上这句： </p>
<p>keep住源文件以及行号 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepattributes SourceFile,LineNumberTable</span><br></pre></td></tr></table></figure>

<h2 id="ProGuard用法和选项"><a href="#ProGuard用法和选项" class="headerlink" title="ProGuard用法和选项"></a>ProGuard用法和选项</h2><h3 id="保留选项："><a href="#保留选项：" class="headerlink" title="保留选项："></a>保留选项：</h3><p><strong>注意选项的命名规律：-keep* 用于防止目标被移除或者重命名、-keep*names则仅仅用于防止重命名。</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-keep</td>
<td>-keep [,modifier,…] class_spec 作为入口点保留的类、类成员。对于库，所有公共成员都需要保留</td>
</tr>
<tr>
<td>-keepclassmembers</td>
<td>-keepclassmembers [,modifier,…] class_spec  指定要保留的类成员，如果它们所属的类被保留的话</td>
</tr>
<tr>
<td>-keepclasseswithmembers</td>
<td>-keepclasseswithmembers [,modifier,…] class_spec 指定需要保留的类，如果其成员符合条件</td>
</tr>
<tr>
<td>-keepnames class_spec</td>
<td>等价于-keep,allowshrinking class_spec 指定其名称需要保留的类和类成员，如果在压缩阶段这些类没有被删除的话。该选项仅用于混淆阶段</td>
</tr>
<tr>
<td>-keepclassmembernames</td>
<td>-keepclassmembernames class_spec 指定名称要保留的类成员，如果在压缩阶段这些类没有被删除的话。该选项仅用于混淆阶段</td>
</tr>
<tr>
<td>-keepclasseswithmembernames</td>
<td>-keepclasseswithmembernames class_spec 指定要保留的类和类成员，如果所有指定的类成员在经历了压缩阶段还存在</td>
</tr>
<tr>
<td>-printseeds [filename]</td>
<td>打印所有匹配-keep的类和类成员，默认打印到标准输出</td>
</tr>
</tbody></table>
<p>-keep选项支持添加限定符，格式为： -keep,限定符 ，限定符包括：</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>includedescriptorclasses</td>
<td>方法、字段的类型描述符中的任何类，跟随被keep的方法/字段一并保留，通常用于保留Native方法的名字时，防止Native方法参数的名字被修改，以保证和Native库兼容</td>
</tr>
<tr>
<td>allowshrinking</td>
<td>指定是否入口点可以被压缩</td>
</tr>
<tr>
<td>allowoptimization</td>
<td>指定是否入口点可以被优化</td>
</tr>
<tr>
<td>allowobfuscation</td>
<td>指定是否入口点可以被混淆</td>
</tr>
</tbody></table>
<p>压缩选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-dontoptimize</td>
<td>不进行优化。默认情况下优化启用，所有方法都在字节码级别进行优化</td>
</tr>
<tr>
<td>-optimizations opt_filter</td>
<td>在更细粒度上控制进行哪些优化</td>
</tr>
<tr>
<td>-optimizationpasses n</td>
<td>优化的步骤数，默认1步，如果发现没有可优化的，后续步骤自动省略</td>
</tr>
<tr>
<td>-assumenosideeffects class_spec</td>
<td>指定不具有副作用（不改变任何状态信息）的方法规格，如果这些方法的返回值没有被使用，那么这样的调用会清除</td>
</tr>
<tr>
<td>-allowaccessmodification</td>
<td>是否允许放宽类、类成员的访问限定符。这可能有利于优化，例如对getter()进行内联，需要相应字段成为public的</td>
</tr>
<tr>
<td>-mergeinterfacesaggressively</td>
<td>允许接口合并，甚至在实现类没有实现所有接口方法的情况下</td>
</tr>
</tbody></table>
<p>混淆选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-dontobfuscate</td>
<td>是否进行混淆，默认是。除了匹配-keep系列选项的类、类成员的名字将被随机的改为短名。为了方便调试而保留的内部属性，例如源代码名称、变量名、行号，都将被移除</td>
</tr>
<tr>
<td>-printmapping [filename]</td>
<td>打印混淆前后类名、类成员名的对照</td>
</tr>
<tr>
<td>-applymapping filename</td>
<td>指定一个先前生成的混淆名对照表，本次依照该对照继续混淆，不在表中的成员生成新的名字</td>
</tr>
<tr>
<td>-obfuscationdictionary filename</td>
<td>指定存放有效混淆后变量名的文件</td>
</tr>
<tr>
<td>-overloadaggressively</td>
<td>混淆时支持激进的重载，允许多个字段、方法使用重复的名字，只要参数和返回值不同</td>
</tr>
<tr>
<td>-useuniqueclassmembernames</td>
<td>让不同名的类成员具有不同的混淆后的名称，让同名的类成员混淆后的名称依旧相同</td>
</tr>
<tr>
<td>-dontusemixedcaseclassnames</td>
<td>混淆后，不使用混合大小写的类名</td>
</tr>
<tr>
<td>-keeppackagenames [pkg_filter]</td>
<td>指定不混淆的包的过滤器，过滤器支持* **和前导的!</td>
</tr>
<tr>
<td>-flattenpackagehierarchy [pkg_name]</td>
<td>对所有被重命名的包进行重新打包，如果不指定参数值，则打包到根目录</td>
</tr>
<tr>
<td>-repackageclasses [pkg_name]</td>
<td>对所有被重命名的类进行重新打包，如果不指定参数值，则打包到根目录</td>
</tr>
<tr>
<td>-keepattributes [attr_filter]</td>
<td>指定需要保留的所有可选属性，参数值是逗号分隔的，所有JVM或ProGuard支持的属性值。支持使用? * ** !。在处理库的时候，至少应该保留Exceptions, InnerClasses, Signature属性，如果程序依赖于注解，则应该保留</td>
</tr>
<tr>
<td>-keepparameternames</td>
<td>保留方法参数的名称和类型。该选项实质上保留了一个修剪（trim）后的LocalVariableTable、LocalVariableTypeTable这两个调试属性，在处理库时可能使用。注意，方法局部变量的名称依旧会混淆</td>
</tr>
<tr>
<td>-renamesourcefileattribute [string]</td>
<td>设置SourceFile、SourceDir 属性为指定的常量值</td>
</tr>
<tr>
<td>-adaptclassstrings [class_filter]</td>
<td>代表了类名的字符串常量值，是否也被混淆（与目标类的名字保持一致）。如果不指定参数值，所有代表类名的字符串常量都被混淆</td>
</tr>
<tr>
<td>-adaptresourcefilenames [file_filter]</td>
<td>是否重命名资源文件，如果其文件名反映了一个被混淆的类的名字</td>
</tr>
<tr>
<td>-adaptresourcefilecontents [file_filter]</td>
<td>是否修改资源文件中的类名，如果对应的类的名字已经被混淆。ProGuard使用平台默认字符集读取文件，如果需要改变这一行为，需要设置LANG环境变量或者JVM系统属性file.encoding</td>
</tr>
</tbody></table>
<p>预校验选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-dontpreverify</td>
<td>指定不进行字节码预校验，对于Java6+默认开启</td>
</tr>
<tr>
<td>-microedition</td>
<td>只是目标类文件将在JME平台上运行</td>
</tr>
</tbody></table>
<p>一般选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-verbose</td>
<td>在处理时打印冗长的信息</td>
</tr>
<tr>
<td>-dontnote [class_filter]</td>
<td>不打印配置选项中，与正则式匹配的类相关的错误或者疏忽</td>
</tr>
<tr>
<td>-dontwarn [class_filter]</td>
<td>不打印配置选项中，与正则式匹配的类相关的重要错误，例如unresolved references</td>
</tr>
<tr>
<td>-ignorewarnings</td>
<td>忽略所有警告，强制进行处理。这可能很危险</td>
</tr>
<tr>
<td>-printconfiguration [filename]</td>
<td>打印解析后的配置信息到目标文件</td>
</tr>
<tr>
<td>-dump [filename]</td>
<td>打印处理后的类文件的内部结构</td>
</tr>
</tbody></table>
<p>通配符匹配规则</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配单个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配类名中的任何部分，但不包含额外的包名</td>
</tr>
<tr>
<td>**</td>
<td>匹配类名中的任何部分，并且可以包含额外的包名</td>
</tr>
<tr>
<td>%</td>
<td>匹配任何基础类型的类型名</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意类型名 ,包含基础类型/非基础类型</td>
</tr>
<tr>
<td>…</td>
<td>匹配任意数量、任意类型的参数</td>
</tr>
<tr>
<td><init></init></td>
<td>匹配任何构造器</td>
</tr>
<tr>
<td><fields></fields></td>
<td>匹配任何字段名</td>
</tr>
<tr>
<td><methods></methods></td>
<td>匹配任何方法</td>
</tr>
<tr>
<td>*(当用在类内部时)</td>
<td>匹配任何字段和方法</td>
</tr>
<tr>
<td>$</td>
<td>指内部类</td>
</tr>
</tbody></table>
<h2 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则"></a>一些规则</h2><h3 id="两个常用的混淆命令，"><a href="#两个常用的混淆命令，" class="headerlink" title="两个常用的混淆命令，"></a>两个常用的混淆命令，</h3><p>注意一颗星表示只是保持该包下的类名，而子包下的类名还是会被混淆；两颗星表示把本包和所含子包下的类名都保持；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">hadcn</span>.<span class="title">test</span>.** </span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">class</span> <span class="title">cn</span>.<span class="title">hadcn</span>.<span class="title">test</span>.*</span></span><br></pre></td></tr></table></figure>

<p>用以上方法保持类后，你会发现类名虽然未混淆，但里面的具体方法和变量命名还是变了，这时如果既想保持类名，又想保持里面的内容不被混淆，我们就需要以下方法了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">bean</span>.** </span>&#123; *; &#125;</span><br></pre></td></tr></table></figure>

<p>在此基础上，我们也可以使用Java的基本规则来保护特定类不被混淆，比如我们可以用extend，implement等这些Java规则。如下例子就避免所有继承Activity的类被混淆</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保留我们使用的四大组件，自定义的Application等等这些类不被混淆</span></span><br><span class="line"><span class="comment"># 因为这些子类都有可能被外部调用</span></span><br><span class="line">-keep public class * extends android.app.Activity</span><br><span class="line">-keep public class * extends android.app.Appliction</span><br><span class="line">-keep public class * extends android.app.Service</span><br><span class="line">-keep public class * extends android.content.BroadcastReceiver</span><br><span class="line">-keep public class * extends android.content.ContentProvider</span><br><span class="line">-keep public class * extends android.app.backup.BackupAgentHelper</span><br><span class="line">-keep public class * extends android.preference.Preference</span><br><span class="line">-keep public class * extends android.view.View</span><br><span class="line">-keep public class com.android.vending.licensing.ILicensingService</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 混淆后，不使用混合大小写的类名</span></span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定需要保留的所有可选属性</span></span><br><span class="line"><span class="comment"># 更多 参考。https://www.guardsquare.com/en/proguard/manual/attributes</span></span><br><span class="line">-keepattributes Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,LocalVariable*Table,*Annotation*,Synthetic,EnclosingMethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包到根目录</span></span><br><span class="line">-repackageclasses <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许放宽类、类成员的访问限定符。</span></span><br><span class="line">-allowaccessmodification</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印解析后的配置信息到目标文件</span></span><br><span class="line">-printconfiguration proguard_test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化的步骤数</span></span><br><span class="line">-optimizationpasses 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在处理时打印冗长的信息</span></span><br><span class="line">-verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不跳过依赖库中的非public类，4.5+默认值</span></span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不跳过包可见的依赖库类成员（字段、方法）</span></span><br><span class="line">-dontskipnonpubliclibraryclassmembers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留native方法的规格，以便能与native库链接</span></span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># keep setters in Views so that animations can still work</span></span><br><span class="line">-keepclassmembers public class * extends android.view.View &#123;</span><br><span class="line">   void <span class="built_in">set</span>*(***);</span><br><span class="line">   *** get*();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># We want to keep methods in Activity that could be used in the XML attribute onClick</span></span><br><span class="line">-keepclassmembers class * extends android.app.Activity &#123;</span><br><span class="line">   public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations</span></span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    public static **[] values();</span><br><span class="line">    public static ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除输出的日志</span></span><br><span class="line"></span><br><span class="line">-assumenosideeffects class com.tuya.smart.android.common.utils.L &#123;</span><br><span class="line"></span><br><span class="line">public static *** d(...);</span><br><span class="line"></span><br><span class="line">public static *** v(...);</span><br><span class="line"></span><br><span class="line">public static *** i(...);</span><br><span class="line"></span><br><span class="line">public static *** e(...);</span><br><span class="line"></span><br><span class="line">public static *** w(...);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留Parcelable序列化类不被混淆</span></span><br><span class="line">-keepclassmembers class * implements android.os.Parcelable &#123;</span><br><span class="line">  public static final android.os.Parcelable<span class="variable">$Creator</span> CREATOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-keepattributes Exceptions,InnerClasses,...  </span><br><span class="line">-keep class [packagename].A&#123;*;&#125;  </span><br><span class="line">-keep class [packagename].A$* &#123;*;&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 A$* 表示所有A的内部类都保留下来，也可以如下使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-keepattributes Exceptions,InnerClasses,...  </span><br><span class="line">-keep class com.xxx.A&#123; *; &#125;  </span><br><span class="line">-keep class com.xxx.A<span class="variable">$B</span> &#123; *; &#125;  </span><br><span class="line">-keep class com.xxx.A<span class="variable">$C</span> &#123; *; &#125;  </span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-cn">压缩代码和资源</a></li>
<li><a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html">ProGuard</a></li>
<li><a href="https://www.guardsquare.com/en/proguard/manual/usage#classspecification">ProGuard manual</a></li>
<li><a href="https://blog.gmem.cc/proguard-study-note">ProGuard学习笔记</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook使用笔记</title>
    <url>/2018/11/18/note-2018-11-18-MacBook%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="环境变量不生效"><a href="#环境变量不生效" class="headerlink" title="环境变量不生效"></a>环境变量不生效</h2><p>在<code>~/.bash_profile</code>中配好环境变量后每次重启终端需要执行<code>source ~/.bash_profile</code>才生效</p>
<p>原因：使用zsh插件，加载的是<code>~/.zshrc</code>文件，<code>~/.zshrc</code>中没有定义任务环境变量</p>
<blockquote>
<p>在<code>~/.zshrc</code>文件后加上<code>source ~/.bash_profile</code></p>
</blockquote>
<h2 id="Mac空间不足，升级系统失败"><a href="#Mac空间不足，升级系统失败" class="headerlink" title="Mac空间不足，升级系统失败"></a>Mac空间不足，升级系统失败</h2><p>Mac电脑空间不足，导致升级系统失败，且无法用U盘升回旧版本。没有用<code>Time Machine</code>备份系统</p>
<p>（搞了半天，差点以为回不来了，公司的IT都说要抹盘了。）</p>
<blockquote>
<ol>
<li>开机按住<code>Option</code>或<code>Command+R</code>进入恢复模式</li>
<li>打开终端（发现可以打开终端，一般来说已经可以为所欲为）</li>
<li>进入磁盘路径：输入<code>cd /Volume/xxx</code>（一般是<code>/Volume/Machine HD-数据/User</code>，如果有空格需要转义）</li>
<li>用<code>rm</code>命令删除不需要的文件，再进行升级</li>
<li>如果需要拷贝重要文件出来<ol>
<li>可以插上U盘，<code>cp 电脑路径 /Volume/U盘名称/路径</code></li>
<li>可以将电脑和另一个电脑连上同一个局域网，用<code>scp</code>命令拷贝文件。</li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程相关概念</title>
    <url>/2018/11/17/basic-2018-10-17-ipc-thread/</url>
    <content><![CDATA[<h1 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h1><p>进程：一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度运行的基本单位</p>
<ul>
<li>正在运行的一个程序（动态的概念，程序是静态的概念）</li>
<li>每个进程拥有独立的地址空间</li>
<li>同一时刻cpu（单核）只运行一个进程</li>
</ul>
<p>线程：进程的一个实体，进程的一条执行路径，轻量级的进程</p>
<ul>
<li>一个进程可以拥有多个线程</li>
<li>每个线程由独立的栈空间</li>
<li>同一进程的多个线程共享内存区域（而进程无法访问其他进程的内存）</li>
</ul>
<h1 id="2-并行和并发"><a href="#2-并行和并发" class="headerlink" title="2. 并行和并发"></a>2. 并行和并发</h1><ul>
<li>并行是同一时刻做多件事情，并发是同一时间间隔内做多件事情</li>
<li>并行是同时做很多事情。并发是一次处理很多事情。</li>
<li>并行是同时执行（可能相关的）计算（依靠多核处理）。并发可以是虚拟的同时执行也可以是真的同时执行（有空闲的cpu，轮流占用CPU和各种资源）。</li>
</ul>
<h1 id="3-进程间通信方式"><a href="#3-进程间通信方式" class="headerlink" title="3. 进程间通信方式"></a>3. 进程间通信方式</h1><p>进程间通信（IPC，Inter-Process Communication）,指多个进程之间相互通信，交换数据的方法。</p>
<p>进程的互斥（mutual exclusion ）是解决进程间竞争关系( <strong>间接制约关系</strong>) 的手段。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。</p>
<p>进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。</p>
<p>进程同步是一种进程通信。进程互斥是一种特殊的同步</p>
<h2 id="3-1-管道-pipe"><a href="#3-1-管道-pipe" class="headerlink" title="3.1. 管道( pipe )"></a>3.1. 管道( pipe )</h2><p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<h2 id="3-2-有名管道-namedpipe"><a href="#3-2-有名管道-namedpipe" class="headerlink" title="3.2. 有名管道 (namedpipe)"></a>3.2. 有名管道 (namedpipe)</h2><p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<h2 id="3-3-信号量-semophore"><a href="#3-3-信号量-semophore" class="headerlink" title="3.3. 信号量(semophore )"></a>3.3. 信号量(semophore )</h2><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p><strong>补充</strong></p>
<p>互斥锁（mutex）：是一种特殊的信号量，当n=1时。防止多个线程同时读写某一块内存区域</p>
<h2 id="3-4-消息队列-messagequeue"><a href="#3-4-消息队列-messagequeue" class="headerlink" title="3.4. 消息队列( messagequeue )"></a>3.4. 消息队列( messagequeue )</h2><p> 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h2 id="3-5-信号-sinal"><a href="#3-5-信号-sinal" class="headerlink" title="3.5. 信号 (sinal )"></a>3.5. 信号 (sinal )</h2><p> 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<h2 id="3-6-共享内存-shared-memory"><a href="#3-6-共享内存-shared-memory" class="headerlink" title="3.6. 共享内存(shared memory )"></a>3.6. 共享内存(shared memory )</h2><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<h2 id="3-7-套接字-socket"><a href="#3-7-套接字-socket" class="headerlink" title="3.7. 套接字(socket )"></a>3.7. 套接字(socket )</h2><p>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h1 id="4-线程间的同步"><a href="#4-线程间的同步" class="headerlink" title="4. 线程间的同步"></a>4. 线程间的同步</h1><p>各个线程可以访问同一进程中的公共变量，资源，所以使用多线程的过程中需要注意的问题是如何防止两个或两个以上的线程同时访问同一个数据，以免破坏数据的完整性。数据之间的相互制约包括<br>1、直接制约关系，即一个线程的处理结果，为另一个线程的输入，因此线程之间直接制约着，这种关系可以称之为同步关系<br>2、间接制约关系，即两个线程需要访问同一资源，该资源在同一时刻只能被一个线程访问，这种关系称之为线程间对资源的互斥访问，某种意义上说互斥是一种制约关系更小的同步</p>
<h2 id="4-1-锁机制：包括互斥锁、读写锁、条件变量"><a href="#4-1-锁机制：包括互斥锁、读写锁、条件变量" class="headerlink" title="4.1. 锁机制：包括互斥锁、读写锁、条件变量"></a>4.1. 锁机制：包括互斥锁、读写锁、条件变量</h2><ul>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
<h2 id="4-2-信号量机制-Semaphore-：包括无名线程信号量和命名线程信号量"><a href="#4-2-信号量机制-Semaphore-：包括无名线程信号量和命名线程信号量" class="headerlink" title="4.2. 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量"></a>4.2. 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</h2><p>允许多个线程使用共享资源，规定访问共享资源线程的最大数目</p>
<h2 id="4-3-信号机制-Signal-：类似进程间的信号处理"><a href="#4-3-信号机制-Signal-：类似进程间的信号处理" class="headerlink" title="4.3. 信号机制(Signal)：类似进程间的信号处理"></a>4.3. 信号机制(Signal)：类似进程间的信号处理</h2><h2 id="4-4-临界区"><a href="#4-4-临界区" class="headerlink" title="4.4. 临界区"></a>4.4. 临界区</h2><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</p>
<h1 id="5-java线程间的通信方式"><a href="#5-java线程间的通信方式" class="headerlink" title="5. java线程间的通信方式"></a>5. java线程间的通信方式</h1><h2 id="5-1-使用共享对象"><a href="#5-1-使用共享对象" class="headerlink" title="5.1. 使用共享对象"></a>5.1. 使用共享对象</h2><p>同一进程中所有线程共享内存区域，因此定义全局变量可供其他线程访问。多线程访问全局变量时最好声明为volatile</p>
<p>volatile能够保证可见性，不能保证原子性，正常情况下内存会拷贝到cpu缓存中，当多个线程运行在不同cpu上的时候对一个变量修改会导致不同步，使用volatile声明之后会直接从内存中读取，不会进行cpu缓存。</p>
<p>synchronized同步能够保证可见性和原子性，同一时刻只允许一个线程访问资源。</p>
<p>synchronized修饰：实例方法、静态方法、代码块</p>
<p>synchronized可以同步方法和同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步代码块，持有this对象的锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">//doSomething……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步方法，默认传入this</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized实际上锁住的是对象，而不是代码块</strong></p>
<p>新建一个实例其他线程仍然可以执行代码块。要想锁住代码块，可以使用下面的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//持有class对象的锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">    <span class="comment">//doSomething……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</li>
</ol>
<h2 id="5-2-while轮询：忙等状态，消耗cpu资源。可使用wait阻塞替代"><a href="#5-2-while轮询：忙等状态，消耗cpu资源。可使用wait阻塞替代" class="headerlink" title="5.2. while轮询：忙等状态，消耗cpu资源。可使用wait阻塞替代"></a>5.2. while轮询：忙等状态，消耗cpu资源。可使用wait阻塞替代</h2><h2 id="5-3-接口回调"><a href="#5-3-接口回调" class="headerlink" title="5.3. 接口回调"></a>5.3. 接口回调</h2><h3 id="java提供的Callable，Future，ExecutorService。"><a href="#java提供的Callable，Future，ExecutorService。" class="headerlink" title="java提供的Callable，Future，ExecutorService。"></a>java提供的Callable，Future，ExecutorService。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ExecutorService提供的方法，传入Callable，submit会封装成FutureTask（继承RunnableFuture接口）然后执行</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Future的get()方法用来获取执行结果，会阻塞线程，直到任务执行完毕。</p>
<h2 id="5-4-IO管道流：PipedInputStream，PipedOutputStream"><a href="#5-4-IO管道流：PipedInputStream，PipedOutputStream" class="headerlink" title="5.4. IO管道流：PipedInputStream，PipedOutputStream"></a>5.4. IO管道流：PipedInputStream，PipedOutputStream</h2><h2 id="5-5-socket套接字"><a href="#5-5-socket套接字" class="headerlink" title="5.5. socket套接字"></a>5.5. socket套接字</h2><h2 id="5-6-消息队列"><a href="#5-6-消息队列" class="headerlink" title="5.6. 消息队列"></a>5.6. 消息队列</h2><h2 id="5-7-wait-，notify-，notifyAll-阻塞和唤醒线程"><a href="#5-7-wait-，notify-，notifyAll-阻塞和唤醒线程" class="headerlink" title="5.7. wait()，notify()，notifyAll()阻塞和唤醒线程"></a>5.7. wait()，notify()，notifyAll()阻塞和唤醒线程</h2><p> 这三个方法都是属于Object的本地final方法；无法被重写，所有类都可以调用这三方法； </p>
<ul>
<li><p>wait()：使当前线程等待，并且释放锁，直到其他线程调用notify()或者notifyAll()方法唤醒。</p>
</li>
<li><p>notify()：唤醒一个等待当前对象的锁的线程（随机）。</p>
</li>
<li><p>notifyAll(）就是唤醒所有在等待当前对象的线程。</p>
</li>
</ul>
<p>wait()和notify()方法要求在调用时线程持有对象的锁，因为线程只有在同步块中才会占用对象的锁，因此对这两个方法的调用需要放在synchronized方法或synchronized块中。</p>
<p>不持有锁的话可能会产生竞态问题，notify可能比wait先执行，导致一直wait</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用synchronized获取对象锁，在同步块中使用wait方法让当前线程进入等待状态，等待当前锁住的对象，</span></span><br><span class="line"><span class="comment">//同样的在另一个同步块中使用notify方法释放对象锁，唤醒等待该对象锁的线程。</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">	obj.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">	obj.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>锁池和等待池</strong></p>
<p>锁池：线程A持有某个对象的锁，导致其他线程不能访问该对象的synchronized方法（代码块），这些线程就会进入锁池，等待对象的锁被释放，与其他线程竞争锁</p>
<p>等待池：线程A调用了某个对象的wait方法，线程A就会释放该对象的锁，进入到该对象的等待池。不会去竞争锁</p>
<p>notify会将等待池中的线程唤醒，被唤醒的线程从等待池进入锁池，与其他线程竞争锁</p>
<p><strong>synchronized是非公平锁，线程需要竞争锁</strong></p>
<p><strong>公平锁：可以使用FIFO（先进先出），维护一个队列，让先进的线程获得锁</strong></p>
<h1 id="6-线程状态"><a href="#6-线程状态" class="headerlink" title="6. 线程状态"></a>6. 线程状态</h1><p><strong><a href="https://www.cnblogs.com/happy-coder/p/6587092.html">转自此处</a></strong></p>
<p><img src="/2018/11/17/basic-2018-10-17-ipc-thread/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p>
<h2 id="6-1-线程共包括以下5种状态。"><a href="#6-1-线程共包括以下5种状态。" class="headerlink" title="6.1. 线程共包括以下5种状态。"></a>6.1. 线程共包括以下5种状态。</h2><ol>
<li>新建状态(New)         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>
<li>就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>
<li>运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>
<li>阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ul>
<li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>
<li> 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>
<li> 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
<li>死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<h2 id="6-2-yield，sleep，join都是Thread的方法"><a href="#6-2-yield，sleep，join都是Thread的方法" class="headerlink" title="6.2. yield，sleep，join都是Thread的方法"></a>6.2. yield，sleep，join都是Thread的方法</h2><p>yield：让步，让当前线程由运行状态进入到就绪状态，从而让其他线程有机会获得cpu（一般是更高优先级的线程，也可能当前线程立马获得cpu）</p>
<p>sleep: 让线程休眠一段时间，进入阻塞状态。放弃cpu，给其他线程执行的机会，但是不释放对象锁，如果加了锁，其他线程还是不能使用资源</p>
<p>join：当前线程挂起，让指定的另一个线程执行。join（long）方法在内部使用的是 wait (long) 方法来实现的；所以join（long）方法具有释放锁的特点。（相当于在程序中间插入了一段代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">        <span class="comment">//主线程会阻塞，直到t线程执行完毕。</span></span><br><span class="line">        <span class="comment">//join的意思是加入，即将线程排队，把t线程加入到队伍里面去</span></span><br><span class="line">        <span class="comment">//也可以传入时间参数，表示主线程只等待一段时间</span></span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep是native方法，并且是静态的，一般使用<code>Thread.sleep(1000);</code>让当前线程休眠</p>
<h1 id="7-同步和异步、阻塞与非阻塞"><a href="#7-同步和异步、阻塞与非阻塞" class="headerlink" title="7. 同步和异步、阻塞与非阻塞"></a>7. 同步和异步、阻塞与非阻塞</h1><p>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。</p>
<h2 id="7-1-同步与异步"><a href="#7-1-同步与异步" class="headerlink" title="7.1. 同步与异步"></a>7.1. 同步与异步</h2><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)<br>同步：就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由调用者主动等待这个调用的结果。</p>
<p>异步：调用在发出之后，方法立即返回，但是结果还没返回。等待计算完结果后被调用者通过状态、消息通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>注：这里的同步和java的线程同步不一样，线程同步是为了防止多个线程修改共有资源时导致的资源不同步的问题</p>
<h2 id="7-2-阻塞与非阻塞"><a href="#7-2-阻塞与非阻塞" class="headerlink" title="7.2. 阻塞与非阻塞"></a>7.2. 阻塞与非阻塞</h2><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<h2 id="7-3-区别"><a href="#7-3-区别" class="headerlink" title="7.3. 区别"></a>7.3. 区别</h2><p>阻塞代码不继续往下执行，不占用cpu，同步的话代码会继续执行（进入方法里面执行），占用cpu</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="Lock和synchronized区别："><a href="#Lock和synchronized区别：" class="headerlink" title="Lock和synchronized区别："></a>Lock和synchronized区别：</h2><ol>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；（I/O和Synchronized都能相应中断，即不需要处理interruptionException异常）</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
<li>Lock可以提高多个线程进行读操作的效率。</li>
<li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li>
</ol>
<p>1 、在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间 (解决方案：tryLock(long time, TimeUnit unit))或者能够响应中断(解决方案：lockInterruptibly())），这种情况可以通过 Lock 解决。</p>
<p>2、当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程都只是进行读操作时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。同样地，Lock也可以解决这种情况 (解决方案：ReentrantReadWriteLock) 。</p>
<p>3、通过Lock得知线程有没有成功获取到锁 (解决方案：ReentrantLock) ，但这个是synchronized无法办到的。</p>
<p>上面提到的三种情形，我们都可以通过Lock来解决，但 synchronized 关键字却无能为力。事实上，Lock 是 java.util.concurrent.locks包 下的接口，Lock 实现提供了比 synchronized 关键字更广泛的锁操作，它能以更优雅的方式处理线程同步问题。也就是说，Lock提供了比synchronized更多的功能。</p>
]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>程序基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker笔记</title>
    <url>/2018/11/04/tool-2018-11-04-Docker/</url>
    <content><![CDATA[<h1 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h1><h2 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h2><p><img src="/2018/11/04/tool-2018-11-04-Docker/docker01.png" alt="docker架构图"></p>
<h2 id="docker概念"><a href="#docker概念" class="headerlink" title="docker概念"></a>docker概念</h2><table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>镜像(Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板。</td>
</tr>
<tr>
<td>容器(Container)</td>
<td>容器是独立运行的一个或一组应用。</td>
</tr>
<tr>
<td>客户端(Client)</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker API 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td>主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td>镜像仓库(Repository)</td>
<td>用来存储具体的镜像，可以理解为代码控制中的代码仓库。通过tag区分版本号</td>
</tr>
<tr>
<td>注册服务器（Registry）</td>
<td>用于管理镜像仓库，起到的是服务器的作用。默认是官方的Docker Hub，可以搭建私有服务器</td>
</tr>
</tbody></table>
<p>镜像资源分为两类：</p>
<p>官方提供的，名称不带前缀，如：<code>hello-world</code></p>
<p>docker用户创建并维护的,名称带用户名前缀，如：<code>username/hello-world</code></p>
<p>镜像名完整组成：<br><code>registryhost/username/repository:tag</code>即<br><code>服务主机/用户名/仓库名:版本号</code><br>registryhost不填，则默认为DockerHub<br>username不填，则表示docker官方提供的镜像<br>tag不填，则默认为latest</p>
<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.docker.com/get-started">官网</a>下载安装，按提示一步步完成，国内下载速度慢的话可以使用迅雷。</p>
<p><strong>注：windows下默认安装在C盘，镜像多的话可能会导致C盘越来越大，可以修改镜像存储路径，<a href="https://blog.csdn.net/stemq/article/details/53150939">参考博客</a></strong></p>
<ul>
<li>windows上安装的docker其实本质上还是借助与windows平台的hyper-v技术来创建一个linux虚拟机，你执行的所有命令其实都是在这个虚拟机里执行的，所以所有pull到本地的image都会在虚拟机的Virtual hard disks目录的文件中，这个文件就是虚拟硬盘文件。如果要想改变路径只需要在hyper-v管理器里设置就可以了。默认的安装路径是C:\Users\Public\Documents\Hyper-V\Virtual hard disks下。</li>
<li>将默认C:\Users\Public\Documents\Hyper-V\Virtual hard disks\MobyLinuxVM.vhdx的文件拷贝到想要改变的路径</li>
<li>控制面板-&gt;管理工具-&gt;Hyper-V管理器-&gt;右键设置-&gt;硬盘驱动器-&gt;虚拟硬盘输入为想要保存的路径</li>
</ul>
<p><img src="/2018/11/04/tool-2018-11-04-Docker/docker03.png" alt="docker修改镜像路径"></p>
<p><img src="/2018/11/04/tool-2018-11-04-Docker/docker04.png" alt="docker修改镜像路径"></p>
<ul>
<li>我试了一下发现重启之后又恢复成原来的路径，解决如下</li>
</ul>
<p><img src="/2018/11/04/tool-2018-11-04-Docker/docker05.png" alt="docker修改镜像路径"></p>
<p><img src="/2018/11/04/tool-2018-11-04-Docker/docker06.png" alt="docker修改镜像路径"></p>
<h2 id="镜像服务器设置"><a href="#镜像服务器设置" class="headerlink" title="镜像服务器设置"></a>镜像服务器设置</h2><p>Perferences… -&gt; Daemon -&gt; Registry mirrors配置</p>
<p>windows：在setting -&gt; Daemon -&gt; Registry mirrors中配置</p>
<p>镜像地址：<br>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a>  </p>
<p>官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></p>
<p>ustc的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></p>
<p>daocloud：<a href="https://www.daocloud.io/mirror#accelerator-doc%EF%BC%88%E6%B3%A8%E5%86%8C%E5%90%8E%E4%BD%BF%E7%94%A8%EF%BC%89">https://www.daocloud.io/mirror#accelerator-doc（注册后使用）</a></p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>可视化工具：<a href="https://kitematic.com/">Kitematic</a></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>容器生命周期管理 — docker [run|start|stop| restart|kill|rm|pause|unpause]  </li>
<li>容器操作运维 — docker [ps|inspect|top|attach|events|logs|wait|export|port]  </li>
<li>容器rootfs命令 — docker [commit|cp|diff]  </li>
<li>镜像仓库 — docker [login|pull|push|search]  </li>
<li>本地镜像管理 — docker [images|rmi|tag|build|history|save|import]  </li>
<li>其他命令 — docker [info|version]</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>CONTAINER:：可以是容器名也可以是容器id<br>REPOSITORY：仓库名<br>REGISTRYHOST：服务主机地址<br>IMAGE：镜像名<br>TAG：版本号，不填则默认为latest</p>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul>
<li><code>docker</code>：查看docker帮助</li>
<li><code>docker &lt;COMMAND&gt; --help</code>：查看具体命令帮助</li>
<li><code>docker -v</code>，<code>docker --version</code>：查看docker版本</li>
<li><code>docker info</code>：查看docker系统信息</li>
<li><code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]</code>:获取容器/镜像的元数据。<br>常用OPTIONS：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :指定返回值的模板文件。</span><br><span class="line">-s :显示总的文件大小。</span><br><span class="line">--type :为指定类型返回JSON。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><ul>
<li><code>docker login -u 用户名 -p 密码</code>: 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</li>
<li><code>docker logout </code>: 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</li>
<li><code>docker search 镜像名</code>：从Docker Hub查找镜像</li>
<li><code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code>： 从镜像仓库中拉取或者更新指定镜像</li>
<li><code>docker push [OPTIONS] NAME[:TAG]</code>：将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><p><code>docker container ls</code>或<code>docker ps</code>：列出运行的容器，加-a或–all可列出所有容器</p>
</li>
<li><p>`docker create [OPTIONS] 镜像名：创建新容器，但不启动</p>
</li>
<li><p><code>docker run [OPTIONS] 镜像名</code>：创建新容器并运行<br>会从本地查找镜像，若不存在，则从默认公共镜像源(DockerHub)下载<br>常用OPTIONS： </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-p: 端口映射，格式为：主机(宿主)端口:容器端口  </span><br><span class="line">-d: 后台运行容器，并返回容器ID，不加-d会显示日志</span><br><span class="line">--name：为容器指定名称</span><br><span class="line">······</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>docker start [OPTIONS] CONTAINER [CONTAINER...]</code>：启动一个或多个已经被停止的容器</p>
</li>
<li><p><code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code>：停止一个或多个运行中的容器</p>
</li>
<li><p><code>docker restart [OPTIONS] CONTAINER [CONTAINER...]</code>：重启一个或多个容器</p>
</li>
<li><p><code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code>：杀掉一个或多个运行中的容器</p>
</li>
<li><p><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code>：删除一个或多少容器</p>
</li>
<li><p><code>docker logs [OPTIONS] CONTAINER</code>：获取容器的日志</p>
</li>
<li><p><code>docker top [OPTIONS] CONTAINER [ps OPTIONS]</code>：查看容器中运行的进程信息，支持 ps 命令参数。</p>
</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul>
<li><code>docker images</code>：列出本地镜像</li>
<li><code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]</code>：获取容器/镜像的元数据<br>常用OPTIONS：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :指定返回值的模板文件。</span><br><span class="line">-s :显示总的文件大小。</span><br><span class="line">--type :为指定类型返回JSON。</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><code>docker build [OPTIONS] PATH | URL | -</code>：根据Dockerfile构建镜像<br>常用OPTIONS:：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- -t，--tag : 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br><span class="line">- -f : 指定Dockerfile路径</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code>：从容器创建一个新的镜像</p>
<p>常用OPTIONS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停。</span><br></pre></td></tr></table></figure></li>
<li><p><code>docker tag [OPTIONS] IMAGE[:TAG][REGISTRYHOST/][USERNAME/]NAME[:TAG]</code>：修改镜像的所属仓库</p>
</li>
<li><p><code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code>：删除一个或多个本地镜像</p>
<p>OPTIONS说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :强制删除；</span><br><span class="line">--no-prune :不移除该镜像的过程镜像，默认移除；</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="把镜像上传到Docker-Hub"><a href="#把镜像上传到Docker-Hub" class="headerlink" title="把镜像上传到Docker Hub"></a>把镜像上传到Docker Hub</h1><h2 id="注册docker账号"><a href="#注册docker账号" class="headerlink" title="注册docker账号"></a>注册docker账号</h2><p><a href="(https://hub.docker.com/)">DockerHub</a></p>
<p>（1）输入DockerId（即用户名，英文小写和数字），邮箱，密码<br>（2）邮箱验证</p>
<h2 id="在hub上创建仓库"><a href="#在hub上创建仓库" class="headerlink" title="在hub上创建仓库"></a>在hub上创建仓库</h2><p>Create Repository，起名，如hello-world，<br>则路径为username/hello-word</p>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>搜索镜像：<code>docker search hello-world</code></p>
<p>拉取镜像：<code>docker pull hello-world</code></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>创建新容器并运行：<code>docker run --name my-hello-world -d hello-world</code></p>
<p>注：</p>
<ul>
<li>加<code>-d</code>返回容器id</li>
<li>加<code>--name</code>命名为’my-hello-world’</li>
</ul>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><p><code>docker ps</code>，<code>docker container ls</code>：可以看到容器id，容器名称等信息。</p>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><h3 id="基于Dockerfile构建新镜像"><a href="#基于Dockerfile构建新镜像" class="headerlink" title="基于Dockerfile构建新镜像"></a>基于Dockerfile构建新镜像</h3><p>待补充//todo</p>
<h3 id="使用commit从容器创建镜像"><a href="#使用commit从容器创建镜像" class="headerlink" title="使用commit从容器创建镜像"></a>使用commit从容器创建镜像</h3><p><code>docker commit -p 容器id/容器名 my-hello-world:v1</code></p>
<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><p>查看本地镜像：<code>docker images</code><br>看看镜像仓库是否存在</p>
<p>可以修改镜像的所属仓库：<br><code>docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</code></p>
<h2 id="登录docker账号"><a href="#登录docker账号" class="headerlink" title="登录docker账号"></a>登录docker账号</h2><p>输入<code>docker login</code>，接着输入用户名和密码<br>或者在docker图形界面登录</p>
<h2 id="本地镜像上传到镜像仓库"><a href="#本地镜像上传到镜像仓库" class="headerlink" title="本地镜像上传到镜像仓库"></a>本地镜像上传到镜像仓库</h2><p><code>docker push username/my-hello-world:v1</code><br>上传成功后可以到hub上查看是否创建成功</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li><p>遇到一个问题：原先我在windows上用的终端时Git Bash，在使用docker的jenkins容器时，需要<code>docker exec -it jenkins /bin/bash</code>，进入交互解释器，提示<code>the input device is not a TTY.  If you are using mintty, try prefixing the command with &#39;winpty&#39;</code></p>
<p>这是由于终端和linux不一样，网上有很多解决办法，说的有点多，弄了一会没弄好就没耐心了，正好我觉得Git Bash不太好用了，如复制粘贴快捷键（一点都不快捷，笔记本的键盘可能会好点）是<code>Ctrl+ins</code>和<code>Shift+ins</code>，且命令提示也不是很友好，于是趁此机会换了cmder命令行工具，顺便学习了一下，结果很满意，想看的可以移步<a href="/2018/12/14/tool-2018-12-14-Cmder/">这里</a>。</p>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料</p>
<ul>
<li><a href="https://www.cnblogs.com/wherein/p/6862911.html">Docker 如何把镜像上传到docker hub</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1593010515480468898&wfr=spider&for=pc">Docker新手入门之四：Docker镜像和仓库的基本使用</a></li>
<li><a href="http://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>青年的楷模 学习的榜样——读《习近平的七年知青岁月》</title>
    <url>/2018/11/02/reader-2017-10-01-PartyArticleStudy/</url>
    <content><![CDATA[ <center>
     <font size="5">青年的楷模 学习的榜样——读《习近平的七年知青岁月》</font><br>
     <font size="4">团中央书记处常务书记 贺军科</font>
 </center>

<p>​    2013年五四青年节，习近平总书记在同各界优秀青年代表座谈时，讲了一段极有文采、极富人生哲理的话：“青年朋友们，人的一生只有一次青春。现在，青春是用来奋斗的；将来，青春是用来回忆的……青年时代，选择吃苦也就选择了收获，选择奉献也就选择了高尚。青年时期多经历一点摔打、挫折、考验，有利于走好一生的路。要历练宠辱不惊的心理素质，坚定百折不挠的进取意志，保持乐观向上的精神状态，变挫折为动力，用从挫折中吸取的教训启迪人生，使人生获得升华和超越。”</p>
<p>　　当时，我听到这段话，第一反应就是青年喜欢听、听得进，肯定会“火”。果不其然，总书记的讲话一经全文公开发表，这段话就在青年中引起强烈共鸣，激励着无数青年发出了“奋斗的青春最美丽”的铮铮誓言。现在，读了《习近平的七年知青岁月》（以下简称《岁月》），了解了总书记青年时期的点点滴滴，我们再来回味和咀嚼这段话，更有一种跨越历史、直击人心的触动与震撼，更能体会到总书记在讲这一番话时的语重心长、殷殷嘱托。我理解，总书记这段话是说给广大青年听的，同时每一个字又是对自己知青岁月的深沉感悟。在那段日子里，青年习近平在艰难困苦中经历摔打、挫折、考验，做到了宠辱不惊、百折不挠、乐观向上，真正实现了人生的升华和超越。透过七年知青岁月，我们更加深刻地感受到了总书记“五四”寄语背后那股震撼人心的力量，这就是“知行合一”所带来的极其强大的心灵感染力、理论说服力、实践穿透力。这种震撼，吸引着我、同样也吸引着广大青年走进总书记的七年知青岁月，感悟总书记的青春奋斗故事给我们带来的深刻启示。《岁月》一经出版发行，就在广大团干部和团员青年中自发形成了读《岁月》、话理想、谈奋斗的浓厚氛围，形成了向青年习近平学习、向习近平总书记看齐的高度自觉。这是人民群众的呼声，这是人民领袖的魅力。</p>
<p>　　一、习近平总书记的七年知青岁月是青年一代励志成才的生动教材</p>
<p>　　习近平总书记寄语青年：“人生的扣子从一开始就要扣好。”总书记的七年知青岁月就是对这句话的最好注脚。对于每一个人来讲，扣人生第一粒扣子时的外部环境是很不一样的。有人可以在亲人的帮助下扣，有人可以在阳光下、灯光下扣，而总书记当初是在黑暗中摸索，在“苦其心志、劳其筋骨、饿其体肤”的环境下，艰难而又准确地扣好这人生第一粒扣子的。惟其艰难，更显伟大，更能够给当代青年以丰富的教益与启迪。</p>
<p>　　青年一代向总书记学习，就是要坚定听党话、跟党走的理想信念。习近平总书记指出，广大团员青年坚定跟党走，就是初心。不忘这个初心，是我国广大青年的政治选择，也是我国广大青年的人生航向。总书记曾经说过：“人生的道路要靠自己来选择。如何选择一条正确的道路，关键是要有坚定的理想信念。否则，环境再好照样会走错路。”总书记青年时期先后写了8份入团申请书、10份入党申请书，即便是在个人处境极为艰难的条件下，始终没有对党产生过怀疑和动摇。这就为我们生动诠释了什么叫矢志不渝、什么叫理想坚定，为广大青年树立了坚守初心不动摇的学习楷模。党的十八大以来，习近平总书记反复强调理想信念是精神之钙；在谈到青年成长道路问题时，每次必讲理想，而且都是第一位的要求。广大青年要把总书记的要求和他青年时代的实践结合起来学习，把理想信念建立在对科学理论的理性认同上，建立在对历史规律的正确认识上，建立在对基本国情的准确把握上，真正牢固树立为实现中华民族伟大复兴中国梦而奋斗的远大理想，坚定跟党走中国特色社会主义道路的坚定信念。</p>
<p>　　青年一代向总书记学习，就是要永葆肯吃苦、不怕苦的奋斗精神。在七年知青岁月里，别人做事从“零”开始，青年习近平却要从“负数”开始，深深体味了最苦、最难的生活，并在苦难中完成了人生的一次升华。从“扁担把他的肩膀磨得一层一层掉皮、出血”到“肩膀上磨出了厚厚的茧子，就不怕扁担磨了”；从“躺在跳蚤堆里睡觉，一咬一挠，浑身发肿”到“对跳蚤的毒素产生抵抗力”；从一开始劳动“连婆姨都不如的每天五六个工分”到两年后“拿到壮劳力的10个工分，成了种地的好把式”。不管多累多苦，青年习近平总是一直拼命干，从来不“撒尖儿”，一步一步地过了跳蚤关、饮食关、劳动关、思想关这“四关”。每过一关都是一份磨砺，都有一份收获，不断积蓄着人生升华与超越的能量。这种苦难的磨砺，既是物质上、身体上的，更是精神上、心灵上的。总书记从不谙世事的“知青”到自称“是个普通农民”“是黄土地的儿子”，体现的是思想深处对农村和农民感情的深刻变化，证明已经完全融入了人民群众之中、深深扎根在中国的大地之中。“青年时代，选择吃苦也就选择了收获。”不同年代，吃苦的含义是不一样的。当代青年不会再有当初大规模上山下乡的那种历练，也很少会有吃不饱肚子的担忧，但是同样会碰到“苦”的环境、尝到“苦”的滋味。作为生活在新时期的青年一代，没有任何理由怨天尤人，必须像青年习近平那样，敢于吃苦、乐于吃苦、善于吃苦、不忘吃苦，在奋斗中创造属于自己的无悔青春。</p>
<p>　　青年一代向总书记学习，就是要养成爱读书、善读书的生活方式。酷爱读书，是《岁月》中几乎每一位受访者都谈到的对习近平总书记的深刻印象。青年习近平到陕北插队，只带了两个行李箱，里面装的全是书；“白天劳动、晚上看书”成为总书记知青岁月的生活常态，而且一直坚持，广泛涉猎了历史、政治、哲学、文学、外交、传统文化等领域的大量书籍，留下了“30里借书、30里讨书”的生动故事，用梁家河老乡的话说，“近平读书有‘书瘾’”，已经到了痴迷的程度。在当时那么差的学习条件下、不怕考试得零分的社会氛围中，青年习近平从来没有放弃读书和思考，这是难能可贵的。他不仅爱读书，而且善读书，“经常是几本书同时看，有所对比，有所分析”，“既知其然，又知其所以然”；注重从实践中求真知，指出“我们读了很多书，但书里有很多水分，只有和群众结合，才能把水分蒸发掉，得到真正的知识”。在总书记青年时代，书很少，很多时候是有什么书就读什么书；现在，书多了，想读什么书就有什么书，但我们的读书学习越来越快餐式、碎片化、浅层次。针对这一问题，总书记在多次讲话中强调，青年抓学习要“下一番心无旁骛、静谧自怡的功夫”，“特别是要克服浮躁之气，静下来多读经典，多知其所以然”，“努力做到又博又专、愈博愈专”。这些要求很有现实针对性，广大青年应当结合青年习近平读书学习的事例，养成爱读书、善读书的生活方式，真正在向书本学习、向实践学习中打牢自身成长的根基。</p>
<p>　　二、习近平总书记的七年知青岁月是年轻干部健康成长的看齐标杆</p>
<p>　　习近平总书记多次用“墩墩苗”来比喻年轻干部的成长，深刻指出：“干部多‘墩墩苗’没有什么坏处，把基础搞扎实了，后面的路才能走得更稳更远。”在七年知青岁月里，青年习近平担任过驻队社教干部、梁家河村党支部书记，在最基层、第一线为老百姓做一件件实事，赢得了群众的口碑，成为“大家都拥护”的村支书。总书记用躬身实践告诉新时期的年轻干部“为什么当干部、怎么当好干部”，为大家树起了看齐的标杆。</p>
<p>　　年轻干部向总书记看齐，就是要一心为民。《岁月》一书给我留下的一个深刻印象就是，习近平总书记“在走上社会之初就与最底层的中国农民同甘苦共患难，由此培养了他一生都割舍不断的深厚感情——从心底里热爱人民，把老百姓搁在心里”。对乞食老汉“解衣推食”、帮助老汉拉车、帮群众找猪、为救治受伤村民而急坏了……这些都是青年习近平为民情怀的自然流露。梁家河的村民们讲，总书记那时候“主要想的就不是自己的前途，而是怎么能做好村里的工作，怎么能让群众的生活好起来”。从政是一条充满不确定性的路，对待这种不确定性，总书记的选择是：“干得好，将来成就一番大事业，干得不好，就在下面给老百姓做些实事，也没什么”，“因为不管从政道路的前景如何，在基层为群众做实事的权利总是不会被剥夺的”。总书记用“在任何岗位上都能为群众做实事”来看淡不确定性，与某些干部用拉帮结派、投机钻营来抵消不确定性，是两种选择、两种境界，泾渭分明、高下立见，老百姓心中自有一杆秤。现在，习近平总书记反复强调“以人民为中心的发展思想”，从总书记的七年知青岁月中我们更深刻地读懂了它的根基与源头。新时期的年轻干部必须始终牢记全心全意为人民服务的宗旨，把人民放在心中最高的位置，坚定不移践行党的群众路线，始终与人民心心相印、与人民同甘共苦、与人民团结奋斗。</p>
<p>　　年轻干部向总书记看齐，就是要勤勉务实。梁家河的村民讲，“近平不搞形式主义，不搞那个年代时兴的学习、运动，而是立志办大事，要给群众做实实在在的事情。”村里缺地缺粮食，他就带领大家打淤地坝；村里缺水，他就带领大家挖深水井；为了方便村民缝补衣服、磨面磨粉、购买日用品和农具，他给村里办起了缝纫社、代销店、铁业社、磨坊。“只要是村民需要的，只要是他能想到的，他都去办，而且都办得轰轰烈烈。”青年习近平的务实还体现在村民都爱听他讲话。村民们都说，“近平开会和其他干部不一样，其他干部开会，讲话的时候老百姓在下边抽旱烟的、说闲话的、纳鞋底的，基本上没有人听。唯独习近平开会，讲话的时候大家都静悄悄地听”，“能把人听憨了！”原因就在于青年习近平“不说空话，不说大话”，讲得“特别实在”，说的都是老百姓想说的心里话。新时期的年轻干部要牢记总书记“空谈误国、实干兴邦”的教诲，一切从实际出发，真正选择人民群众急需的事情去干，选择打基础、利长远的事情去干，特别是要把那些已经决定了的好事实事，快干、干成、干好，真正让人民群众有实实在在的获得感。</p>
<p>　　年轻干部向总书记看齐，就是要敢于担当。“敢说、敢做、敢担当”，这是梁家河的乡亲们对青年习近平担任村党支部书记时领导风格的一致评价。当年，总书记做事“有决心、有毅力，轻易不说出口，只要说出口的话，只要认定了的事，他就坚持到底”。打坝、办沼气、办代销店、办铁业社，等等，没有哪件事情是半途而废的，无论遇到什么困难，他都能想办法克服。特别是在当时的政治和经济环境下，搞副业是有风险的，很容易被扣帽子。但是，只要群众需要、对集体有利，总书记就会在严谨把握政策的基础上，带领大家坚决地干。这就是一种担当。党的十八大以来，总书记带领全党直面问题和弊端，坚定不移推进全面从严治党，抓铁有痕、踏石留印，以钉钉子精神逐步深化，实现了党风、政风、社会风气的明显好转。这背后所体现的顽强意志品质和强烈责任担当，与总书记七年知青岁月中的奋斗是一脉相承的。当前，我们正处于全面决胜小康的关键时期，处于改革攻坚期、社会转型期、矛盾凸显期，更需要党员干部敢于担当。年轻干部必须牢记总书记提出的20字好干部标准，真正把责任扛在肩上，敢于较真、敢于碰硬、敢于直面矛盾，争当迎难而上、攻坚克难的勇士。</p>
<p>　　三、习近平总书记的七年知青岁月在当代青年内心赢得了强大真挚的情感认同</p>
<p>　　当今世界正处于百年不遇的大变局之中，我们比历史上任何时期都更接近实现中华民族伟大复兴的目标。越是这个关键历史时期，我们越需要一个坚强的领导核心。党的十八大以来，习近平总书记以马克思主义政治家的雄才大略、远见卓识、坚定信念，在进行具有许多新的历史特点的伟大斗争中运筹帷幄、勇于担当、率先垂范，赢得了包括广大青年在内的全党全军全国各族人民的衷心爱戴，在党的十八届六中全会上正式明确为党中央的核心、全党的核心。这是党之幸、国家之幸、民族之幸，是具有重大现实意义和深远历史意义的政治成果，我们必须备加珍惜、坚决捍卫。</p>
<p>　　对核心的绝对忠诚和坚定追随，最根本的在于发自内心的崇敬与爱戴，最深沉、最持久的源泉是心灵上的情感认同。1949年5月7日，周恩来同志在中华全国青年第一次代表大会上作报告，发出了“学习毛泽东”的号召，指出：“决不要把毛泽东看成一个偶然的、天生的、神秘的、无法学习的领袖……我们的领袖是从人民当中生长出来的，是跟中国人民血肉相联的，是跟中国的大地、中国的社会密切相关的。”现在，我们同样需要更加全面、更加深入、更加生动地理解和认识我们的领袖，“不仅看到他们在台上作大报告的样子，也知道一点儿他们的酸甜苦辣和内心世界”。《岁月》一书正是为人民群众特别是青年一代提供了这样一个难得的窗口。</p>
<p>　　习近平总书记是从人民当中生长出来的。在梁家河的七年时间里，总书记窑洞里的知青越来越少，但是来这里拉话、讨论事情、听说书的老乡越来越多。这是一幅没有刻意导演、但却十分具有象征意义的画面，定格了总书记密切联系群众、深深扎根群众的生动景象。</p>
<p>　　习近平总书记是跟中国人民血肉相联的。青年习近平离开梁家河时，村民们送了一程又一程，难舍难分。40年后，总书记再次来到梁家河，对乡亲们讲：“当年，我人走了，但我把心留在了这里。”简简单单的话语背后，饱含着与人民的深厚感情。</p>
<p>　　习近平总书记是跟中国的大地、中国的社会密切相关的。总书记曾经说过：“15岁来到黄土地时，我迷惘、彷徨；22岁离开黄土地时，我已经有着坚定的人生目标，充满自信。”在梁家河的7年岁月，总书记读懂了“生活”这部大书，读懂了“中国农村”这部大书，也读懂了“实际”这部大书。这是总书记与黄土地的不解之缘，从中国的大地、中国的社会中汲取到无穷的智慧和力量。</p>
<p>　　最近，我经常和各级团干部和各领域团员青年聊起读《岁月》一书的感受和体会。不少青年朋友讲：“五年来，习近平总书记带领党和国家干了许多得民心、顺民意的大事难事，我们感到总书记的形象在心目中越来越高大，由衷地信服和拥护总书记的核心地位；最近读了《习近平的七年知青岁月》，又感到总书记和我们离得越来越近、贴得越来越紧，发自内心地爱戴这样的人民领袖。”看完《岁月》一书，我们都能强烈地感受到，书中讲述的习近平总书记的每一个青春奋斗故事都很实在，都是普通人经过努力能够做到的，但是这么多故事背后的闪光点集中到一个人身上，就诞生了“伟大”。正是因为这种普通群众都能理解和认知的“伟大”，包括广大青年在内的人民群众才发自内心地感到习近平总书记既可敬、又可亲，既高大、又贴近，具有强烈的人格魅力。</p>
<p>　　理解这份“伟大”，还需要我们置身当时的历史条件和时代环境去体悟。当我们只是作为一个旁观者，回望过去时，历史已经定格，呈现出一种确定性；但是，在真实的历史正在行进时，充满了未知、充满了不确定性。我们现在回头看，习近平总书记在梁家河一待就是七年，很不容易；但更不容易的是，总书记当初在梁家河，不知道自己要待多久，很多时候看不到未来、也设计不了自己的未来。在那种情况下，总书记仍然坚守初心、坚持学习、坚持奋斗、坚持工作，支撑这份宝贵的坚守与坚持的，就是信仰的力量、为民的情怀、务实的作风、担当的精神。现在，我们进行伟大斗争、建设伟大工程、推进伟大事业、实现伟大梦想，正需要有这样一股力量、这样一份情怀、这样一种作风、这样一身担当的领袖来掌舵领航。</p>
<p>　　“每一代青年都有自己的际遇和机缘，都要在自己所处的时代条件下谋划人生、创造历史。”时代在变、环境在变，不变的是榜样的力量。习近平总书记七年知青岁月对青年一代成长成才的启示，具有跨越时空的永恒价值。当代青年要向习近平总书记学习，始终坚守初心、坚定理想，始终与人民相结合、和群众在一起，多一些摔打磨练、多几分淡定从容，不在坐享其成中虚度青春，要在不懈奋斗中创造未来，勇做走在时代前列的奋进者、开拓者、奉献者，努力在实现中国梦的生动实践中放飞青春梦想。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>名词和缩写解释笔记</title>
    <url>/2018/10/24/note-2018-10-24-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>网络用语可使用在线工具查询：<a href="https://lab.magiconch.com/nbnhhsh/?from=home">能不能好好说话</a></p>
<h1 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>cli</td>
<td>command-line interface</td>
<td>命令行界面</td>
<td>终端</td>
</tr>
<tr>
<td>CR</td>
<td>Carriage Return</td>
<td>回车</td>
<td>对应ASCII中转义字符\r</td>
</tr>
<tr>
<td>LF</td>
<td>Linefeed</td>
<td>换行</td>
<td>对应ASCII中转义字符\n</td>
</tr>
<tr>
<td>apt</td>
<td>Advanced Packaging Tool</td>
<td></td>
<td>Linux下的一款安装包管理工具</td>
</tr>
</tbody></table>
<h2 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2><p>位（bit）是计算机存储的最小单位，字节是计算机处理数据的最小单位，1字节=8位</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>bit</td>
<td></td>
<td>位</td>
<td>存放一位二进制数，即 0 或 1，最小的存储单位</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
<td>字节</td>
<td>1B=8bit</td>
</tr>
<tr>
<td>KB</td>
<td>Kilobyte</td>
<td>千字节</td>
<td>1KB=1024B</td>
</tr>
<tr>
<td>MB</td>
<td>Megabyte</td>
<td>兆字节</td>
<td>1MB=1024KB</td>
</tr>
<tr>
<td>GB</td>
<td>Gigabyte</td>
<td>吉字节</td>
<td>1GB=1024MB</td>
</tr>
<tr>
<td>TB</td>
<td>Trillionbyte</td>
<td>太字节</td>
<td>1TB=1024GB</td>
</tr>
<tr>
<td>PB</td>
<td>Petabyte</td>
<td>拍字节</td>
<td>1PB=1024GB</td>
</tr>
<tr>
<td>EB</td>
<td>Exabyte</td>
<td>艾字节</td>
<td>1EB=1024PB</td>
</tr>
<tr>
<td>ZB</td>
<td>Zettabyte</td>
<td>泽字节</td>
<td>1ZB=1024EB</td>
</tr>
<tr>
<td>YB</td>
<td>Yottabyte</td>
<td>尧字节</td>
<td>1YB=1024ZB</td>
</tr>
<tr>
<td>BB</td>
<td>Brontobyte</td>
<td>珀字节</td>
<td>1BB=1024YB</td>
</tr>
<tr>
<td>NB</td>
<td>NonaByte</td>
<td>诺字节</td>
<td>1NB=1024BB</td>
</tr>
<tr>
<td>DB</td>
<td>DoggaByte</td>
<td>刀字节</td>
<td>1DB=1024NB,计算机中最大的储存单位</td>
</tr>
</tbody></table>
<h2 id="吉利数字"><a href="#吉利数字" class="headerlink" title="吉利数字"></a>吉利数字</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>65536</td>
<td>2的16次方</td>
</tr>
<tr>
<td>65535</td>
<td>2的16次方-1:理论上计算机能达到的最大进程数</td>
</tr>
</tbody></table>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>TLS</td>
<td>Transport Layer Security</td>
<td>传输层安全</td>
<td></td>
</tr>
<tr>
<td>SSL</td>
<td>Secure Sockets Layer</td>
<td>安全套接层</td>
<td>tls的前身，最初由netscape开发，被IETF标准化并改名为tls</td>
</tr>
<tr>
<td>CA</td>
<td>Certificate Authority</td>
<td></td>
<td>证书颁发机构</td>
</tr>
<tr>
<td>CSR</td>
<td>Cerificate Signing Request</td>
<td></td>
<td>证书请求文件</td>
</tr>
<tr>
<td>crt</td>
<td>Certificate</td>
<td>证书文件</td>
<td>客户端认证的证书</td>
</tr>
<tr>
<td>ssid</td>
<td>Service Set Identifier</td>
<td>服务集标识</td>
<td>用来区分不同的网络。SSID就是一个局域网的名称,无线网络中SSID，是路由器发送的无线信号的名字SSID技术可以将一个无线局域网分为几个需要不同身份验证的子网络，每一个子网络都需要独立的身份验证，只有通过身份验证的用户才可以进入相应的子网络，防止未被授权的用户进入本网络。</td>
</tr>
<tr>
<td>DNS</td>
<td>Domain Name System</td>
<td>域名系统</td>
<td>特网上作为域名和<a href="https://baike.so.com/doc/4252723-4455111.html">IP地址</a>相互映射的一个<a href="https://baike.so.com/doc/6591740-6805519.html">分布式数据库</a>，能够使用户更方便的访问<a href="https://baike.so.com/doc/2011565-2128705.html">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a href="https://baike.so.com/doc/5331327-5566564.html">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析(或主机名解析)。DNS协议运行在<a href="https://baike.so.com/doc/5418284-5656447.html">UDP</a>协议之上，使用端口号53。通常 Internet 主机域名的一般结构为:主机名.三级域名.二级域名.顶级域名。</td>
</tr>
</tbody></table>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>VNC</td>
<td>Virtual Network Console</td>
<td>虚拟网络控制台</td>
<td></td>
</tr>
<tr>
<td>ELK</td>
<td>Elasticsearch+Logstash+Kibana</td>
<td>三个软件的缩写</td>
<td>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</td>
</tr>
</tbody></table>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>Transmission Control Protocol</td>
<td>传输控制协议</td>
<td>传输层协议，有连接，可靠，三次握手建立连接，四次挥手断开连接</td>
</tr>
<tr>
<td>UDP</td>
<td>User Datagram Protocol</td>
<td>用户数据报协议</td>
<td>传输层协议，无连接，不可靠</td>
</tr>
<tr>
<td>http</td>
<td>Hyper Text Transport Protocol</td>
<td>超文本传输协议</td>
<td></td>
</tr>
<tr>
<td>https</td>
<td></td>
<td>http+ssl</td>
<td></td>
</tr>
<tr>
<td>POP3</td>
<td>Post Office Protocol 3</td>
<td>邮局协议的第3个版本</td>
<td>规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。</td>
</tr>
<tr>
<td>SMTP</td>
<td>Simple Mail Transfer Protocol</td>
<td>简单邮件传输协议</td>
<td>控制邮件的中转方式，属于TCP/IP协议</td>
</tr>
<tr>
<td>IMAP</td>
<td>Internet Mail Access Protocol</td>
<td>交互式邮件存取协议</td>
<td>邮件访问标准协议之一，与POP的不同：开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。</td>
</tr>
<tr>
<td>RTP</td>
<td>Real-time Transport Protocol</td>
<td>实时传输协议</td>
<td>RTP数据协议</td>
</tr>
<tr>
<td>RTCP</td>
<td>Real-time Transport Control Protocol</td>
<td>实时传输控制协议</td>
<td>RTP控制协议，控制RTP传输</td>
</tr>
<tr>
<td>RTSP</td>
<td>Real Time Streaming Protocol，</td>
<td>实时流协议</td>
<td>可以发送暂停，播放，停止等请求</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>IETF：国际互联网工程任务组（The Internet Engineering Task Force，简称 IETF）是一个公开性质的大型民间国际团体，汇集了与互联网架构和互联网顺利运作相关的网络设计者、运营者、投资人和研究人员，并欢迎所有对此行业感兴趣的人士参与。</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ECS</td>
<td>Elastic Compute Service</td>
<td>云服务器</td>
<td></td>
</tr>
<tr>
<td>MUA</td>
<td></td>
<td>邮件用户代理</td>
<td>它是一种应用程序，或者电子邮件客户端程序。通过 MUA 程序，我们可以发送邮件，也可以把接收到的邮件保存在客户端的邮箱中。这两种操作属于不同的两个进程。MUA通过POP（邮局协议）和STMP（简单邮件传输协议）从电子邮件服务器发送或接收消息。</td>
</tr>
<tr>
<td>MTA</td>
<td></td>
<td>邮件传送代理</td>
<td>是电子邮件服务器的两个独立进程，MUA向电子邮件服务器发送一个电子邮件，MTA会判断这个邮件的地址是否在本服务器上。如果是则通过MDA发送到目的邮箱MUA.如果不是MTA就把这个邮件传送到包含目的邮箱列表的电子邮件服务器。</td>
</tr>
<tr>
<td>MDA</td>
<td></td>
<td>邮件分发代理</td>
<td></td>
</tr>
<tr>
<td>dsl</td>
<td>Domain Specified Language</td>
<td>领域特定语言</td>
<td></td>
</tr>
<tr>
<td>Stub</td>
<td></td>
<td>桩</td>
<td>在某个地方插入一个Stub，用于占位，Stub中一般没有实际内容，运行时会替换成真正的对象。如ViewStub</td>
</tr>
<tr>
<td>Hook</td>
<td></td>
<td>钩子</td>
<td>对某个方法、流程进行拦截、处理。如Git Hook、生命周期Hook等</td>
</tr>
<tr>
<td>Fake</td>
<td></td>
<td>伪造</td>
<td>开发或测试的时候模拟数据源、模拟行为</td>
</tr>
<tr>
<td>Mock</td>
<td></td>
<td>模拟</td>
<td>单元测试模拟数据，如方法返回值、变量等</td>
</tr>
<tr>
<td>Foo</td>
<td></td>
<td></td>
<td>无实际意义，不知道给函数或变量起什么名字的时候可以叫foo。也被解释做Fuck Oriented Object、Fu的变体（fuck-up）</td>
</tr>
<tr>
<td>DRY</td>
<td>Don’t Repeat Yourself</td>
<td>干原则</td>
<td>指在程序设计以及计算中避免重复代码，将公共部分提取、抽象。</td>
</tr>
<tr>
<td>PayLoad</td>
<td></td>
<td>有效载荷、负载</td>
<td>对接收者有用的数据，接口返回的有用字段，信头和元数据等称为开销数据。<br>例如委托卡车运东西，货物的重量，车子重量，司机重量都属于载重，对于客户来说，只关心货物重量，因此货物重量是有效载重。</td>
</tr>
</tbody></table>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><h2 id="岗位"><a href="#岗位" class="headerlink" title="岗位"></a>岗位</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>Operator</td>
<td>运维、管理员</td>
<td>维护公司的服务器能够正常提供服务，细分的话包括系统部分，网络部分，应用程序部分，数据库部分等。现在市面上主要的OP有三种：网络游戏运维，网站运维，大型项目测试和生产环境运维。</td>
</tr>
<tr>
<td>PM</td>
<td>Product Manager</td>
<td>产品经理</td>
<td>负责市场调查并根据用户的需求，确定开发何种产品，选择何种技术、商业模式等，举凡产品从创意到上市，所有相关的研发、调研、生产、编预算、广告、促销活动等等，都由产品经理掌控</td>
</tr>
<tr>
<td>PJM</td>
<td>Project Manager</td>
<td>项目经理</td>
<td>对项目实行质量、安全、进度、成本管理的责任保证体系和全面提高项目管理水平设立的重要管理岗位。项目经理是为项目的成功策划和执行负总责的人。</td>
</tr>
<tr>
<td>RD</td>
<td>Research and Development Engineer</td>
<td>研发工程师</td>
<td></td>
</tr>
<tr>
<td>FE</td>
<td>Front-End Engineer、Front-End Development</td>
<td>前端工程师，前端开发</td>
<td></td>
</tr>
<tr>
<td>QA</td>
<td>Quality Assurance</td>
<td>质量保证</td>
<td>细分包括PQA（产品）、SQA（供应商 or 软件）、DQA（开发 or 设计）、TQA（全面 or 测试）。有时也指测试</td>
</tr>
<tr>
<td>QC</td>
<td>Quality Control</td>
<td>质量控制</td>
<td></td>
</tr>
<tr>
<td>QE</td>
<td>Quality Engineer</td>
<td>质量工程师</td>
<td></td>
</tr>
<tr>
<td>UED</td>
<td>User Experience Design</td>
<td>用户体验设计</td>
<td></td>
</tr>
<tr>
<td>UI设计</td>
<td>User Interface Design</td>
<td>用户界面设计</td>
<td>对软件的人机交互、操作逻辑、界面美观的整体设计</td>
</tr>
<tr>
<td>KA</td>
<td>Key Account</td>
<td>重要客户</td>
<td></td>
</tr>
<tr>
<td>OEM</td>
<td>Original Equipment Manufacturer</td>
<td>原始设备制造商</td>
<td>OEM生产：定点生产（代工），即委托他人生产</td>
</tr>
<tr>
<td>ODM</td>
<td>Original Design Manufacturer</td>
<td>原始设计商</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>KBI</td>
<td>Key Behavior Index</td>
<td>关键行为指标</td>
<td>考察各部门及各级员工在一定时间、一定空间和一定职责范围内关键工作行为履行状况的量化指标，是对各部门和各级员工工作行为管理的集中体现。</td>
</tr>
<tr>
<td>KPI</td>
<td>Key Performance Indicators</td>
<td>关键绩效指标</td>
<td>又称主要绩效指标、重要绩效指标、绩效评核指标等，是指衡量一个管理工作成效最重要的指标，是一项数据化管理的工具，必须是客观、可衡量的绩效指标。这个名词往往用于财政、一般行政事务的衡量。是将公司、员工、事务在某时期表现量化与质化的一种指标。可协助将优化组织表现，并规划愿景。</td>
</tr>
<tr>
<td>OKR</td>
<td>Objectives and Key Result</td>
<td>目标与关键成果法</td>
<td>跟踪目标和完成情况的管理工具和方法</td>
</tr>
<tr>
<td>OAR</td>
<td>Objectives Action Review</td>
<td>目标行为回顾</td>
<td></td>
</tr>
<tr>
<td>gdpr</td>
<td>General Data Protection Regulation</td>
<td>通用数据保护条例</td>
<td></td>
</tr>
<tr>
<td>QCC</td>
<td>Quality Control Circle</td>
<td>品控圈</td>
<td></td>
</tr>
<tr>
<td>PDCA</td>
<td>Plan、Do、Check、Action</td>
<td></td>
<td>一种质量管理方法：选定课题-把握现状-制定目标-分析原因-制定对策-按对策实施-检查效果-巩固措施-总结改进</td>
</tr>
<tr>
<td>SOP</td>
<td>Standard Operation Procedure</td>
<td>标准作业程序</td>
<td></td>
</tr>
<tr>
<td>NRE</td>
<td>Non-Recurring Engineering</td>
<td>非循环工程</td>
<td>NRE费用即一次性工程费用</td>
</tr>
<tr>
<td>MP</td>
<td>Mass Product</td>
<td>量产阶段</td>
<td></td>
</tr>
<tr>
<td>WS</td>
<td>Working Sample</td>
<td>试验样品</td>
<td></td>
</tr>
<tr>
<td>ES</td>
<td>Engineering Sample</td>
<td>工程样品</td>
<td></td>
</tr>
<tr>
<td>CS</td>
<td>Commercial Sample</td>
<td>商业货样</td>
<td></td>
</tr>
</tbody></table>
<p>质量七工具</p>
<ul>
<li>控制图：目标-实际</li>
<li>柏拉图：缺陷数量-比例</li>
<li>流程图：发现流程缺陷</li>
<li>因果图(鱼骨图)：人机料法环测</li>
<li>检查表：</li>
<li>直方图：</li>
<li>散布图：用于表征两个变量之间是否有相关性</li>
</ul>
<h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>LGTM</td>
<td>Look good to me</td>
<td>我觉得可以</td>
<td>别人征求意见时觉得没问题，代码审核没有意见。可以回复LGTM</td>
</tr>
<tr>
<td>Loop More</td>
<td>Loop More</td>
<td></td>
<td>转发邮件添加更多联系人</td>
</tr>
<tr>
<td>CC</td>
<td>Carbon Copy</td>
<td>抄送</td>
<td></td>
</tr>
<tr>
<td>FYI</td>
<td>for your information</td>
<td>供你参考</td>
<td></td>
</tr>
<tr>
<td>TBD</td>
<td>to be determined</td>
<td>待定</td>
<td></td>
</tr>
<tr>
<td>OOO</td>
<td>out of office</td>
<td>不在办公室</td>
<td></td>
</tr>
<tr>
<td>IAM</td>
<td>in a meeting</td>
<td>在开会</td>
<td></td>
</tr>
<tr>
<td>WAH</td>
<td>work at home</td>
<td>在家办公</td>
<td></td>
</tr>
<tr>
<td>EOD</td>
<td>end of the day</td>
<td>下班前</td>
<td>催促别人下班前回复</td>
</tr>
<tr>
<td>COB</td>
<td>close of the business</td>
<td>下班前</td>
<td>催促别人下班前回复</td>
</tr>
<tr>
<td>ETA</td>
<td>Estimated Time of Arrival</td>
<td>预计到达时间</td>
<td></td>
</tr>
<tr>
<td>OTOH</td>
<td>On the Other Hand</td>
<td>另一方面</td>
<td></td>
</tr>
</tbody></table>
<p>Not sure if my last email：我不太确定您是否收到了我的上一封邮件，希望别人回复</p>
<p>To put it more simply…：简单来说…</p>
<p>Looking forward to …：期待你的回复，提前表达期待</p>
<p>Thanks in advance.：提前表达感谢</p>
<p>… I’d be most grateful.：提前表达感谢</p>
<p>邮件礼仪</p>
<ul>
<li>感谢开头感谢别人回复自己邮件，不用太客套，废话少说：Thanks for the quick reply/updated information.Thanks for getting back to me.</li>
<li>道歉邮件回的晚了，或者临时通知别人事情，要先道歉：Sorry for the late reply.Apologies for the late notice.</li>
<li>附件英语是attachment。但是如果你说please find the attachment会显得很没有水平。一般直接用动词attached或enclosed：Attached/Enclosed please find the report.I attached the report and please take a look.</li>
<li>收尾最后收尾一般都是询问别人意下如何。不要用please tell me…这种不地道的中式英语。可以这么说：Please let me know your thoughts.Looking forward to your insight.</li>
</ul>
<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>MRD</td>
<td>Market Requirements Document</td>
<td>市场需求文档</td>
<td>市场需求、功能需求 。如市场与竞争对手分析，通过哪些功能来实现商业目的，功能/非功能需求分哪几块，功能的优先级等等</td>
</tr>
<tr>
<td>PRD</td>
<td>Product Requirements Document</td>
<td>产品需求文档</td>
<td>需求分析</td>
</tr>
<tr>
<td>FSD</td>
<td>Functional Specifications Document</td>
<td>功能详细说明</td>
<td></td>
</tr>
<tr>
<td>PDR</td>
<td>Preliminary Design Review</td>
<td>初步设计评审</td>
<td></td>
</tr>
<tr>
<td>ToS</td>
<td>Terms of Service</td>
<td>服务条款</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>IaaS</td>
<td>Infrastructure as a Service</td>
<td>基础设施及服务</td>
<td>如阿里云。PaaS、SaaS、BaaS都是基于IaaS</td>
</tr>
<tr>
<td>PaaS</td>
<td>Platform as a Service</td>
<td>平台即服务</td>
<td>搭建平台，集成应用产品，整合起来提供服务，以SaaS模式提交给客户。属于SaaS的一种应用。简化应用部署流程</td>
</tr>
<tr>
<td>SaaS</td>
<td>Software as a Service</td>
<td>软件即服务</td>
<td>通过网络提供程序应用类服务</td>
</tr>
<tr>
<td>Baas</td>
<td>Backend as a Service</td>
<td>后端即服务</td>
<td>整合并提供特定领域的云后端服务，包括数据存储、推送、社交媒体整合等，用于快速开发移动应用，提供API或SDK。如聚合数据。简化应用开发流程、</td>
</tr>
</tbody></table>
<h2 id="运营"><a href="#运营" class="headerlink" title="运营"></a>运营</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>CPA</td>
<td>Cost To Action</td>
<td>根据用户行为付费的计费方式（如打开一次广告，注册一次账号，购买一次会员等）</td>
<td></td>
</tr>
<tr>
<td>CPS</td>
<td>Cost To Sales</td>
<td>以实际销售产品数量支付佣金的计费方式</td>
<td></td>
</tr>
<tr>
<td>ASO</td>
<td>App Store Optimization</td>
<td>应用商店优化</td>
<td></td>
</tr>
</tbody></table>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>OCS</td>
<td>Online Charge System</td>
<td>在线计费系统（订单管理系统）</td>
<td></td>
</tr>
<tr>
<td>CRM</td>
<td>Customer Relationship Management</td>
<td>客户关系管理</td>
<td></td>
</tr>
<tr>
<td>SQM</td>
<td>Sales Quota Management</td>
<td>销售目标管理系统</td>
<td></td>
</tr>
<tr>
<td>OA</td>
<td>Office Automation</td>
<td>办公自动化</td>
<td>综合系统。包括流程审批、协同工作、沟通工具、文档管理、论坛、计划管理、项目管理、任务管理、会议管理、系统集成、通讯录等应用</td>
</tr>
<tr>
<td>SSO</td>
<td></td>
<td>单点登录</td>
<td>在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。</td>
</tr>
<tr>
<td>BSS</td>
<td></td>
<td></td>
<td>基站子系统</td>
</tr>
</tbody></table>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>AOP</td>
<td>Aspect Oriented Programming</td>
<td>面向切面编程</td>
<td>针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</td>
</tr>
<tr>
<td>OOP</td>
<td>Object Oriented Programming</td>
<td>面向对象编程</td>
<td>针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。</td>
</tr>
<tr>
<td>OOD</td>
<td>Object-Oriented Design</td>
<td>面向对象设计</td>
<td></td>
</tr>
<tr>
<td>IoC</td>
<td>Inversion of Control</td>
<td>控制反转</td>
<td></td>
</tr>
<tr>
<td>DI</td>
<td>Dependency Injection</td>
<td>依赖注入</td>
<td></td>
</tr>
<tr>
<td>TDD</td>
<td>Test-Driven Development</td>
<td>测试驱动开发</td>
<td>先写单元测试，再实现功能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名词</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>编译型语言</td>
<td>使用编译器在程序运行之前编译，一次编写，处处编译，如C，C++</td>
</tr>
<tr>
<td>解释型语言</td>
<td>使用解释器在程序运行时解释，每次运行都要解释，java是解释型语言，将源码编译成.class（字节码文件），但是不是机器码，通过jvm对.class文件进行解释再执行</td>
</tr>
<tr>
<td>机器语言</td>
<td>机器可以执行的语言。高级语言都需要翻译成机器语言才可以被机器识别</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>一方库/包</td>
<td>本项目或者本工程中的类和方法、接口等</td>
</tr>
<tr>
<td>二方库/包</td>
<td>公司内部的依赖库，公司内部其他项目发布的jar包，如公司项目平台的核心依赖包</td>
</tr>
<tr>
<td>三方库/包</td>
<td>外部的开源库或开源项目贡献的jar， 比如apache、google、Ali等发布的依赖</td>
</tr>
<tr>
<td>A端</td>
<td>指开发、管理方</td>
</tr>
<tr>
<td>B端</td>
<td>Business： 企业用户商家</td>
</tr>
<tr>
<td>C端</td>
<td>Consumer： 个人用户、消费者</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RCT</td>
<td>React</td>
</tr>
<tr>
<td>i18n</td>
<td>（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。在资讯领域，国际化(i18n)指让产品（出版物，软件，硬件等）无需做大的改变就能够适应不同的语言和地区的需要。对程序来说，在不修改内部代码的情况下，能根据不同语言及地区显示相应的界面。 在全球化的时代，国际化尤为重要，因为产品的潜在用户可能来自世界的各个角落。通常与i18n相关的还有L10n（“本地化”的简称）。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>AOSP</td>
<td>Android Open-Source Project</td>
<td>Android 开放源代码项目</td>
<td></td>
</tr>
<tr>
<td>adt</td>
<td>Android Developer Tools</td>
<td>安卓开发者工具</td>
<td>为Eclipse IDE开发的插件，使用了sdk工具，用来开发Andorid应用</td>
</tr>
<tr>
<td>aapt</td>
<td>Android Asset Packaging Tool</td>
<td>安卓资源打包工具</td>
<td>将Android资源文件（res目录下）打包成R.java类(资源索引表)，以及.arsc资源文件（压缩资源文件）</td>
</tr>
<tr>
<td>apt</td>
<td>Annotation Processing Tool</td>
<td>注解处理器</td>
<td>在编译时扫描和处理注解</td>
</tr>
<tr>
<td>SDK</td>
<td>Software Development Kit</td>
<td>软件开发工具包</td>
<td>具备一定功能的应用软件的开发工具的集合。SDK包含了API的定义，API定义了对外的接口和规范，SDK还包含功能的具体实现和一些辅助功能。</td>
</tr>
<tr>
<td>API</td>
<td>Application Programming nterface</td>
<td>应用程序编程接口</td>
<td>SDK开发者提供给调用方使用的接口</td>
</tr>
<tr>
<td>SPI</td>
<td>Service Provider Interface</td>
<td>服务发现接口</td>
<td>调用方提供给外部实现的接口，要求实现方按照调用方的规范进行实现</td>
</tr>
<tr>
<td>FFI</td>
<td>Foregin Function Interface</td>
<td>语言交互接口，外部函数接口</td>
<td>用于两种不同的语言之间互相通信调用。如Java中的JNI</td>
</tr>
<tr>
<td>JNI</td>
<td>Java Native Interface</td>
<td>Java本地接口</td>
<td>用于Java与C/C++通信的接口</td>
</tr>
<tr>
<td>DLL</td>
<td>Dynamic Link Library</td>
<td>动态链接库</td>
<td>.dll文件不能直接执行，他们通常由 .exe 在执行时装入，内含有一些资源以及可执行代码等。</td>
</tr>
<tr>
<td>ABI</td>
<td>Application Binary Interface</td>
<td>应用程序二进制接口</td>
<td>描述应用程序和操作系统之间的底层接口，约定目标文件格式、数据类型、如何进行系统调用等</td>
</tr>
<tr>
<td>EABI</td>
<td>Embedded ABI</td>
<td>嵌入式ABI</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>两种不同语言之间互相调用一般有两种方案：</p>
<ol>
<li>将函数做成一个独立的服务：跨进程通信（IPC）或通过网络协议通信（RPC、RESTful）</li>
<li>通过FFI调用，将其它语言的接口内嵌到本语言中，调用效率更高</li>
</ol>
</blockquote>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>DBA</td>
<td>Database Administrator</td>
<td>数据库管理员</td>
<td>负责管理和维护数据库服务器的人。数据库管理员负责全面管理和控制数据库系统</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言</td>
<td>由SELECT子句，FROM子句，WHERE子句组成的查询块：SELECT &lt;字段名表&gt;FROM &lt;表或视图名&gt;WHERE&lt;查询条件&gt;</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manage Language</td>
<td>数据操纵语言</td>
<td>插入：INSERT，更新：UPDATE，删除：DELETE</td>
</tr>
<tr>
<td>DDL</td>
<td>Data Define Language</td>
<td>数据定义语言</td>
<td>用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：CREATE TABLE/VIEW/INDEX/SYN/CLUSTER ，DDL操作是隐性提交的！不能rollback</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言</td>
<td>用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视，授权：GRANT。回滚：ROLLBACK。提交：COMMIT</td>
</tr>
<tr>
<td>CRUD</td>
<td>Create、Retrieve、Update、Delete</td>
<td>增删改查</td>
<td></td>
</tr>
</tbody></table>
<p>注释：<br>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p>
<p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p>
<p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>HTML</td>
<td>HyperText Markup Language</td>
<td>超文本标记语言</td>
<td></td>
</tr>
<tr>
<td>CSS</td>
<td>Cascading Style Sheets</td>
<td>层叠样式表</td>
<td></td>
</tr>
<tr>
<td>SPA</td>
<td>Single Page Application</td>
<td>单页Web应用</td>
<td></td>
</tr>
<tr>
<td>SSR</td>
<td>Server Side Render</td>
<td>服务端渲染</td>
<td></td>
</tr>
<tr>
<td>CSRF</td>
<td>Cross-site request forgery</td>
<td>跨站请求伪造</td>
<td>也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</td>
</tr>
</tbody></table>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>XML</td>
<td>eXtensible Markup Language</td>
<td>可扩展标记语言</td>
<td></td>
</tr>
<tr>
<td>XSL</td>
<td>eXtensible Stylesheet Language</td>
<td>可扩展样式表语言</td>
<td>可描述如何来显示 XML 文档，包括三部分：XSLT、XPath、XSL-FO</td>
</tr>
<tr>
<td>XSLT</td>
<td>XSL Transformations</td>
<td></td>
<td>用于转换 XML 文档的语言，XSLT 使用 XPath 在 XML 文档中查找信息。</td>
</tr>
<tr>
<td>XPath</td>
<td></td>
<td></td>
<td>通过元素和属性在 XML 文档中导航的语言</td>
</tr>
<tr>
<td>XSL-FO</td>
<td></td>
<td></td>
<td>用于格式化 XML 文档的语言</td>
</tr>
</tbody></table>
<h2 id="XML和HTML"><a href="#XML和HTML" class="headerlink" title="XML和HTML"></a>XML和HTML</h2><table>
<thead>
<tr>
<th>XML</th>
<th>HTML</th>
</tr>
</thead>
<tbody><tr>
<td>被设计为具有自我描述性</td>
<td></td>
</tr>
<tr>
<td>旨在传输信息：被设计用于结构化、传输和存储数据，其焦点是数据的内容</td>
<td>旨在显示信息：被设计用来显示数据，其焦点是数据的外观</td>
</tr>
<tr>
<td>标签没有被预定义。需要自定义标签</td>
<td>有预定义标签，如<code>&lt;a&gt;、&lt;div&gt;</code>等</td>
</tr>
</tbody></table>
<h1 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ASR</td>
<td>Automatic Speech Recognition</td>
<td>自动语音识别技术</td>
<td></td>
</tr>
<tr>
<td>NLU</td>
<td>Natural Language Understanding</td>
<td>自然语言理解</td>
<td></td>
</tr>
<tr>
<td>NLP</td>
<td>Natural Language Processing</td>
<td>自然语言处理</td>
<td></td>
</tr>
<tr>
<td>TTS</td>
<td>Text-To-Speech</td>
<td>语音转文字</td>
<td>语音合成</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="网络用语"><a href="#网络用语" class="headerlink" title="网络用语"></a>网络用语</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RTFM</td>
<td>Read The Fucking Manual</td>
<td>滚回去看说明手册</td>
<td></td>
</tr>
<tr>
<td>STFW</td>
<td>Search The Fucking Web</td>
<td>滚回去百度</td>
<td></td>
</tr>
<tr>
<td>ASL</td>
<td>Age、Sex、Location</td>
<td></td>
<td>相亲用</td>
</tr>
<tr>
<td>SUX</td>
<td>suck的第三人称单数</td>
<td>滥，差劲</td>
<td>that sux=sb</td>
</tr>
<tr>
<td>LMAO</td>
<td>laughing my ass off</td>
<td>笑死宝宝</td>
<td></td>
</tr>
<tr>
<td>FTW</td>
<td>for the win</td>
<td>棒棒哒</td>
<td></td>
</tr>
<tr>
<td>LOL</td>
<td>laughing out loud</td>
<td>大声笑</td>
<td></td>
</tr>
<tr>
<td>YOLO</td>
<td>you only live once</td>
<td>人生只有一次</td>
<td></td>
</tr>
<tr>
<td>FML</td>
<td>fuck my life</td>
<td>悲催的人生</td>
<td></td>
</tr>
<tr>
<td>TL;DR</td>
<td>too long; didn ’ t read</td>
<td>太长不看</td>
<td></td>
</tr>
<tr>
<td>TGIF</td>
<td>thank god it’s Friday</td>
<td>天啊，星期五了</td>
<td></td>
</tr>
<tr>
<td>LB</td>
<td>Like Back</td>
<td>互粉啊！互粉！</td>
<td></td>
</tr>
<tr>
<td>HMU</td>
<td>Hit Me Up</td>
<td>妹妹约么</td>
<td></td>
</tr>
<tr>
<td>BRB</td>
<td>Be right back</td>
<td>我一定会回来的。</td>
<td>同义：BBL=Be back late；BFN=bye bye for now</td>
</tr>
<tr>
<td>NSFL</td>
<td>Not Safe For Life</td>
<td>慎入</td>
<td>比如单生狗，慎入</td>
</tr>
<tr>
<td>MTFBWY</td>
<td>May The Force Be With You</td>
<td>愿原力与你同在</td>
<td>《星球大战》中的经典台词，有 Good luck 的意思。</td>
</tr>
<tr>
<td>TIL</td>
<td>Today I learnt</td>
<td>今天我学到了</td>
<td></td>
</tr>
</tbody></table>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RSS</td>
<td><a href="https://baike.baidu.com/item/Really/16030355">Really</a> Simple Syndication</td>
<td>简易信息聚合（聚合内容）</td>
<td>RSS是一种用于共享新闻和其他Web内容的数据交换规范，就是将订户订阅的内容传送给他们的通讯协同格式(Protocol)。是站点用来和其他站点之间共享内容的一种简易方式（也叫聚合内容），在Blog开始盛行的时候得到广泛的应用。 RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含了全文或是节录的文字，再加上发用者所订阅之网摘布数据和授权的元数据。网络摘要能够使发行者自动地发布他们的数据，同时也使读者能更够定期更新他们喜欢的网站或是聚合不同网站的网摘。<br>RSS摘要可以借由RSS阅读器、feed reader或是aggregator等网页或以桌面为架构的软件来阅读。标准的XML档式可允许信息在一次发布后通过不同的程序阅览。用户借由将网摘输入RSS阅读器或是用鼠标点取浏览器上指向订阅程序的RSS小图标之URI（非通常称为URL）来订阅网摘。RSS阅读器定期检阅是否有更新，然后下载给监看用户界面。<br>RSS可以是以下三个解释的其中一个：<br>Really Simple Syndication（真正简单的整合） RDF (Resource Deion Framework) Site Summary Rich Site Summary（丰富站点摘要）</td>
</tr>
<tr>
<td>Feed</td>
<td></td>
<td></td>
<td>Feed就是为满足以某种形式持续得到自己更新的需求而提供的格式标准的信息出口。就是信源。信息发布网站将网站全部或者部分信息整合到一个 RSS 文件中，这个文件就被称之为 feed 。信源中包含的数据都是标准的 XML 格式，不但能直接被其他站点调用，也能在其他的终端和服务中使用。<br>RSS订阅的过程中会用到的“Feed”，便是表示这是用来接收该信息来源更新的接口</td>
</tr>
</tbody></table>
<h2 id="建模-游戏"><a href="#建模-游戏" class="headerlink" title="建模/游戏"></a>建模/游戏</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
</tr>
</thead>
<tbody><tr>
<td>PBR</td>
<td>Physicallly-Based Rendering</td>
<td>基于物理的渲染方式</td>
</tr>
<tr>
<td>PBS</td>
<td>Physicallly-Based Shader</td>
<td>基于物理的着色方式</td>
</tr>
</tbody></table>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>翻译</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SD卡</td>
<td>Secure Digital Memory Card</td>
<td>安全数字卡</td>
<td></td>
</tr>
<tr>
<td>TF卡</td>
<td>T-Flash，MicroSD</td>
<td>微型SD卡</td>
<td>TF卡比SD卡小，TF卡插入适配器中可以转换为SD卡</td>
</tr>
<tr>
<td>ROM</td>
<td>Read-Only Memory</td>
<td>只读存储器</td>
<td>一般存储BIOS等不需要被修改的基本程序</td>
</tr>
<tr>
<td>RAM</td>
<td>Random Access Memory</td>
<td>随机存取存储器</td>
<td>也叫主存、运行内存，用于临时存储程序、数据和中间结果，断电之后丢失。如PC上的内存条</td>
</tr>
<tr>
<td>Flash</td>
<td>Flash Memory</td>
<td>闪存</td>
<td>非易失性，断电之后还能保存数据。并且可以直接运行程序，不需要读到RAM中。一般用于嵌入式产品，如U盘、数码相机、MP3等</td>
</tr>
<tr>
<td>eMMC</td>
<td>Embedded Multi Media Card</td>
<td></td>
<td>集成了一个控制器，即Flash+主控IC，主要针对手机或平板电脑等内嵌式存储器。提供标准接口管理Flash，使得手机厂商能够专注开发其他部分</td>
</tr>
<tr>
<td>Cache</td>
<td></td>
<td>高速缓冲存储器</td>
<td>位于CPU和内存之间，存储CPU临时数据，比RAM速度更快</td>
</tr>
<tr>
<td>SSD</td>
<td>Solid State Disk</td>
<td>固态硬盘</td>
<td>读写速度比SATA块，读写次数少于硬盘，价格更高</td>
</tr>
<tr>
<td>SATA</td>
<td>Serial Advanced Technology Attachment</td>
<td>机械硬盘</td>
<td></td>
</tr>
<tr>
<td>SRAM</td>
<td>Static RAM</td>
<td>静态随机存储器</td>
<td></td>
</tr>
<tr>
<td>DRAM</td>
<td>Dynamic RAM</td>
<td>动态随机存储器</td>
<td></td>
</tr>
<tr>
<td>SDRAM</td>
<td>Synchronous Dynamic RAM</td>
<td>同步动态随机存储器</td>
<td></td>
</tr>
<tr>
<td>SDR SDRAM</td>
<td>Single Data Rate SDRAM</td>
<td>单信道同步动态随机存储器</td>
<td>数据预取宽度为1bit</td>
</tr>
<tr>
<td>DDR1 SDRAM</td>
<td>Double Data Rate SDRAM</td>
<td>双信道同步动态随机存储器</td>
<td>数据预取宽度为2bit，即每次存取2bit为1组的数据</td>
</tr>
<tr>
<td>DDR2 SDRAM</td>
<td>Double Data Rate Two SDRAM</td>
<td>双信道两次同步动态随机存储器</td>
<td>数据预取宽度为4bit</td>
</tr>
<tr>
<td>DDR3 SDRAM</td>
<td>Double Data Rate Three SDRAM</td>
<td>双信道三次同步动态随机存储器</td>
<td>数据预取宽度为8bit</td>
</tr>
<tr>
<td>PROM</td>
<td>Programmable ROM</td>
<td>可编程只读存储器</td>
<td></td>
</tr>
<tr>
<td>EPROM</td>
<td>Erasable Programmable ROM</td>
<td>可擦除可编程只读存储器</td>
<td></td>
</tr>
<tr>
<td>OTPROM</td>
<td>One Time Programmable ROM</td>
<td>一次编程只读存储器</td>
<td></td>
</tr>
<tr>
<td>EEPROM</td>
<td>Electrically Erasable Programmable ROM</td>
<td>电子式可擦除可编程只读存储器</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题配置</title>
    <url>/2018/10/20/blog-2018-10-20-NexTConfig/</url>
    <content><![CDATA[<h1 id="博客效果"><a href="#博客效果" class="headerlink" title="博客效果"></a>博客效果</h1><p><img src="/2018/10/20/blog-2018-10-20-NexTConfig/%E5%8D%9A%E5%AE%A2%E6%95%88%E6%9E%9C.png" alt="博客效果"></p>
<h1 id="NexT配置"><a href="#NexT配置" class="headerlink" title="NexT配置"></a>NexT配置</h1><h2 id="添加Readme-md文件"><a href="#添加Readme-md文件" class="headerlink" title="添加Readme.md文件"></a>添加Readme.md文件</h2><p>在Hexo目录下的source根目录下添加一个README.md文件，修改站点配置文件<code>_config.yml</code>，将skip_render参数的值设置为<code>skip_render: README.md</code>，跳过渲染该文件</p>
<h2 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h2><p>修改主题配置文件 themes/next/_config.yml，不同动态背景，值为true应用：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Only fit scheme Pisces</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="修改文章底部的带-号的标签"><a href="#修改文章底部的带-号的标签" class="headerlink" title="修改文章底部的带#号的标签"></a>修改文章底部的带#号的标签</h2><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 rel=”tag”&gt;#，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h2 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h2><p>在<a href="http://www.easyicon.net/">EasyIcon</a>中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span> </span><br><span class="line">	<span class="attr">small:</span> <span class="string">/images/favicon.ico</span></span><br><span class="line">	<span class="attr">medion:</span> <span class="string">/images/favicon.ico</span></span><br><span class="line">	<span class="comment">#apple_touch_icon: /images/apple-touch-icon-next.png</span></span><br><span class="line">	<span class="comment">#safari_pinned_tab: /images/logo.svg</span></span><br><span class="line">  	<span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  	<span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。</p>
<p>安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改站点配置文件：</p>
<blockquote>
<p>search:<br>path: search.xml<br>field: post<br>format: html<br>limit: 10000</p>
</blockquote>
<p>修改NexT主题配置文件：</p>
<blockquote>
<p>local_search:<br>​    enable: true</p>
</blockquote>
<p>【踩坑】：启用搜索功能之后，使用<code>hexo serve</code>运行正常，点击按钮弹出搜索框，发布到GitPage，搜索框直接显示到搜索按钮旁边了。</p>
<blockquote>
<p>打开浏览器开发者工具，找到html元素，查看本地和GitPage页面差异，发现两者<code>main.css</code>样式不同，GitPage上搜素框css样式丢失</p>
<p>解决：<code>hexo clean</code>清除之前的编译结果，<code>hexo g -d</code>重新部署</p>
</blockquote>
<h2 id="去掉NexT自带的文章目录序号"><a href="#去掉NexT自带的文章目录序号" class="headerlink" title="去掉NexT自带的文章目录序号"></a>去掉NexT自带的文章目录序号</h2><p>NexT会为文章自动加上目录序号，如果自己的文章里面已经加了序号，不需要自动加的话，则修改主题配置文件</p>
<p><img src="/2018/10/20/blog-2018-10-20-NexTConfig/%E9%85%8D%E7%BD%AE%E5%8E%BB%E6%8E%89%E7%9B%AE%E5%BD%95%E5%BA%8F%E5%8F%B7.png" alt="去掉文章目录序号"></p>
<h2 id="生成分类、标签和关于页面"><a href="#生成分类、标签和关于页面" class="headerlink" title="生成分类、标签和关于页面"></a>生成分类、标签和关于页面</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p><code>hexo new page tags</code>：在<code>站点/source/</code>目录下会生成新的文件夹tags，在该文件夹下会有一个index.md文件，头信息修改如下，不需要加正文内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2018-04-04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>同理，将tags换成categories即可</p>
<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>同理，自行编辑文章内容，不需要加type</p>
<p>注：主题配置文件的menu需要将tags和categories的注释去掉</p>
<h2 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h2><p>可以修改next主题下的layout和source中的布局和css样式，定制主题</p>
<h2 id="添加站点地图sitemap"><a href="#添加站点地图sitemap" class="headerlink" title="添加站点地图sitemap"></a>添加站点地图sitemap</h2><p>为了让博文被google或百度检索，需要使用hexo的sitemap功能。</p>
<ol>
<li>安装插件，自动生成站点地图：<code>sitemap.xml、baidusitemap.xml</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>hexo g -d</code>生成并发布博客之后，可以通过<code>博客地址/sitemap.xml</code>、<code>博客地址/baidusitemap.xml</code>访问站点地图文件</li>
</ol>
<h3 id="Google检索"><a href="#Google检索" class="headerlink" title="Google检索"></a>Google检索</h3><ol>
<li>登录<a href="https://search.google.com/search-console/about">Google Search Console</a></li>
<li>点击立即使用，输入域名或<code>xxx.github.io</code>验证资源。</li>
<li>选择HTML标记验证，如下图</li>
</ol>
<img src="/2018/10/20/blog-2018-10-20-NexTConfig/Google Search验证资源.jpg" style="zoom:33%;">

<ol start="4">
<li>如果使用NexT主题，可以直接修改<strong>主题配置文件</strong>，<code>google_site_verification: xxx</code>，填入<code>content</code>中的内容。（原理是自动帮我们在生成的静态html文件head中添加<code>&lt;meta&gt;</code>）</li>
<li><code>hexo g -d</code>重新生成并发布博客</li>
<li>回到Google Search Console，点击验证</li>
<li>添加站点地图文件<code>sitemap.xml</code>，如下图。过一段时间会在<strong>概述</strong>中显示被索引的情况</li>
</ol>
<img src="/2018/10/20/blog-2018-10-20-NexTConfig/添加Google站点地图.png" style="zoom: 67%;">

<h3 id="百度检索"><a href="#百度检索" class="headerlink" title="百度检索"></a>百度检索</h3><ol>
<li>登录【<a href="https://ziyuan.baidu.com/site/index#/">百度资源管理平台-用户中心-站点管理</a>】</li>
<li>点击添加网站，输入博客地址</li>
<li>选择HTMl标签验证</li>
<li>如果使用NexT主题，可以直接修改<strong>主题配置文件</strong>，<code>baidu_site_verification: xxx</code>，填入<code>content</code>中的内容。</li>
<li><code>hexo g -d</code>重新生成并发布博客</li>
<li>回到百度资源页面完成验证</li>
<li>添加站点地图文件<code>baidusitemap.xml</code>，如下图。过一段时间可以查看索引数据</li>
</ol>
<img src="/2018/10/20/blog-2018-10-20-NexTConfig/添加百度站点地图.png" style="zoom: 67%;">

<h2 id="添加博客字数统计"><a href="#添加博客字数统计" class="headerlink" title="添加博客字数统计"></a>添加博客字数统计</h2><ol>
<li>安装插件：<code>npm i hexo-symbols-count-time --save</code></li>
<li>修改站点配置文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment"># 文章字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>   <span class="comment"># 站点总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>  <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>   <span class="comment"># 排除代码字数统计</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>   <span class="comment"># 平均单词长度</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>   <span class="comment"># 平均每分钟阅读单词数</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span> <span class="comment"># 时长单位</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改主题配置文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">false</span>   <span class="comment"># 是否另起一行</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>【踩坑】：配置之后发现文章字数始终为空，打印<code>post.length</code>为<code>undefined</code>。最终发现因为先安装了<code>hexo-wordcount</code>，卸载之后需要执行<code>hexo clean</code>清除缓存</p>
<h2 id="添加站点访问统计"><a href="#添加站点访问统计" class="headerlink" title="添加站点访问统计"></a>添加站点访问统计</h2><p>修改主题配置文件，页脚会出现访问量。<strong>会和<code>Live2d</code>冲突。可以使用valine的visitor进行字数统计，见下文添加评论系统</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><p>使用Valine（基于LeanCloud云服务）作为评论系统。（也可以用Disqus、Gitalk、<a href="https://livere.com/">Livere</a>、<a href="http://changyan.kuaizhan.com/">畅言</a>等）</p>
<blockquote>
<p>看别人用Gitalk也挺不错的，还可以将评论发到issue，及时收到通知。缺点是需要登录GitHub账号，可能会劝退一拨人</p>
</blockquote>
<p>由于<code>busuanzi</code>统计站点访问量会和<code>Live2d</code>插件冲突，因此使用Valine visitor进行访问统计。（会和<code>leancloud_visitors</code>冲突，打开一个就行）</p>
<p>步骤如下：</p>
<ol>
<li>注册<a href="https://www.leancloud.cn/">LeanCloud</a>账号，实名认证</li>
<li>进入控制台，创建应用</li>
<li>在【设置-应用凭证】中找到appId和appKey</li>
<li>【设置-安全中心】可以配置Web安全域名，避免别人拿到appId和appKey之后使用</li>
<li>在LeanCloud控制台【数据存储-结构化数据】中创建Class，起名为Counter，如下图。（Comment为评论记录，Counter为访问记录）</li>
</ol>
<p><img src="/2018/10/20/blog-2018-10-20-NexTConfig/LeanCloud%E5%88%9B%E5%BB%BAClass.png"></p>
<ol start="7">
<li>修改主题配置文件，如下</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">&quot;第3步中的appId&quot;</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">&quot;第3步中的appKey&quot;</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">&quot;欢迎交流讨论&quot;</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 文章阅读统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 文章评论</span></span><br></pre></td></tr></table></figure>



<h2 id="配置Live2d卡通人物"><a href="#配置Live2d卡通人物" class="headerlink" title="配置Live2d卡通人物"></a>配置Live2d卡通人物</h2><ol>
<li>安装<code>npm install --save hexo-helper-live2d</code>，具体配置见官网说明<a href="https://github.com/EYHN/hexo-helper-live2d">hexo-helper-live2d</a></li>
<li>安装动画model，如<code>npm install live2d-widget-model-koharu</code>，可以到<a href="https://github.com/xiazeyu/live2d-widget-models">live2d-widget-models</a>挑选自己喜欢的model，效果见<a href="https://huaji8.top/post/live2d-plugin-2.0/">hexo live2d插件 2.0 !</a></li>
<li>将下述配置拷贝到根目录<code>_config.yml</code>中，不能拷到主题配置中，否则不生效。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-koharu</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">250</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">500</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure>

<h2 id="右上角配置Fork-me-on-GitHub入口"><a href="#右上角配置Fork-me-on-GitHub入口" class="headerlink" title="右上角配置Fork me on GitHub入口"></a>右上角配置Fork me on GitHub入口</h2><ol>
<li>到<a href="http://tholman.com/github-corners/">GitHub Corners</a>或者<a href="https://github.blog/2008-12-19-github-ribbons/">GitHub Ribbons</a>选择喜欢的图标，copy相应的代码</li>
<li>将代码粘贴到<code>themes/next/layout/_layout.swig</code>文件中(放在<code>body</code>的内即可)</li>
<li>修改<code>href</code>链接为想要跳转的地址，如GitHub主页</li>
</ol>
<h2 id="添加每日一言-今日诗词"><a href="#添加每日一言-今日诗词" class="headerlink" title="添加每日一言/今日诗词"></a>添加每日一言/今日诗词</h2><ol>
<li>在<strong>layout或者md文档</strong>中添加下面代码。我是将今日诗词添加到了<strong>关于页面</strong>，将每日一言添加到了<code>/themes/next/layout/_partials/sidebar/site_overview.swig</code>中</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--今日诗词--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-border poem-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-border poem-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-title&quot;</span>&gt;</span>念两句诗<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;poem&quot;</span>&gt;</span>挑选中...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>&gt;</span></span><br><span class="line"><span class="javascript">    jinrishici.load(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">      poem.innerHTML = result.data.content</span><br><span class="line"><span class="javascript">      info.innerHTML = <span class="string">&#x27;【&#x27;</span> + result.data.origin.dynasty + <span class="string">&#x27;】&#x27;</span> + result.data.origin.author + <span class="string">&#x27;《&#x27;</span> + result.data.origin.title + <span class="string">&#x27;》&#x27;</span></span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--每日一言--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem-side&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hitokoto&quot;</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hitokotofrom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>&gt;</span></span><br><span class="line"><span class="javascript">  fetch(<span class="string">&#x27;https://v1.hitokoto.cn&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span></span><br><span class="line"><span class="javascript">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line">       	hitokoto.innerHTML = data.hitokoto</span><br><span class="line"><span class="javascript">    	<span class="keyword">if</span>(data.from_who != <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">      	  hitokotofrom.innerHTML =<span class="string">&#x27;——&#x27;</span> + data.from_who + <span class="string">&#x27; 《&#x27;</span> + data.from + <span class="string">&#x27;》&#x27;</span></span></span><br><span class="line"><span class="javascript">      	&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">	  hitokotofrom.innerHTML =<span class="string">&#x27;——《&#x27;</span> + data.from + <span class="string">&#x27;》&#x27;</span> </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    .catch(<span class="built_in">console</span>.error) </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>/themes/next/source/css</code>中添加下面的css样式，也可自行修改样式</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.poem-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">730px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#797979</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: none;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">80px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-wrap</span> <span class="selector-class">.poem-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Lato&#x27;</span>, <span class="string">&quot;PingFang SC&quot;</span>, <span class="string">&quot;Microsoft YaHei&quot;</span>, sans-serif;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">letter-spacing</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#797979</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-wrap</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#797979</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-wrap</span> <span class="selector-tag">p</span><span class="selector-id">#poem</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-wrap</span> <span class="selector-tag">p</span><span class="selector-id">#info</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-border</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">27%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#797979</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-right</span> &#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-left</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">685px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.poem-border</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">18%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.poem-wrap</span> &#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">        <span class="attribute">border-top</span>: <span class="number">2px</span> solid <span class="number">#797979</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.poem-wrap</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">6px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.poem-border</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-side</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">5%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-side</span> <span class="selector-tag">div</span><span class="selector-id">#hitokoto</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.poem-side</span> <span class="selector-tag">div</span><span class="selector-id">#hitokotofrom</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加文章置顶功能"><a href="#添加文章置顶功能" class="headerlink" title="添加文章置顶功能"></a>添加文章置顶功能</h2><ol>
<li>安装插件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在需要置顶的文章头部中添加<code>top: true</code></li>
<li>配置置顶图标：在<code>&lt;div class=&quot;post-meta&quot;&gt;</code>中添加下面代码</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-meta&quot;</span>&gt;</span></span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;far fa-thumb-tack&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#7D26CD&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">  <span class="comment">&lt;!--省略..--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>置顶图标无法显示？</p>
<blockquote>
<p>由于<code>next</code>主题使用的<code>fontawesome</code>图标只有<code>all.min.css</code>，不包含<code>fa-thumb-tack</code>（图钉）图标。需要手动下载<code>fontawesome</code>图标，替换<code>next/source/lib/font-awesome</code>下的文件夹。</p>
<p>这里就不引入了，换成<code>fa-fire</code>（火）或者<code>fa-bolt</code>（闪电）图标，能看懂就行</p>
</blockquote>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://www.mdslq.cn/archives/40609c5b.html#%E6%B7%BB%E5%8A%A0READMEmd%E6%96%87%E4%BB%B6">Hexo博客Next主题个性设置集锦</a></li>
<li><a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html">Hexo+NexT 主题配置备忘</a></li>
<li><a href="https://blog.csdn.net/qq_40265501/article/details/80030627">hexo博客添加搜索功能</a></li>
<li><a href="https://blog.csdn.net/qq_44036990/article/details/105088198">hexo(next)——每日一言、今日诗词</a></li>
<li><a href="https://blog.csdn.net/qq_42889280/article/details/103087433">Hexo博客+Next主题深度优化与定制</a></li>
<li><a href="https://eericzeng.github.io/2019/07/14/hexo%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9sitemap%E7%9A%84%E4%BD%BF%E7%94%A8/">hexo博客站点sitemap的使用</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo更换主题：NexT</title>
    <url>/2018/10/19/blog-2018-10-19-HexoTheme-NexT/</url>
    <content><![CDATA[<p>前面讲了如何使用<a href>Hexo和GitPage搭建博客</a>，开始本篇之前确保上篇的配置都已完成。如安装nodejs、Git环境、Hexo插件等。<br>再次说明一下：在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>将前者称为<strong>站点配置文件</strong>， 后者称为<strong>主题配置文件</strong>。</p>
<h2 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h2><p>创建 Hexo 主题非常容易，您只要在 <code>themes</code> 文件夹内，新增一个任意名称的文件夹，并修改 <code>_config.yml</code>内的 <code>theme</code> 设定，即可切换主题。</p>
<p>Hexo提供了很多种<a href="https://hexo.io/themes/">主题</a>，可挑选自己喜欢的。</p>
<p>主题文件说明：<br>（1）<code>_config.yml</code>：主题的配置文件。修改时会自动更新，无需重启服务器。<br>（2）languages：语言文件夹，不同语言文件<br>（3）layout：布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式。<br>（3）script：脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件<br>（4）source：资源文件夹，存放 CSS、JavaScript、images 文件等资源。</p>
<h2 id="NexT主题使用"><a href="#NexT主题使用" class="headerlink" title="NexT主题使用"></a>NexT主题使用</h2><p><a href="http://theme-next.iissnan.com/getting-started.html">官方文档</a></p>
<h3 id="下载NexT主题"><a href="#下载NexT主题" class="headerlink" title="下载NexT主题"></a>下载NexT主题</h3><p>cmd打开终端，进入站点根目录（配置了Git环境变量）。或者直接右键点击<code>Git Bash Here</code>打开Git终端。<br>输入以下命令克隆主题到根目录下的<code>themes/next</code>文件夹中。<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
<h3 id="启用NexT主题"><a href="#启用NexT主题" class="headerlink" title="启用NexT主题"></a>启用NexT主题</h3><p>打开站点配置文件， 找到 theme 字段，并将其值更改为 next。</p>
<h3 id="运行验证"><a href="#运行验证" class="headerlink" title="运行验证"></a>运行验证</h3><p>输入<code>hexo s</code>启动服务，浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> ，可以看到主题已经变更。<br>可以输入<code>hexo g -d</code>生成静态文件部署到仓库中。</p>
<p>生成静态文件之前可使用<code>hexo clean</code>命令清除缓存</p>
<h2 id="NexT主题配置文件说明"><a href="#NexT主题配置文件说明" class="headerlink" title="NexT主题配置文件说明"></a>NexT主题配置文件说明</h2><p>主题配置文件：<code>站点根目录/themes/next/_config.yml</code>中已经有具体的说明了，下面讲下常用的配置以及示例</p>
<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>NexT内置了三套主题，这里叫Scheme（用一送三很划算）：<br>修改主题配置文件的scheme字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Muse: 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span><br><span class="line">Mist: Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">Pisces: 双栏 Scheme，小家碧玉似的清新</span><br></pre></td></tr></table></figure>

<h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>修改主题配置文件的menu字段</p>
<p>格式为<code>菜单项名称（会匹配翻译）: 链接 || Font Awesome图标</code></p>
<p><strong>注：旧版本<code>链接 ||</code>中间有空格，升级Hexo之后跳转404，链接多了个<code>%20</code>，表示空格，需要删除</strong></p>
<p>示例配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/||</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">/schedule/||</span> <span class="string">calendar</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml||</span> <span class="string">sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/|| heartbeat</span></span><br></pre></td></tr></table></figure>
<p>菜单项的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。如简体中文配置文件：languages/zh-Hans.yml</p>
<p>修改翻译或者添加自定义的字段other：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  commonweal: 公益404</span><br><span class="line">  other: 其他</span><br></pre></td></tr></table></figure>

<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>修改avatar字段，设置头像链接地址，如：</p>
<table>
<thead>
<tr>
<th>完整的互联网URI</th>
<th>放置到 <code>source/images/</code>路径下</th>
</tr>
</thead>
<tbody><tr>
<td><code>avatar: http://example.com/avatar.png</code></td>
<td><code>avatar: /images/avatar.png</code></td>
</tr>
<tr>
<td>文章中引用图片也是如此</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Next升级"><a href="#Next升级" class="headerlink" title="Next升级"></a>Next升级</h2><p>hexo升级之后Next会出现一些错误，原来Next版本为5.1.4，需要升级为V7+。</p>
<p>本文配置基于V5，升级之后部分配置需要相应修改。</p>
<p><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">参考升级说明</a></p>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p>hexo g生成报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR Template render error: (e:\GitPageBlog\AkiyamaBlog\themes\next\layout\post.swig)</span><br><span class="line">Error: Unable to call `post[&quot;categories&quot;][&quot;toArray&quot;]`, which is undefined or falsey</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改<code>themes/next/layout/_macro/post.swig</code>文件，去掉<code>post.categories.toArray()</code>和<code>post.tags.toArray()</code>中的<code>toArray()</code></p>
</blockquote>
<p><strong>注：回来补充，不能去掉toArray()，否则文章的分类和标签无法显示……估计和个人的版本有关系</strong></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>和<a href="http://theme-next.iissnan.com/getting-started.html">NexT官方文档</a>。下篇介绍NexT的一些进阶配置。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo介绍</title>
    <url>/2018/10/18/blog-2018-10-18-HexoIntro/</url>
    <content><![CDATA[<h1 id="Hexo目录"><a href="#Hexo目录" class="headerlink" title="Hexo目录"></a>Hexo目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml 	&#x2F;&#x2F;站点配置文件</span><br><span class="line">├── package.json	&#x2F;&#x2F;npm配置</span><br><span class="line">├── scaffolds		&#x2F;&#x2F;模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span><br><span class="line">├── source			&#x2F;&#x2F;子文件夹相当于一个个页面(page)，每个页面对应一个布局文件，可以修改主题里的配置文件改变样式</span><br><span class="line">|   ├── _drafts		&#x2F;&#x2F;草稿页面：存放所有草稿</span><br><span class="line">|   ├── _posts		&#x2F;&#x2F;文章页面：存放所有文章，所有文章都是同一个布局</span><br><span class="line">|   ├── about		&#x2F;&#x2F;关于页面</span><br><span class="line">|   ├── categories	&#x2F;&#x2F;分类页面</span><br><span class="line">|   ├── tags		&#x2F;&#x2F;标签页面</span><br><span class="line">|   └──………………</span><br><span class="line">└── themes			&#x2F;&#x2F;主题</span><br></pre></td></tr></table></figure>



<h1 id="Hexo一些基本概念"><a href="#Hexo一些基本概念" class="headerlink" title="Hexo一些基本概念"></a>Hexo一些基本概念</h1><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>前页（扉页、版权页、目次等），位于文章最上方<code>---</code>分隔的区域，做一些变量声明和配置。也可以用json格式，使用<code>;;;</code>分隔</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>layout</code></td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td><code>title</code></td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td><code>date</code></td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td><code>updated</code></td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td><code>comments</code></td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>标签（不适用于分页），无顺序</td>
<td></td>
</tr>
<tr>
<td><code>categories</code></td>
<td>分类（不适用于分页），有顺序</td>
<td></td>
</tr>
<tr>
<td><code>permalink</code></td>
<td>覆盖文章网址</td>
<td></td>
</tr>
</tbody></table>
<h2 id="模板（Scaffold）"><a href="#模板（Scaffold）" class="headerlink" title="模板（Scaffold）"></a>模板（Scaffold）</h2><p>模板决定了网站内容的呈现方式，可以根据模板生成初始化文章</p>
<table>
<thead>
<tr>
<th>模板</th>
<th>用途</th>
<th>回调</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>首页</td>
<td>post</td>
</tr>
<tr>
<td>post</td>
<td>文章</td>
<td>index</td>
</tr>
<tr>
<td>page</td>
<td>分页</td>
<td>index</td>
</tr>
<tr>
<td>archive</td>
<td>归档</td>
<td>index</td>
</tr>
<tr>
<td>category</td>
<td>分类归档</td>
<td>archive</td>
</tr>
<tr>
<td>tag</td>
<td>标签归档</td>
<td>archive</td>
</tr>
</tbody></table>
<h2 id="局部模版（Partial）"><a href="#局部模版（Partial）" class="headerlink" title="局部模版（Partial）"></a>局部模版（Partial）</h2><p>可以在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利</p>
<h2 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h2><p>如果页面结构类似，例如两个模板都有页首（Header）和页脚（Footer），您可考虑通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>site</code></td>
<td><a href="https://hexo.io/zh-cn/docs/variables#%E7%BD%91%E7%AB%99%E5%8F%98%E9%87%8F">网站变量</a></td>
</tr>
<tr>
<td><code>page</code></td>
<td>针对该页面的内容以及 front-matter 所设定的变量。</td>
</tr>
<tr>
<td><code>config</code></td>
<td>网站配置</td>
</tr>
<tr>
<td><code>theme</code></td>
<td>主题配置。继承自网站配置。</td>
</tr>
<tr>
<td><code>_</code> (单下划线)</td>
<td><a href="http://lodash.com/">Lodash</a> 函数库</td>
</tr>
<tr>
<td><code>path</code></td>
<td>当前页面的路径（不含根路径）</td>
</tr>
<tr>
<td><code>url</code></td>
<td>当前页面的完整网址</td>
</tr>
<tr>
<td><code>env</code></td>
<td>环境变量</td>
</tr>
</tbody></table>
<h3 id="网站变量"><a href="#网站变量" class="headerlink" title="网站变量"></a>网站变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>site.posts</code></td>
<td>所有文章</td>
</tr>
<tr>
<td><code>site.pages</code></td>
<td>所有分页</td>
</tr>
<tr>
<td><code>site.categories</code></td>
<td>所有分类</td>
</tr>
<tr>
<td><code>site.tags</code></td>
<td>所有标签</td>
</tr>
</tbody></table>
<h3 id="页面变量"><a href="#页面变量" class="headerlink" title="页面变量"></a>页面变量</h3><h4 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.title</code></td>
<td>页面标题</td>
</tr>
<tr>
<td><code>page.date</code></td>
<td>页面建立日期（<a href="http://momentjs.com/">Moment.js</a> 对象）</td>
</tr>
<tr>
<td><code>page.updated</code></td>
<td>页面更新日期（<a href="http://momentjs.com/">Moment.js</a> 对象）</td>
</tr>
<tr>
<td><code>page.comments</code></td>
<td>留言是否开启</td>
</tr>
<tr>
<td><code>page.layout</code></td>
<td>布局名称</td>
</tr>
<tr>
<td><code>page.content</code></td>
<td>页面的完整内容</td>
</tr>
<tr>
<td><code>page.excerpt</code></td>
<td>页面摘要</td>
</tr>
<tr>
<td><code>page.more</code></td>
<td>除了页面摘要的其余内容</td>
</tr>
<tr>
<td><code>page.source</code></td>
<td>页面原始路径</td>
</tr>
<tr>
<td><code>page.full_source</code></td>
<td>页面的完整原始路径</td>
</tr>
<tr>
<td><code>page.path</code></td>
<td>页面网址（不含根路径）。我们通常在主题中使用 <code>url_for(page.path)</code>。</td>
</tr>
<tr>
<td><code>page.permalink</code></td>
<td>页面的完整网址</td>
</tr>
<tr>
<td><code>page.prev</code></td>
<td>上一个页面。如果此为第一个页面则为 <code>null</code>。</td>
</tr>
<tr>
<td><code>page.next</code></td>
<td>下一个页面。如果此为最后一个页面则为 <code>null</code>。</td>
</tr>
<tr>
<td><code>page.raw</code></td>
<td>文章的原始内容</td>
</tr>
<tr>
<td><code>page.photos</code></td>
<td>文章的照片（用于相簿）</td>
</tr>
<tr>
<td><code>page.link</code></td>
<td>文章的外部链接（用于链接文章）</td>
</tr>
</tbody></table>
<h4 id="文章（post）：和-page-布局类似，但是添加了下列变量。"><a href="#文章（post）：和-page-布局类似，但是添加了下列变量。" class="headerlink" title="文章（post）：和 page 布局类似，但是添加了下列变量。"></a>文章（post）：和 <code>page</code> 布局类似，但是添加了下列变量。</h4><table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.published</code></td>
<td>如果该文章已发布则为True</td>
</tr>
<tr>
<td><code>page.categories</code></td>
<td>该文章的所有分类</td>
</tr>
<tr>
<td><code>page.tags</code></td>
<td>该文章的所有标签</td>
</tr>
</tbody></table>
<h4 id="首页（index）"><a href="#首页（index）" class="headerlink" title="首页（index）"></a>首页（index）</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.per_page</code></td>
<td>每页显示的文章数量</td>
</tr>
<tr>
<td><code>page.total</code></td>
<td>总文章数</td>
</tr>
<tr>
<td><code>page.current</code></td>
<td>目前页数</td>
</tr>
<tr>
<td><code>page.current_url</code></td>
<td>目前分页的网址</td>
</tr>
<tr>
<td><code>page.posts</code></td>
<td>本页文章</td>
</tr>
<tr>
<td><code>page.prev</code></td>
<td>上一页的页数。如果此页是第一页的话则为 <code>0</code>。</td>
</tr>
<tr>
<td><code>page.prev_link</code></td>
<td>上一页的网址。如果此页是第一页的话则为 <code>&#39;&#39;</code>。</td>
</tr>
<tr>
<td><code>page.next</code></td>
<td>下一页的页数。如果此页是最后一页的话则为 <code>0</code>。</td>
</tr>
<tr>
<td><code>page.next_link</code></td>
<td>下一页的网址。如果此页是最后一页的话则为 <code>&#39;&#39;</code>。</td>
</tr>
<tr>
<td><code>page.path</code></td>
<td>当前页面的路径（不含根目录）。我们通常在主题中使用 <code>url_for(page.path)</code>。</td>
</tr>
</tbody></table>
<h4 id="归档-archive-：与-index-布局相同，但新增以下变量。"><a href="#归档-archive-：与-index-布局相同，但新增以下变量。" class="headerlink" title="归档 (archive)：与 index 布局相同，但新增以下变量。"></a>归档 (archive)：与 <code>index</code> 布局相同，但新增以下变量。</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.archive</code></td>
<td>等于 <code>true</code></td>
</tr>
<tr>
<td><code>page.year</code></td>
<td>年份归档 (4位)</td>
</tr>
<tr>
<td><code>page.month</code></td>
<td>月份归档 (没有前导零的2位数)</td>
</tr>
</tbody></table>
<h4 id="分类-category-：与-index-布局相同，但新增以下变量。"><a href="#分类-category-：与-index-布局相同，但新增以下变量。" class="headerlink" title="分类 (category)：与 index 布局相同，但新增以下变量。"></a>分类 (category)：与 <code>index</code> 布局相同，但新增以下变量。</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.category</code></td>
<td>分类名称</td>
</tr>
</tbody></table>
<h4 id="标签-tag-：与-index-布局相同，但新增以下变量。"><a href="#标签-tag-：与-index-布局相同，但新增以下变量。" class="headerlink" title="标签 (tag)：与 index 布局相同，但新增以下变量。"></a>标签 (tag)：与 <code>index</code> 布局相同，但新增以下变量。</h4><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>page.tag</code></td>
<td>标签名称</td>
</tr>
</tbody></table>
<h1 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>npm install -g hexo-cli</td>
<td>安装hexo插件</td>
</tr>
<tr>
<td>npm update -g hexo-cli</td>
<td>升级</td>
</tr>
<tr>
<td>npm install hexo-deployer-git –save</td>
<td>安装部署git插件</td>
</tr>
<tr>
<td>hexo –version、hexo -v</td>
<td>查看版本</td>
</tr>
<tr>
<td>hexo list <type></type></td>
<td>列出网站资料</td>
</tr>
</tbody></table>
<h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><table>
<thead>
<tr>
<th>简写</th>
<th>完整</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>hexo n “我的博客”</td>
<td>hexo new “我的博客”</td>
<td>新建文章</td>
</tr>
<tr>
<td>hexo p</td>
<td>hexo publish</td>
<td>发表草稿</td>
</tr>
<tr>
<td>hexo g</td>
<td>hexo generate</td>
<td>生成，</td>
</tr>
<tr>
<td>hexo s</td>
<td>hexo server</td>
<td>启动服务预览</td>
</tr>
<tr>
<td>hexo d</td>
<td>hexo deploy</td>
<td>将.deploy目录部署到GitHub</td>
</tr>
</tbody></table>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>hexo init [folder]</td>
<td>新建站点。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立站点。</td>
</tr>
<tr>
<td>hexo server</td>
<td>启动服务，监视文件变动并自动更新，无须重启服务器。默认地址：<a href="http://localhost:4000/">http://localhost:4000/</a></td>
</tr>
<tr>
<td>hexo server -s</td>
<td>静态模式，只使用静态文件</td>
</tr>
<tr>
<td>hexo server -p 5000</td>
<td>指定服务端口启动，默认4000</td>
</tr>
<tr>
<td>hexo server -i 192.168.1.1</td>
<td>自定义 IP，默认localhost</td>
</tr>
<tr>
<td>hexo server -l</td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
<tr>
<td>hexo clean</td>
<td>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</td>
</tr>
<tr>
<td>hexo g</td>
<td>生成静态网页至public目录</td>
</tr>
<tr>
<td>hexo g –watch</td>
<td>监视文件变动</td>
</tr>
<tr>
<td>hexo d</td>
<td>部署网站</td>
</tr>
</tbody></table>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p><code>hexo new [layout] &lt;title&gt;</code>：新建文章。如果指定设置 <code>layout</code> 的话，默认使用站点配置文件 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数（默认为post）代替。如果标题包含空格的话，使用引号括起来。</p>
<ul>
<li>hexo new post 文章名：新建文章，会在<code>source/_post/</code>目录下新建文件</li>
<li>hexo new draft 草稿名：新建草稿，会在<code>source/_draft/</code>目录下新建文件</li>
<li>hexo new page 页面名：新建页面，会生成<code>source/页面名/index.md</code>，如关于、分类、标签</li>
</ul>
<p>可以自定义模版，在<code>scaffolds</code>目录下新建或修改模版文件，<code>hexo new </code>会从<code>scaffolds</code>文件夹下找到对应的模版，生成文件。</p>
<h2 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h2><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>hexo –safe</td>
<td>在安全模式下，不会载入插件和脚本。安装新插件遭遇问题时，可以尝试以安全模式重新执行</td>
</tr>
<tr>
<td>hexo –debug</td>
<td>在终端中显示调试信息并记录到 <code>debug.log</code></td>
</tr>
<tr>
<td>hexo –silent</td>
<td>隐藏终端信息</td>
</tr>
<tr>
<td>hexo –config custom.yml</td>
<td>自定义配置文件的路径，执行后将不再使用 <code>_config.yml</code></td>
</tr>
<tr>
<td>hexo –draft</td>
<td>显示 <code>source/_drafts</code> 文件夹中的草稿文章</td>
</tr>
<tr>
<td>hexo –cwd /path/to/cwd</td>
<td>自定义当前工作目录（Current working directory）的路径。</td>
</tr>
</tbody></table>
<h1 id="Hexo配置参数说明"><a href="#Hexo配置参数说明" class="headerlink" title="Hexo配置参数说明"></a>Hexo配置参数说明</h1><p>站点配置文件：<code>站点根目录/_config.yml</code></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>网站标题</td>
</tr>
<tr>
<td>subtitle</td>
<td>副标题</td>
</tr>
<tr>
<td>description</td>
<td>描述、签名</td>
</tr>
<tr>
<td>keywords</td>
<td>博客关键字，利于SEO（搜索引擎优化）</td>
</tr>
<tr>
<td>author</td>
<td>作者、昵称</td>
</tr>
<tr>
<td>language</td>
<td>语言，如zh-Hans</td>
</tr>
<tr>
<td>timezone</td>
<td>时区</td>
</tr>
<tr>
<td>theme</td>
<td>主题</td>
</tr>
<tr>
<td>deploy</td>
<td>部署网站</td>
</tr>
<tr>
<td>permalink</td>
<td>永久链接</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">    type: 部署方式，如git</span><br><span class="line">    repo: 仓库地址</span><br><span class="line">    branch: 分支名</span><br></pre></td></tr></table></figure>

<p>permalink配置示例：<br>使用<code>hexo new post &quot;文章&quot;</code>生成文章时会自动命名，并且生成静态文件时会生成相应的文件夹路径。<br>| 参数                            | 结果                        |<br>| ——————————- | ————————— |<br>| <code>:year/:month/:day/:title/</code>     | 2013/07/14/hello-world      |<br>| <code>:year-:month-:day-:title.html</code> | 2013-07-14-hello-world.html |<br>| <code>:category/:title</code>              | foo/bar/hello-world         |</p>
<p>permalink变量<br>| 变量          | 描述                                                       |<br>| ————- | ———————————————————- |<br>| <code>:year</code>       | 文章的发表年份（4 位数）                                   |<br>| <code>:month</code>      | 文章的发表月份（2 位数）                                   |<br>| <code>:i_month</code>    | 文章的发表月份（去掉开头的零）                             |<br>| <code>:day</code>        | 文章的发表日期 (2 位数)                                    |<br>| <code>:i_day</code>      | 文章的发表日期（去掉开头的零）                             |<br>| <code>:title</code>      | 文件名称                                                   |<br>| <code>:post_title</code> | 文章标题                                                   |<br>| <code>:id</code>         | 文章 ID                                                    |<br>| <code>:category</code>   | 分类。如果文章没有分类，则是 <code>default_category</code> 配置信息。 |</p>
<h1 id="Hexo图片路径配置"><a href="#Hexo图片路径配置" class="headerlink" title="Hexo图片路径配置"></a>Hexo图片路径配置</h1><p>Hexo Markdown文章中使用图片需要将图片放到<code>source/images</code>文件夹下，通过<code>![](/images/图片名称)</code>引用。</p>
<p>这种方式在<strong>Typora中无法预览图片</strong></p>
<p>解决方案：</p>
<ol>
<li>修改_config.yml文件：<code>post_asset_folder: true</code><ol>
<li>使用<code>hexo new post 文章名称</code>时，会创建相同名称的文件夹</li>
<li>将要引用的图片放到该文件夹下</li>
</ol>
</li>
<li>安装插件：<code>npm install https://github.com/CodeFalling/hexo-asset-image</code></li>
<li>文章中引用图片路径：<code>![](文件夹名称/图片名称)</code></li>
</ol>
<h1 id="Hexo支持mermaid图表"><a href="#Hexo支持mermaid图表" class="headerlink" title="Hexo支持mermaid图表"></a>Hexo支持mermaid图表</h1><ol>
<li>安装插件：<code>npm install hexo-filter-mermaid-diagrams</code></li>
<li>旧版本配置步骤多一点</li>
<li>新版本直接在<strong>主题配置文件</strong>中启用mermaid即可</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># theme/next/_config.yml</span></span><br><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br></pre></td></tr></table></figure>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>参考<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>，下篇介绍Hexo更换主题：以NexT为例，并进行简单的配置。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitPage搭建博客</title>
    <url>/2018/10/17/blog-2018-10-17-Hexo-GitPage/</url>
    <content><![CDATA[<h1 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h1><p>静态网页生成工具，可用于搭建博客。使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，有多种主题供选择。<br><a href="https://hexo.io/zh-cn/docs/">中文官方文档</a></p>
<h2 id="与Jekyll的区别？"><a href="#与Jekyll的区别？" class="headerlink" title="与Jekyll的区别？"></a>与Jekyll的区别？</h2><p>在 Github Page 里用 Jekyll 其实是上传一个工程文件 ，Github 自动生成静态文件，而 Hexo 是先生成好文件再部署的。<br>此外，jekyll基于Ruby，Hexo基于Node</p>
<p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>将前者称为 站点配置文件， 后者称为 主题配置文件。</p>
<h1 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p><a href="https://nodejs.org/en/">Node.js安装</a><br>安装后打开cmd，输入<code>node -v</code>、<code>npm -v</code>检查是否安装成功（环境变量自动配置好了）<br>等于<code>node --version</code>、<code>npm --version</code><br><a href="https://git-scm.com/">Git安装</a><br>在电脑上右键出现Git Bash Here、Git GUI Here即表示安装成功。<br>若配置了环境变量，可输入<code>git --version</code>检查是否安装成功</p>
<p>注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。</p>
<h2 id="安装hexo命令行工具"><a href="#安装hexo命令行工具" class="headerlink" title="安装hexo命令行工具"></a>安装hexo命令行工具</h2><p>使用<a href="https://www.npmjs.com.cn/">npm</a>进行安装：终端输入<code>npm install -g hexo-cli</code><br>安装完成后可使用<code>hexo -v</code>或者<code>hexo --version</code>检查是否安装成功<br>注释：-g表示全局安装，不加则将模块下载到当前目录的node_modules中</p>
<p>如果下载较慢，可以设置<a href="https://npm.taobao.org/">淘宝国内镜像</a>，又如下几种方式<br>（1）永久使用：</p>
<blockquote>
<p>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
</blockquote>
<p>（2）临时使用：</p>
<blockquote>
<p>npm –registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
</blockquote>
<p>（3）可保存配置： </p>
<blockquote>
<p>编辑.npmrc文件，加入registry = <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
</blockquote>
<p>（4）使用cnpm替代npm命令：</p>
<blockquote>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>  cnpm install -g hexo-cli</p>
</blockquote>
<p>配置成功后可通过<code>npm config get registry</code>命令验证是否成功</p>
<h2 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h2><ol>
<li>终端进入一个空目录，输入<code>hexo init</code>，在该文件夹下初始化hexo工程，称为站点根目录</li>
<li>输入<code>npm install</code>安装所需组件，即package.json中配置的库</li>
<li>输入<code>hexo s</code>或<code>hexo server</code>启动服务</li>
<li>默认端口为4000，访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可，也可通过<code>hexo server -p 端口号</code>指定端口号<br>出现下图就成功了，里面已经有一篇文章hello world了<br><img src="/2018/10/17/blog-2018-10-17-Hexo-GitPage/hexo01.png" alt="hexo成功图"></li>
</ol>
<h1 id="GitPage搭建"><a href="#GitPage搭建" class="headerlink" title="GitPage搭建"></a>GitPage搭建</h1><h2 id="Git账号注册"><a href="#Git账号注册" class="headerlink" title="Git账号注册"></a>Git账号注册</h2><p>跳过，就和我们平常注册账号一样</p>
<h2 id="GitPage创建"><a href="#GitPage创建" class="headerlink" title="GitPage创建"></a>GitPage创建</h2><p>创建一个新的仓库，仓库名称使用：用户名.github.io，如图<br><img src="/2018/10/17/blog-2018-10-17-Hexo-GitPage/GitPage01.png" alt="git仓库创建"><br>创建完之后就可以通过 <code>https://moon-lights.github.io/</code> 来访问博客地址了</p>
<h1 id="将GitPage和Hexo联系起来"><a href="#将GitPage和Hexo联系起来" class="headerlink" title="将GitPage和Hexo联系起来"></a>将GitPage和Hexo联系起来</h1><h2 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h2><p>跳过，在<a href>另一篇文章</a>里介绍</p>
<h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>打开根目录的 <code>_config.yml</code> 文件，找到deploy，修改如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">​    type: git</span><br><span class="line">​    repo: git@github.com:moon-lights&#x2F;moon-lights.github.io.git</span><br><span class="line">​    branch: master</span><br></pre></td></tr></table></figure>
<p>repo地址如下图获取<br><img src="/2018/10/17/blog-2018-10-17-Hexo-GitPage/GitPage02.png" alt="ssh地址拷贝"></p>
<h2 id="安装上传到GitHub的插件"><a href="#安装上传到GitHub的插件" class="headerlink" title="安装上传到GitHub的插件"></a>安装上传到GitHub的插件</h2><p>cmd打开终端，进入站点根目录，输入<code>npm install --save hexo-deployer-git</code></p>
<p>注释：</p>
<table>
<thead>
<tr>
<th>npm install X</th>
<th>npm install X –save</th>
<th>npm install X –save-dev</th>
</tr>
</thead>
<tbody><tr>
<td>把X包安装到node_modules目录中</td>
<td>把X包安装到node_modules目录中</td>
<td>把X包安装到node_modules目录中</td>
</tr>
<tr>
<td>不会修改package.json</td>
<td>会在package.json的dependencies属性下添加X</td>
<td>会在package.json的devDependencies属性下添加X</td>
</tr>
<tr>
<td>运行npm install命令时，不会自动安装X</td>
<td>运行npm install命令时，会自动安装X</td>
<td>运行npm install命令时，会自动安装X</td>
</tr>
<tr>
<td></td>
<td>之后运行npm install –production或者注明NODE_ENV变量值为production时，会自动安装X到node_modules目录中</td>
<td>之后运行npm install –production或者注明NODE_ENV变量值为production时，不会自动安装X到node_modules目录中</td>
</tr>
</tbody></table>
<p>运行时需要用到的包使–save，否则使用–save-dev。</p>
<h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><p>使用<code>hexo generate</code>命令生成静态文件，简写为<code>hexo g</code><br>此命令会在站点根目录生成public文件夹，即最终推到GitHub的文件。（与jekyll不同，jekyll是将工程推到Github，由GitPage生成静态文件，而这里是先生成静态文件再推到GitHub）</p>
<h2 id="将静态文件推到GitHub上"><a href="#将静态文件推到GitHub上" class="headerlink" title="将静态文件推到GitHub上"></a>将静态文件推到GitHub上</h2><p>使用<code>hexo deploy</code>命令推到GitHub上，简写为<code>hexo d</code></p>
<p>上面两个命令可以合并为<code>hexo generate --deploy</code>或<code>hexo deploy --generate</code><br>当然也可以简写为<code>hexo g -d</code>或<code>hexo d -g</code></p>
<h2 id="访问博客地址"><a href="#访问博客地址" class="headerlink" title="访问博客地址"></a>访问博客地址</h2><p>访问刚才的博客地址，可以看到博客页面已经换成了Hexo的默认主题了，满满的成就感~~。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="两年后-，更新nodejs，hexo-g-d发布失败。错误如下"><a href="#两年后-，更新nodejs，hexo-g-d发布失败。错误如下" class="headerlink" title="两年后~，更新nodejs，hexo g -d发布失败。错误如下"></a>两年后~，更新nodejs，hexo g -d发布失败。错误如下</h2><p><img src="/2018/10/17/blog-2018-10-17-Hexo-GitPage/HexoDeployFailed.png" alt="Hexo发布失败"></p>
<p>解决方案：</p>
<ol>
<li><p>更新hexo命令行工具：<code>npm install -g hexo-cli</code></p>
</li>
<li><p>更新<code>package.json</code>中依赖组件的版本</p>
<ol>
<li>使用<code>npm update</code>更新所有依赖组件的版本</li>
<li>发现hexo从<code>^3.7.0</code>版本变到了<code>^3.9.0</code>，试了一下发布还是不行</li>
<li><code>package.json</code>中，版本号使用了^，只会更新小版本，不会更新大版本，因此还是版本号还是<code>3.x.x</code></li>
<li>从<a href="https://github.com/hexojs/hexo-starter">hexo工程模板</a>中拷贝最新的<code>package.json</code>，替换原来的版本</li>
<li>再执行<code>npm install</code>和<code>npm update</code>更新版本到<code>^5.3.0</code>，其他依赖也更新</li>
</ol>
</li>
<li><p>再执行<code>hexo g -d</code>，成功发布</p>
</li>
</ol>
<p><img src="/2018/10/17/blog-2018-10-17-Hexo-GitPage/HexoDependenciesVersion.png" alt="Hexo依赖版本图"></p>
<h3 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h3><p><strong><a href="../note/2021-4-12-NPM.md">npm依赖包版本说明</a></strong></p>
<h2 id="升级之后菜单跳转404，url带-20"><a href="#升级之后菜单跳转404，url带-20" class="headerlink" title="升级之后菜单跳转404，url带%20"></a>升级之后菜单跳转404，url带%20</h2><p>next menu配置：旧版本<code>链接 ||</code>中间有空格，升级Hexo之后需要删除空格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/||</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">/schedule/||</span> <span class="string">calendar</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml||</span> <span class="string">sitemap</span></span><br></pre></td></tr></table></figure>

<h2 id="GitPage-构建失败"><a href="#GitPage-构建失败" class="headerlink" title="GitPage 构建失败"></a>GitPage 构建失败</h2><p>2021-5-16照常<code>hexo g -d</code>发布博客，结果收到GitHub错误邮件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The page build failed for the &#96;master&#96; branch with the following error:</span><br><span class="line"></span><br><span class="line">Unable to build page. Please try again later.</span><br><span class="line"></span><br><span class="line">For information on troubleshooting Jekyll see:</span><br><span class="line"></span><br><span class="line">  https:&#x2F;&#x2F;docs.github.com&#x2F;articles&#x2F;troubleshooting-jekyll-builds</span><br><span class="line"></span><br><span class="line">If you have any questions you can submit a request at https:&#x2F;&#x2F;support.github.com&#x2F;contact?repo_id&#x3D;367865705&amp;page_build_id&#x3D;253625473</span><br></pre></td></tr></table></figure>

<p>整了足足半天没解决，收了几十封错误邮件。尝试了很多方法无效：</p>
<ol>
<li><p>删除新上传的文件</p>
</li>
<li><p>排查错误字符</p>
</li>
<li><p>回退版本</p>
</li>
<li><p><code>hexo clean</code>、并删除<code>.deploy_git</code>文件夹</p>
</li>
<li><p>使用本地Jekyll编译运行正常</p>
</li>
<li><p>删除了远程Git仓库，新建GitPage</p>
</li>
<li><p>最后甚至准备转战Gitee发布，结果创建GitPage服务的时候提示服务不可用……</p>
<p><img src="/2018/10/17/blog-2018-10-17-Hexo-GitPage/GiteePages.png" alt="GiteePages"></p>
</li>
</ol>
<p>本地构建运行<code>hexo serve</code>正常，使用jekyll编译也正常，说明文章格式没有错误。就是GitPage构建的时候失败了。</p>
<p>最后实在没办法，于是暂时放着，静下来整理博客，反正本地运行也可以看。</p>
<p>结果到晚上随手发布了一下，居然成功了、成功了……</p>
<p>只能说GitHub太坑，估计下午哪里瓦特了</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>下篇介绍下Hexo的一些基本概念、配置和常用命令</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓跨平台方案简介</title>
    <url>/2018/10/14/android-2018-10-14-HybridSolution/</url>
    <content><![CDATA[<h2 id="Hybrid-App"><a href="#Hybrid-App" class="headerlink" title="Hybrid App"></a>Hybrid App</h2><p>//todo 跨平台方案对比，选型</p>
<p>Hybrid App（混合模式移动应用）：介于web-app、native-app这两者之间的app，兼具Native App（原生app）良好用户交互体验的优势”和“Web App跨平台开发的优势”。</p>
<p>原因：</p>
<ul>
<li>传统app需要同时开发android和iOS两个app，成本较大。</li>
<li>使用H5具有低成本、高效率、跨平台等特性</li>
</ul>
<p>原理：Hybrid APP底层依赖于Native提供的容器（UIWebview），上层使用Html&amp;Css&amp;JS做业务开发，底层透明化、上层多样化。</p>
<p>优点：共享ui代码，提高开发效率</p>
<p>缺点：性能比不上Native。</p>
<p>场景：有利于前端介入，适合业务快速迭代。</p>
<h2 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h2><p>flutter，weex，reactnative等</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb基础概念笔记</title>
    <url>/2018/10/10/webdev-2018-10-10-JavaWebBasicNote/</url>
    <content><![CDATA[<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="java对象"><a href="#java对象" class="headerlink" title="java对象"></a>java对象</h2><p>POJO（Plain Ordinary Java Object，简单Java对象）</p>
<p>POJO在不同环境、场合下有不同意义：</p>
<ul>
<li>PO（Persistant Object，持久对象）：数据库表在java中映射的对象</li>
<li>BO（Business Object，业务对象）：业务层的Java对象</li>
<li>VO（View Object，视图对象）：表现层的Java对象</li>
<li>DTO（Data Transfer Object，数据传输对象）：在两个系统间传递数据，需要将POJO序列化，如RPC</li>
<li>JavaBean：遵循特定写法的java类，通常具有以下特征：<ul>
<li>属性私有</li>
<li>实现getter和setter</li>
<li>具有无参构造函数</li>
<li>实现序列化</li>
</ul>
</li>
<li>EJB(Enterprise JavaBean，企业级JavaBean)：一组JavaBean的集合，组合起来实现某块业务的功能</li>
</ul>
<h2 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h2><ul>
<li>Model层：模型层，mvc中的model</li>
<li>Dao层：（Data Access Object，数据访问对象），封装数据库操作（CRUD），常用框架：Mybatis，hibernate，spring-data-jpa等</li>
<li>Service层：业务层，封装业务逻辑，调用dao层进行处理，如跨表查询，判断等问题</li>
<li>Controller层：控制层，用于接收请求，分发到具体service，调用service层方法，返回数据，封装响应页面返回给前端</li>
<li>View层：视图层，如jsp、模板（template）（前后端分离之后，view层就到前端去了）</li>
</ul>
<h3 id="Entity、Model、Domain的区别"><a href="#Entity、Model、Domain的区别" class="headerlink" title="Entity、Model、Domain的区别"></a>Entity、Model、Domain的区别</h3><ul>
<li>Entity：实体，对应数据库表</li>
<li>Model：更接近业务，将entity进行处理</li>
<li>Domain：类似model，model主要是在mvc中提出来的概念，模块化的话称为domain更常见</li>
</ul>
<p>Model会对Entity进行处理：如数据库存储性别用（1，2），Entity里面存储的是int型，经过转换封装成Model，再传给前端，避免前端做判断</p>
<p>Entity和Model在数据库中就相当于表和视图的关系，表存储可能会有很多无用的字段，所以在表上建立视图，用于频繁读取。</p>
<h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>jpa（java persistent api，java持久化api）</p>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><ul>
<li>1开头的归类为临时响应，并需要客户端继续请求</li>
<li>2开头归类为请求成功</li>
<li>3开头归类为重定向</li>
<li>4开头归类为请求出错</li>
<li>5开头归类为服务器问题</li>
</ul>
<p>http常用的状态码及其对应的含义如下：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>客户应该继续发出请求</td>
</tr>
<tr>
<td>101</td>
<td>客户要求服务器根据请求转换HTTP协议版本</td>
</tr>
<tr>
<td>200</td>
<td>服务器响应正常。</td>
</tr>
<tr>
<td>201</td>
<td>提示知道新文件的URL</td>
</tr>
<tr>
<td>202</td>
<td>接受和处理、但处理未完成</td>
</tr>
<tr>
<td>203</td>
<td>返回信息不确定或不完整</td>
</tr>
<tr>
<td>204</td>
<td>请求收到，但返回信息为空</td>
</tr>
<tr>
<td>205</td>
<td>服务器完成了请求，用户代理必须复位当前已经浏览过的文件</td>
</tr>
<tr>
<td>206</td>
<td>服务器已经完成了部分用户的GET请求</td>
</tr>
<tr>
<td>300</td>
<td>请求的资源可在多处得到</td>
</tr>
<tr>
<td>301</td>
<td>删除请求数据</td>
</tr>
<tr>
<td>302</td>
<td>在其他地址发现了请求数据</td>
</tr>
<tr>
<td>303</td>
<td>建议客户访问其他URL或访问方式</td>
</tr>
<tr>
<td>304</td>
<td>该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。</td>
</tr>
<tr>
<td>305</td>
<td>请求的资源必须从服务器指定的地址得到</td>
</tr>
<tr>
<td>306</td>
<td>前一版本HTTP中使用的代码，现行版本中不再使用</td>
</tr>
<tr>
<td>307</td>
<td>申明请求的资源临时性删除</td>
</tr>
<tr>
<td>400</td>
<td>无法找到请求的资源。</td>
</tr>
<tr>
<td>401</td>
<td>访问资源的权限不够。</td>
</tr>
<tr>
<td>402</td>
<td>保留有效ChargeTo头响应</td>
</tr>
<tr>
<td>403</td>
<td>没有权限访问资源。</td>
</tr>
<tr>
<td>404</td>
<td>需要访问的资源不存在。</td>
</tr>
<tr>
<td>405</td>
<td>需要访问的资源被禁止。</td>
</tr>
<tr>
<td>406</td>
<td>根据用户发送的Accept头，请求资源不可访问</td>
</tr>
<tr>
<td>407</td>
<td>访问的资源需要代理身份验证。</td>
</tr>
<tr>
<td>408</td>
<td>客户端没有在用户指定的时间内完成请求</td>
</tr>
<tr>
<td>409</td>
<td>对当前资源状态，请求不能完成</td>
</tr>
<tr>
<td>410</td>
<td>服务器上不再有此资源且无进一步的参考地址</td>
</tr>
<tr>
<td>411</td>
<td>服务器拒绝用户定义的Content-Length属性请求</td>
</tr>
<tr>
<td>412</td>
<td>一个或多个请求头字段在当前请求中错误</td>
</tr>
<tr>
<td>413</td>
<td>请求的资源大于服务器允许的大小</td>
</tr>
<tr>
<td>414</td>
<td>请求的URL太长。</td>
</tr>
<tr>
<td>415</td>
<td>请求资源不支持请求项目格式</td>
</tr>
<tr>
<td>416</td>
<td>请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</td>
</tr>
<tr>
<td>417</td>
<td>服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</td>
</tr>
<tr>
<td>500</td>
<td>服务器内部错误。如代码执行异常</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持请求的函数</td>
</tr>
<tr>
<td>502</td>
<td>服务器暂时不可用，有时是为了防止发生系统过载</td>
</tr>
<tr>
<td>503</td>
<td>服务器过载或暂停维修</td>
</tr>
<tr>
<td>504</td>
<td>关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持或拒绝支请求头中指定的HTTP版本</td>
</tr>
</tbody></table>
<h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><h3 id="解释一：转发是服务器行为，重定向是客户端行为"><a href="#解释一：转发是服务器行为，重定向是客户端行为" class="headerlink" title="解释一：转发是服务器行为，重定向是客户端行为"></a>解释一：转发是服务器行为，重定向是客户端行为</h3><p>转发过程：客户浏览器发送http请求—-》web服务器接受此请求–》调用内部的一个方法在容器内部完成请求处理和转发动作—-》将目标资源发送给客户；<br>在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</p>
<p>重定向过程：客户浏览器发送http请求—-》web服务器接受后发送302状态码响应及对应新的location给客户浏览器–》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址—-》服务器根据此请求寻找资源并发送给客户。<br>在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。</p>
<h3 id="解释二：重定向，其实是两次request"><a href="#解释二：重定向，其实是两次request" class="headerlink" title="解释二：重定向，其实是两次request,"></a>解释二：重定向，其实是两次request,</h3><p>第一次，客户端request   A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中，传输的信息会被丢失。</p>
<p>请求转发是服务器内部把对一个request/response的处理权，移交给另外一个<br>对于客户端而言，它只知道自己最早请求的那个A，而不知道中间的B，甚至C、D。 传输的信息不会丢失。</p>
<h3 id="解释三：假设你去办理某个执照，"><a href="#解释三：假设你去办理某个执照，" class="headerlink" title="解释三：假设你去办理某个执照，"></a>解释三：假设你去办理某个执照，</h3><p>重定向：你先去了A局，A局的人说：“这个事情不归我们管，去B局”，然后，你就从A退了出来，自己乘车去了B局。 </p>
<p>转发：你先去了A局，A局看了以后，知道这个事情其实应该B局来管，但是他没有把你退回来，而是让你坐一会儿，自己到后面办公室联系了B的人，让他们办好后，送了过来。</p>
<p>注：</p>
<p>转发或重定向后需要return避免代码往下执行。</p>
<p>连续发两次forward，会报错：Cannot forward after response has been committed</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记</title>
    <url>/2018/10/04/note-2018-10-04-Git/</url>
    <content><![CDATA[<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><p>工作区</p>
<p>暂存区</p>
<p>版本库</p>
<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><p>//todo</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul>
<li><code>git diff --cached </code>：比较暂存区和版本库</li>
<li><code>git diff</code>：比较工作区和版本库</li>
<li><code>git patch/git am</code>：生成补丁、打补丁</li>
<li><code>git log 文件名</code>：查看某个文件的修改历史<ul>
<li>-3：查看最近三个提交</li>
<li>–stat：查看修改了哪些文件，不看文件细节</li>
</ul>
</li>
<li><code>git reset head</code>：取消暂存，使用别名<code>git unstage</code></li>
<li><code>git reset</code>：默认不修改文件，只修改Git记录。–hard同时修改文件，</li>
<li><code>git checkout &lt;file&gt;</code>:取消修改，回退到版本库</li>
<li><code>git revert &lt;commit-id&gt;</code>：撤销中间的某个版本，生成一个新的提交</li>
<li><code>git merge &lt;side2：合并到当前分支&gt;</code></li>
<li><code>git cherry-pick &lt;commit-id&gt;</code>：copy一个版本到当前分支，不出现交叉，不影响被copy的分支</li>
<li><code>git rebase side1 [side2:结构上side2在side1后面，side2省略的话，会将当前分支加到side1后面]</code>。第一个参数是基，第二个参数是要生成的补丁。side1省略的话相当于git rebase origin/head head。</li>
<li><code>git remote prune origin</code>。远程分支已删除，本地未同步。通过git remote show origin查看，根据提示使用git remote prune origin同步已删除的分支</li>
<li><code>git commit --amend</code>:修改最后一次提交信息</li>
<li>合并最后两个提交：<ul>
<li><code>git rebase -i 倒数第三个commit</code></li>
<li>pick第一个，squash第二个</li>
</ul>
</li>
<li>修改倒数第二次提交信息：<ul>
<li>git rebase -i head~2（倒数第三个commit）。</li>
<li>将相应commit的pick改为edit</li>
<li>退出编辑</li>
<li>git commit –amend 修改提交信息。</li>
<li>git rebase –continue：恢复提交</li>
</ul>
</li>
<li><code>git blame &lt;file&gt;</code>显示文件每一行修改版本和作者</li>
</ul>
<h1 id="Git-Flow工作流"><a href="#Git-Flow工作流" class="headerlink" title="Git-Flow工作流"></a>Git-Flow工作流</h1><p>//todo</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>快捷键笔记</title>
    <url>/2018/10/04/note-2018-10-04-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="命令行常用快捷键"><a href="#命令行常用快捷键" class="headerlink" title="命令行常用快捷键"></a>命令行常用快捷键</h1><p>光标移动：<br><code>ctrl+a</code>：移动到行首<br><code>ctrl+e</code>：移动到行尾<br><code>option+左右</code>：以单词为单位移动</p>
<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><p>光标移动：<br>b：前移一个单词词首<br>w：后移一个单词词首<br>e：后移一个单词词尾<br>nw、nb：n为数字，表示移动n个单词<br>0：移到行首<br>^：移到行首，不包括空格<br>$：移到行尾</p>
<p>vi文档内搜索：/搜索内容，n键跳到下一处位置</p>
<h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><p><code>command+f12（File Structure）</code>：打开类结构<br><code>ctrl+h（Type Hierarchy）</code>：打开类继承关系<br><code>ctrl+tab</code>：切换tab<br><code>option+左右</code>：单词移动</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行笔记</title>
    <url>/2018/10/04/note-2018-10-04-TerminalCommand/</url>
    <content><![CDATA[<p>windows命令行工具推荐cmder</p>
<p>windows和mac下命令有所区别，使用cmder的别名功能可以进行统一</p>
<p>mac系统基于unix内核，linux是类unix系统，因此两者命令基本一样，有细微差别</p>
<table>
<thead>
<tr>
<th>作用</th>
<th>Linux/Mac</th>
<th>windows</th>
</tr>
</thead>
<tbody><tr>
<td>打开文件或文件夹</td>
<td>open [path]</td>
<td>explorer.exe [path]、explorer [path]</td>
</tr>
<tr>
<td>列出当前目录文件</td>
<td>ls</td>
<td>ls</td>
</tr>
<tr>
<td>列出当前目录文件详情</td>
<td>ll</td>
<td>ls -alF、dir。（-R：递归遍历）</td>
</tr>
<tr>
<td>打印当前目录路径</td>
<td>pwd</td>
<td>pwd</td>
</tr>
<tr>
<td>拷贝文本</td>
<td>pbcopy（mac专有）</td>
<td>无</td>
</tr>
<tr>
<td>查看系统信息</td>
<td>sw_vers</td>
<td>winver</td>
</tr>
<tr>
<td>计算器</td>
<td>bc</td>
<td>calc</td>
</tr>
<tr>
<td>查看ip</td>
<td>ifconfig</td>
<td>ipconfig</td>
</tr>
<tr>
<td>匹配字符串</td>
<td>grep</td>
<td>find</td>
</tr>
<tr>
<td>创建文件夹</td>
<td>mkdir</td>
<td>mkdir、md</td>
</tr>
<tr>
<td>创建文件</td>
<td>touch</td>
<td>type、touch</td>
</tr>
<tr>
<td>查看应用安装路径</td>
<td>which</td>
<td>where</td>
</tr>
<tr>
<td>查看系统磁盘使用情况</td>
<td>df</td>
<td>df</td>
</tr>
<tr>
<td>查看目录或文件大小</td>
<td>du</td>
<td>du</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>cd /d c:\Users\41001\Desktop</code>：<code>/d</code>表示直接进入该盘符</li>
<li><code>grep [options] PATTERN FILE</code>：<code>grep -inR enable_global_input *</code><ul>
<li>-i：忽略大小写</li>
<li>-n：输出匹配的行号</li>
<li>-R：递归遍历文件夹</li>
<li>-E：可以输入多个：<code>grep -E &quot;word1|word2|word3&quot; file.txt </code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2018/08/14/tech-2018-08-14-Encrypt/</url>
    <content><![CDATA[<h1 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h1><h2 id="Diffie-Hellman（迪菲-赫尔曼）密钥交换算法原理："><a href="#Diffie-Hellman（迪菲-赫尔曼）密钥交换算法原理：" class="headerlink" title="Diffie-Hellman（迪菲-赫尔曼）密钥交换算法原理："></a>Diffie-Hellman（迪菲-赫尔曼）密钥交换算法原理：</h2><ol>
<li>Alice与Bob确定两个大素数n和g，这两个数不用保密</li>
<li>Alice选择另一个大随机数x，并计算A如下：A=gx mod n</li>
<li>Alice将A发给Bob</li>
<li>Bob  选择另一个大随机数y，并计算B如下：B=gy mod n</li>
<li>Bob将B发给Alice</li>
<li>计算密钥K1如下：K1=Bx mod n</li>
<li>计算密钥K2如下：K2=Ay mod n</li>
<li>K1=K2，因此Alice和Bob可以用其进行加解密</li>
</ol>
<h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><p>rsa加密算法是基于这样的数学事实：两个大素数（质数）相乘容易，而对得到的乘积求因子则很难。加密过程如下：</p>
<ol>
<li>选择两个大素数P、Q</li>
<li>计算N=P*Q</li>
<li>选择一个公钥（加密密钥）E，使其不是(P-1)与(Q-1)的因子</li>
<li>选择私钥（解密密钥）D，满足条件：<code>(D*E) mod (P-1)(Q-1)=1</code></li>
<li>加密时，明文PT计算密文CT：<code>CT=PTE mod N</code></li>
<li>解密时，从密文CT计算明文PT：PT=CTD mod N 这也是SSL中会用一种密钥交换算法。</li>
</ol>
<h1 id="公钥和私钥、加密和解密、签名和认证"><a href="#公钥和私钥、加密和解密、签名和认证" class="headerlink" title="公钥和私钥、加密和解密、签名和认证"></a>公钥和私钥、加密和解密、签名和认证</h1><p>公钥（public key）可以公开，私钥（private key）自己持有。用其中一个进行加密，只能用另一个进行解密</p>
<h2 id="在加密的场景下，公钥用来加密，私钥用来解密。"><a href="#在加密的场景下，公钥用来加密，私钥用来解密。" class="headerlink" title="在加密的场景下，公钥用来加密，私钥用来解密。"></a>在加密的场景下，<strong>公钥用来加密，私钥用来解密</strong>。</h2><p>Bob用Alice的公钥对消息进行加密，并把加密之后的消息传回给Alice；Alice应该保存好与这个公钥相对应的私钥，当Alice收到Bob发来的加密过的消息后，通过手里的私钥对其进行解密。</p>
<p>只有私钥可以解密，而公钥不可以，所以即使公钥被窃听者Eve知道也没有关系。</p>
<h2 id="在签名的场景下，私钥用来加密，公钥用来解密"><a href="#在签名的场景下，私钥用来加密，公钥用来解密" class="headerlink" title="在签名的场景下，私钥用来加密，公钥用来解密"></a>在签名的场景下，私钥用来加密，公钥用来解密</h2><p>签名是对上述过程的反向应用，即在此场景下，用私钥进行“加密”，而公钥进行“解密”，更清晰的说法是：在此场景下，用私钥进行“签名”，用公钥进行“认证”。目的是保证内容是Alice发出的</p>
<p>因为私钥只有Alice自己知道，所以用私钥对消息进行签名后，只有与之对应的公钥才能对这个签过名的消息进行认证，而公钥是公开的，通过这个过程可以知道该消息确实是属于Alice的。</p>
<p>如使用ssh登录GitHub仓库，本地持有私钥，服务器发送一段文本，本地使用私钥进行加密发送给服务器，服务器进行解密并验证通过</p>
<p><strong>参考</strong></p>
<p><a href="https://www.zhihu.com/question/25912483">知乎：RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密？</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Android依赖配置</title>
    <url>/2018/08/04/android-2018-08-04-DependenciesNote/</url>
    <content><![CDATA[<h2 id="Gradle依赖配置"><a href="#Gradle依赖配置" class="headerlink" title="Gradle依赖配置"></a>Gradle依赖配置</h2><h3 id="implementation和api"><a href="#implementation和api" class="headerlink" title="implementation和api"></a>implementation和api</h3><p><code>implementation</code>：依赖隔离</p>
<p><code>api</code>：依赖传递，相当于原来的<code>compile</code></p>
<p>从3.4版本的gradle开始，compile已经被api与implementation取代</p>
<p>compileOnly：只在编译时引用，只能保证代码能编过，运行的时候会由于找不到类失败</p>
<h2 id="常用框架、依赖库配置"><a href="#常用框架、依赖库配置" class="headerlink" title="常用框架、依赖库配置"></a>常用框架、依赖库配置</h2><h3 id="ButterKnife配置和使用"><a href="#ButterKnife配置和使用" class="headerlink" title="ButterKnife配置和使用"></a>ButterKnife配置和使用</h3><ol>
<li>base module中添加依赖<code>api rootProject.ext.dependencies[&quot;butterknife&quot;]</code></li>
<li>library module添加注解处理器<code>annotationProcessor rootProject.ext.dependencies[&quot;butterknife-compiler&quot;]</code></li>
<li>library module添加butterknife插件：在模块的build.gradle顶部添加<code>apply plugin: &#39;com.jakewharton.butterknife&#39;</code></li>
<li>project module引用插件依赖：在工程的build.gradle–&gt;buildscript–&gt;dependencies中添加<code>classpath &quot;com.jakewharton:butterknife-gradle-plugin:8.4.0&quot;</code></li>
<li><code>@BindView(R.id.**)</code>改成<code>@BindView(R2.id.**)</code></li>
</ol>
<p>注意：</p>
<ul>
<li>缺少第3，4步会报<code>attribute value must be constant……</code>问题</li>
<li>缺少第2步会报空指针</li>
<li>不同butterknife版本和gradle版本配置会有所不同。有时候会出现问题，具体怎么解决的忘了，有空再补</li>
</ul>
<p>补充：</p>
<p><strong>APT</strong>(Annotation Processing Tool)即<strong>注解处理器</strong>，是一种处理注解的工具，确切的说它是javac的一个工具，它用来在<strong>编译时</strong>扫描和处理注解。注解处理器以<strong>Java代码</strong>(或者编译过的字节码)作为输入，生成**.java文件<strong>作为输出。<br> 简单来说就是在编译期，通过注解生成</strong>.java**文件。摘自<a href="ttps://www.jianshu.com/p/7af58e8e3e18">【Android】APT</a></p>
<h3 id="ARouter配置"><a href="#ARouter配置" class="headerlink" title="ARouter配置"></a>ARouter配置</h3><ol>
<li><p>base module中添加依赖api rootProject.ext.dependencies[“arouter”]</p>
</li>
<li><p>所有的module中添加</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">javaCompileOptions &#123;</span><br><span class="line">	annotationProcessorOptions &#123;</span><br><span class="line">		arguments = [<span class="attr">moduleName:</span> project.getName()]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>路由页面使用@Route注解@Route(path = “/homepage/HomePageActivity”)，路径前必须带/</p>
</li>
<li><p>跳转使用ARouter.getInstance().build(“/homepage/HomePageActivity”).navigation();</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC和RPC框架【转载】</title>
    <url>/2018/07/24/tech-2018-07-24-RPC/</url>
    <content><![CDATA[<h2 id="转载"><a href="#转载" class="headerlink" title="[转载]"></a>[转载]</h2><p>作者：EnjoyMoving</p>
<p>链接：<a href="https://www.zhihu.com/question/25536695/answer/285844835">https://www.zhihu.com/question/25536695/answer/285844835</a></p>
<p>RPC：远程调用。通过RPC框架，使得我们可以像调用本地方法一样地调用远程机器上的方法：</p>
<p>1、本地调用某个函数方法</p>
<p>2、本地机器的RPC框架把这个调用信息封装起来（调用的函数、入参等），序列化(json、xml等)后，通过网络传输发送给远程服务器</p>
<p>3、远程服务器收到调用请求后，远程机器的RPC框架反序列化获得调用信息，并根据调用信息定位到实际要执行的方法，执行完这个方法后，序列化执行结果，通过网络传输把执行结果发送回本地机器</p>
<p>4、本地机器的RPC框架反序列化出执行结果，函数return这个结果</p>
<p>服务调用端（本地机器）：</p>
<p><img src="/2018/07/24/tech-2018-07-24-RPC/RPC01.png" alt="img"></p>
<p>服务提供端（远程机器）：</p>
<p><img src="/2018/07/24/tech-2018-07-24-RPC/RPC02.png" alt="img"></p>
<p>Java Netty 是在TCP(Socket)层对nio进行封装的框架，在RPC框架中可用于解决网络传输问题。</p>
<p>现在流行的微服务框架（dubbo、spring cloud等），实际上就是各种各样的RPC框架</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Mina心跳检测实现</title>
    <url>/2018/07/24/tech-2018-07-24-MinaHeartbeat/</url>
    <content><![CDATA[<p>上一篇文章讲了Mina的简单使用，这一篇将要讲讲怎么用Mina实现心跳检测。网上有很多相关的文章，但是我觉得比较难理解，自己折腾了好久才明白，所以想用我觉得容易理解的话总结一下。也给自己做个笔记。</p>
<h1 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h1><p>​    1.心跳机制有什么用？<br>在TCP的长连接中，有可能两端有很长一段时间没有数据往来，理论上连接应该是一直保持的。但实际情况中，如果中间节点出现故障，连接断开（如防火墙，或者断网等），这时候故障是难以知道的。</p>
<p>比如客户端因为某种情况断开了连接，服务端并不会收到消息，可能还傻傻的等待对方发送消息过来。反过来也一样。</p>
<p>所以发明了心跳机制来维持长连接，保活。</p>
<p>​    2.心跳机制是什么？</p>
<p>心跳机制原理很简单，就是客户端每隔一段时间发送一个“请求心跳包”到服务端，服务端收到“请求心跳包”之后回复一个心跳包，客户端接收到“回复心跳包”后判断连接正常。</p>
<p>如果客户端“在一定时间（即超时时间）”没有收到回复包则表示中间出错了，可以尝试重新连接或者做出相应的操作。</p>
<p>当然一般我们会设置一个变量，“多次判断”有没有收到回复包。比如3次没收到回复包，才判断连接出错。如果收到了回复包，则把变量重置为0。</p>
<p>由谁（客户端还是服务端）发起请求其实都一样，当然也可以两边都发，具体情况看需求和方便性。比如为了减轻服务端压力，由客户端发出请求较合适。</p>
<p><img src="/2018/07/24/tech-2018-07-24-MinaHeartbeat/mina_heartbeat01.png" alt="mina心跳包01"></p>
<p>​    3.心跳包是什么？</p>
<p>心跳包其实就是双方规定的一个信息，可以是一个数字、一串字符、也可以是一个结构对象，只要接收方能够判断就行。</p>
<p>我把发出请求的心跳包叫做心跳请求包，把回复的心跳包叫做心跳回复包。</p>
<p>心跳包之所以叫心跳包是因为：他像心跳一样每隔一定时间发送一次，以此告诉对方，自己还活着。</p>
<h1 id="Mina实现心跳机制"><a href="#Mina实现心跳机制" class="headerlink" title="Mina实现心跳机制"></a>Mina实现心跳机制</h1><p>​    上一篇文章讲了Mina的简单使用，我们通过设置IoHandler来处理业务逻辑，IoHandler中有messageReceived方法，当接收到消息时回调此方法。</p>
<p>​    <strong>1.很容易想到的方法</strong></p>
<p>所以我们很容易想到，只要在任何一端（假设为A端）设置一个定时器，定时发送一个心跳请求包。然后在另一端（假设为B端）的messageReceived方法中判断接收到的消息是不是心跳请求包。如果是，则发出一个心跳回复包，同样在A端的messageReceived方法中判断接收到的消息是不是一个心跳回复包。如果是则判断连接成功。</p>
<p>​    <strong>2.定时器</strong></p>
<p>上面说的思路肯定是能够实现的，现在我们来说下这个定时器怎么设置。</p>
<p>上一篇文章中还提到了一个函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数会在判断当前Session为闲置状态时，每隔10S调用一次IoHandler的sessionIdle方法，因此我们可以使用这个函数设置合适的时间，在sessionIdle中发出心跳请求包，就不用自己写一个定时器了。</p>
<p>​    <strong>3.这么容易满足吗？</strong></p>
<p>上面说的已经能够实现正常的心跳机制了。但是把所有的代码和判断都放在IoHandler的业务逻辑处理中，是否不够优雅？</p>
<p>在上篇文章中，我们提到了消息是通过IoService接收，通过层层拦截器IoFilterChain，然后才传递到IoHandler中进行业务逻辑处理，处理之后的发送也需要通过层层拦截器才能发送出去。</p>
<p>因此我们想心跳包检测要是能在拦截器阶段就被消费掉，是否就不用传递到IoHandler中了，IoHandler就可以只处理业务逻辑，将心跳检测独立出来。</p>
<p>很庆幸，Mina已经将这个拦截器给我们封装好了，我们只需要知道如何使用即可。</p>
<p>​    <strong>4.Mina的心跳检测拦截器/过滤器</strong></p>
<p><strong>创建拦截器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            <span class="comment">//实现KeepAliveMessageFactory接口方法</span></span><br><span class="line">            HeartRequestFactoryImpl heartRequestFactory = <span class="keyword">new</span> HeartRequestFactoryImpl();</span><br><span class="line">            <span class="comment">//创建拦截器，第一个参数是心跳处理接口，第二个参数是心跳超时处理接口</span></span><br><span class="line">            KeepAliveFilter kaf = <span class="keyword">new</span> KeepAliveFilter(heartRequestFactory, <span class="keyword">new</span> KeepAliveRequestTimeoutHandlerImpl());</span><br><span class="line">            <span class="comment">//设置请求间隔，单位s</span></span><br><span class="line">            kaf.setRequestInterval(<span class="number">20</span>);</span><br><span class="line">            <span class="comment">//设置超时时间</span></span><br><span class="line">            kaf.setRequestTimeout(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//设置是否forward到下一个filter,默认为false</span></span><br><span class="line"><span class="comment">//            kaf.setForwardEvent(true);</span></span><br><span class="line">            acceptor.getFilterChain().addLast(<span class="string">&quot;heart&quot;</span>, kaf);</span><br></pre></td></tr></table></figure>


<p><strong>需要注意的是：</strong></p>
<p>（1）客户端也需要添加心跳检测拦截器，只不过KeepAliveMessageFactory实现方法不同</p>
<p>（2）由服务端发出心跳请求包的话，客户端不需要实现超时处理方法，即KeepAliveRequestTimeoutHandler。超时方法是一定时间内没有收到“心跳回复包”才调用的，而客户端只会收到心跳请求包，不会收到心跳回复包</p>
<p>我们需要做的主要是实现KeepAliveMessageFactory接口方法</p>
<p>有四个方法，isRequest，isResponse，getRequest，getResponse需要我们实现，这些方法具体作用如下：</p>
<p>isRequest：判断接收到的消息是不是心跳请求包<br>isResponse：判断接收到的消息是不是心跳回复包<br>getRequest：获取心跳请求包<br>getResponse：获取心跳回复包</p>
<p><strong>关键要理解这些方法返回值的含义和调用时机：</strong></p>
<p>以服务端发送心跳请求包为例（反过来也一样），流程如下：<br><img src="/2018/07/24/tech-2018-07-24-MinaHeartbeat/mina_heartbeat02.png" alt="mina心跳包02"></p>
<p>可以看到，客户端和服务端都需要创建拦截器，实现KeepAliveMessageFactory接口方法，只不过写法不一样。其他的发送消息流程并不需要关心</p>
<p>除此之外，发送请求包的一方还可以实现超时处理接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepAliveRequestTimeoutHandlerImpl</span> <span class="keyword">implements</span> <span class="title">KeepAliveRequestTimeoutHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//在超时时间范围内没有收到消息会调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keepAliveRequestTimedOut</span><span class="params">(KeepAliveFilter keepAliveFilter, IoSession ioSession)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;心跳超时！&quot;</span>);<span class="comment">//做出相应处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>分析源码：</strong></p>
<p>心跳拦截器KeepAliveFliter源码，关键部分如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(NextFilter nextFilter, IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.messageFactory.isRequest(session, message)) &#123;</span><br><span class="line">            Object pongMessage = <span class="keyword">this</span>.messageFactory.getResponse(session, message);</span><br><span class="line">            <span class="keyword">if</span>(pongMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nextFilter.filterWrite(session, <span class="keyword">new</span> DefaultWriteRequest(pongMessage));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.messageFactory.isResponse(session, message)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resetStatus(session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.isKeepAliveMessage(session, message)) &#123;</span><br><span class="line">            nextFilter.messageReceived(session, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(NextFilter nextFilter, IoSession session, WriteRequest writeRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object message = writeRequest.getMessage();</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.isKeepAliveMessage(session, message)) &#123;</span><br><span class="line">        nextFilter.messageSent(session, writeRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(NextFilter nextFilter, IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(status == <span class="keyword">this</span>.interestedIdleStatus) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!session.containsAttribute(<span class="keyword">this</span>.WAITING_FOR_RESPONSE)) &#123;</span><br><span class="line">            Object pingMessage = <span class="keyword">this</span>.messageFactory.getRequest(session);</span><br><span class="line">            <span class="keyword">if</span>(pingMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nextFilter.filterWrite(session, <span class="keyword">new</span> DefaultWriteRequest(pingMessage));</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.getRequestTimeoutHandler() != KeepAliveRequestTimeoutHandler.DEAF_SPEAKER) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.markStatus(session);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.interestedIdleStatus == IdleStatus.BOTH_IDLE) &#123;</span><br><span class="line">                        session.setAttribute(<span class="keyword">this</span>.IGNORE_READER_IDLE_ONCE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resetStatus(session);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.handlePingTimeout(session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == IdleStatus.READER_IDLE &amp;&amp; session.removeAttribute(<span class="keyword">this</span>.IGNORE_READER_IDLE_ONCE) == <span class="keyword">null</span> &amp;&amp; session.containsAttribute(<span class="keyword">this</span>.WAITING_FOR_RESPONSE)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handlePingTimeout(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.forwardEvent) &#123;</span><br><span class="line">        nextFilter.sessionIdle(session, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）我们设置了setRequestInterval，每隔一定时间就会调用sessionIdle方法，该方法最主要的就是下面几句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object pingMessage = <span class="keyword">this</span>.messageFactory.getRequest(session);<span class="comment">//调用getRequest获得返回值</span></span><br><span class="line"><span class="keyword">if</span>(pingMessage != <span class="keyword">null</span>) &#123;                                        <span class="comment">//如果有返回值</span></span><br><span class="line">    nextFilter.filterWrite(session, <span class="keyword">new</span> DefaultWriteRequest(pingMessage));<span class="comment">//将该该返回值发送出去，因此该返回值表示的含义就是心跳请求包</span></span><br><span class="line">    …………                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>即如果getRequest方法设置了返回值，就会将该返回值发送出去，所以这个返回值的意义就是“心跳请求包”。</p>
<p>（2）客户端收到消息，会调用拦截器的messageReceived方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.messageFactory.isRequest(session, message)) &#123;<span class="comment">//我们在isRequest方法中判断接收到的是不是心跳请求包，如果是返回为true</span></span><br><span class="line">        Object pongMessage = <span class="keyword">this</span>.messageFactory.getResponse(session, message);<span class="comment">//然后调用getResponse方法获得返回值</span></span><br><span class="line">        <span class="keyword">if</span>(pongMessage != <span class="keyword">null</span>) &#123;                                                <span class="comment">//如果有返回值</span></span><br><span class="line">            nextFilter.filterWrite(session, <span class="keyword">new</span> DefaultWriteRequest(pongMessage));<span class="comment">//则将该返回值发送出去，因此该返回值的意义就是心跳回复包</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.messageFactory.isResponse(session, message)) &#123;<span class="comment">//我们在isResponse方法中判断接收到的是不是心跳回复包，如果是返回为true</span></span><br><span class="line">        <span class="keyword">this</span>.resetStatus(session);                        <span class="comment">//接收到了心跳回复包，需要重置状态，如重新开始计时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.isKeepAliveMessage(session, message)) &#123;<span class="comment">//该方法执行了一遍isRequest和isResponse，如果接收到的消息既不是心跳请求包，也不是回复包</span></span><br><span class="line">        nextFilter.messageReceived(session, message);<span class="comment">//则将该消息往下传递，即交给下个拦截器或者交给Handler的messageReceive方法处理</span></span><br><span class="line">    &#125;<span class="comment">//如果接收到的消息是心跳请求包“或者”心跳回复包，则在上面几句中就已经将该消息消费掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面还有一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            <span class="comment">//设置是否forward到下一个filter,默认为false</span></span><br><span class="line"><span class="comment">//            kaf.setForwardEvent(true);</span></span><br></pre></td></tr></table></figure>


<p>这句话的作用从源码中可以看出来，源码的sessionIdle方法后面有这么一段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.forwardEvent) &#123;</span><br><span class="line">    nextFilter.sessionIdle(session, status);<span class="comment">//如果设置为true，会将该状态往下传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>不知道大家还记不记得IoHandler里面也有sessionIdle方法，上面已经讲过，它的调用时机是通过setIdleTime来设置的，而setForwardEvent设置为false的话，则会将Idle事件拦截掉，不往下传递到IoHandle的sessionIdle，即该方法失效。</p>
<p>总的来说，就是设置了setRequestInterval的话，则设置setIdleTime将会失去意义。</p>
<p>以上是我的理解，如有谬误，恳请各位前辈指出。有不懂得也可以留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程和Mina入门</title>
    <url>/2018/07/23/tech-2018-07-23-Mina/</url>
    <content><![CDATA[<h1 id="网络编程的一些知识点"><a href="#网络编程的一些知识点" class="headerlink" title="网络编程的一些知识点"></a>网络编程的一些知识点</h1><ol>
<li>首先需要知道网络的几层架构，有好几种分类方式，如五层架构：物理层、数据链路层、网络层、传输层、应用层。其中IP是网络层协议，IP协议用于在互联网中找到对应的主机，TCP和UDP是传输层协议，应用层协议就很多了，最常用的就是HTTP协议。 </li>
<li>了解整个网络的过程是怎么样的很重要，以后学到的才可以一一对应进去。 </li>
<li>然后一些相关概念要掌握：ip、端口、协议、服务器、Socket（客户端、服务端等）、线程、阻塞、非阻塞、长连接、短连接、心跳机制（用于维持长连接的技术）、RPC（远程过程调用）、还有许多相关的协议。 </li>
</ol>
<h2 id="一些注意的点："><a href="#一些注意的点：" class="headerlink" title="一些注意的点："></a>一些注意的点：</h2><ol>
<li>TCP是传输层协议，主要用于建立连接。我们常说的Socket连接、Http连接等其实指的就是TCP连接。</li>
<li>网络是语言无关的，所以可以用两种不同的语言实现TCP连接，然后进行通信。</li>
<li>长连接和短连接是相对的：但都是TCP连接</li>
<li>对于HTTP协议，它是基于TCP/IP协议的。HTTP连接指的是TCP连接，TCP建立连接后，HTTP可以在这条连接上发出请求， 还有接受响应。因此HTTP连接叫做Http请求和Http响应更为合适。</li>
<li>HTTP1.0默认是短连接，即完成一次网络请求就断开连接（发出HTTP请求并且接受到响应的过程）。</li>
<li>HTTP1.1可以长连接，即客户端和服务端都不调用close方法。</li>
<li>UDP是无连接、不可靠的。不可靠是相对的：不保证传输的到，不保证按顺序到达，不保证错误重发等。不过可以通过代码控制来保证。</li>
</ol>
<h1 id="Mina入门"><a href="#Mina入门" class="headerlink" title="Mina入门"></a>Mina入门</h1><h2 id="Mina是什么？"><a href="#Mina是什么？" class="headerlink" title="Mina是什么？"></a>Mina是什么？</h2><p>Apache Mina是一个网络通信应用框架，实现了java NIO（非阻塞）技术，支持多种协议，能够帮助我们快速进行网络开发。 </p>
<p>除了mina框架外，还有netty框架。</p>
<h2 id="为什么要有Mina？"><a href="#为什么要有Mina？" class="headerlink" title="为什么要有Mina？"></a>为什么要有Mina？</h2><p>TCP和UDP较为高深。Socket对TCP和UDP的接口进行了封装，方便程序员使用，程序员可以通过socket 创建服务端和客户端，建立连接，进行通信。</p>
<p>但是使用Socket会有很多线程还有并发的问题需要解决（可以使用线程池，异步IO等方法），java NIO技术就是为了解决这些而提出的一套方案。</p>
<p>但是java NIO编程也很复杂，因此开发出了Mina框架，让我们能够快速的进行网络编程，而不用自己去实现一套NIO方案。Mina除了实现底层IO操作外，还支持多种协议的通信，总之是十分强大的一套框架。</p>
<p>在Mina之上还有一些第三方平台可以实现网络通讯功能，如融云等，当然借助第三方平台也受限于第三方平台。简单的项目用第三方平台是完全没问题的。</p>
<h2 id="Mina工作流程？"><a href="#Mina工作流程？" class="headerlink" title="Mina工作流程？"></a>Mina工作流程？</h2><p><img src="/images/Mina/mina01.png" alt="Mina流程"></p>
<ol>
<li><p>IoService：封装了IO操作，我们只需要使用即可，不需要自己实现异步和线程</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IoAcceptor和IoConnector都实现了IoService接口，其中</span><br><span class="line">	IoAcceptor创建服务端口，用于接受连接</span><br><span class="line">	IoConnector创建与服务端的连接</span><br></pre></td></tr></table></figure></li>
<li><p>IoFilterChain：过滤器/拦截器，对数据进行过滤或拦截，Mina自带许多封装好的过滤器，当然我们也可以自己实现</p>
</li>
<li><p>IoHandler：提供回调方法，我们只需要在里面实现业务逻辑。</p>
</li>
</ol>
<p>流程如图所示，因此我们编写代码也是按这个步骤。客户端和服务端代码基本相同，步骤如下：</p>
<ol>
<li>首先创建IoService</li>
<li>添加过滤器/拦截器IoFilterChain</li>
<li>实现IoHandler对数据进行业务逻辑处理</li>
</ol>
<h2 id="怎么用Mina？"><a href="#怎么用Mina？" class="headerlink" title="怎么用Mina？"></a>怎么用Mina？</h2><p>首先去<a href="%22http://mina.apache.org/downloads-mina.html%22">官网</a>下载mina包，导入这两个包（必须），Mina还有很多其他的包和功能，在这里就不介绍了，其实我也不会。 </p>
<p>Binaries是jar包，Sources是源码</p>
<p><img src="/images/Mina/mina02.png" alt="导入包"></p>
<h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第一步，新建accepter：服务端（等待客户端连接，所以命名为acceptor）</span></span><br><span class="line">            NioSocketAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">            <span class="comment">// 第二步，设置Handler，需要实现IOHandler接口，用于处理消息（主要有创建、连接、接收、发送、关闭、异常、闲置7个状态回调）</span></span><br><span class="line">            acceptor.setHandler(<span class="keyword">new</span> MinaServerHandler());</span><br><span class="line">            <span class="comment">// 第三步，设置拦截器</span></span><br><span class="line">            <span class="comment">//设置log拦截器</span></span><br><span class="line">            acceptor.getFilterChain().addLast(<span class="string">&quot;log&quot;</span>, <span class="keyword">new</span> LoggingFilter());</span><br><span class="line">            <span class="comment">//设定消息编码规则拦截器</span></span><br><span class="line">            acceptor.getFilterChain().addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory()));</span><br><span class="line">           <span class="comment">//添加socket配置</span></span><br><span class="line">            <span class="comment">/*设置读取数据缓冲区大小</span></span><br><span class="line"><span class="comment">            指定缓冲区大小以通知底层操作系统为读取的数据分配多少空间。*/</span></span><br><span class="line">            acceptor.getSessionConfig().setReadBufferSize(<span class="number">2048</span>);</span><br><span class="line">            <span class="comment">/*指定了什么时候检查空闲 session。</span></span><br><span class="line"><span class="comment">            第一个参数用于判断session是否闲置的条件</span></span><br><span class="line"><span class="comment">            有三个状态：1.不读取也不写入时判断为闲置，2.不读取时判断为闲置，3.不写入时判断为闲置，默认为2</span></span><br><span class="line"><span class="comment">            第二个参数表示session闲置时在10秒后调用Handler的sessionIdle方法。*/</span></span><br><span class="line">            acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 第四步，创建端口，等待连接，端口号2001，客户端需要连接到该端口</span></span><br><span class="line">            acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">2001</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaServerHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;<span class="comment">//Mina会自动调用这些方法，具体要在什么时候做什么需要自行实现</span></span><br><span class="line">    <span class="comment">//发生异常回调，可打印异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端捕捉：&quot;</span> + cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收到消息时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端消息接收：&quot;</span> + message.toString());</span><br><span class="line">        <span class="comment">//收到客户端消息为quit时，关闭该会话</span></span><br><span class="line">        <span class="keyword">if</span> (message.toString().trim().equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">            session.closeNow();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向客户端发送消息，会调用messageSent</span></span><br><span class="line">        session.write(<span class="string">&quot;回复消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送消息成功时调用，注意发送消息不能用这个方法，而是用session.write();</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端消息发送:&quot;</span> + message.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接断开时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接创建时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接闲置时调用，闲置状态通过setIdleTime第一个参数判断，调用频率通过setIdleTime第二个参数设置，这里是10s一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session闲置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接成功时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步，建立一个connecter</span></span><br><span class="line">        NioSocketConnector connecter = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        <span class="comment">// 第二步，设置消息处理的Handler，和服务端一模一样，实现IOHandler接口即可</span></span><br><span class="line">        connecter.setHandler(<span class="keyword">new</span> MinaClientHandler());</span><br><span class="line">        <span class="comment">// 第三步，设置拦截器，编码规则应该和服务端一样，即TextLineCodecFactory，除了mina自带的编码方式之外，还可以自己定义编码协议</span></span><br><span class="line">        connecter.getFilterChain().addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory()));</span><br><span class="line">        <span class="comment">// 第四步，连接服务器，127.0.0.1代表本机ip，2001是端口号</span></span><br><span class="line">        ConnectFuture future = connecter.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">2001</span>));</span><br><span class="line">        <span class="comment">// 阻塞直到和服务器连接成功</span></span><br><span class="line">        future.awaitUninterruptibly();</span><br><span class="line">        <span class="comment">//下面代码用于测试，从客户端控制台输入</span></span><br><span class="line">        BufferedReader inputReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in, <span class="string">&quot;utf-8&quot;</span>)); <span class="comment">// 从控制台读取的输入内容</span></span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span> (!(s = inputReader.readLine()).equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">                future.getSession().write(<span class="string">&quot;客户端发送消息：&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaClientHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端异常捕捉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端消息发送:&quot;</span> + message.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端session关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端session闲置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收消息：&quot;</span> + message.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，总共只要4个类就可实现简单的异步IO通讯，将客户端和服务端代码分别运行（先运行服务端，否则客户端可能会找不到端口），然后可以从客户端控制台输入，查看输出，理解各方法的调用时机。 </p>
<p>补充：看到Mina中的XXXFuture就说明这个方法是异步执行的</p>
<p>客户端的<code>future.awaitUninterruptibly();</code>相当于把异步执行转变为同步执行，因此在这个方法下面的其他语句是没法执行的。这是为了防止使用<code>future.getSession();</code>等方法时无法返回对象的情况</p>
<p>可以用下面的方法代替上面的阻塞方法，这个方法用于添加监听器，在异步执行结果返回时调用监听器中的回调方法，这个方法下面的语句是能正常执行的。future.getSession();的获取可以写在回调方法里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future.addListener(<span class="keyword">new</span> IoFutureListener&lt;IoFuture&gt;() &#123;<span class="comment">//异步执行直到结果返回时回调方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(IoFuture ioFuture)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里有一篇mina详解，讲的比较详细，有兴趣的朋友可以看这篇文章：<a href="http://tbstone.iteye.com/blog/1976487">mina框架详解</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一次写博客，表达可能不是很到位，排版和字体大小应该也有问题，希望大家多多担待和支持。</p>
<p>下一篇将介绍如何用mina框架进行心跳检测。</p>
<p>以上是我自己的一些理解，如有谬误，恳请各位前辈指出！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程和Mina入门</title>
    <url>/2018/07/23/tech-2018-07-23-JavaNetBase-Mina/</url>
    <content><![CDATA[<h1 id="网络编程的一些知识点"><a href="#网络编程的一些知识点" class="headerlink" title="网络编程的一些知识点"></a>网络编程的一些知识点</h1><ol>
<li>首先需要知道网络的几层架构，有好几种分类方式，如五层架构：物理层、数据链路层、网络层、传输层、应用层。其中IP是网络层协议，IP协议用于在互联网中找到对应的主机，TCP和UDP是传输层协议，应用层协议就很多了，最常用的就是HTTP协议。 </li>
<li>了解整个网络的过程是怎么样的很重要，以后学到的才可以一一对应进去。 </li>
<li>然后一些相关概念要掌握：ip、端口、协议、服务器、Socket（客户端、服务端等）、线程、阻塞、非阻塞、长连接、短连接、心跳机制（用于维持长连接的技术）、RPC（远程过程调用）、还有许多相关的协议。 </li>
</ol>
<h2 id="一些注意的点："><a href="#一些注意的点：" class="headerlink" title="一些注意的点："></a>一些注意的点：</h2><ol>
<li>TCP是传输层协议，主要用于建立连接。我们常说的Socket连接、Http连接等其实指的就是TCP连接。</li>
<li>网络是语言无关的，所以可以用两种不同的语言实现TCP连接，然后进行通信。</li>
<li>长连接和短连接是相对的：但都是TCP连接</li>
<li>对于HTTP协议，它是基于TCP/IP协议的。HTTP连接指的是TCP连接，TCP建立连接后，HTTP可以在这条连接上发出请求， 还有接受响应。因此HTTP连接叫做Http请求和Http响应更为合适。</li>
<li>HTTP1.0默认是短连接，即完成一次网络请求就断开连接（发出HTTP请求并且接受到响应的过程）。</li>
<li>HTTP1.1可以长连接，即客户端和服务端都不调用close方法。</li>
<li>UDP是无连接、不可靠的。不可靠是相对的：不保证传输的到，不保证按顺序到达，不保证错误重发等。不过可以通过代码控制来保证。</li>
</ol>
<h1 id="Mina入门"><a href="#Mina入门" class="headerlink" title="Mina入门"></a>Mina入门</h1><h2 id="Mina是什么？"><a href="#Mina是什么？" class="headerlink" title="Mina是什么？"></a>Mina是什么？</h2><p>Apache Mina是一个网络通信应用框架，实现了java NIO（非阻塞）技术，支持多种协议，能够帮助我们快速进行网络开发。 </p>
<p>除了mina框架外，还有netty框架。</p>
<h2 id="为什么要有Mina？"><a href="#为什么要有Mina？" class="headerlink" title="为什么要有Mina？"></a>为什么要有Mina？</h2><p>TCP和UDP较为高深。Socket对TCP和UDP的接口进行了封装，方便程序员使用，程序员可以通过socket 创建服务端和客户端，建立连接，进行通信。</p>
<p>但是使用Socket会有很多线程还有并发的问题需要解决（可以使用线程池，异步IO等方法），java NIO技术就是为了解决这些而提出的一套方案。</p>
<p>但是java NIO编程也很复杂，因此开发出了Mina框架，让我们能够快速的进行网络编程，而不用自己去实现一套NIO方案。Mina除了实现底层IO操作外，还支持多种协议的通信，总之是十分强大的一套框架。</p>
<p>在Mina之上还有一些第三方平台可以实现网络通讯功能，如融云等，当然借助第三方平台也受限于第三方平台。简单的项目用第三方平台是完全没问题的。</p>
<h2 id="Mina工作流程？"><a href="#Mina工作流程？" class="headerlink" title="Mina工作流程？"></a>Mina工作流程？</h2><p><img src="/2018/07/23/tech-2018-07-23-JavaNetBase-Mina/mina01.png" alt="Mina流程"></p>
<ol>
<li><p>IoService：封装了IO操作，我们只需要使用即可，不需要自己实现异步和线程</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IoAcceptor和IoConnector都实现了IoService接口，其中</span><br><span class="line">	IoAcceptor创建服务端口，用于接受连接</span><br><span class="line">	IoConnector创建与服务端的连接</span><br></pre></td></tr></table></figure></li>
<li><p>IoFilterChain：过滤器/拦截器，对数据进行过滤或拦截，Mina自带许多封装好的过滤器，当然我们也可以自己实现</p>
</li>
<li><p>IoHandler：提供回调方法，我们只需要在里面实现业务逻辑。</p>
</li>
</ol>
<p>流程如图所示，因此我们编写代码也是按这个步骤。客户端和服务端代码基本相同，步骤如下：</p>
<ol>
<li>首先创建IoService</li>
<li>添加过滤器/拦截器IoFilterChain</li>
<li>实现IoHandler对数据进行业务逻辑处理</li>
</ol>
<h2 id="怎么用Mina？"><a href="#怎么用Mina？" class="headerlink" title="怎么用Mina？"></a>怎么用Mina？</h2><p>首先去<a href="%22http://mina.apache.org/downloads-mina.html%22">官网</a>下载mina包，导入这两个包（必须），Mina还有很多其他的包和功能，在这里就不介绍了，其实我也不会。 </p>
<p>Binaries是jar包，Sources是源码</p>
<p><img src="/2018/07/23/tech-2018-07-23-JavaNetBase-Mina/mina02.png" alt="导入包"></p>
<h3 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第一步，新建accepter：服务端（等待客户端连接，所以命名为acceptor）</span></span><br><span class="line">            NioSocketAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">            <span class="comment">// 第二步，设置Handler，需要实现IOHandler接口，用于处理消息（主要有创建、连接、接收、发送、关闭、异常、闲置7个状态回调）</span></span><br><span class="line">            acceptor.setHandler(<span class="keyword">new</span> MinaServerHandler());</span><br><span class="line">            <span class="comment">// 第三步，设置拦截器</span></span><br><span class="line">            <span class="comment">//设置log拦截器</span></span><br><span class="line">            acceptor.getFilterChain().addLast(<span class="string">&quot;log&quot;</span>, <span class="keyword">new</span> LoggingFilter());</span><br><span class="line">            <span class="comment">//设定消息编码规则拦截器</span></span><br><span class="line">            acceptor.getFilterChain().addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory()));</span><br><span class="line">           <span class="comment">//添加socket配置</span></span><br><span class="line">            <span class="comment">/*设置读取数据缓冲区大小</span></span><br><span class="line"><span class="comment">            指定缓冲区大小以通知底层操作系统为读取的数据分配多少空间。*/</span></span><br><span class="line">            acceptor.getSessionConfig().setReadBufferSize(<span class="number">2048</span>);</span><br><span class="line">            <span class="comment">/*指定了什么时候检查空闲 session。</span></span><br><span class="line"><span class="comment">            第一个参数用于判断session是否闲置的条件</span></span><br><span class="line"><span class="comment">            有三个状态：1.不读取也不写入时判断为闲置，2.不读取时判断为闲置，3.不写入时判断为闲置，默认为2</span></span><br><span class="line"><span class="comment">            第二个参数表示session闲置时在10秒后调用Handler的sessionIdle方法。*/</span></span><br><span class="line">            acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 第四步，创建端口，等待连接，端口号2001，客户端需要连接到该端口</span></span><br><span class="line">            acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">2001</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaServerHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;<span class="comment">//Mina会自动调用这些方法，具体要在什么时候做什么需要自行实现</span></span><br><span class="line">    <span class="comment">//发生异常回调，可打印异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端捕捉：&quot;</span> + cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收到消息时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端消息接收：&quot;</span> + message.toString());</span><br><span class="line">        <span class="comment">//收到客户端消息为quit时，关闭该会话</span></span><br><span class="line">        <span class="keyword">if</span> (message.toString().trim().equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">            session.closeNow();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向客户端发送消息，会调用messageSent</span></span><br><span class="line">        session.write(<span class="string">&quot;回复消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送消息成功时调用，注意发送消息不能用这个方法，而是用session.write();</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端消息发送:&quot;</span> + message.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接断开时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接创建时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接闲置时调用，闲置状态通过setIdleTime第一个参数判断，调用频率通过setIdleTime第二个参数设置，这里是10s一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端session闲置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接成功时回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步，建立一个connecter</span></span><br><span class="line">        NioSocketConnector connecter = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        <span class="comment">// 第二步，设置消息处理的Handler，和服务端一模一样，实现IOHandler接口即可</span></span><br><span class="line">        connecter.setHandler(<span class="keyword">new</span> MinaClientHandler());</span><br><span class="line">        <span class="comment">// 第三步，设置拦截器，编码规则应该和服务端一样，即TextLineCodecFactory，除了mina自带的编码方式之外，还可以自己定义编码协议</span></span><br><span class="line">        connecter.getFilterChain().addLast(<span class="string">&quot;codec&quot;</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory()));</span><br><span class="line">        <span class="comment">// 第四步，连接服务器，127.0.0.1代表本机ip，2001是端口号</span></span><br><span class="line">        ConnectFuture future = connecter.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">2001</span>));</span><br><span class="line">        <span class="comment">// 阻塞直到和服务器连接成功</span></span><br><span class="line">        future.awaitUninterruptibly();</span><br><span class="line">        <span class="comment">//下面代码用于测试，从客户端控制台输入</span></span><br><span class="line">        BufferedReader inputReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in, <span class="string">&quot;utf-8&quot;</span>)); <span class="comment">// 从控制台读取的输入内容</span></span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span> (!(s = inputReader.readLine()).equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">                future.getSession().write(<span class="string">&quot;客户端发送消息：&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaClientHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端异常捕捉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端消息发送:&quot;</span> + message.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端session关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端session闲置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收消息：&quot;</span> + message.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，总共只要4个类就可实现简单的异步IO通讯，将客户端和服务端代码分别运行（先运行服务端，否则客户端可能会找不到端口），然后可以从客户端控制台输入，查看输出，理解各方法的调用时机。 </p>
<p>补充：看到Mina中的XXXFuture就说明这个方法是异步执行的</p>
<p>客户端的<code>future.awaitUninterruptibly();</code>相当于把异步执行转变为同步执行，因此在这个方法下面的其他语句是没法执行的。这是为了防止使用<code>future.getSession();</code>等方法时无法返回对象的情况</p>
<p>可以用下面的方法代替上面的阻塞方法，这个方法用于添加监听器，在异步执行结果返回时调用监听器中的回调方法，这个方法下面的语句是能正常执行的。future.getSession();的获取可以写在回调方法里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future.addListener(<span class="keyword">new</span> IoFutureListener&lt;IoFuture&gt;() &#123;<span class="comment">//异步执行直到结果返回时回调方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(IoFuture ioFuture)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里有一篇mina详解，讲的比较详细，有兴趣的朋友可以看这篇文章：<a href="http://tbstone.iteye.com/blog/1976487">mina框架详解</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一次写博客，表达可能不是很到位，排版和字体大小应该也有问题，希望大家多多担待和支持。</p>
<p>下一篇将介绍如何用mina框架进行心跳检测。</p>
<p>以上是我自己的一些理解，如有谬误，恳请各位前辈指出！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Jekyll-博客工具</title>
    <url>/2018/07/15/blog-2018-07-15-Jekyll/</url>
    <content><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul>
<li><code>_config.yml</code>：这个文件是为了保存配置的。也可用命令行配置</li>
<li><code>_includes</code>：这里面的就是可以重复利用的文件。这个文件可以被其他的文件包含，重复利用。相当于网页的include，如header，footer等</li>
<li><code>_layout</code>：存放网页的模板文件</li>
<li><code>_posts</code>：存放具体的博客文章。文件必须为<code>year-month-date-title.markup</code>的格式。文件格式可以是md，html等、</li>
<li><code>_site</code>：这个文件夹存放的是最终生成的文件。 编译器生成，建议放到.gitignore里</li>
</ul>
<p>Jekyll运行会遍历所有的文件，进行解析生成文件。</p>
<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>将工程上传到GitHub上即可访问，但是每次写好博客都需要上传访问，太麻烦，可以先在本地调试。</p>
<p>本地调试需要安装环境：Ruby+Devkit+Jekyll</p>
<p>下载安装包不用配置环境变量。官方提供了ruby和devkit合成的安装包：<a href="https://rubyinstaller.org/downloads/">下载地址</a></p>
<p><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll01.png" alt="jekyll01"></p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li>指定安装路径，勾选use UTF-8<br><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll02.png" alt="jekyll02"></li>
<li>勾选MSYS2<br><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll03.png" alt="jekyll03"></li>
<li>点击finish<br><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll04.png" alt="jekyll04"></li>
<li>自动弹出命令行，输入1，等待安装成功<br><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll05.png" alt="jekyll05"></li>
<li>安装jekyll：打开dos，输入gem install jekyll，等待安装完成</li>
<li>安装完成后输入jekyll -v，出现版本号说明安装成功</li>
<li>安装bundle：在dos中输入gem install bundle，等待安装完成</li>
<li>dos中切换到工程目录，执行jekyll serve或者jekyll build即可运行</li>
<li>浏览器中输入localhost:4000访问</li>
</ol>
<h1 id="运行过程中出错记录"><a href="#运行过程中出错记录" class="headerlink" title="运行过程中出错记录"></a>运行过程中出错记录</h1><ul>
<li><p>提示将_config.yml文件的gem:改成plugins:</p>
</li>
<li><p>提示缺少依赖，需要安装，根据具体情况安装，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install jekyll-sitemap</span><br><span class="line">gem install jekyll-seo-tag</span><br><span class="line">gem install jekyll-feed</span><br></pre></td></tr></table></figure></li>
<li><p>不允许出现中文名，可能出现下面的情况：</p>
<ol>
<li>运行起来之后访问不到文章：文章文件带中文名</li>
</ol>
<p><code>[2018-07-15 16:42:37] ERROR &#39;/2018/07/15/ELK数据分析.html&#39; not found.</code></p>
<ol start="2">
<li>也可能在编译时就出错无法运行：检查是否有文件包含中文名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Liquid Exception: Liquid error (line 13): invalid byte sequence in UTF-8 in sitemap.xml</span><br><span class="line">             Error: Liquid error (line 13): invalid byte sequence in UTF-8</span><br><span class="line">             Error: Run jekyll build --trace for more information.</span><br></pre></td></tr></table></figure></li>
<li><p>如果博客文章中出现jekyll的语法，也会被解析，可能会导致报错：</p>
<p>在文章中使用了这一句，jekyll进行了解析</p>
<p><img src="/2018/07/15/blog-2018-07-15-Jekyll/jekyll07.png" alt="jekyll07"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Liquid Exception: Could not locate the included file &#39;file.ext&#39; in any of</span><br><span class="line">[&quot;E:&#x2F;GitPageBlog&#x2F;moon-lights.github.io&#x2F;includes&quot;]. Ensure it exists in one of those directories </span><br><span class="line">and, if it is a symlink, does not point outside your site source. in E:&#x2F;GitPageBlog&#x2F;moon-</span><br><span class="line">lights.github.io&#x2F;posts&#x2F;tool&#x2F;2018-7-15-Jekyll.md</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>参考资料</p>
<ul>
<li><a href="https://www.cnblogs.com/zjjDaily/p/8695978.html">使用Github pages+jekyll搭建自己的博客（windows版）</a></li>
<li><a href="https://www.jianshu.com/p/ffbbed22f984">Jekyll使用篇 1 - 发布文章、加入评论功能、加入Google Analytics</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/jekyll/">Jekyll教程_Jekyll开发中文手册[PDF]下载-极客学院Wiki</a></li>
<li><a href="http://ju.outofmemory.cn/entry/98471">Jekyll 语法简单笔记</a></li>
<li><a href="https://www.jekyll.com.cn/docs/home/">Jekyll官网</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch+Logstash+Kibana</title>
    <url>/2018/07/15/tool-2018-07-15-ELK/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ol>
<li>Elasticsearch：后台分布式存储以及全文检索</li>
<li>Logstash: 日志加工、“搬运工” </li>
<li>Kibana：数据可视化展示。</li>
</ol>
<p>Logstash(收集服务器上的日志文件)<br>保存到 ElasticSearch(搜索引擎)<br>Kibana提供友好的web界面(从ElasticSearch读取数据进行展示)</p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>实现后台分布式存储以及全文检索<br>（全文检索就是对一篇文章进行索引，可以根据关键字搜索）</p>
<p>elasticsearch基于lucene的搜索服务器，lucene是一个库，elastic对其进行了封装，减少复杂度。<br>elasticsearch可以检索数据，返回统计结果，速度快。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><p>Cluster ：集群。</p>
<p>多个搜索服务器的集合</p>
</li>
<li><p>Node：节点。</p>
<p>组成集群的单个服务器</p>
</li>
<li><p>Shard：分片。</p>
<p>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。 </p>
<p>当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的</p>
</li>
<li><p>Replia：副本。</p>
<p>为提高查询吞吐量或实现高可用性，可以使用分片副本。<br>副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。<br>当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p>
</li>
</ul>
<h3 id="对应数据库概念"><a href="#对应数据库概念" class="headerlink" title="对应数据库概念"></a>对应数据库概念</h3><p><img src="/2018/07/15/tool-2018-07-15-ELK/ElasticSearch.jpg" alt="Elastic概念对应数据库"></p>
<h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>Kibana 是一个开源分析和可视化平台，旨在可视化操作 Elasticsearch 。Kibana可以用来搜索，查看和与存储在 Elasticsearch 索引中的数据进行交互。可以轻松地进行高级数据分析，并可在各种图表，表格和地图中显示数据。</p>
<p> Kibana 可以轻松理解海量数据。其简单的基于浏览器的界面使您能够快速创建和共享动态仪表板，实时显示 Elasticsearch 查询的更改。</p>
<p>安装Kibana简单快速。您可以安装 Kibana ，并在几分钟内开始探索您的 Elasticsearch 索引 - 不需要代码，也不需要需额外的基础架构。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>静态代码分析平台SonarQube</title>
    <url>/2018/07/14/tool-2018-07-14-SonarQube/</url>
    <content><![CDATA[<h2 id="Sonar是什么？"><a href="#Sonar是什么？" class="headerlink" title="Sonar是什么？"></a>Sonar是什么？</h2><p>SonarQube(以前叫Sonar)是持续检测代码质量的开源平台<br>静态代码分析工具、代码质量检测工具<br>支持不同编程语言</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>作为一个代码分析平台，Sonar由以下三个部分组成：</p>
<ol>
<li>数据库：存放配置信息和分析结果信息；</li>
<li>一个Web服务器：建立工程，在线浏览分析结果，配置分析规则；</li>
<li>客户端、分析端：执行源代码分析；</li>
</ol>
<p>服务端和客户端有多种搭配方式<br>sonarqube + sonar-runner<br>/sonar-scanner<br>sonarqube + maven<br>sonarqube + IDE     如：IntelliJ、android studio、eclipse</p>
<p>sonar的命令行分析端软件有两种分别是Runner和Scanner，官网文档中写的是Scanner，但Runner和它安装、使用都基本一致。</p>
<p>客户端分析代码后将结果显示在服务端（浏览器），也可以存到数据库中，服务端可以部署在本地部署到远程<br>本地默认端口为localhost:9000</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;在SonarQube平台创建工程，设置ProjectName和ProjectKey</span><br><span class="line"></span><br><span class="line">&gt;在本地需要扫描的工程目录下创建sonar-project.properties，内容如下：</span><br><span class="line">&gt;sonar.projectKey&#x3D;project_key </span><br><span class="line">&gt;sonar.projectName&#x3D;project_name </span><br><span class="line">&gt;sonar.projectVersion&#x3D;1.0 </span><br><span class="line">&gt;sonar.sources&#x3D;.&#x2F; </span><br><span class="line">&gt;sonar.language&#x3D;py &#x2F;&#x2F;需要扫描哪种语言的代码，如python:py，java:java</span><br><span class="line">&gt;sonar.sourceEncoding&#x3D;UTF-8 </span><br><span class="line">&gt;sonar.host.url&#x3D;http:&#x2F;&#x2F;your_host:your_port&#x2F;[your_prefix] </span><br><span class="line"></span><br><span class="line">&gt;执行sonar-scanner -X 命令，结果会上传到SonarQube平台</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>我们做好朋友吧</title>
    <url>/2018/04/14/personal-2018-04-14-AsJoker/</url>
    <content><![CDATA[<h2 id="动漫梗"><a href="#动漫梗" class="headerlink" title="动漫梗"></a>动漫梗</h2><ul>
<li>凯多：你刚说要当什么王来着？<ul>
<li>——大哥，你听错了，我是海贼，叫王路飞。</li>
<li>王路飞：在叫我？</li>
</ul>
</li>
<li>雷利：我把One Piece告诉索隆了，你们去找他把。<ul>
<li>索隆：我带你们去吧。</li>
</ul>
</li>
<li>天空一声巨响，主角闪亮登场。<ul>
<li>黄猿闪亮登场。</li>
</ul>
</li>
<li>护夫狂魔汉库克已上线。</li>
<li>卡二指着太平洋对路飞说：看见了嘛，这是我对你放的水。</li>
<li>最快的果实给了最懒得人，最热的果实给了心最冷的人，最冷的果实给了心最热的人。</li>
<li>隔壁都写到下一代海贼王了。</li>
<li>桌前的尾田显得弱小，可怜又无助。他呆呆地坐在椅子上，没错，又到了交稿地日期。突然，手机发出了熟悉地“叮”的一声，尾田拿起手机激动的爆了句粗口：<code>QQ</code>看点的小编终于更新了！</li>
<li>但是赤犬忍了，他要留在海军去执行他心中的正义，他要是不忍，别的不说，打个路奇还是挺简单的。<ul>
<li>黄猿起码还是很听话的。</li>
</ul>
</li>
<li>我老沙谁都不服，和谁都五五开。</li>
<li>黄猿：三年又三年，一转眼三十年过去了，龙你再不来救我我就要当上元帅了。</li>
<li>冯克雷用右手摸别人的脸蛋就能变成那个人，用左手摸一下自己的脸蛋就能变回去<ul>
<li>要是摸了红发，没手变不会去怎么办</li>
</ul>
</li>
<li>柯拉松也许会迟到，但它永远不会缺席<ul>
<li>已经到了，还转发了。</li>
</ul>
</li>
<li>顶上战争被打到叫爸爸的男人——马歇尔·D·蒂奇<ul>
<li>原谅我不厚道的笑了。</li>
</ul>
</li>
<li>巴基可是顶上战争开直播的男人。<ul>
<li>谁都打不过，跟谁都过两招。</li>
<li>网红鼻祖。</li>
<li>正是在下。</li>
<li>凯多送出了一个飞机。</li>
<li>大妈/罗杰/路飞/送出了一个穿云箭/玫瑰花。</li>
<li>罗杰船上估计只有巴基没有霸王色霸气，但他有霸王色运气。</li>
</ul>
</li>
<li>什么叫做烂尾，海贼王的船上有5个霸王色怎么了，怎么滴，你进清华北大里面不个个是大佬。</li>
<li>三将星之耻：斯慕吉。失踪、拔剑、榨果汁。<ul>
<li>九亿悬赏，八亿的腿</li>
<li>有事找库栗，没事找慕吉</li>
<li>斯慕吉：我不划水，三将星就死光了啊</li>
<li>斯慕吉：喂，谁快来阻止贝基他们啊</li>
</ul>
</li>
<li>基德：老弟我跟你说，真不是兄弟我若，咱几个谁来都一样。<ul>
<li>路飞：以前兄弟我不信你，直到那个狼牙棒过来的时候。</li>
</ul>
</li>
<li>你看的山贼王吧。<ul>
<li>——海军王。</li>
</ul>
</li>
<li>罗杰、白胡子：卡普，我当你兄弟，你却让我儿子叫你爷爷。</li>
<li>我是吃了人人果实的车，我的能力是没有中间商赚差价<ul>
<li>我是吃了鱼鱼果实的能力者，我的能力是可以变成鱼但是不能上岸，果实副作用是不能游泳</li>
<li>翻车鱼</li>
</ul>
</li>
<li>过年了，龙召集卧底们聚餐。那一日，红狗自己在空无一人的海军总部吃的年夜饭</li>
<li>铁骨铮铮王境泽，新人罗杰布鲁克，北大还行撒贝宁，区区四皇老甚平</li>
<li>莫利亚和凯多<ul>
<li>东海提督克里克可是曾经和五皇草帽分庭抗礼的。</li>
<li>这和角都在千里之外朝柱间扔了个手里剑有什么分别吗？<ul>
<li>上个打败我的，可是初代火影。</li>
</ul>
</li>
<li>没有剪刀的莫利亚是怎么玩的。</li>
<li>就是被甚平一拳打飞的那个呗，我当时看一位琦玉老师走错片场了呢。</li>
</ul>
</li>
<li>自从看了海贼王，我不抽烟了，酒不喝了，每天三餐营养均衡搭配，早睡早起，每天起来晨跑，就tm为了比尾田多活几天。</li>
<li>昨天我用明哥的步伐，还有黄猿的表情，学着斯莫格抽烟，去校长办公室，用白胡子和红发的台词，说了一句：给我个面子，做我儿子吧。后来我有了红发的胳膊，青雉的腿，藤虎的眼睛和黑胡子的牙<ul>
<li>醒醒，别做梦了</li>
</ul>
</li>
<li>如果你在一座荒岛上，让你选择一颗恶魔果实，你会选择哪个恶魔果实<ul>
<li>问题来了，我为什么会在荒岛上？<ul>
<li>造化钟神秀</li>
<li>阴阳割昏晓</li>
</ul>
</li>
<li>我选好了，去哪里领？是快递送到家还是去批发领还是政府统一发？</li>
<li>冰冻果实在海上造路</li>
<li>我还是想要袁世凯夺取的革命果实</li>
</ul>
</li>
<li>黄猿翘班闪现去月球旅游，刚好碰到正在考古的艾尼路。两人相见都吓得要死，立刻打了起来，随后发现都是能力者就停手了。黄猿：你是电？艾尼路：你是光？<ul>
<li>你是唯一的神话</li>
<li>你是秀儿吗</li>
</ul>
</li>
<li>瓦尔波是唯一比路飞能吃的<ul>
<li>大妈小时候吃到没朋友</li>
</ul>
</li>
<li>早就看出来鼬神要灭族了，因为全宇智波族唯有鼬神用的飘柔<ul>
<li>鼬神已经看透了那些杀马特</li>
<li>其他全是拉芳</li>
</ul>
</li>
<li>初代：四代你咋死的？<ul>
<li>四代：封印九尾死的</li>
<li>初代：啥？那玩意能死人？</li>
<li>四代：闭嘴，再问劳资打死你？</li>
<li>初代：我让你两只手</li>
<li>四代：有本事让我1002个（初代千手）</li>
<li>四代用的是查克拉，初代是查吨拉<ul>
<li>查纳拉，查微拉，查毫克拉</li>
</ul>
</li>
</ul>
</li>
<li>鼬：晓这衣服真难受，火遁还要伸脖子<ul>
<li>卡卡西口罩火遁都没说什么</li>
</ul>
</li>
<li>下一代火影应该是木叶丸吧<ul>
<li>必须的！他师傅是火影，师傅的爸爸也是火影，他师傅的老师也是火影，他爷爷也是火影，他爷爷的徒弟也是火影，他爷爷的徒弟的爷爷也是火影，他爷爷的徒弟的爷爷的弟弟也是火影，不让他当火影合适吗？</li>
<li>火影都是关系户</li>
<li>历史课代表</li>
<li>六代帝皇丸</li>
</ul>
</li>
<li>斑：因为你喜欢木遁，所以我起名木叶村<ul>
<li>柱间：因为你喜欢火，所以我起名火影</li>
</ul>
</li>
<li>水门：论实力鼬不一定打得过我，论资历我比她高。论天赋，我的天赋曾经震惊忍界，为什么他能称神。<ul>
<li>岸本：那你以后叫门神</li>
<li>水神，风神，波神</li>
</ul>
</li>
<li>房子漏水了，把宇智波止水叫来，宇智波止不了，叫宇智波带土来淹，土淹不了，证明宇智波鼬失败了，这时候宇智波佐助着拐杖，想移走宇智波富岳这座大山来挡水，可是他移不动，宇智波斑得动，大家都不信，只有宇智波信</li>
<li>初代：三代你又是咋死的？<ul>
<li>三代：我咋死的你心里没点bi数</li>
</ul>
</li>
<li>打辉夜的时候，一乐：鸣人记住你只有一次机会，如果你失败了，我就会秒了他<ul>
<li>一乐：现在的小孩都不吃拉面了，这样的世界毁了算了</li>
<li>一乐：现在的孩子都不吃拉面了，鸣人我要创造一个为你存在的世界，开启9勾玉轮回眼，无限月读</li>
</ul>
</li>
<li>旗木五五开、旗木猹猹西（闰土）</li>
<li>此生无悔入火影，来世愿生木叶村</li>
<li>木叶飞舞之处，火亦生生不息。</li>
<li>整个火影故事里，有人相信血统，有人相信精神，有人相信身体，有人相信眼睛，有人相信先天传承，有人相信后天努力。只有大蛇丸，他相信科学。</li>
<li>第四次忍界大战后，鸣人参加合营考试之前先参加中忍考试，一群规则是不允许开仙人模式，于是鸣人身后默默地升起来几个求道玉。</li>
<li>佩恩杀的自来也，和我长门有什么关系呢<ul>
<li>你抓鲁迅跟我周树人有什么关系</li>
<li>你抓佩恩跟我长门有什么关系</li>
</ul>
</li>
<li>小李用努力证明了，在一群挂逼面前什么都不是<ul>
<li>佐助证明了，只要充钱就能变强</li>
<li>大招一开封号八百集</li>
</ul>
</li>
<li>天晴了，雨停了，二柱子觉得自己又行了。<ul>
<li>天阴了，下雨了，二柱子一瘸一拐地回来了</li>
<li>放最狠的话，挨最毒的打</li>
</ul>
</li>
<li>赢了当村长，输了娶小樱</li>
<li>看火影那么多年，才知道。晓组织的十叛忍：佩恩，迪达拉，小南，鼬，绝，带土，鬼鲛，角都，飞段，蝎。代表了人类的十个梦想：和平，艺术，友情，亲情，统治，爱情，力量，金钱，宗教，童年。<ul>
<li>晓组织的十叛忍：佩恩，迪达拉，小南，鼬，绝，带土，鬼鲛，角都，飞段，蝎。代表了工科生的十个梦想：通信工程，爆破工程，材料工程，工程热力学，基因工程，运输工程，水利工程，医药工程，社会工程，机械工程。还有曾经加入晓的大蛇丸和佐助，代表了生物工程和电子工程。</li>
</ul>
</li>
<li>游龙当归海，还不迎我自来也。猛虎当归山，山不迎我大豪杰，云鹤当归天，天不迎我妙木仙。</li>
<li>火影里有个人，他光棍节出生，一辈子不顺，被自己亲手教的徒弟杀死，尸体沉入大海。差一点能跟女神在一起，差一点就可以看到徒弟成为火影，就连火影完结日也没能赶上，11.10日火影完结日的后一天，就是他的生日，他叫自来也，总是差一点点就能圆满。</li>
<li>博人问鸣人：爸爸，你年轻的时候干了什么伟大的事啊？<ul>
<li>鸣人：我用了15年，帮我曾经最喜欢的女生追回了她的丈夫</li>
<li>博人：那妈妈呢？</li>
<li>鸣人眼里光线都温柔了：妈妈坚持到了我爱她的那一天</li>
</ul>
</li>
<li>川木袭击木叶<ul>
<li>那家伙不在的话，村子里能装逼的，就只有我了</li>
<li>卡卡西在疯狂想带土的账号和密码</li>
</ul>
</li>
<li>一天，佐良娜对佐助说：爸爸，爸爸我也要万花筒写轮眼。佐助没办法，去找大蛇丸秽土转生了鼬，佐助告诉了鼬，然后鼬一巴掌呼死了佐助，对佐良娜说：愚蠢的侄女啊，憎恨我把……</li>
<li>斑：你tm也想起舞吗？<ul>
<li>斑：一脚踹开棺材门，左边看一眼右边看一眼。心想：柱间不在，劳资可以装逼了。</li>
<li>斑：你见过我全盛时期得样子吗？柱间：不仅见过，我还锤过。斑：你也想起舞？柱间：我甚至想蹦迪！</li>
</ul>
</li>
<li>木叶谁都可以惹，上忍随便虐，火影也可以玩，但是千万不要去惹下忍</li>
<li>都tm别惹我，我看了900多集柯南，精通两千多种杀人手法，了解800多种不在场证明，上一个不给我点赞的已经凉了，你们自己看着办吧，为了让更多的人了解我的可怕，送我上去</li>
<li>一袋米要扛几楼（感受痛楚吧），一袋米要扛两楼（思考痛楚吧），一袋米又给多了（接受痛苦吧），一袋米有稀泥（理解痛楚吧），苦苦有泥（现在开始），谁给你一袋米哦（让世界感受痛楚），辛辣天森（神罗天征）<ul>
<li>为了一袋米毁灭世界的人</li>
</ul>
</li>
<li>名声，力量，曾拥有电瓶世界一切的男人偷车王切格·D·周某，在入狱前的一句话让全世界人们奔向停车场，我把所有的电瓶车都放在那里了，于是让世界迎接大偷车时代，偷车王，老子当定了</li>
<li>奥特曼为什么不一开始就放死光？<ul>
<li>你斗地主一开始就放王炸？</li>
</ul>
</li>
<li>吃你们饭的是姚麟，和我古力德（贪婪）有什么关系？</li>
<li>这叫留一手（爱德华，姚麟被吃进暴食肚子里，带了阿尔一只手）</li>
<li>下雨=无能</li>
<li>金伯利：带着四个演员怎么打（钢炼）</li>
<li>懒惰最勤奋，暴怒最冷静</li>
<li>认爹大军，（父亲大人）</li>
<li>星爵才是真的牛逼，银护一打养父，银护二打生父，复联34打岳父，他才是真正的灭爸，真父愁者~</li>
<li>雷神上赛季出一把黑切拿了败方MVP，这赛季想出肉带飞全场，没想到钢铁侠顶着被封号的压力开外挂秒杀全场，导致美队心态爆炸宣布退游。</li>
<li>复联一，有鹰眼，赢了。复联二，有鹰眼，赢了。复联三，没鹰眼，输了。复联四，有鹰眼，赢了。这个故事告诉我们，打团不能没有射手<ul>
<li>复联1，浩克上了，赢了，复联2，浩克上了，赢了，复联3，浩克没上，输了。复联4，浩克上了，赢了。这个故事告诉我们，打团坦克不能怂</li>
</ul>
</li>
</ul>
<h2 id="沙雕网友使我快乐"><a href="#沙雕网友使我快乐" class="headerlink" title="沙雕网友使我快乐"></a>沙雕网友使我快乐</h2><ul>
<li><p>我现在还不知道如何回答你的问题， 但是总有一天我会回答它， 只要答案真的存在，我就会将其抓住， 比起等我回答更重要的是相信自己的力量。</p>
</li>
<li><p>周瑜死后，诸葛亮非常伤心的参加了周瑜的葬礼。但是诸葛亮死后，周瑜为什么没有参加诸葛亮的葬礼。由此可见周瑜妒忌怨恨，此人心中狭隘。</p>
</li>
<li><p>算命先生：你算什么东西？</p>
<ul>
<li>配钥师：你配吗？配几把？</li>
</ul>
</li>
<li><p>日本的文化给我感觉就是我的杀父仇人有个貌美如花的女儿</p>
</li>
<li><p>多年前有个笑话研究报告。说是蜘蛛听觉在脚上。实验过程是这样的：对着蜘蛛大吼一声，蜘蛛跑开了，同一只蜘蛛，把腿都剪掉再对他大吼一声，蜘蛛没跑，由此可证，蜘蛛听觉在脚上。</p>
</li>
<li><p>我让媳妇听了这首歌，她竟然说不好听，就跟她吵了起来，可后来我想：我一个大男人，为何要和一个女人计较，何况还是媳妇。我当时就道歉了，媳妇也很高兴，放下了手里的菜刀，她妹妹抓着我头发的手也松开了，丈母娘的拐杖也扔了，老丈人拿出手机说：棺材退了吧。看看，只要多沟通，生活还是蛮和谐的。</p>
</li>
<li><p>一边看看点一边吃饭，忽然停电了，我急忙扒了两口饭，瞬间来电了，我惊呼，这莫非是扒扒拉能亮</p>
</li>
<li><p>突然好想去放牛，没有压力，没有江湖套路。以我的智商，只放一头，多了我也数不过来，它吃草就行了，累了，就趴在牛身上睡觉，饿了就喝点牛奶，无聊了就吹吹牛逼。</p>
</li>
<li><p>笑得我葡萄牙和西班牙都掉了，就剩下一颗姜子牙，还流了一身阿富汗，我就随手用吕布擦了擦，我又看了一眼天上的赵云，用狂铁打造了部饮魔刀，坐在小乔上面钓了一条周瑜，上了一炷孙尚香，默默点了个公孙瓒。</p>
</li>
<li><p>有次我去挖人参，忘记套红绳了，结果人参跑了，我一直追到了珠穆朗玛峰，我感觉人参已经达到了巅峰。</p>
</li>
<li><p>大家不要相信他发的东西，上次他说吃榴莲之前放进微波炉里五分钟会更甜，md现在家里都不能呆了，邻居们劝我搬家，说我在炖屎</p>
</li>
<li><p>人生三大错觉：1.她喜欢我 2.我能反杀 3.手机有信息</p>
</li>
<li><p>我柯镇恶行走江湖这么多年什么没见过？出手吧。。。三秒后。。。要杀要刮悉听尊便！</p>
</li>
<li><p>考拉一生99%的时间都用于吃和睡，还有1%的时候用于找对象，它们漫无目的的晃荡着找，如果实在找不到，就放弃了，回去继续睡。 </p>
</li>
<li><p>你好，我同学的号上什么也没有，希望你赶紧把号还给他当然我的号也没什么有价值的东西，也不要盗我的号，我是学计算机的，我有100种方法让你现形 ，希望你赶紧把号还给他，要不然我就要采取一些手段了，到时候你就难堪了。</p>
</li>
<li><p>银角大王将宝葫芦倒置，喊了一声：“周鸿祎！”周鸿祎应了一声，嗖的便被吸了进去。银角大王查看时，里面除了周鸿祎，还有360杀毒、360压缩、360浏览器、360安全卫士、360游戏大厅等熙熙攘攘一干人。银角大王惊讶道：“怎的来了这么多？”宝葫芦开言道：“我就只点了个‘下一步’。” 危险！您的宝葫芦有53个漏洞。银角大王正要说话，看到一旁的李彦宏在笑，大怒，反转宝葫芦正要喊，李彦宏嗖的一声钻进了宝葫芦，银角大王转过葫芦一看，里面除了李彦宏，还有百度贴吧、百度手机管家、百度浏览器、百度杀毒、百度输入法、百度外卖、百度安全中心、百度云、百度音乐、百度知道、百度百科……密密麻麻一干人，银角大王问怎么回事，宝葫芦开口道：“我什么都没干！”旁边马化腾看了笑出了声，银角大王怒了，翻过葫芦就对准了马化腾，刚想开口，突然见马化腾拿了一个一模一样的葫芦站在银角大王家门口。</p>
</li>
<li><p>我是个主玩盾卫的玩家，有一次遇到一个喇叭找人带虎狼的新人，我打得慢，我也就免费带了他，我看他装备比较奇怪，可能是个回归萌新，我就想起了刚玩这款游戏时候的我，我也是一个小白，在大家的帮助下开始冲钱的。最后出了他的武器，打完虎狼她加了我好友 当然 我同意了，那时候我还不知道她是妹子，ID不太看得出来。后来她还是每天都要蹭我的虎狼慢车， 以前我把元宝看的相当重要 但没关系，她经常忘了关宠物抢我元宝，有一次她跟我说她近一段时间应该不会玩游戏了，她被小草洗号了，然后我才后悔怎么没早告诉她预防小草关远程什么的。我这段时间也越来越强，买了新天空开始挑战宝莱坞和博士。然后她回来了，脚底有个十分显眼的甜心特效，她跟我说她开始懂得变强了，有兴趣继续玩下去了。我和她占了一条博物馆，带她一起升级，我们每天都会打虎狼，她也时不时要抢我元宝，有一次打仓库还抢了我一个挺不错的徽章，我喷了她好久。有一天她说她打不过梦幻图书馆，完全不会跑，我也解释不清楚，她就加了我扣扣让我语音教她打，我比较腼腆 接通语音我才知道她是妹子，我顿时不知道该怎样和妹子对话.. 教她打过梦幻图书馆，我运气很好地出了个格挡韧性的徽章，而更令我感到幸运的是她那句“一直以来谢谢你啦”。我们的等级越来越高，我和她挂机都没磕秘药和经验buff，我在等她升级。后来有一天我上号看到她在线，给她发了一个的表情 0.0 ，她说她260了，于是我就带他走了一波宝莱坞。我打得很艰难，毕竟我才262，她也语音跟我说这个副本这么难打的啊～第二天我正在推塔，看见她上线了就问她要打什么本不，她说不了，她挂了个黄，宝莱坞和大桥都带她打完了。我也不知道为什么，我的心情很沉重，但是我没有问她什么 怕她感到尴尬。后来在有一天在宝莱坞门口我遇见他们了，因为我们一直都喜欢在10线。她说带我一起，我看了看她黄的信息，265级的匕首，新天空百爆百速，血皇饰品，天九武器，古代披风。曾经我们在一起经历了那么多的战斗，现在我才知道我和他差距是多大。他打宝莱坞很快，也把她保护得很好，我在旁边尽可能放特效高点的技能找存在感。她坐在一旁的时候直接组队说 说以前以为我超级厉害的，后来遇到了大佬才发现我和她一样的咸鱼。我没说话，但我心里很气。之后几个星期我没有再主动找过她，她也不再需要我带副本，我不知道她对于我是怎样的存在，只是莫名地觉得心很痛。后来有一次代古斯攻城，我一眼就看到了人群中没有上位的她，但我没有说话，默默地蹭代古斯，她也没有跟我打招呼。<br>所以说谁能资助我买个三千爆手？</p>
</li>
<li><p>今天走在街上一小孩对我吐口水，我不但没有骂他反而摸摸他的头说：真懂事！给了他5块钱，告诉他对别人也要这样。等我逛一圈回来看到她脸已经肿了</p>
</li>
<li><p>马岱，字丁琳，吗丁啉专治魏延</p>
</li>
<li><p>昨儿天儿太热我家热得快炸了</p>
</li>
<li><p>我这辈子没喜欢过哪个明星，唯独蔡徐坤是个例外，真心喜欢她， 因为他救过我的命。那是2018年的晚上我吃了包过期的辣条，地沟油中毒，医生说太晚了，我在弥留之际看了一眼电视，坤坤正好在跳舞，我立马吐了出来</p>
</li>
<li><p>大家注意了！！在一些国道上，有一些不法商贩打着卖草莓的幌子贩卖人体器官。一定要警惕！就在昨天，路过路段时，有人卖草莓，我过去尝了尝，当尝到第30个的时候，他压低声音在我耳边问我：你要脸不？我没敢要</p>
</li>
<li><p>对不起，我不接受网恋，虚无缥缈的东西给不了我安全感，猜忌和怀疑是深夜流泪的根源，我要稳稳的幸福，伸手就能碰到的那种。但是——如果你问我网恋吗，前面的话就当我没说，加我。</p>
<ul>
<li>好好得为什么要网恋，是酒不好喝了，还是游戏不好玩了，看也看不见，摸也摸不着，有啥好玩的？但是你要是问我网恋吗，前面的话当我没说，加我！</li>
</ul>
</li>
<li><p>我faker谁都不服，就服兵役</p>
</li>
<li><p>余歌，多好听的名字，可惜你姓张</p>
</li>
<li><p>天醒吧的朋友们再见了，很抱歉做了这个决定，希望我们有缘再见吧，因为遇到了一些意料之外的突发状况，对我的影响和打击比较大，所以不打算继续呆在吧里了，和大家道个别吧，真的挺舍不得你们的，这么久了，能够认识你们真的很开心，谢谢你们带给我了许多的欢乐和感动，谢谢你们一直陪伴在我身边，这次离开贴吧，主要原因是我的手机没电了，等我充好电就回来。</p>
</li>
<li><p>他龙袍加身，他富可敌国。他权倾一方，他俯瞰众生。他山珍海味，他挥金如土。他博学多才，他智勇双全。他英俊潇洒，他妻妾成林。他高大威猛，他夜夜春宵。他风流倜傥，他万众瞩目。他杀尽负他之人，他斩尽世间不平。<br>他醒了。他要开始搬砖去了</p>
</li>
<li><p>吉尼斯世界纪录因记录了最多的吉尼斯世界记录而被吉尼斯世界纪录记录为吉尼斯世界纪录，而这也被吉尼斯世界纪录记录为第一个记录吉尼斯世界纪录的吉尼斯世界纪录</p>
</li>
<li><p>一天，老师开始发试卷，一个女生多拿了一张，她大喊：老师我有了我有了。一男生没有试卷，他大喊：是我的，是我的。教室瞬间安静了。</p>
</li>
<li><p>9月4日晚，无业游民张某约网友刘某到自己的出租屋内喝酒。期间刘某感叹有钱人太多，张某随即表示：不如出去弄点钱？刘某随即响应。解放路的监视探头显示，9月5号凌晨5时16分许，他们的早餐摊支起来了。</p>
</li>
<li><p>记得有次我被五步蛇咬了，我立马抓住了那条蛇。每走4步就让它咬一口，就这样坚持到了医院。有次我朋友也被五步蛇咬了，可惜他没有抓住那条蛇，于是他只能每走4步就跟别人借一步说话。就这样坚持到了医院。</p>
</li>
<li><p>如果一个男孩子对你这种彪悍的女孩子特别好，只有一个原因，他敬你是条汉子。</p>
</li>
<li><p>初墨，多么优雅的名字，可惜他姓熊。扒杰，多么高端的名字，可惜他姓朱。渔歌，多么诗意的名字，可惜他姓章。巅峰，多么上气的名字，可惜她姓杨。紫藤，多么仙气的名字，可惜她姓杜。</p>
</li>
<li><p>我上京东去买了一个降落伞，而且惊奇的里面居然没有差评，我马上就买了一个，立马坐着飞机去跳伞，在我跳下去的那一刻，我似乎明白了为什么没有差评</p>
<ul>
<li>应该是并夕夕</li>
</ul>
</li>
<li><p>看一个小妹妹在网吧玩植物大战僵尸，坚果放最后，前面放炮手，我强忍住笑问她为什么？她说那坚果笨笨傻傻，所以我要保护她，突然想，看似成熟的我们，其实丢掉了很多。然后我打举报电话查封了这家允许未成年上网的黑网吧</p>
</li>
<li><p>对啊，谁没追过星啊，追星那时候我都是啊啊啊啊啊我这辈子非朴灿烈不嫁，最后我还不是当了边伯贤的老婆嘛。</p>
</li>
<li><p>埋炸弹的小女孩一晚上没有卖出去一个炸弹，她冷的不行了，点燃了一个炸弹，结果全镇人都见到了他们的祖母</p>
</li>
<li><p>我今年22岁，男，年纪轻轻就有车有房，和一个成熟稳重的80岁的女朋友，我不想表达什么，只是想跟大家说，加油，一定会闯出属于自己的一片天！</p>
</li>
<li><p>最近买了电子烟，使用感觉还不错。昨天出门坐公交车随手就塞到了牛仔裤兜里，可能是牛仔裤太紧，压倒开关了，整个车厢的人都看我胯下部位一直在冒烟，我还根本没发觉，知道一个好心的哥们拍拍我：哥们，你好像屌炸了。</p>
</li>
<li><p>学校统一订购辅导书，价格十块，回家跟老妈报12块，多出的2块准备私藏。老妈不行，问了我同年级的邻居，他竟然说15块……我永远忘不了老妈惊讶的表情看着我说：是多少就说多少嘛，你那点零花钱留着自己用。说完给了我15块，望着邻居，我真心觉得自愧不如。</p>
</li>
<li><p>1、在非洲，毎60秒，就有一分钟过去。</p>
<ul>
<li>2、凡是每天憋尿过多的人，有高几率100年内死去！</li>
<li>3、据研究，毎呼吸60秒，就减少1分钟寿命。</li>
<li>4、当你吃下了20碗米饭，换算下来竟然相当于摄入了20碗米饭的热量。</li>
<li>5、谁能想到，这名16岁少女，4年前只是一位12岁少女。</li>
<li>6、中国人在睡觉时，大多数美国人在工作。</li>
<li>7、当蝴蝶在南半球拍了两下翅膀，他就会稍微飞高一些。</li>
<li>8、据统计：未婚生育的人中有大多数为女性。</li>
<li>9、如果你每天省下来一包烟钱，10天后你就能买10包烟。</li>
<li>10、当你左脸被打，你的左脸就会痛。</li>
<li>11、人被杀，就会死。</li>
<li>12、中国教英语方式有极大错误，在美国就连小学生都能说一口流利的英语。</li>
</ul>
</li>
<li><p>紧急通知，据科学研究表明，千万不要喝刚烧开的热水。——因为会烫</p>
</li>
<li><p>一天，蔡徐坤在拿抹布擦桌子，看到一只小蚂蚁，于是他儒雅随和的问，小蚂蚁，你的父母呢？怎么只有你一个？小蚂蚁回答：你抹死了</p>
</li>
<li><p>你不得不承认的6个事实：</p>
<ul>
<li>1、你的头转不了两圈；</li>
<li>2、你数不了自己的头发；</li>
<li>3、当你把舌头伸出来鼻子不能呼吸；</li>
<li>4、你正在做第三条；</li>
<li>5、你发现原来你可以做到；不过样子看起来像小狗；</li>
<li>6、你正在笑，因为我把你整了。</li>
</ul>
</li>
<li><p>昨天我去鬼屋玩，被吓了一跳摔了一跤，整个屋子的鬼都围过来问我有没有事！</p>
</li>
<li><p>今天去电影院看前任3我没哭，出电影院我哭了，我的电瓶车不见了</p>
<ul>
<li>周某：我胡汉三又回来了</li>
</ul>
</li>
<li><p>刚才坐公交过大桥，上了大桥我对司机说我坐过站了，车内的人全站了起来，其中一个掏出20元给我，我说tmd20元做出租车怎么够啊，又有几个人站出来拿100元给我说，大兄弟别激动，这些钱给你等一下叫滴滴</p>
</li>
<li><p>西天取经，六耳猕猴混了进来，真假美猴王只有唐僧能分辨出来。唐僧说：“为师想吃桃子。”两猴犹豫了一下，都变成了桃子，突然唐僧大喊：“八戒，给我拿下那只猕猴桃”</p>
</li>
<li><p>小时候说要把头发梳成大人摸样，长大了发现大人并没有什么头发。</p>
</li>
<li><p>高中那时候，我坐暖气垫旁边，一个冬天的早上，女同桌带来了一袋牛奶，他放在暖气垫上想把牛奶加热，过了一会，她碰了碰我，说：摸摸我的奶，热了没有。结果那一整天我都没有好好听课。</p>
</li>
<li><p>以前有个学长，四川的，军训的时候有一天早上他就喊：孩子，我的孩子呢。</p>
<ul>
<li>我们都看他挺年轻的就问他：你孩子多大啊？</li>
<li>四十二啊</li>
<li>你多大？</li>
<li>十八啊？</li>
</ul>
</li>
<li><p>校长说了：看到老人跌倒就要扶，要是讹你，我来替你出30万，政治老师陪你去法庭，语文老师做辩护，数学老师算胜率，你要是被关进去，地理和物理老师勘测地形，化学老师配置炸药，体育老师救你出来</p>
</li>
<li><p>小姐姐能求你们件事麻？小时候家里比较穷，断奶比较早，希望这几位姐姐能帮我找回那段不完整的童年，好人一生平安</p>
</li>
<li><p>只要你喜欢沙雕表情包，我们就是好朋友</p>
<ul>
<li>沙雕网友拿了就走</li>
</ul>
</li>
<li><p>在胡同里听见有人喊：陛下、陛下。我抬头应了一声：谁在呼唤朕。然后被泼了一脸水，楼上泼水那妹子却说：早喊你避一下了，活该。我捡起砖头，叫了她一声王后！</p>
</li>
<li><p>曾经有人跟我说，只要去了广东，就会在一声声靓仔中迷失自我，可我到了广东之后，他们都叫我叼毛。</p>
</li>
<li><p>我要去马来西亚开会，3月8号那天给老婆发信息，告诉老婆我已上飞机，搭乘马航MH370回来，结果马航……出事了。我已经在宾馆呆了两年多了，求高人支个招，我想回家……</p>
<ul>
<li>三年前，我老公要去出差，三月八回来，当天新闻马航370出事了，正好老公那班，伤心抱着隔壁老王嚎啕大哭，怎么会这样<ul>
<li>他在一楼</li>
</ul>
</li>
</ul>
</li>
<li><p>一场辩论赛主题是“辩论赛究竟有没有意义”，正方选手进行了认真的准备，并按时到达了辩论赛场。过了半个小时，反方还没有出现。</p>
</li>
<li><p>我爱上一个女孩，可是她的家人极力反对，哎，尤其是她的老公，扬言要砍我</p>
</li>
<li><p>刘备驾马将跌入悬崖，张飞见此便喝到：主公，你快勒马！刘备：我快乐你妈隔壁</p>
</li>
<li><p>古代有个商人从川中收购了一批柑橘、芝麻、小麦、兽皮准备运过河对面去卖，然后他租了一条小船运货物，突然船桨断掉了，船夫就问商人，你的货物中有没有什么东西可以做船桨的？</p>
<ul>
<li>——我有橘麻麦皮不知当桨不当桨</li>
<li>古有一商，于川中购一批麻、橘、麦、皮，以船运于外地贩卖。船半途，水急桨朽，桨断而顺水失，船夫甚急，顾商人：无桨不得行，尔货中有长直之物可当桨？商人道：吾有橘麻麦皮不知当桨不当桨？</li>
</ul>
</li>
<li><p>我杀谁都是死刑，生命在我面前，何其平等</p>
</li>
<li><p>程序员：我去相亲网站找女朋友了</p>
<ul>
<li>——找到了么？</li>
<li>程序员：找到了他们页面的bug（敬业）</li>
</ul>
</li>
<li><p>心理学上有潜意识激励的说法。例如你每天早上出门前对着镜子说一句“你很棒”，一段时间后，那块镜子就会成为一块很棒的镜子</p>
</li>
<li><p>泽大怒，怒以手指天曰：吾王境泽，便是饱受饥之苦，即死于野兮下临不测之渊，乎又以手折腰指于众，众人皆惊，速退数步，泽见而笑矣，仰天长笑曰：吾定不为五斗米，必不食尔等小粒食！未几，泽顾左右，笑曰：甚香！</p>
</li>
<li><p>吾得一元，购糖，拐幼童，得千，寻风尘女子，事毕迷之，取得肾，得万，购弹药，抢银行，得五百万，钱已有，已不愁身后之事，自觉坏事做绝，需改过，于午时遇一跌倒老者，遂扶之，剩八角。。。</p>
</li>
<li><p>我养了一条鱼，我非常喜欢他，有一天我发现他死了，这令我悲伤不已，我不想土葬，我想把它给火葬，把骨灰洒回海洋让她回到母亲的怀抱，谁知道这玩意越烤越香，于是我开了瓶啤酒，真香。</p>
</li>
<li><p>木兰从军后，很想念母亲，于是就把母亲的样子绣到了手帕上，将军看到了，关切的问：“你秀你妈呢？”待木兰凯旋而归，皇上论功行赏，看见了木兰秀的这个手帕，皇上说：“此手帕可有人与卿共秀之？”木兰答：“没有，臣独秀”</p>
</li>
<li><p>高手在人间，失手在阴间，人躺太平间，视频留人间，兄弟吊炸天，死后必升天，这人我见过，走的很安详，那天风很大，火烧得很旺，骨灰还滚烫，家属很坚强，没有流眼泪，还在打麻将。</p>
</li>
<li><p>车速不快，嚼颗槟榔；槟榔加烟，法力无边；槟榔生吞，道法乾坤；槟榔配酒，永垂不朽；槟榔加烟又加酒，阎王在向你招手，槟榔加狗屎，枪都打不死；槟榔加红牛，嚼完操地球；槟榔加月经，越吃越年轻。</p>
</li>
<li><p>懵逼树上懵逼果，懵逼树下你和我，懵逼树前排排坐，一人一个懵逼果，懵逼有你还有我，原来懵逼不止我，懵逼树下懵逼魂，懵逼魂中懵逼人，一人一个懵逼魂，人生懵逼最销魂。一人一座懵逼坟，来世再做懵逼人。哦~耶……</p>
</li>
<li><p>昨天我在网吧，玩吃鸡一看只剩一块，便无聊打开苍老师的视频，看了一个多小时还没下机，我就去问网管是不是机子出问题了，网管深吸了一口烟，斜着眼看着我说：“你后面那三个小学生没人给你充了5块”</p>
</li>
<li><p>1998年我去云南瑞丽逛赌石市场时随手买了一个，鹅蛋大小，讨价还价半天5块钱拿下，切开一看当场惊呆所有人，糯种、满色、正阳绿、六分水，没有一丝绺裂！唯一的缺点就是有点酸，不过老板说正常，缅甸猕猴桃都这样。</p>
</li>
<li><p>你好！我叫宅博士，我是星星球上最杰出的机器师，我的父亲叫宅在佳，桃子姐姐是我暗恋的对象，我有五个孩子， 名字叫开心、花心、甜心、小心、粗心，他们都是半机器人，总有一天我会让QQ看点里的人都认识我宅博士</p>
<ul>
<li>——认识你了，好了你的愿望实现了，快去睡觉把</li>
<li>——应该是搬砖把</li>
</ul>
</li>
<li><p>当鲸鱼在海洋中死去，它的尸体最终会沉入海底，生物学家赋予这个过程一个名字“鲸落”，一座鲸鱼的尸体可以供养整套生命系统长达百年，这是它留给大海最后的温柔。但很多人不知道的是，当鲨鱼在海洋中死去，也会掉落海底，也有一个浪漫而孤独的名字——鲨凋</p>
</li>
<li><p>萧峰开局满级，段誉半路开挂，虚竹盗满级账号，慕容复前期靠着充值大礼包到处浪，后期都没有满级，只有鸠摩智前期一步一个脚印打怪升级，后期满级，但由于前期欺负段誉，后期被段誉开挂暴打，一气之下删装备退游</p>
<ul>
<li>——乔峰是遇强则强</li>
<li>乔峰：只要音响没灭就每一个人能打败我，导演说的</li>
<li>bgm在乔峰就不会败</li>
</ul>
</li>
<li><p>我一个人默默地走在路上，忽然看到一个背影很像辰东的人，我快速冲了上去，然后，到了近前发现不是他，我叹了一口气，轻轻放下了手中的板砖。</p>
</li>
<li><p>叙利亚：美国你为什么打我？</p>
<p>​    ——美国：因为我怀疑你有核武器。</p>
<p>​    叙利亚：那中国也有核武器，你怎么不打中国</p>
<p>​    ——美国：因为中国真的有核武器</p>
</li>
<li><p>“娘娘让我用魔器取大王心脏，朝歌城便可失而复得了”</p>
<ul>
<li>“来吧，只要爱妃高兴，我什么都愿意”</li>
<li>“大王，没有了大王，天下对我又有何用？”</li>
<li>“臣妾有一事隐瞒大王多时了”</li>
<li>“朕早就知道爱妃是狐狸变的，寡人宁负天下也绝不负你。就像我们当初相识，来来来，我和美人斟酒对饮”</li>
<li>“其实臣妾是公狐狸变的～”</li>
</ul>
</li>
<li><p>李云龙：什么他娘的精锐，老子打的就是精锐。</p>
</li>
<li><p>渣男 全体起立 ，入队宣言：从此寻花问柳，不谈一生厮守， 从此灯红酒绿，再也不想牵谁的手， 从此人海漂流，闭口不谈爱到白头， 从此单打独斗，再也不会为谁彻夜流泪，从此放下离愁生生世世酒，敬自由 再见了</p>
</li>
<li><p>小明很冷，把毯子裹在身上，老师说：请改成被字句。小华不假思索地说：小明很冷，把被子裹在身上。老师说：你可以滚了</p>
</li>
<li><p>等我哪天死了，不要把我埋了，把我的骨灰撒到大海里，我不是为国家省土地，也不是心怀宽广去守护祖国的海洋，只是希望死后依然能够浪起来……</p>
</li>
<li><p>她对我说：这班上有你喜欢的吗？我嗯了一声，她问我是谁？我说你猜，然后她把班上同学猜个遍，我都摇摇头，她问还有别人吗？我没说话，她立马脸色绯红，我把嘴凑到她耳朵边说：还有男生你没猜呢。</p>
</li>
<li><p>大学里，看我不顺眼的一定告诉我，我马上改，千万别在水里下毒；觉得我让你丢面子的可以好好和我交流，千万别趁郊游时让我溺水身亡；觉得我哪里招惹你了可以放学留下我，千万不要深夜连捅我18刀；如果你觉得我上课表现积极过于装逼，请一定给我小纸条，不要最后下课了用教学用具将我殴打至半身不遂；如果觉得我和你女神男神走的太近，请和我成为好基友，我会帮你搞定他，千万别看到我的时候泼硫酸；如果觉得你精神出现了问题，可以告诉一起的室友，我们一定不会放弃你的，别演变成灭寝惨案…如果我能顺利毕业，真心感谢各位同学的不杀之恩/微笑</p>
</li>
<li><p>好男生不会撩妹，会撩妹大半渣男，喜欢你的你看不上，没对上眼废话贼多，对上眼了又不敢说，总之你喜欢的名花有主，喜欢你的惨不忍睹，我是个有故事的男生，你是个没想法的女生，游戏好玩，学业繁重，我就是直男。</p>
</li>
<li><p>小时候家里穷，买不起鞋，只能穿着破洞的小布鞋躲在角落里看着人家穿着光鲜亮丽的球鞋在球场上奔驰，从那起我就发誓以后一定要让像我一样的人穿的起球鞋。长大后我的梦想实现了，成为了一名出色的莆田鞋贩，买鞋加我。</p>
</li>
<li><p>午时三刻，监斩投令，刽子手举刀欲斩，死囚仰天大笑三声“哈哈哈！”刀止，监斩不解，问死囚为何发笑，死囚一脸沉思：“养生专家诚不我欺，每天笑一笑果然能多活几秒”</p>
</li>
<li><p>世界上最没尊严的三种生物：印度的蛇，俄罗斯的熊和中国的已婚男人</p>
</li>
<li><p>大家好，我是埃及法老，相信大家今天都听到神秘的“埃及牛逼”的呼喊了吧，是的，我要复活了，现在只差100人民币即可复活，如果你愿意助我复活，请将100元转入我的微信，等我统治世界之后，你就是我的左护法</p>
<ul>
<li>IG夺冠后我哭了，我对象没有哭，然后我把她也打哭了。</li>
<li>满屏都是IG，IG，IG确实牛逼，课是又有谁记得今天11月3号是我们民族史上一个沉痛的日子，哎，沉痛哀悼五年前的11月3号……东莞大扫黄</li>
</ul>
</li>
<li><p>擎天柱战斗中被炸成了碎片，大黄蜂带着他的碎片来到了山东蓝翔，唐国强校长愁眉苦脸的问：这一堆是啥？大黄蜂：你若安好，便是擎天。</p>
</li>
<li><p>“每天起床第一句，希望老公快死去。婚后的我有怨气，老公不死不平息！世上好人活不长，渣男长寿不公平！死去，你快死去，变成寡妇我开心！……我唱起来了怎么回事</p>
</li>
<li><p>彭于晏这种就是虚肌肉，就是吃各种蛋白质，增肌。看上去很结实，其实没卵用，打个比方就是我和他单挑，过不了五秒，他就会跪在我前面的地面上，掐我的人中求我不要死。</p>
<ul>
<li>——兄弟，40米的刀不好收啊</li>
<li>——唉，你40米的大刀还好了，我80米的大刀拔到一半又得收回去……</li>
</ul>
</li>
<li><p>君子不拆夫妻秒，匠人不拆鸳鸯锁，不是不能拆，是这锁头有毒，这锁头镇外，锁的是艳阳净，护的是月下明，这个时候，它就会出现毒，小偷若是不慎，他就会中毒，毒是锈毒，锈从锁中生，毒从锈中来，这锈，就是沉毒锈。</p>
<ul>
<li>——要不是看到最后三个字我差点就信了</li>
<li>——一本正经的胡扯</li>
<li>——你来晚了</li>
</ul>
</li>
<li><p>有个女生问我520是什么意思？我做出了以下回答：5个落实，落实经济结构调整，落实精准扶贫，落实社会保障，落实环境治理，落实反腐倡廉；2是2个要，既要金山银山，又要绿水青山；0是对犯法犯罪行为的零容忍</p>
</li>
<li><p>有个十四岁的小子欠我九块钱，听说他要去国外躲一躲，我要不要去追？毕竟不是一块两块的事</p>
</li>
<li><p>4年前，一个男孩喝多了给我打电话，唱的美人鱼，唱完他说他喜欢我，虽然我们没有在一起，但是会永远记得有一个人喜欢过我，给我唱过歌，和我牵过手，没能在一起也许只因为都是男生吧。</p>
</li>
<li><p>哪个男生没有蹲着尿尿过</p>
</li>
<li><p>验证了那句，放下砖块不能养你，搬起砖块不能抱你</p>
</li>
<li><p>兄弟两每天都要剪刀石头布</p>
<ul>
<li>输了总会哭</li>
<li>一个人太孤独</li>
</ul>
</li>
<li><p>取少量学生放入试管中，加入过量作业，溶解过滤，得到学霸和学渣，往学霸中加入少量试卷，学霸无明显变化，往学渣中加入少量试卷，学渣全部溶解并产生大量气泡，若加入大量游戏，学渣瞬间沸腾。</p>
</li>
<li><p>活着污染空气，死了浪费土地，半死不活浪费人民币</p>
</li>
<li><p>上学时有一个女孩，皮肤很白，笑起来很好看，全校公认的笑话，一次下课我在楼梯间亲了她，她红着脸跑开了，我亲她不是因为我喜欢她，而是她是学校的扛把子的女朋友，我就喜欢那种被人追着打的感觉，死亡如风，常伴吾身。</p>
</li>
<li><p>小葵花妈妈又来上课了，一楼咳嗽老不好，估计是装的，打一顿就好了，一楼撸管老不射，多半是废了，切掉就好</p>
</li>
<li><p>我和她相处六年，她一直不准我吸烟，可惜时光荏苒，我和她还是分开了，虽然很是不舍。两年后我在街上碰见了她，我慌忙地把烟掐了，她一脸诧异的看着我，我才突然想起来，她，已不再是我的班主任！</p>
</li>
<li><p>今天打一盘排位，我家诸葛亮武陵仙君一直追着对面庄周打，我于是忍不住问诸葛亮为什么他要死追着庄周打，于是他说：武陵人捕鱼为业。</p>
</li>
<li><p>女朋友让我拧罐头，我拧不开，她生气了，跑到隔壁老王大哥家求助，求半个小时了还不回来，我过去偷偷趴在门上偷听，听女朋友在里面喊：用力！不要停！用力。我心里一喜，哈哈，原来老王也拧不开。</p>
</li>
<li><p>手控：想到这么好看的手要用来擦屁股……答应我，以后不要上厕所了好吗？</p>
<ul>
<li>现在的科技不是搓屁股自动水洗了吗？</li>
<li>我家马桶就是，上完厕所可以直接水洗屁股，但是冬天你不提前把温度设好的话，冻得你菊花疼。</li>
</ul>
</li>
<li><p>我有个小姨，只比我大几岁，有次我和小姨手挽手上街。结果被路过的班主任发现了，回去给我妈告状说我早恋，我妈质问我那天怎么回事，我回忆了一下说：你问你妹啊。我妈瞬间一个嘴巴抽过来了。</p>
</li>
<li><p>如果有一个男生他能把你的照片当成手机屏幕，可以随时让你翻他的手机，可以把微信和支付宝的密码给你，甚至可以把银行卡的密码也给你，那你就取他的钱打给我知道了吗。</p>
</li>
<li><p>记得我小时候看到一个男生，精致地五官，帅气地脸庞，纯洁干净地气息，像极了不食人间烟火地精灵，那天妈妈告诉我，我也是第一天知道。“孩子，那叫镜子”</p>
</li>
<li><p>去便利店买矿泉水，老板拿了一瓶哇哈哈地矿泉水给我，就顺口问了一句多少钱，老板说2块，我拿起矿泉水，指着包装对老板说：上面建议零售价不是1.5元吗？老板回道：我不接受它的建议。</p>
</li>
<li><p>这谁发明的，真是害人不浅，女生可千万别去学。（衬衫，扣子，双面贴）</p>
<ul>
<li>我一直以为安全裤是用来防小人的，没想到连我这样的正人君子也防。</li>
</ul>
</li>
<li><p>拿天她误入打架混战，我为救她被人砍了一刀，后来我们相爱了，我以为这就是爱情。直到她跟有钱的人走了，她婚礼我去纹身店把疤盖住，从此我不相信爱情！可是我一点都不难过，因为我也不知道这是谁编的，这是我复制过来的。</p>
</li>
<li><p>和朋友去吃小龙虾，隔壁桌一个小女孩问他妈：妈妈，小龙虾回不了家他妈妈会不会着急啊。他妈妈楞那了，这么善良的问题让我怎么下得了口，这时老板来解围了：不会的，它们一家都在这了</p>
</li>
<li><p>不管你在哪里你都要记住：当你放屁时一定要说一声好像什么东西糊了，这样你的屁就被别人吸光了。</p>
</li>
<li><p>预备，唱！在那山的那边海的那边有一群大水B，他们抢楼真牛B，他们升级坐电梯，他们回贴水贴从来不看题，噢可爱的大水B，噢可爱的大水B，他们齐心协力开动脑筋升到了十三级，他们吐槽占楼卖萌又装B。</p>
</li>
<li><p>“买狗吗？便宜卖”</p>
<ul>
<li>你这狗忠诚吗？</li>
<li>必须的，我已经卖了26次了</li>
</ul>
</li>
<li><p>我们都是九年义务教育，只有你是十年寒窗苦读</p>
<ul>
<li>同九义，汝何秀</li>
</ul>
</li>
<li><p>我是一名夜班公交车司机，一天我因为看《灵车》撞到了树上，醒来后发现自己到了古代，听有人说：侯府生嫡女了，我离开这里当了官，我官升一品时发现成龙大哥提着大宝剑来到我身边：你们看小说是不是很不方便啊。</p>
</li>
<li><p>一只乌鸦想和瓶子里的水，瓶子太高喝不到，乌鸦跑到很远的河边捡石子，扔到瓶子里，就在他快要喝到水的时候，他才想起来，卧槽，我刚刚是不是到了河边？</p>
<ul>
<li>让我黑魔仙赐予你智慧。</li>
</ul>
</li>
<li><p>我这个人脾气是好，但是一旦有人触碰到了我的底线，那么，我会降低我的底线。</p>
</li>
<li><p>明明有别墅，我却租房住，明明有豪车，我却骑自行车，明明有女朋友，我却打光棍。这就是我……和明明的区别</p>
</li>
<li><p>张三和李四都是门卫，两人是好兄弟，某天中午张三来值班，换李四吃饭，张三突然说：大哥你等等，我要拉肚子。李四答：那你快去拉，拉完了我好去吃。</p>
</li>
<li><p>我以前救了一只受伤的老虎，痊愈后就放生了。那一年我路过那片森林的时候看到了它，它看着我，我看着它，我们都向对方跑去，等我们距离只有两米的时候，我发现，我tm认错了！</p>
</li>
<li><p>消防员：不，你不能进去</p>
<ul>
<li>我：不，放开我，让我进去。</li>
<li>消防员：里面火势太大了，你进去会有生命危险的！</li>
<li>我：不行！难道我就眼睁睁的看着火势蔓延下去吗？</li>
<li>消防员：那你拿着寒假作业进去干什么？</li>
</ul>
</li>
<li><p>康师傅方便面用的那头牛，这么多年过去了，别说皮外伤了，都长胖了。</p>
</li>
<li><p>曹操墓发现一具小孩尸骨。专家：那是小时候的曹操</p>
<ul>
<li>500块钱和锦旗正在路上</li>
</ul>
</li>
<li><p>自由美利坚，枪击每一天。快乐阿富汗，提枪就是干。和平叙利亚，地雷满地炸。英勇俄罗斯，单挑一个师。大国梵蒂冈，怎么都不慌。和平伊拉克，地铺子弹壳。韩国有点迷，万物皆申遗。威武大中华，和平千万家</p>
<ul>
<li>是核。下次不要犯这么低级的错误了</li>
</ul>
</li>
<li><p>我有贤相董卓，孝子吕布，忠臣司马懿，聪慧之子刘禅，上将邢道荣、潘凤，王牌说客蒋干，神速运粮苟安，何愁大业不成。</p>
</li>
<li><p>现在B站有的视频真的过分了，已经是严重地网络暴力，网络暴力是什么意思我就不说了，自己查，但我想说网络暴力真的可能导致生命危险，比如我可能会被笑死。（蔡徐坤告b站）</p>
</li>
</ul>
<h2 id="活该你单身"><a href="#活该你单身" class="headerlink" title="活该你单身"></a>活该你单身</h2><ul>
<li>今天陪学妹逛街，她看中一条裙子可没带钱，我借钱给她，学妹问我，有女朋友吗？我说没有，学妹提起裙摆转了一圈问我：好看吗？我：好看。学妹说：男朋友买的。我一巴掌抽过去，明明是我给买的，你是不是不想还了！</li>
<li>女：我可以喜欢你吗？男：可以啊，我也喜欢我自己。</li>
<li>其实男生和女生不一样的，女生小时候喜欢学习好的，大一点喜欢阳光帅气的，再往后想找个有钱人，再往后可能经历太多看破了，只想找个老实人。一直在改变。哪像男生一直喜欢好看的，从未改变过。<ul>
<li>男生也想找个喜欢的，后来发现女生喜欢有钱的，后来努力赚钱，见到她看到她悔过的眼神眼里渐渐有了点水雾，心底呐喊一声：有钱真特么爽啊！</li>
</ul>
</li>
<li>我发现我挺会哄女孩子上床的，只要我一发消息给她，她就会说我要睡觉了，我还真是个渣男</li>
<li>劳资没有故事，没有女朋友，没有考研，没有不治之症，不骑猪上战场，KTV也唱不哭小姐，也不是从哪里来的，一个平凡到极致得单身狗，老子就是单纯来要赞的，就要200个，就是那么狂，而且还是复制的。</li>
<li>现在的女生真TM会装，和几个同学KTV小聚，最后走的时候女神说她喝醉了，要我送她回家，我说你TMD喝果汁也醉？幸亏老子机灵，要不又耽误劳资回去玩王者荣耀了。</li>
<li>今天我正在打王者荣耀，突然想起女朋友还在大雪中等我，我反手就给了自己一巴掌，觉得自己真不是东西，妈的巅峰赛怎么能分心呢。</li>
<li>我们就该让女人们吃点苦，跟男人子啊一起，现在比个例子：男人和女人劫婚要一栋房一辆车。但是男人和男人劫婚就会有两栋房和两辆车，懂我意思吧！</li>
<li>女：我去洗澡了。男：注意安全。</li>
<li>突然好想我的女朋友，不知道她下课了没？那边冷不冷，吃饭了吗，今天有没有不开心的事，现在住哪，多大了，叫什么名字，长什么样？</li>
<li>我的女朋友很优秀，他不撒娇，不粘人，不拜金，不胆小，不暴力，不做作，不心机，不娇气，不存在。</li>
<li>那一年开学没多久，我暗恋的女孩子坐在树下哭泣，好象是被人打了，我走过去安慰着她替她擦药，我们就这样看着彼此也渐渐地有了好感。直到多年以后我们结婚了，她还不知道那天是我叫人打她的。</li>
<li>女孩子大姨妈来了，却见她拿出手机玩起了游戏，女孩心里一下凉了半截，女孩只好拿出自己的手机充电。两分钟后，男孩突然把手机贴到她肚子上，原来是小米手机，一股暖意涌上心头，女孩偷偷把充电的三星Note7拔了下来<ul>
<li>小米发烫，三星爆炸</li>
</ul>
</li>
<li>第一句话，真诚地问她：美女，你是处女吗？如果她说是，你就说我也是处，如果她说不是，你就说，我也不是，我是白羊座。</li>
<li>很久以前，我得到了阿拉丁神灯，许了一个愿望，愿我在死前能找到女朋友，结果，精灵掐指一算：恭喜你，骚年，你得到了永生。</li>
<li>是烟不好抽，是酒不好喝，是游戏不好玩，还是基情不够，为什么你们要去碰爱情这个狗东西？</li>
<li>花心被人骂，专心被人耍，真心被人骗，好心被践踏。</li>
<li>刚刚准备要睡觉了，突然，前女友打电话来对我说：她男朋友不要她了，我安慰地说：傻瓜，别哭，站在那里等我。说完我就挂了电话，盖好被子睡觉了。晚安！</li>
<li>骨子里有份倔强，刚刚没忍住。对不起<ul>
<li>那你说，你为什么说对不起，你哪里不对</li>
<li>对不起，我倔强了。。</li>
</ul>
</li>
<li>这么可爱的小姐姐，打一拳应该会哭很久。</li>
<li>我和你是什么关系呢？就像是上海的南京路和南京的上海路听起来相似又亲密，实际上，毫无关系。</li>
<li>我不干净了，我现在真的是个很脏的女孩子，都说女孩子要保护好自己，开始我也没想到一时不慎会发生这种事，我是在家里啊！我以为家里就可以放松了，谁能想到我竟然会一脚踩到垃圾桶。。。</li>
<li>其实我很想关心你，可是你就是不生病。我很想为你哭一次，可是你就是不死</li>
<li>女：陪陪我？男：干嘛？女：你别走。男：有事吗？？女：我喜欢你。男：666<ul>
<li>男：陪陪我？女：有病吧？男：你别走。女：傻叉？男：我喜欢……女：吃翔？</li>
</ul>
</li>
<li>有小姐姐养火花的吗？一天一句cnm，七天一个小火花，一月一个大火花。</li>
<li>英文字母A和B谈恋爱了，B对A说：只要我存在一天就会爱你一天，一直一直到永远。A宠溺的抱抱她深情的说到，你个傻B</li>
<li>有一次晚自习老师不在，班里炸开了锅，突然校长从后门进来，把我们训斥了一顿，顿时班里鸦雀无声了，接着……他又从前门进来了，点了点头说：这个班真不错，很有纪律性，不像刚刚那个班。</li>
<li>我爱一个人，可是他全家都不同意，尤其是她老公</li>
<li>卧槽，这是赢了还是输了（斗地主，单生狗和情侣）<ul>
<li>输了人生赢了人民币</li>
<li>赢了游戏输了人生</li>
</ul>
</li>
<li>你要是喜欢一个女生，就好好学习，找个好工作，挣好多好多的钱，等她结婚的时候，你多出些份子钱！</li>
<li>我对象一秒钟见不到我都不行，时刻都要粘着我，睡觉都要搂着我，不搂着我睡不着觉地那种，好烦。够了没？不够的话，我再编</li>
<li>我开始恋爱啦，和一个认识蛮久的女孩子，真的是太喜欢了，以后没有丧气话了，全是甜言蜜语，她也很体贴，多开心啊。至于我为什么突然有了男朋友呢？我也不知道， 因为这是我复制的。</li>
<li>给朋友们八条建议：<ul>
<li>1.谈恋爱首先要找你爱的，如果结婚就要找爱你的</li>
<li>2.千万别输在“等”这个字上</li>
<li>3.永远留住30%的神秘</li>
<li>4.不要低估任何一个人</li>
<li>5.别把没教养当作有气场</li>
<li>6.谈恋爱可以穷，结婚不可以</li>
<li>7.谈恋爱一定要找我</li>
<li>8.牢记第7条，前6条并没有什么卵用</li>
<li>9.最后，这是我复制的，但是7，8条是真的</li>
</ul>
</li>
</ul>
<h2 id="神评论"><a href="#神评论" class="headerlink" title="神评论"></a>神评论</h2><ul>
<li>秀儿，是你吗？<ul>
<li>是秀儿吗？回答爸比。</li>
<li>就你秀</li>
<li>你真优秀</li>
<li>天秀</li>
<li>同是腰间盘，为啥你那么突出？</li>
<li>来人，把朕的传国玉玺拿来，给我的秀儿砸个核桃</li>
<li>扶寡人起来，给我的秀儿赐座</li>
<li>秀儿坐下休息休息</li>
<li>我不敢乱评论，怕等会有人用青龙偃月刀教我梳中分，用方天画戟给我削苹果，用传国玉玺给我砸核桃，爬高压线给我弹奏东风破，然后叫我秀儿</li>
<li>最近，博物馆的珍贵文物青龙偃月刀，传国玉玺，方天画戟，丈八蛇矛，屠龙刀，伯乐琴等频频失窃，望各位转发此消息，见到可疑人物要积极举报，谢谢合作！</li>
<li>青龙偃月刀为何沦为水果刀？传国玉玺缺的一角竟是砸核桃所致？何人能用13500斤得金箍棒擀饺子皮？张飞为何哭诉自己的蛇矛被抢去织毛衣？京外高压线为何频频发出琴声？敬请关注今日说法《秀儿，是你吗？》</li>
</ul>
</li>
<li>好消息! 2262年有闰正月!就是有两个春节!可以放两次假 !!! 距离2262年只有241年了! 大家要坚持活下去！<ul>
<li>待到春节休两次，家祭无忘告乃翁</li>
<li>下一世约好了喝酒啊！</li>
</ul>
</li>
<li>我的天，瞧瞧这个优秀答案，我亲爱的上帝，这是汤姆斯·尤独秀的奖杯，是谁把它那到这儿来的，来，我亲爱的汤姆斯，这是你的，摸他之前记得用蒂花之秀洗手液，这会让您显得庄重</li>
<li>自古一楼爱吃屎<ul>
<li>自古二楼爱喝尿</li>
<li>自古三楼长得丑</li>
<li>……</li>
<li>怀疑我们的控楼能力？（点赞数控制楼层）</li>
</ul>
</li>
<li>如果我是一楼，跟二楼说，你是我的<ul>
<li>如果我是二楼，告诉一楼我喜欢他， 如果一楼是小姐姐，那么不好意思打扰了<ul>
<li>不好意思你不是</li>
</ul>
</li>
<li>如果我是三楼，请告诉一楼和二楼祝你们幸福</li>
<li>二楼是男的，难不成你想搞基</li>
</ul>
</li>
<li>当年大和号为了防止侧翻在另一侧紧急损管，放入同等重量的海水。<ul>
<li>然后怎么样了</li>
<li>然后竖直沉下去了。</li>
</ul>
</li>
<li>老师：我教书给你，你却想跟我育人？</li>
<li>拥有最多手办的秦始皇表示不服<ul>
<li>女娲：你说什么？</li>
</ul>
</li>
<li>旱的旱死，涝的老死<ul>
<li>hands hands，loads loads</li>
</ul>
</li>
<li>衣服很ok，服务也很好，但人生从来不是一帆风顺的，处处充满了惊喜与考验，所以给个差评锻炼一下你<ul>
<li>是买个闺蜜的，她穿着竟然特别好看，差评</li>
</ul>
</li>
<li>网易《我爱她》（群星）<ul>
<li>网易我就喜欢你这么奸诈的样子</li>
<li>我没有版权的歌，总有一个叫群星的歌手能模仿原唱</li>
</ul>
</li>
<li>“你瞅啥”——“你丑，丑到我了”</li>
<li>我有一个朋友……<ul>
<li>好一个无中生友</li>
<li>从现在开始，假设你就是你的朋友</li>
<li>你说的朋友是不是就是你自己</li>
</ul>
</li>
<li>记得小时候喜欢看枪战片，有一次升旗仪式，一个女生晕倒了，我大喊：有狙击手，卧倒，一瞬间全校都趴下了，都十几年了校长还记得我，学校还流传我的传说。<ul>
<li>我是一名顶尖的狙击手，一天我在执行任务，准备狙杀目标时，目标突然倒地，一名小学生喊道：有狙击手！我至今不明白他是怎么发现我的</li>
<li>我是那个女生，当时有颗子弹飞快地从我眼前划过，之后我看见天台有血，然后我因为恐惧和晕血就昏了，之后还流传了什么鬼传说</li>
<li>我是那个校长，当时学生卧倒时地上掉一堆手机</li>
<li>在现场，我是那个国旗，当时全部吓趴了，全场只有我一个站的</li>
<li>现场，我是那把巴雷特M82A1狙击枪，狙击手用我时卡壳了，至今我也不明白为什么目标会倒地</li>
<li>我是那个升旗台，说真的我挺懵，本来好好的升旗仪式，我在女生晕倒的瞬间感到了压力，随后一声大喊所有人面对我趴倒在地上，那一刻我以为我是天王老子上身</li>
<li>我是副校长，当时说好了打死正校长，结果校长突然趴下，我还以为被发现了，吓死了</li>
<li>……</li>
</ul>
</li>
<li>看了这个视频，我还是要总结一下六个点，……<ul>
<li>我比你少，我总结了三点，…</li>
<li>我感觉那两点也是要说下的，..</li>
<li>还有这点，.</li>
<li>我给你补充一点，.</li>
<li>还不完善，我改一点，.</li>
<li>我就比较牛逼了，我总结不出来</li>
</ul>
</li>
<li>初听不知曲中意，再听已是付费曲。（网易云音乐）</li>
<li>这也就是win8之后直接win10的原因，因为win9要去斩华雄</li>
<li>马云卸任唱《怒放的生命》<ul>
<li>马老板果然凭亿近人</li>
<li>这位歌手真是多财多亿啊</li>
</ul>
</li>
<li>不说了，和顺侯府生嫡女了你知道吗？（看点小说梗）<ul>
<li>宠，给我往死里宠。</li>
<li>侯门嫡女，如珠似宝，唯一美中不足的是，她姓王，在家排行第八</li>
</ul>
</li>
<li>一想到联合国我就想到了乌克兰提议取消俄罗斯一票否决权被俄罗斯一票否决<ul>
<li>土耳其更牛逼，说让五常轮流来。然后被五常一致否决</li>
<li>五大流氓的权力都是打出来的</li>
</ul>
</li>
<li>我是一个直男，最烦这种gay里gay气的人，所以我希望我的另一半也是一个直男</li>
<li>小李子：颜值是什么，有我的水枪好玩吗？<ul>
<li>小栗旬：水枪好玩，但太累了，和我一起挖鼻屎把</li>
<li>来，接水枪</li>
</ul>
</li>
<li>第……第一次当喷子，有……有点紧张，你们……你们都是小笨蛋，啊，对……对不起，好像有点过分了，不，我骂人了，警察叔叔会不会把我抓走啊，啊！我的……我的奶瓶掉了，呜呜呜<ul>
<li>第一次……当……爸爸……嗯……点紧张</li>
<li>儿子啊，你让我找的好苦啊，当年你被嫖娼的拐走，没想到你还能活着出来，来来俩，告诉爸爸你是吃了多少东西活过来的</li>
</ul>
</li>
<li>最后一次警告看这个评论的人，你们都tm给老子小心点，首先我不管你是什么身份，什么背景，混的多么牛逼，是不是老板，是不是社会人。这些我都不知道，我也都不在意，你们给我记住，最近天气转凉，大家多穿衣服</li>
<li>鬼这种东西是存在的，记得有一次早上，我起了床，突然感觉有一种神秘的力量在拉扯着我，我感觉难受极了，还好村里的灵婆来了，告诉我，我的毛衣穿反了，不然，那次我就死于非命了<ul>
<li>第一次见到把衣服穿反说的这么有灵性的</li>
</ul>
</li>
<li>我觉得吧，看点里的人总是爱跟风，蔡徐坤人长得挺帅得啊，徐峥大光头怎么都没见他们骂？坤哥多帅啊，就他们一群喷子总骂人，一遇到真正厉害的就怂了，傻子们积点德吧，毕竟像我这样会写藏头诗的人不多了。</li>
<li>你们这些撞衫的不算什么，我前几天在街上撞老婆了，和我老婆长得一模一样，要不是我老婆告诉我他出差了，我还真以为那是我老婆了。<ul>
<li>醒醒，你没有老婆</li>
</ul>
</li>
<li>酒以陈为香，人以冠为首，物以稀为贵！<ul>
<li>大家好，我是香首贵</li>
<li>大家好，我是酒人物</li>
<li>大家好，我是以以以</li>
<li>大家好，我是为为为</li>
<li>大家好，我是陈冠希</li>
</ul>
</li>
<li>盛到碗里再盛到嘴里，为什么不直接进碗呢<ul>
<li>吃到肚子里再拉到马桶里，为什么不直接把盛好的饭倒进马桶里？还省得你拉了，对吧。</li>
</ul>
</li>
<li>三石弟弟的神仙颜值终于还是被你们发现了，藏不住了，我好酸……<ul>
<li>小明：神仙长什么样，告诉我</li>
<li>听说过天蓬元帅吗</li>
<li>还有南极仙翁</li>
<li>再见到我这样的神仙之前，别老是拿他们和我对比好吗</li>
</ul>
</li>
<li>我记得小时候喜欢把脑袋摘下来，那时候也没人告诉我不能摘，久而久之我摘习惯了就安不回去了<ul>
<li>我生前也这么完</li>
<li>别吹牛了，摘下来你还能活？我小时候就因为脑袋摘下来死过</li>
</ul>
</li>
<li>你知道海水为什么是蓝色的吗<ul>
<li>因为海里有鱼，鱼会吐泡泡，布鲁布鲁（blue）</li>
</ul>
</li>
<li>鸟可以一边飞一边拉屎吗？<ul>
<li>可以</li>
</ul>
</li>
<li>马云：一家啤酒公司出三百万让我拍个广告，我不去，三百万对我来说太便宜了，马卖脾。</li>
<li>今年17，希望比楼下高17个赞，不要多了，多了就老了<ul>
<li>你在挑衅我们的控楼能力</li>
<li>不，你在考验我们的数学运算能力</li>
</ul>
</li>
<li>我也是一名退伍地狙击手，参加过两次集体任务，我看着我的副手牺牲在我不到10米的地方，我只能看着无能为力（战狼一：围尸打援）<ul>
<li>当年打巨人城废墟，我看着我的队友没有复活币一个个死去，我却无能为力，最后我自己一个人亲手干掉了泰坦（穿越火线）</li>
</ul>
</li>
<li>拜月：地球是圆的<ul>
<li>李逍遥：你懂爱吗？</li>
<li>拜月：我在说地球</li>
<li>李逍遥：你tm根本就不懂爱，去死吧</li>
<li>拜月：我就想说地球是圆的，你们疯了吗？</li>
<li>——我说地球是圆的，他们不相信，还要来打我</li>
</ul>
</li>
<li>蔡徐坤上台时被蚊子咬了以下，哎呦好痛啊，顿时瘫倒在地，满头大汗，捂住伤口，保安问还可以嘛，蔡徐坤强忍剧痛爬起来，粉丝们哭成泪人（冒死发文，友军厚葬）<ul>
<li>友军在此</li>
</ul>
</li>
<li>一头公牛从远处狂奔而来说：快跑啊！小编来了！母牛说：小编来了关我屁事啊？公牛急忙说：小编吹牛逼啊。母牛大惊：拔腿就跑，边跑边问：你是公牛你怕什么啊？公牛无奈道：现在的小编不仅吹牛逼，还扯蛋。<ul>
<li>小牛也跑，还爱扯犊子</li>
</ul>
</li>
<li>那年我破门而出，结果我家门坏了<ul>
<li>那年我背井离乡，村里的人再没有喝过一口井水</li>
<li>那年我浪子回头，整个村子都被水淹了</li>
<li>那年我卷土重来，整个村子都被土埋了</li>
<li>那年我金盆洗手，整个村子都暴富了</li>
<li>那年我意气风发，整个村子都被吹飞了</li>
<li>那年我牛逼哄哄，整个村子的牛逼都没有了</li>
<li>那年我悬梁刺股，村里的人再也没有了屁股</li>
<li>这层楼有毒</li>
</ul>
</li>
<li>地振高岗，一派溪山千古秀；<ul>
<li>门朝大海，三河合水万年流。敢问兄弟可是韦香主？</li>
</ul>
</li>
<li>终于找到你<ul>
<li>原来你在这</li>
</ul>
</li>
<li>被金钱蒙蔽了双眼，被爱情冲昏了头脑，被社会吞没了人性<ul>
<li>——这是一条被网友吞没的优秀评论</li>
</ul>
</li>
<li>五十块钱？早恋？我要伸张正义，不不不，我不是为了那五十块钱，我是为了伸张正义，为了祖国的花朵。（举报早恋奖50块）</li>
<li>开局三张图，内容全靠编</li>
<li>我的儿子是最帅的，前提是你们谁要和我生个儿子。<ul>
<li>——我我我！</li>
<li>——善意的提醒一下，两个男人是不能生孩子的。</li>
</ul>
</li>
<li>明天我要去动手术了，我尽量在拖，但是因为最近的气候原因必须要做的，头部结缔组织群里切除手术，祝我好运，陌生人，可以给个赞吗？<ul>
<li>——剪个头发至于吗</li>
</ul>
</li>
<li>“你感动吗？”——“不敢动”</li>
<li>这男的现在在医院，我看见他了，他说医院的wifi挺好的</li>
<li>在下野猪佩奇，明猪不装暗逼，我出去吃一口猪食，回来要是没有十个赞，我就拱死在坐的各位，注意 是拱死（路过的也跑不了） <ul>
<li>——“非洲瘟都没能死你” </li>
<li>——“闹猪瘟”</li>
</ul>
</li>
<li>游戏中毒是种病，得治，治病就得去医院，医院在G港旁边，不谢。</li>
<li>我是精神病医院主任，我院领导在看到你发表的文章后，对你的病情十分重视，让我来和你取得联系。神经病是一种可治可防的病，只要你积极主动和配合，就一定可以治愈，最后希望你能树立信心，祝你早日康复，病魔早日战胜你。</li>
<li>你是什么？和尚还是科学家？<ul>
<li>我是一位出家的科学家</li>
</ul>
</li>
<li>我和小编是世交，我和他爷爷常常以棋会友，杀的你死我活，定分个高下。一次，最后我只剩一个士，他爷爷只剩个象。于是便约定，两棋都可以过河，然后他爷爷用象象我，我用士士他爷爷，就这样，他爷爷象我，我士他爷爷。</li>
<li>“我有一个大胆的想法，不知当讲不当讲”——“我国有一套完整的刑法，请收起你的想法”</li>
<li>楼主，虽然没有看到源码，仅凭那寥寥数几的图片，就让我汗颜啊，对楼主瞬间佩服的五体投地，有如醍醐灌顶之效，暮然回首发现自己已经没有什么技术可言，真是关公面前耍大刀班门弄斧。楼主的无私奉献精神，值得生活在物欲横流的当今社会背景下的人深思，让我再次感受到世上还有好人在好人一生平安，至此请容许我再次对楼主产生敬佩之情，此敬佩非彼敬佩，是由心而发令人肃然起敬。于是经过深思熟虑之后，我终于做出了一个令我都不敢相信的决定，那就是超过百字的回复。至此，我又做出了决定，要顶起这个帖子，不然将会受到道德的谴责，让真理无法重见天日，我相信一滴水也能激起千层浪，好帖不应石沉大海，顶起</li>
<li>“草!”——此回复虽有且仅有一个字,却深刻地表达了回复人的深深的祝福与刻骨的情感,可谓言简意赅,一字千金,字字扣人心弦,催人泪下,足以见作者扎实的文字功底和信手拈来的写作技巧及惨绝人寰的创新能力.实是佩服佩服!再加上以感叹号收尾,点睛之笔,妙笔生花,意境深远,照应前文,升华主题,把作者的感情表达得淋漓尽致,给人无限感动和惆怅,有浑然天成之感,实乃回复中之极品,祝福中之绝笔.）</li>
<li>路过。这句话虽然只有短短两个字，却透露出一丝高冷与漫不经心的从容，与本人那放荡不羁的身影相得益彰，结尾的句号礼貌又不失疏离，恰如其分地显示了本人高贵而优雅地气质，此时你若回头，便会看到一位心情似乎不太好地西楼扛把子与你擦肩而过。</li>
<li>老夫装逼20多年，自以为无人能敌，今日得见贤弟，才知一山还有一山高，能将装逼这种艺术和装可爱融为一体，实乃老夫生平之仅见，贤弟的装逼技术已至化境，老夫自叹不如，老夫决定退隐装逼界，从此不问世事</li>
<li>袁隆平爷爷一定后悔让你们吃太饱。</li>
<li>要是秦始皇还活着，看到你们这么闲，长城起码还能在多加两万米，兵马俑的坑还能挖大点<ul>
<li>要是隋炀帝还活着，看到你们这么闲，大运河还能再挖两万米</li>
</ul>
</li>
<li>评论一群活在新时代的垃圾废物有资格说别人么<ul>
<li>屁话，历史就是拿给后人评论的，你可以评论未来的人？</li>
</ul>
</li>
<li>老子寸土不让，儿子一枪不放（张作霖、张学良）</li>
<li>东北三连击：老铁、太君、666</li>
<li>当领导吃喝嫖赌的时候开开心心，遇到麻烦就是你行你上，当年曹刿论战的时候也是先加官再打仗的</li>
<li>如果这赞是单数我吃翔，如果是双数楼下全部吃翔，玩的就是心跳，要的就是刺激！<ul>
<li>——请不要骗屎吃</li>
</ul>
</li>
<li>从前有个商人说：“我的矛可以刺穿天下所有的盾，我的盾可以防住天下所有的矛”，这时一个人说到：“那拿你的矛刺你的盾会怎样？”商人拿矛戳死了他：“就你特么b话多”</li>
<li>抓住小编了！！快！！一楼拿绳子，二楼架锅烧水，三楼准备柴火，四楼准备好盐、油、酱、醋，五楼，哎，五楼你脱裤子干嘛？这个不能日，不能日！六楼拦住五楼，七楼、八楼一起把小编扛来，小心！它咬人！</li>
<li>你错了，长得丑，别人才不会嫉妒你，路上坏人不会惦记你，长得丑才好，长得丑是我为人处事的第二标准。<ul>
<li>完了，怎么办，我长得这么好看</li>
</ul>
</li>
<li>确认过眼神，是我惹不起的人。</li>
<li>猫：我回头就是一爪子，结果发现他爸站在后面，我也很无奈</li>
<li>能遇到邓超这样的future，可以说是很幸运了<ul>
<li>further</li>
<li>不是father？</li>
</ul>
</li>
<li>你不是一个人<ul>
<li>楼主，楼上说你不是人</li>
</ul>
</li>
<li>我记得5年前看到一个被土拨鼠咬伤的帖子，楼主到现在也没回复我们</li>
<li>我打王者荣耀的时候遇到了陈奕迅<ul>
<li>我还遇到薛之谦呢，可是被我们吊打</li>
</ul>
</li>
<li>冰封战神返场了，期待了很长时间，但我决定不买了，天气变冷了，给妈妈添件衣服<ul>
<li>希望你真是这样想的，不是骗赞的</li>
</ul>
</li>
<li>大家好，我是铠，有人加我铠哥，有人叫我铠爷，还有人叫我八秒真男人，甚至有人叫我铠甲勇士，这都不重要，我妹妹露娜要结婚了，我亏欠她太多了，所以我准备在她结婚的时候送她一件嫁衣，希望有人能资助我71块钱，感激不尽。</li>
<li>问：周瑜的媳妇叫小乔，小乔的姐姐叫大乔，大乔嫁给了孙策，孙策妹妹叫孙尚香，孙尚香后来嫁给了刘备，刘备有个儿子叫刘禅，刘禅即位后，他的皇后叫张皇后，张皇后的母亲叫夏侯娟，夏侯娟的父亲叫夏侯渊，夏侯渊的哥哥叫夏侯惇，夏侯惇管周瑜叫什么？<ul>
<li>叫周瑜去中路</li>
<li>叫周瑜别送</li>
</ul>
</li>
<li>曹操宴请家将，席间两个小妾为了争宠而相互打闹，吵着要曹操替他们佐助，曹操大怒：你俩同归于尽好了！全场鸦雀无声，突然一将冲出跪地说到：末将于禁谢丞相赏赐！。<ul>
<li>末将于禁，愿为曹家世代延续香火。（赴汤蹈火）</li>
</ul>
</li>
<li>大家好，我只想告诉大家，我爱学习，学习使我快乐，所以我想买两本练习册做做，只要88.88+58.88块，请大家资助我，绝对不是为了什么冰封战神美猴王，如果没有的话我等会再来发一遍<ul>
<li>你应该学学楼上</li>
</ul>
</li>
<li>千万不要点这个赞，三个月前有人赞我他考上了清华。一个月前有人赞我，他追到了心仪的女孩，上周有人赞我，他捡了五百块钱，昨天有人赞我，他免了暑假作业。各位切勿以身试险啊<ul>
<li>——之前有人赞了你，被罚抄作业了</li>
</ul>
</li>
<li>别再骂鹿晗了，你们了解鹿晗吗，你们知道鹿晗有多么不容易吗？他拍戏时手指划破了，都坚持没去医院，医生说要是晚来一小时的话就痊愈了（友军快来，我坚持不住了）<ul>
<li>突击手已就位</li>
<li>狙击手已就位</li>
<li>蔡徐坤原名蔡萝莉，号女装大佬，与鹿晗并称铁血硬汉，上次被蚊子咬了，只哭了三天</li>
</ul>
</li>
<li>女装只有0次和无数次</li>
<li>大家好，我是一名小学生，我刚刚在外面观察蚂蚁，我先放了一颗糖，不一会一个蚂蚁来了，可是他拿不动，于是我看到他去找同伙了，等他们快来了，我把糖拿走了。</li>
<li>我在等一个女孩<em>子</em>拿掉我手头的烟，我就不抽了。等喜欢的人睡到我怀里我就不熬夜了。等我穿到喜欢的人送的衣服,我就不要风度只要温度了。我们喝不到清晨的粥，只可喝到深夜的酒，哈喽，陌生人。</li>
<li>很一般的一首歌，旋律不优美，演唱不出彩，歌词无内涵，总体评价不及小苹果一半的一半<ul>
<li>李荣浩：本来想唱一句完整的歌词来着，后来忘了</li>
<li>感谢荣浩在百忙之中抽空敷衍我们</li>
</ul>
</li>
<li>没文化真可怕，我给你们科普一下，这叫海螺，又名眼镜蛇，学名北极熊，医学用名又叫大海龟，一般生活再沙漠，所以俗称贵宾犬，不懂就不要乱说你们一个个的，连八爪鱼都不认识，你们好意思说他是皮皮虾，佩服</li>
<li>最新的解压方法：平躺，放松大腿，大脚拇指尽量往下按，其他四根脚趾头尽量上抬，记得回来赞我哦<ul>
<li>抽筋怎么办，在线等</li>
</ul>
</li>
<li>我有个朋友，跟这作者差不多，也是爱编故事，去年走的，走的时候并不安详，尸体在太平间抽搐了三天，火化时烧到一半还停电了，等了半天再烧。家属坚强的忍住没有哭，甚至还有一个笑出了声</li>
<li>中国脑残千千万，快手抖音各一半，开个直播像要饭，只要能红啥都干，要是礼物给到位，各种姿势啥都会，完全任由你支配，又不脏又不累，又不担心会犯罪，南抖音北快手，智障界两泰斗，喷我TM全是狗</li>
<li>啥也别说，快！有哪位兄弟在湘潭万达广场的，我在四楼厕所的第二个蹲位。</li>
<li>大家好，我是骗子，我想吃棒棒糖，愿意上当受骗的就给我发2块钱红包，就当给自己买个教训，不要问我为什么别人骗15我骗2块，因为我是一个不贪心的片子，傻的来，不傻的就别来了，因为我感觉我可能骂不过你<ul>
<li>你倒是留个联系方式啊</li>
</ul>
</li>
<li>最近新皮肤出了很多，钱又不够花了，今天又找妈妈要钱，妈妈问我为什么最近钱花的这么快，我哭着对妈妈说我吸毒了。妈妈浑身颤抖着，扶起了我，突然大笑道：还好还好，我还以为你玩王者荣耀了呢。</li>
<li>这个太简单了，只要把自己的头切下来，然后用手拿着，你问我结束之后怎么弄回去，说实话我也不知道，我只弄过一遍。<ul>
<li>闯了你嘞鬼咯，哪个哈戳戳的看到起相信嘛</li>
<li>四川人说，听的你的话，斤斤拉到卡！信你个锤子</li>
</ul>
</li>
<li>佛：我可以满足你一个愿望。<ul>
<li>我：让每个人都健康快乐</li>
<li>佛：愿望太大了就四天</li>
<li>我：那就春天夏天秋天冬天</li>
<li>佛：就三天</li>
<li>我：那就昨天今天明天</li>
<li>佛：就一天</li>
<li>我：那就每一天好了</li>
<li>佛苦笑着说：那就赞你的人每天健康快乐</li>
</ul>
</li>
<li>元芳你怎么看？<ul>
<li>大人，用眼睛看</li>
<li>大人，属下用暴风影音看</li>
</ul>
</li>
<li>你好，网恋吗？不用爆照不用见面，每天跟你说早安，中午跟你说午安，晚上跟你说晚安，感冒了给你驱寒温暖，当我们聊久了，聊出感情时，我会告诉你，对不起，我只是玩玩</li>
<li>深海鱼一般没人看见，所以长得很放肆</li>
<li>有个很傻的男孩，每天在看点里发评论，但没人理他，回复他，或关注他，他的出现只想默默的祝福所有人。抱歉，那个很傻的男孩就是我，如果你看到这条评论，那么祝福你，陌生人，希望你余生有人相伴，祝你幸福。</li>
<li>有一天我问魔镜：天下那个男的最帅。魔镜说：当然是您最帅了。我反手就把魔镜朝地上一摔，大吼道：再做给我点赞的哪个不比我帅？</li>
<li>在下不才，有一诗相送：霄边失沙壁，暮幽晓寂寂。朔画镶方辟，酒会虾碧碧。诗歌笑抬剑，大步鸟飞疾。春才尔白雾，成田方沟辟。泥若香不透，卧草逆麻蔽。</li>
<li>女孩子不小心把手划一个口子，男孩看见了，也用刀把自己的手划了个口子，女孩问他为什么，男孩说：这样我们就是两口子了。女孩笑了，过了两天，两人得破伤风死了。<ul>
<li>女孩给男孩做可乐鸡翅！男孩吃了以后对女孩说很好吃。女孩拿过来吃了一口对男孩说没熟。男孩对女孩笑了笑。你做的不管怎么样我多喜欢！女孩看着男孩英俊的面孔笑了！ 两天后，他们两个得禽流感死了。</li>
</ul>
</li>
<li>帖子写的很好。不过兄弟，别怪我多疑，以你的语言表达能力，文字组织能力，我绝对不相信你是一个刚从达内培训出来，一个月拿7000块，头发油腻不修边幅得安卓程序员。写作这个东西看起来容易，但这么长得帖子，要写的井井有条，张弛有度，要长期训练才行的。何况要再懂技术，那就更难了，这也许是你好些年前得经历，现在有时间重新回忆，也许你是很专业得写作者，只是不知道干嘛到这个已经快没落得论坛上来灌水，万一你真是沧海遗珠，也不要做什么安卓后端了，互联网行业能够写作的技术人员太稀缺了，你给我留个言，工资翻一倍，北京，广州，上海随你挑<ul>
<li>回帖写的很好，不过兄弟，别怪我多疑，以你的路子人际关系网的范围，我绝不相信你是一个互联网猎头，你吹牛逼的能力在茫茫天涯太稀缺了，万一你真是偷天换日，欲盖弥彰，巧言令色，口舌如簧，见光死，自圆其说，自欺欺人，欺世盗名，瞒天过海，贼眉鼠眼，心怀鬼胎的吹牛皮职业大神，你也不要在天涯回帖骗人了，天涯你这种人才太稀缺了，你给我留个言，天涯各大板块版主任你挑。</li>
</ul>
</li>
<li>nmsl，意思就是Never Mind the Scandal and Libel，意思是永远不要理会谣言和中伤，所以蔡徐坤加油，蔡徐坤nmsl！蔡徐坤nmsl！</li>
<li>文体两开花<ul>
<li>什么都不说了，开花</li>
<li>大家好，谈到七龙珠我就想起猴子，想起猴子我就想起了，今年下半年的中美合拍的西游记即将开拍……</li>
<li>中国老一辈的艺术家，美猴王的扮演者六小龄童，合计36年的演艺生涯，拍下无数经典的荧幕形象，文化人说话不能体面点吗？体谅体谅六小龄童老师不行吗，两次三次的黑就算了，开始到现在黑个不停，花时间黑人有意思吗？（藏头）</li>
</ul>
</li>
<li>老婆这么漂亮还出轨，想不通啊！（陈思成）<ul>
<li>给你个全皮肤的王者号，你也会不想打王者了</li>
<li>你以后有了孩子就知道了，我买了各种汽车变形金刚给孩子，他就是跑去隔壁邻居家的马桶圈，我说你咋这么没眼光，这么多玩具不玩，他回答：因为没玩过……</li>
</ul>
</li>
<li>蚩尤（网名）：好可爱，一种复杂的眼神<ul>
<li>说吧，兄弟你想干嘛。</li>
<li>这是他的坐骑</li>
<li>你当年就是骑着这个打黄帝的。。。</li>
</ul>
</li>
<li>为啥以前那么穷头发那么多，现在人的生活水平好了，路上好多年轻秃子<ul>
<li>以前洗发水是洗发水，现在造假太多了</li>
<li>现在秃顶的是以前那帮长头发的二愣子</li>
</ul>
</li>
<li>周慧敏，当年的最爱 我的最爱<ul>
<li>错了，最开始是你爸爸的最爱，后来是你和你爸爸的最爱，现在是你爸爸和你还有你儿子的最爱</li>
</ul>
</li>
<li>一个巴掌拍不响<ul>
<li>呼你脸上响不响</li>
<li>你脸伸过来，我打一下，看响不响</li>
<li>你路上被狗咬了，难不成是因为你勾引了疯狗？</li>
</ul>
</li>
</ul>
<h2 id="看弹幕让我知道不是一个人在皮，而是一群人"><a href="#看弹幕让我知道不是一个人在皮，而是一群人" class="headerlink" title="看弹幕让我知道不是一个人在皮，而是一群人"></a>看弹幕让我知道不是一个人在皮，而是一群人</h2><ul>
<li>单身久了，看只尸蟞都觉得眉清目秀。</li>
<li>北冥有鱼，其名为鲲，鲲之大，一锅炖不下</li>
<li>你以为你接受的是谁的爱？是一个天神的爱，她背叛了所有的神灵去爱你，为你忍受一切痛苦，带给你欢乐，你居然去泡一条鱼？<ul>
<li>我现在就把他抓回来煲鱼头汤</li>
</ul>
</li>
<li>性感云龙，在线指挥（亮剑）<ul>
<li>性感成瞎子，在线撤退</li>
<li>性感大喵，在线摔帽</li>
<li>性感燕双鹰，在线杀鬼子</li>
<li>性感丁伟，在线炸钱</li>
</ul>
</li>
<li>周卫国：等劳资上大号，三十万东北军给你打成筛子（文章：周卫国，张学良）<ul>
<li>您的余额已不足，请及时充值</li>
</ul>
</li>
<li>世上能跟小僧打成平手的没有几个，能把小僧打死的倒很多（天龙八部：鸠摩智）<ul>
<li>阁下就是乔峰，贫僧今天总算有幸会齐北乔峰，南慕容，只可惜南慕容早已不堪一击。……降龙十八掌果然是世上绝学，世上能够和小僧打成平手的没有几人。</li>
<li>大师你错了，慕容公子乃是在下的朋友，他的武功造诣在下十分清楚。一时成败何以定输赢？况且他实在是烂，是乔某所不能及。</li>
<li>他的武功造诣在下十分清楚，菜的一匹，我都不愿说他</li>
</ul>
</li>
<li>刚开服的时候大家起点一样，所以慕容复大杀四方，但是后期慕容复坚持不充值，天真的认为踏踏实实做任务打怪升级，就可以做全服第一，还说自己玩的是真天龙。再看乔峰，首充就送音响一台，虚竹、段誉更厉害，入行虽然晚，但是强力充值全服第一，激活游戏隐藏剧情，瞬间爆炸，你玩的过RMB玩家吗</li>
<li>马东锡：可以走法律程序，但我要和他一个监狱<ul>
<li>他在韩国是神一样的存在，所以我们叫他神马东锡</li>
</ul>
</li>
<li>过儿何苦为难过儿。（扫毒，刘德华，古天乐）</li>
<li>咏春，张天志<ul>
<li>咏梅，王安石</li>
<li>咏鹅，骆宾王</li>
<li>咏柳，贺知章</li>
<li>咏雪，刘义庆</li>
</ul>
</li>
</ul>
<h2 id="雷人台词"><a href="#雷人台词" class="headerlink" title="雷人台词"></a>雷人台词</h2><ul>
<li>因为这种锁，一旦锁上了，只能用钥匙才能打开</li>
<li>目测着十二只断手不是来自一个人</li>
<li>如果是自杀，那他的动机肯定是不想活了</li>
<li>在子弹飞出去的时候快速抖动，让子弹拐弯，这就是枪斗术（抖枪术）</li>
<li>我爷爷在9岁那年就死了</li>
<li>八年抗战马上就要开始了</li>
<li>柯镇恶：看我眼色行事</li>
<li>谢三哥，我这辈子没说过谢字</li>
<li>说出吾名，吓汝一跳，吾乃零陵上将邢道荣！主公，尽可放心，凭末将手中这把梨花开山斧，一定能教什么张飞、赵云之流有来无回，主公，末将必生擒诸葛亮，待末将把他们引入瓮城，万箭齐发，射杀刘备、张飞、诸葛亮。到时候本将军再领一队军马，直取荆州，拿下关羽。<ul>
<li>若军师肯放我回去，我愿为内应，引贵军来袭，活捉刘氏父子，献与军师，我邢道荣若有半句虚言，生时天打雷霹，死时挫骨扬灰。</li>
<li>说出吾名，吓汝一跳，待吾下去，逗你一笑</li>
</ul>
</li>
<li>我有贤相董卓，孝子吕布，忠臣司马懿，聪慧之子刘禅，上将邢道荣、潘凤，王牌说客蒋干，神速运粮苟安，何愁大业不成</li>
</ul>
<h2 id="猥琐笑话"><a href="#猥琐笑话" class="headerlink" title="猥琐笑话"></a>猥琐笑话</h2><ul>
<li>董卓为试众人忠，会晚宴时，令貂蝉抹墨于胸，灯熄，再亮时，众人手皆黑，唯吕布非也，卓大喜，乃赏布，布笑之，而露黑齿。</li>
<li>我不反对夏天女孩子穿裙子，特别是超短裙，想要凉快地心情大家都懂，可你们为什么要在短裤下面穿安全裤？人与人之间最基本的信任都没有了吗？难道我还会偷窥你们不成？想到这，我愤怒地从地上爬了起来。</li>
<li>新婚之夜，小编问妈妈：“妈妈，怎么才能生小孩。”妈妈说：“用你最坚硬的部位碰撞你媳妇尿尿的地方就可以了。”于是，小编用头撞向马桶，当场去世，螺旋升天。<ul>
<li>头铁</li>
</ul>
</li>
<li>性盛至灾，割以永治</li>
<li>是艺术请不要打码，是色情请不要传播<ul>
<li>色情艺术，打码传播</li>
<li>艺术和码不能共存</li>
<li>马家的败类</li>
<li>心中无码，自然高清</li>
<li>兄弟，借一部说话</li>
</ul>
</li>
<li>如果已婚，请穿好你的衣服，这是对你丈夫的尊重；如果未婚，也请穿好衣服，这是对你自己的尊重，如果是出来卖的，请说明价格和服务，这是对消费者的尊重；如果不卖只是为了博眼球，请你再穿少点，老衲看的不够清楚。</li>
<li>有天，唐僧饿了说：悟空，为师饿了，你去化点斋饭吧！悟空很快回来，手里只拿了几根黄瓜，唐僧：这是到哪里了？悟空：方圆几百里都是黄瓜地，我也不知道这是哪里！唐僧：扶我起来，想必是到了女儿国了！</li>
<li>生人不敢开口，熟人不敢下手。没有一见钟情的资本，又缺乏日久生情的条件，人群中的段子手，人群后的单身狗，躲得过对酒当歌的夜，逃不掉四下无人的街。我期盼着以为富婆看穿我的坚强，让我卸下我的伪装。</li>
<li>那年我在深圳一家充气娃娃厂上班，厂里每个人的工作岗位都不一样，有的是装胳膊的，有的装腿的，我的工作是负责装逼，整个流水线有几十个装逼的人，但他们靠装逼混时间混工资，只有我装的逼既逼真又耐用</li>
<li>我是外地的，刚来庵埠，不小心被蜈蚣咬了口，伤口开始肿胀，吃药打针都没得用，看到没办法了，正好遇到一个道士，道士说我遇到的是百年蜈蚣精，要治好必须去寻找它的天敌。所以问大家，庵埠附近哪里有鸡。<ul>
<li>找个鸡都这么委婉</li>
</ul>
</li>
<li>坐公交，一妹子上车，我拍拍他的大腿说：这有软座，谁知妹子叫道：得了吧，一会软座变硬座，硬座变插座，到时候走都走不了了</li>
<li>我在经过了思想斗争之后，实在是忍不住，终于推开了妹妹的房间门，我把妹妹扑倒在床上，开始扒她的裤子，妹妹激烈反抗，但是面对我还是没有用，他只能在那默默的哭泣，半天过后，我终于帮她换号了纸尿裤。</li>
<li>汤唯，杨幂，江疏影，莉哥3块全部带走<ul>
<li>借一部说话</li>
</ul>
</li>
<li>上次给我莉哥种子的那个哥们，请你出来一下，184G特么下载了我两个晚上，下载完一看竟然是春晚合集，感谢你让我意识到健康生活，请你留下你的联系方式，还有地址，方便我登门拜访。<ul>
<li>——送你上去，借楼，那个给我325G新闻联播的兄弟，你出来，保证不打死你</li>
</ul>
</li>
<li>上次有一个傻哥们问我要莉哥种子，我为了他的健康，就把184G春晚合集发给了他，听说这个哥们在看点上找我，要登门拜访我，我家住在翻斗花园二号楼一零零一室，我叫胡图图，记得来我们家要按门铃<ul>
<li>——终于找到你了</li>
<li>——cnm原来就是你，我下了好几天</li>
</ul>
</li>
<li>我看到路边车里有一对男女被锁车里了，衣服都脱了，拼命挣扎，车一晃一晃的，女的很难受，好像缺氧，男的正在做人工呼吸，人命关天，我捡块砖头就砸过去，他们得救了，一直喊着是谁是谁，可我已走远了，不用谢我，我叫雷锋</li>
<li>等我练出腹肌，以后再有小姐姐问路，我就掀开上衣，指着肚子说：小姐姐你看，你现在在这个路口，上北下南，您往南走，走过三个路口，你会看见一片草地，上面有个大电线杆子，你可以坐上去等车</li>
<li>语文课上，老师说：“‘炎炎烈日下，一个少女正在用手挡住阳光’，谁能把这句话翻译成文言文?”小明站起来说：“一女怕日，以手遮阴。”全班响起了轰轰烈烈的掌声。</li>
<li>知男而上，迎男而上，男上加男，强人锁男，世上无难事只怕有心人，奸男显阻，左右为男，步履奸男，孤掌男鸣，插炽男桃，男颜之隐，难舍男分，本性男移，男能可贵，天理男容。<ul>
<li>满头大汉，满汉全席，汉留夹背</li>
</ul>
</li>
<li>美国有个节目，说小伙网恋对象是女装大佬，然后得知实情后，说：人生苦短，何妨一试？于是就亲起来了</li>
<li>一世鹰名，毁于一蛋。<ul>
<li>鸡鹰突变</li>
<li>东条鹰鸡</li>
</ul>
</li>
<li>小编啊，你爹让我带句话给你，在大城市打工，你小子千万不要乱搞，不然回去传染给你媳妇，害了你哥不要紧，如果你嫂子传染给你爹，让你妈有事，那全村人就都完了<ul>
<li>——一个感冒看你说的</li>
</ul>
</li>
<li>‘我爱上了一个比我小6岁的女孩，现在还在上学’，造孽啊！你要是把‘爱’字去掉，那才是造孽啊，再把‘比我小’去掉那就真的造孽了，再把‘了’字去掉还要造孽啊，再把‘学’字去掉我就可以拖出去枪毙了。</li>
<li>寝室一上铺室友在和女友聊短信，女友说：“月亮下去了，太阳怎么还不出来”，室友想半天不懂什么意思，就问我们，我们也不懂……只听寝室长幽幽地说了一句：月经走了，怎么还不来日。嗖的一声，上铺那家伙就不见了……<ul>
<li>——之所以他是寝室长不是没有原因的</li>
</ul>
</li>
<li>听最嗨的歌曲，喝最强烈的酒，日最骚的女鬼，开最快的跑车，出最惨的车祸，住最好的医院，打最贵的石膏，撩最翘的护士，玩最炫的轮椅，睡最好的棺材，挖最深的坑口，埋最好的土地，烧最厚的钱纸，长最高的坟草，投最牛逼的胎 看最牛的评论，叼最小的路过，屌最大的都点赞。</li>
<li>工资四千每月都拿出三千去做慈善，身边的朋友说我傻，劝我把钱存起来娶老婆，但是当我看见漆黑的巷里站着的弱女子，望着那无辜的眼神，我所做的一切都是值得的，我会把慈善当成我生活中的一部分，坚持下去，心存善念，加油<ul>
<li>嫖个娼给你说的这么高大上</li>
</ul>
</li>
<li>夜已深，天微凉。路过小巷见几女，衣甚薄，风中瑟瑟抖，爱心起，欲施二三百，岂料女甚感恩硬拽屋中，更怜爱，遂生情，云雨三刻，觉不爱，施之分手费二百，何错之有？<ul>
<li>嫖娼都能被你说的那么冠冕堂皇，你真是个人才</li>
<li>人家只是一见钟情，陷入爱河，不能自拔，后来发现不能长相厮守，于是给了点分手费，这么凄美的爱情故事怎么到了你们嘴里就变成嫖娼了呢？</li>
<li>然尔等不知礼数，肆意妄为，国有法制之，尔虽心怜，但汝等家中尚有妻室，可施钱粮，不可施精血，天意难测，若尔因与此女云雨而身染隐疾，岂不呜呼？</li>
</ul>
</li>
<li>从前有个穷学生，买不起灯油，他的隔壁住着一对新婚夫妇，昼夜烽烟灯火通明，他就在墙上凿了一个洞，从此学业荒废，一蹶不振。</li>
<li>我们男生快手玩多了戒不了，正如女生玩抖音一个道理，舒服</li>
<li>牛顿说过，你有一个苹果我有一个苹果，我们交换了还是有一个苹果，但是你有一个网站，我有一个网站，我们交换了就有了两个网站。<ul>
<li>兄弟，借一部说话</li>
</ul>
</li>
<li>一男老师气愤地对上课睡觉的女生说：我在上面累的要死，你在下面一动不动，不配合也就罢了，连一点反应都没有，将来要是肚子里没东西，别怪老师不行</li>
<li>有一位伟人曾经说过：我们的女同志，从上往下要看两个突出的问题，从下往上看，有个明显的漏洞，身为男人的我们要用勤劳的双手去抓住问题，用革命的枪杆，堵住漏洞</li>
<li>日本人觉得女孩子有小虎牙很可爱，欧美人觉得女孩子有雀斑就很可爱，而你们这些人，居然觉得女孩子下面有大宝贝才可爱。</li>
<li>有没有网恋的小哥哥，我会撒娇，会卖萌，会娇喘，游戏打得也不吭，处的好的话可以奔现，但是有一点，你不能摸人家的几把。</li>
<li>小生不才，愿用一夜冲动换姑娘十月安稳，若姑娘不愿，但请莫怪小生用三年牢狱之灾换姑娘一生阴影。</li>
<li>身不在高，米五就行。胸不在大，有型则灵。斯是萝莉，为吾是侵，洋装猫耳朵，小嘴大眼睛，短发很俏丽，长发也飘逸，可以给糖果，玩亲亲。无八卦之乱耳，无血拼之劳行。学校游泳室，公园小凉亭。孔子云：三年起步，最高死刑。</li>
<li>之前打排位，一个安其拉突然说：我男朋友想要，我先挂机。她还开着麦，最后我们四个硬生生守了两个小时</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>著名台词</title>
    <url>/2018/04/14/personal-2018-04-14-Phrase/</url>
    <content><![CDATA[<ul>
<li>马东锡：可以走法律程序，但我要和他一个监狱——《恶人传》</li>
<li>“你是谁？”“我是中国最后一个皇帝。”“用什么证明？”溥仪走向龙椅，从那下面拿出了蛐蛐，笑得就像个孩子。——《末代皇帝》</li>
<li>曾经引以为傲的高音，现在已经无法驾驭了，听台下自发的大合唱，校长谭咏麟眼含热泪，70随唱不动又如何，你起头就行。</li>
<li>“我得了抑郁症，该怎么办”<ul>
<li>“不要紧，城里来了位著名的小丑，会说所有笑话，看了他的表演，你就不会再烦恼了”</li>
<li>“可是医生，我就是那个小丑啊”</li>
</ul>
</li>
<li>智力与爱人的能力无光，爱本就很纯粹，很简单。有多少自认为聪明的人确失去了爱人的能力。——《山姆先生》</li>
<li>人生陆远，只有忘得甘敬，才能得到江莱，赢得嘉禾——《好先生》<ul>
<li>人生陆远，就算没有忘得甘敬，江莱也在等你</li>
</ul>
</li>
<li>阿娘说：想吃什么，什么便是良药——《灵魂摆渡-黄泉》<ul>
<li>我见你生得好看，闻着香甜</li>
</ul>
</li>
<li>行动处处长行动不便，情报处处长为情所困，明家人身份不明</li>
<li>他的初恋不是他给了阿泽，是他自己弄丢的哦。<ul>
<li>所以搞怪的不是红绿灯不是时机，而是我数不清的犹豫——《请回答1988》</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我要是对你有感觉又不和你在一起你会不会觉得我吊着你。</span><br><span class="line">要说我对你有感觉呢有勉强和你在一起你会不会觉得我欺骗你</span><br><span class="line">你说我要是对你没感觉却和你在一起会不会觉得我玩弄你</span><br><span class="line">你要是觉得我对你没感觉又不和你在一起会不会觉得我伤害你</span><br><span class="line">	——《疯人院》</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">看对面来的是谁家女子，生得春光满面，美丽非凡，</span><br><span class="line">这位姑娘，请你停下美丽的脚步，你可知自己犯下了什么样的错误……</span><br><span class="line">这位官人，明明是你的马蹄踢翻了我的竹篮，</span><br><span class="line">你看这宽阔的道路直通蓝天，你却非让这可恶的畜生溅起我满裙污点，怎么反倒怪罪起我的错误？</span><br><span class="line">你的错误，就是美若天仙，</span><br><span class="line">你婀娜的身姿让我的手不听使唤，</span><br><span class="line">你蓬松的乌发涨满了我的眼帘，看不见道路山川，只有漆黑一片</span><br><span class="line">你明艳的面颊让我胯下的这头畜生神魂颠倒，忘记了他的主人是多么威严……</span><br><span class="line">	——《大明宫词》</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">之前总以为是湘琴拯救了银河系才能和直树在一起，后来慢慢发现是直树用光了所有的运气才遇见湘琴</span><br><span class="line"></span><br><span class="line">“我知道你讨厌笨蛋  但你不能欺负我老婆 ”  </span><br><span class="line"></span><br><span class="line">-直树,你要吃蛋糕吗?-我不要。-不是我做的，是我买的。-直树: 好吧,吃一块。</span><br><span class="line"></span><br><span class="line">“江同学你好，我是F班的袁湘琴。嗯，我想你并不认识我，但是我对你却很了解喔。 从第一次在新生训练上看到你，那一天，我的眼光就不知道该怎麼离开你。 不管是致辞的你，还是和旁人聊天的你，还是落寞不说话的你，我总可以很快的在人群中知道你的位置，找到你的位置。彷佛你在哪里，光就在哪里。”</span><br><span class="line"></span><br><span class="line">“湘琴好像永远都不知道我有多爱她”</span><br><span class="line"></span><br><span class="line">湘琴:“我真的是医学系天才江直树的妻子！”</span><br><span class="line"></span><br><span class="line">湘琴：咦你怎么买了巧克力的蛋糕啊，你不是最喜欢草莓的吗？植树：没办法，今天店里只卖这种口味。湘琴：没关系，幸好我最喜欢巧克力口味了。</span><br><span class="line"></span><br><span class="line">湘琴：这是你第二次吻我诶。    </span><br><span class="line">直树：不，这是第三次</span><br><span class="line">湘琴：可是？（努力在脑海中数啊数）</span><br><span class="line">直树：好了，不要数了（一把拥入怀中。。内心想说笨蛋，不能让你知道我偷偷亲你了。）</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>星座学说</title>
    <url>/2018/04/14/personal-2018-04-14-ZodiacStudy/</url>
    <content><![CDATA[<p>泰坦尼克号4月14沉没<br> 2016年4月14日大话西游重映</p>
<p>【白羊座怪癖】</p>
<ul>
<li>双重人；</li>
<li>热爱暗恋；</li>
<li>有时自卑不喜欢跟人打交道，有点闷骚没事喜欢放空；</li>
<li>失眠或者嗜睡；</li>
<li>笑起来是个孩子，冷起来是个谜；</li>
<li>偏执、悲观、轻微强迫症、洁癖、言出必行、悲观、不自信、自恋、自以为是、多疑；</li>
<li>性格和脾气极端；</li>
<li>跟自己较劲，瞎琢磨；</li>
<li>好心肠，易被感动；</li>
<li>爱讲道理整理癖爱纠结。</li>
</ul>
<p>我突然明白为什么石进会写《白羊座的忧伤》和《可惜不是双鱼座》这两首歌了，他一定也和我一样，一直以为自己是双鱼座，直到有一天发现，原来自己一直不是双鱼座……</p>
<p>白羊男一般都很会玩，而且对自己的朋友都很好，有时候白羊男对自己的异性朋友要比对自己的恋人还要好。<br>白羊男生气时，什么狠的话都说得出，例如滚远点、爱怎么想怎么想，那个时候，即使你是他热恋中的女友，他也不会网开一面，可是一般你要是真的感觉很受伤了，不理他了，他又会觉得后悔，觉得伤你了，可是他一般还是不会主动来道歉，除非你给他台阶他才会让你知道他觉得自己错了。<br>一般若不是原则性的问题，和白羊男分手都会有回旋余地，一开始相恋时，你闹闹情绪、提提分手，一般闹完,他们也会当已经过去，可是要是你搞外遇被他晓得，若他还爱你，或许会给你一次机会，可是若你那次机会还不回头，那么很抱歉，从此他都不会再回头了，而且要是你一直闹脾气，跟他吵架，那么等到有一天他爆发出来的时候，就真的很难有任何回旋余地，除非他还没得到你。<br>白羊男，对女孩子的外貌都有一定要求，白羊男要是对一个女的只是娱乐心态，那么他就要求这个女的很性感，比如气质型、清新范。其实白羊男内心喜欢的是比较可爱、又单纯点的女孩子，傻傻的笨笨的，但不要太白痴型的。<br>白羊男一般都不喜欢女的常常一个电话打很久不挂，因为对于他们来说，根本没那么多话可以说，可是一般作为白羊的女友，每当这时候都会很伤心，要是刚开始他还在对你很有兴趣时，他即使心里不开心也会装作很喜欢跟你聊电话，可是当你跟他吵架几次后，他就会越来越对这点不爽，若你能改，那或许还有救，要是依旧跟他闹，那很抱歉，他也不会迁就你，那关系就会越来越僵。<br>白羊男一般很怕女孩子哭，不管是自己爱的人，还是爱自己的人，女孩子一哭，他们多半都会沉默，唯一不同的是，对着爱自己的女人，他们哄几句后要是没效果，就会选择不理，而对自己爱的女人，要是在他面前哭，他心里也会很难过，眼泪攻势这一招在前期用很有效果，可用多了，也没用，白羊男会觉得你很脆弱，他会有压力，当你连哭都没效果时，可能他已经在思考要离开你了。<br>白羊男一般都给人花心的感觉，其实也不是，他们不会很明显地拒绝，喜欢处于暧昧与明朗的界限，可能他们只是想选择一个真正适合自己的女孩子，要是白羊跟你一起，还是让你没安全感，那么或许他觉得跟你只能娱乐，不会放太多心思在你身上，在喜欢白羊男前期，你可以使用感动他这一招，这招在他对你还有兴趣时用对你们的感情特别有帮助，可是在他不爱你时，你做再多感人的事情也等于零。<br>白羊男心底都会有一段难忘的感情，这段感情往往白羊男都会伤得很重，于是自那段感情之后，他们就觉得很难信任女人的真心，白羊男其实比谁都聪明，让你感觉他很真诚，其实他常常玩弄一个女人也让你要死要活地不知道要放弃还是要继续，而这时候或许他早就已经在物色新的对象了。<br>如果你不是美女，那么请不要觉得自己可以感化白羊男，因为对于白羊来说，多半是一见钟情，外貌过不了关，他更没耐心去看你的性格适合不适合他了，白羊男一般喜欢长头发的女孩子居多，白羊男不喜欢太有心机的女人，要是你被他觉得你出卖了他，不管出于任何理由，他可能连解释的机会都不给你，直接疏远你。<br>白羊男，其实都很讨厌自己的女友跟以前的男友还保持着联系，他们嘴上会说着无所谓，其实心里只是怕要被伤，所以装作很不在乎，白羊男其实内心都有很柔软的地方，要是他为你付出得多了，他会觉得自己会被人看扁，这个时候他可能反而会离自己爱的人远了，因为他把自尊看得很重，所以千万不要太让你心爱的白羊男为你挖心挖肺，这样他们会觉得很受伤也很不爽。<br>白羊男有时候很神经质，前一天还很热情，后一天就很冷淡了，白羊男在遇到不开心的事情时，喜欢安静，不爱说话，要是你足够了解他，请在这时候不要打扰他，要是你打扰他，他搞不好就蹦出几句让你呕到家气到家的话，他不想说的东西，你问再多也没用，他要是想说的，他自然会告诉你。<br>不要觉得白羊男爱你，你就该让他为你改变，他或许会因为觉得自己为你心动而为了不让你伤心稍微作点改变，可是白羊天性喜好我行我素，要是他的改变你依旧不领情，那不好意思，他又会回到一开始的冷漠和让人难以理解，白羊男很受不了自己的付出没有回报，对于他们来说特别讲究公平。.<br>爱白羊男很累，你必须要给他足够的空间，因为他玩起来真的可以昏天暗地，忘了其他一切事情，其实这不代表他不爱你，只能说他在那个瞬间更想玩，有时候正当你觉得被他忽略时，他忽然给你点暗示其实他也有惦记你，有点可爱，让你又好气又好笑。<br>白羊男最讨厌解释，要是他觉得没必要解释的东西，你追问再多次，他或许也只会说没什么，白羊男其实有时候又很喜欢安静，喜欢一个人做一些发泄情绪的事情，这个时候千万不要去打扰他，白羊男的情绪一般都不会持续太久，开心或者伤心都一样。<br>白羊男多数都吃软不吃硬，他要是哄你了，请见好就收，不要因为心里不舒服还要继续跟他闹，他要是爱你，他脾气上来时，他会挂你电话，或者喊你别说了，这个时候，你千万不要觉得他是对你不在乎，他只是不会解释不懂表达，其实他只是怕说出让你伤心的话所以选择先冷静自己的情绪。<br>开始懂事的白羊，一般事业心都很强，为了事业可以暂时放掉一切影响自己情绪的因素，例如一段让他累到无法安心学习或者工作的感情，放掉一些休闲娱乐的机会，这个时候他们思考的是要在事业有成时，找一个女人安定下来，给她一辈子的幸福，白羊男在成家后，一般都是个好丈夫和好爸爸。<br>不要说白羊男分了手就会把前恋人遗忘，其实他们只是把她们的记忆放在心底深处，然后又选择让自己轻松的方式继续生活，继续恋爱，但是要是你给他的印象深刻，你真心爱过他或者让他真心爱过，一年半载之后，他们会回来找你，这个时候不要觉得是和好，可能只是把你当成他关心的朋友，他说话会有些让你想歪，可是其实他们只是真心希望你幸福，他们即使不再爱你了，也会因为你用以前爱他们的热情爱其他的男人心里而有点不爽。<br>对待白羊男，你千万要记住，不要看表面，要用心去体会他们的付出，不要让他们告诉你你应该怎么去做，而是要自己努力去走进他们的心。 </p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>道</title>
    <url>/2018/04/14/personal-2018-04-14-Think/</url>
    <content><![CDATA[<ul>
<li><p>从来没有什么孙悟空，也没有什么西游记，师徒五人，其实只有唐僧，其他四个都是唐僧的心魔。途中的磨难，都是唐僧内心的磨砺——定住心猿则悟空，拴住意马则化龙，戒贪戒色共八戒，戒杀戒嗔是悟净，身心纯净朝佛祖，心之所在即西天</p>
</li>
<li><p>以前怕坟，觉得那里面都是鬼，自从有了亲人躺在那里才明白，原来小时候害怕的鬼，是别人日思夜想都再也见不到的人。</p>
</li>
<li><p>古代的药房门口写着：但愿世上无疾苦，宁可架上药生尘</p>
<ul>
<li>现在的药房门口写着：会员积分，买十赠二，消费58送15个鸡蛋</li>
</ul>
</li>
<li><p>有一天，我回到家无意间看见一个箱子，打开一看，里面有很多小人，它们有的拿着枪，有的背着电台，其中一个小人问我：“你看见我们司令了吗？他到哪里去了”，我愣了一下说：“你们司令不会回来了。”小人问为什么，我哽咽着说：“因为他长大了。”</p>
</li>
<li><p>小时候摔倒了，要看看周围有没有人，有就哭，没有就爬起来，长大后摔倒了，要看看周围有没有人，有就爬起来，没有就哭</p>
</li>
<li><p>我们就一天天长大，长出了胡须和白发，为柴米油盐而吵架，心里还是忘不了她。</p>
</li>
<li><p>十年前的心脏很厚，用力才能碎，里面是红袖章，发条青蛙，鸡毛毽子，信纸和崭新的回力运动鞋。十年后的心脏很薄，一吹就能破，里面是啤酒瓶，失眠夜，路灯，黑眼圈和忘关的电视机。</p>
</li>
<li><p>忍一时越想越气，退一步越想越亏</p>
<ul>
<li>同是射手（王者荣耀）</li>
</ul>
</li>
<li><p>原来最开始撕开的那道口子，就已经是你能撕开的最大的口子了，可能指以为后来能找到合适的另一半，穷尽一生，才徒然发现，最开始那个才是最好的。“画屏绣步障，物物自成双。如何湖上望，只是见鸳鸯”。说的就是这个吧</p>
<ul>
<li>这话说得好，就像我妈常说的：一嫁不中，千嫁无用</li>
</ul>
</li>
<li><p>好文章总是没人看，我曾听说过住在罗生门的恶鬼，因为害怕人性的凶残而逃走。</p>
</li>
<li><p>女孩想看世俗，在身上挂了个牌子写：我是艾滋病人，抱抱我好吗？结果她看到行人绕着她走，对她指指点点。当她暗笑那些人时，跑来个男孩抱了她，她很诧异，他告诉她：别怕，我也是艾滋病患者。她听到后像疯一样推开了他</p>
</li>
<li><p>你好。<br>很幸运看到你的问题。<br>但是又很遗憾到现在还没有人回答你的问题。也可能你现在已经在别的地方找到了答案，那就得恭喜你啦。<br>对于你的问题我爱莫能助！<br>可能是你问的问题有些专业了。或者别人没有遇到或者接触过你的问题，所以帮不了你。建议你去问题的相关论坛去求助，那里的人通常比较多，也比较热心，可能能快点帮你解决问题。<br>希望我的回答也能够帮到你！<br>快过年了，<br>最后祝您全家幸福健康快乐每一天！</p>
</li>
<li><p>小丑只是想吓一下女孩，没想到却得到了一个拥抱，孤单的人害怕有人靠近，却也渴望拥抱</p>
</li>
<li><p>自从用了网易云，我把《故事会》退订了</p>
</li>
<li><p>邪正看眼鼻，真假看嘴唇，功名看气概，富贵看精神，主意看指爪，风波看脚筋，若要看条理，全在言语中。</p>
</li>
<li><p>压死骆驼的不是最后一根稻草，而是每一根稻草</p>
</li>
<li><p>一个五岁的小男孩在一群大人的争执中不知所措。他小心翼翼地问道：收养是什么意思。旁边地小女孩低头思考了一下，说：收养的意思就是，你不是怀在妈妈肚子里，而是心里。</p>
</li>
<li><p>心比长相好，懂比爱重要。</p>
</li>
<li><p>我从来都不喜欢分享我的朋友给别人</p>
</li>
<li><p>爱笑的男孩子运气不会太差</p>
<ul>
<li>因为运气差的男孩子笑不出来。</li>
</ul>
</li>
<li><p>幸亏长得丑，没体验过各位的爱恨情仇</p>
</li>
<li><p>买名表算不算缴智商税</p>
<ul>
<li>你要是戴着名表去忽悠人，那不是智商税</li>
<li>你要是被忽悠着去买名表，那就是智商税</li>
<li>你要是被戴着名表的人忽悠了，那你既没有智商，也没有钱去缴智商税</li>
</ul>
</li>
<li><p>于是，当我们开启上帝视角会发现：从女生的角度讲，设定了重重条件，渴望的得不到，得到的却不渴望；从男生的角度讲，千辛万苦越过护城河，爬过高墙，却发现姑娘内心的城堡仍然层层防御，壁垒森严。如果你不能打开她的内心，那么做再多感动、惊喜、有心的事，可能也无济于事。你对高原很有反应，高原对你毫无反应。现在回到最初的问题：为什么很多好女孩没有男朋友。我的看法是，如果没有爱情，条件就是一切，需要占据压倒性优势；有了爱情，条件不过是张启程票，只要让她一开始不排斥你就行。</p>
</li>
<li><p>Z姑娘总是抱怨身边没什么条件合适的人，但是通过***才发现，条件比她好的男生一抓一大把。我后来总结：这就像是春运，都知道火车票很难抢，但你要是上了车，会发现，身边个个都有票。条件这种东西，当你不具备的时候，它很关键，是一切的前提；但当你具备的时候，他就没那么重要了，只是起步的基础。这就像春运，上车前抢到票是关键，而一旦上了车，你会发现有没有座位，是软座还是硬座，是站着还是躺着，旁边的人是翩翩公子还是抠脚大汉，才是真正影响这一路上你的体验和心情的根本因素。在爱情面前，所有的条件都只是铺垫，价值交换只能满足社会需要，并不能满足情感的需要。就像Z姑娘引用一部电影的台词说道：曾经以为生命中最糟糕的事，就是孤独终老。其实不是，最糟糕的是，与那些让你感到孤独的人一起终老。</p>
</li>
<li><p>为什么美国富强，因为你晚上睡觉时，美国人正在努力工作。</p>
<ul>
<li>我tm在上班的时候，他们不是在睡觉吗？</li>
</ul>
</li>
<li><p>“你是如何搞砸一段关系的？”——“正常发挥”</p>
</li>
<li><p>“你感情路不顺吗？”——“顺啊，一路上都没什么人”</p>
</li>
<li><p>这个世上没有感同身受，只有冷暖自知</p>
</li>
<li><p>我曾经很奇怪为什么是瓶邪而不是灵邪，毕竟张起灵和吴邪听起来更配一些。直到我看到盗墓笔记的那句话，世上有很多张起灵，却只此一个闷油瓶。后来，我明白，张起灵是张家的张起灵，闷油瓶却是吴邪的闷油瓶。</p>
</li>
<li><p>你要的是幸福，还是对错</p>
</li>
<li><p>当矛盾发生时，一个不服软，一个在赌气，觉得对方在无理取闹，一个是有心事却得不到关心，这时往往便是疏远的开始。</p>
</li>
<li><p>《骆驼祥子》里有一段话：这世间真话本就不多，一个女子的脸红，胜过一大段对白。可后来有了胭脂，便分不清是真情还是假意。</p>
</li>
<li><p>神雕以写情见长，却狗血地加上尹志平与小龙女一段不堪事。多曾不以为然，而今明了。杨过龙女，一失臂一失贞，好似明镜蒙尘，白璧多瑕。这对璧人虽失去彼此所珍，十六年守望和一生相濡，却将世间一切虚妄地蚊子血米饭粒活成现世地明月光朱砂痣。</p>
</li>
<li><p>如果所有人都说你好，那么你已经死了；如果所有人都说你不好，那么你离死不远了；如果有人说你好，有人说你不好，那么你还活着。</p>
</li>
<li><p>我的前前任和前任都很棒，他们一个教我做温柔的女人，一个教我做成熟的大人。但我更爱我的现任，因为他教我做回小孩。——胡杏儿</p>
</li>
<li><p>我养了两盆一帆风顺，总是王了浇水，等到叶子耷拉下来才想起来喷点水，不出一个小时，又精神起来了。其实我也和这两盆花差不多吧，每当快要死的时候喷点水就又活过来了。</p>
</li>
<li><p>每个当下的善恶都是这个“当下”之前的教育和引导以及环境所造成的人心善恶，而顺序学说却是将每个善恶进行抽丝剥茧的分析，查过程找原因，最终评定善恶的根源和大小。但顺序学说又主要是由人性本恶的学说延伸而来，我们处世，最主要的还是评判一个人的恶的情况比较多。大部分情况下我们界定善的标准是“利己而不损人”</p>
</li>
<li><p>物有本末，事有终始，知所先后，则近道矣。《大学》</p>
</li>
<li><p>陈平安的顺序学说有分先后，审大小，定善恶和知行合一这四个关键点，后来又发展出了脉络学说，也是为定善恶查漏补缺。分先后，不仅时间要分先后，逻辑也要分先后；审大小，应该小到一家人情，一地风俗，大到一国律法，一洲礼仪；定善恶，应要持中正态度，不度入个人情感，不受外物干扰。最为关键的是要按脉络从头到尾捋一遍，站在对方角度看待问题，再去判对错，定善恶。最后，知道了答案那就起而行之，知行合一。</p>
</li>
<li><p>物来顺应，未来不迎，当时不杂，既往不恋</p>
</li>
<li><p>把所有“我不会”变成“我可以学”，把所有“我怕我不行”变成“我可以试试”</p>
</li>
<li><p>男人有两大爱好，拉良家妇女下水，劝风尘女子从良;女人有两大爱好，和穷人总是谈钱，和富人谈的全是感情。如今客户也有两大爱好：和质量好的谈价格，和价格低的谈质量！市场虽然很透明，但你却什么也看不清，我只能告诉你，水很深，熟人是想给你最好的，只是你不信任罢了！</p>
</li>
<li><p>电影院里一个小孩问妈妈：“怎么这么多大人？大人也爱看动漫么？” 妈妈说“是看动漫的小孩都长大了”</p>
</li>
<li><p>如果一个人住，千万不要在下午时睡觉，一觉睡到六七点，等你一睁开眼，看着朦胧黑黑的天空和空荡的房间，会有一种被世界遗弃的感觉，孤独在这一刻体现得淋漓尽致。</p>
</li>
<li><p>戏一旦开了口，哪怕台下没有人也要唱完。人不听，鬼神听。记得两年前上课听老师讲过民国戏子和《桃花扇》的故事，后来发现了这首曲，感受愈加深刻。都道戏子无情，怎知戏子也有心。“俺曾见，金陵玉树莺声晓，秦淮水榭花开早，谁知道容易冰消！眼看他起朱楼，眼看他宴宾客，眼看他楼塌了。这青苔碧瓦堆，俺曾睡过风流觉，把五十年兴亡看饱。那乌衣巷，不姓王；莫愁湖，鬼夜哭；凤凰台，栖枭鸟!残山梦最真，旧境丢难掉。不信这舆图换稿，诌一套‘哀江南’，放悲声唱到老。”</p>
</li>
<li><p>酒逢知己千杯少，话不投机半句多，遥知湖上一樽酒，能忆天涯万里人</p>
</li>
<li><p>我用了半小时赞了500条评论，我知道，我能做的就只有这样。一个小小的赞，让你们开心一点。。陌生人。胃不好别吃辣的冷的，想哭就哭吧。累了就听听歌吧，带上耳机，坐在你爱的地方。你会发现生活没有什么多烦，多痛。有的只有你心中的哪片向往的生活。</p>
</li>
<li><p>歪理一：爱情不分先来后到，只要她还没结婚，我就有机会</p>
<ul>
<li>爱情不是任何插足行为的挡箭牌，如果喜欢的人已经有了恋爱关系，那请你和她保持距离，克制自己的感情，不要逾越。公平竞争只存在于单身的情况下，不管你有多喜欢一个人，只要他有恋人，另一方就是无辜的，爱情不是伤害别人的借口。因为它虽然不分先来后到，但是讲礼义廉耻</li>
</ul>
</li>
</ul>
<ul>
<li><p>1.如果一个人足够聪明，知道在不同场合，不同时间，对不同的人，做不一样的行为，说不一样的话，展现不一样的情绪，呈现不同的状态，给不同的人不一样的印象。知道什么是对的什么是错的，什么是好的什么是坏的。但这并不会有什么帮助，因为心理学只能帮他知道这些却不能帮他做出选择。比如有些事明明知道不好也会去做。<br>2.有心为善、虽善不赏，有心为恶、虽恶不罚。情绪是否有好坏，如果有好坏是否就对应好人和坏人。如果没有好坏，为什么要在知道自己是焦虑，敌对等状态的时候去隐藏他，表现出合群，合理，圆滑，世故。我们选择这么做，往往不是为了自己好过，而是为了别人好过，给别人一个好的印象，让别人不会不舒服，给事情不会造成坏的影响。所以，是不是心理学第一步是认识自己，第二步在了解自己的前提下做出改变，不是为了让自己变得更好，而是为了给别人留下一个更好的自己。如果人人都是心理学专家，是不是人人都没有自我，因为这个自我已经被改变，人人都做那心理学定义了的”好人”</p>
</li>
<li><p>1.需要先明白为什么要参加社交（群体活动、场合）才能针对社恐或者社交障碍做出改变。就好像只讲了方法却没讲为什么要这么做。</p>
<ol start="2">
<li>针对第一个问题为什么要参加社交，再提出疑问：社交是否应该带有目的性或者功利性？<br>3.针对第2个问题，如果不应该，那再反问第一个问题，为什么要参加社交？</li>
<li>针对第2个问题，如果应该，我们称之为“应酬”，如果只是单纯不喜欢参加这种“应酬”，该怎么做？</li>
<li>针对第4个问题，如果答案是要参加，那再反问第1个问题，为什么要参加这种应酬，罗列应酬的好处优势，让大家喜欢上应酬？</li>
<li>针对第5个问题，如果答案是要参加但是可以不喜欢，只是为了在“不得不或者必要的场合”能够做合适的应对，那社交应该是一种辅助技能，目的并不是为了改变自我</li>
</ol>
</li>
<li><p>对于明确要求：更应该让需求方主动说清楚，以5w2h方式建立需求，而不是一点一点挤牙膏去问。如果一个一个问，一般需求方每次只会回答一小点，需要追问。如果一次问7个问题打7个问号，一个是显得不太礼貌。另一个是需求方并不一定会一次回答7个问题。还需要再追问。</p>
</li>
<li><p>对于科学衡量：最近很多问题，解决起来很简单，但是为了识别风险或者为了验证是否存在那样的风险，做了很多尝试和验证，想得太多，所以很耗时间，但是最终问题难度也只能算D，外人是从结果出发想这个问题，自然会简单了许多，但是RD解问题的时候考虑的远远不是解完该问题就好了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>博君一笑图</title>
    <url>/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/</url>
    <content><![CDATA[<img src="/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/列夫托尔斯泰日记.jpg" style="zoom:25%;">

<img src="/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/斜着看.jpg" style="zoom:25%;">

<p>神评：防窥膜，看不见</p>
<img src="/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/巨人烂尾1.jpg" style="zoom:25%;">

<img src="/2018/04/14/personal-2018-04-14-%E5%8D%9A%E5%90%9B%E4%B8%80%E7%AC%91%E5%9B%BE/巨人烂尾2.jpg" style="zoom:25%;">
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>作为一个诗人</title>
    <url>/2018/04/14/personal-2018-04-14-AsPoetry/</url>
    <content><![CDATA[<center>
    <b><font size="5">越人歌</font></b><br>
    <font size="2">【作者】佚名 【朝代】先秦</font><br>
    今夕何夕兮搴洲中流。<br>
    今日何日兮得与王子同舟。<br>
    蒙羞被好兮不訾诟耻。<br>
    心几烦而不绝兮得知王子。<br>
    山有木兮木有枝。<br>
    心悦君兮君不知。<br>
</center>



<center>
    <b><font size="5">南歌子词二首 / 新添声杨柳枝词</font></b><br>
    <font size="2">【作者】温庭筠 【朝代】唐</font><br>
    一尺深红胜曲尘，天生旧物不如新。<br>
    合欢桃核终堪恨，里许元来别有人。<br>
    井底点灯深烛伊，共郎长行莫围棋。<br>
    玲珑骰子安红豆，入骨相思知不知。<br>
</center>


<center>
    <b><font size="5">鹧鸪天·元夕有所梦</font></b><br>
    <font size="2">【作者】姜夔 【朝代】宋</font><br>
       肥水东流无尽期。当初不合种相思。<br>
    梦中未比丹青见，暗里忽惊山鸟啼。<br>
    春未绿，鬓先丝。人间别久不成悲。<br>
    谁教岁岁红莲夜，两处沉吟各自知。<br>
</center>


<center>
    <b><font size="5">古相思曲</font></b><br>
    <font size="2">乐府</font><br>
       十三与君初相识，王侯宅里弄丝竹。<br>
    只缘感君一回顾，使我思君朝与暮。<br>
    再见君时妾十五，且为君作霓裳舞。<br>
    可叹年华如朝露，何时衔泥巢君屋？<br>
</center>


<center>
    <b><font size="5">古相思曲</font></b><br>
    <font size="2">乐府</font><br>
       君似明月我似雾，雾随月隐空留露。<br>
    君善抚琴我善舞，曲终人离心若堵。<br>
    只缘感君一回顾，使我思君朝与暮。<br>
    魂随君去终不悔, 绵绵相思为君苦。<br>
    相思苦，凭谁诉？遥遥不知君何处。<br>
    扶门切思君之嘱，登高望断天涯路。<br>
</center>



<center>
    <b><font size="5">绸缪</font></b><br>
    <font size="2">【作者】佚名 【朝代】先秦</font><br>
       绸缪束薪，三星在天。今夕何夕，见此良人？子兮子兮，如此良人何？<br>
    绸缪束刍，三星在隅。今夕何夕，见此邂逅？子兮子兮，如此邂逅何？<br>
    绸缪束楚，三星在户。今夕何夕，见此粲者？子兮子兮，如此粲者何？<br>
</center>


<center>
    <b><font size="5">我亦好歌亦好酒</font></b><br>
    <font size="2">【作者】殊同 【朝代】现代</font><br>
       我亦好歌亦好酒，唱与佳人饮与友。歌宜关西铜绰板，酒当直进十八斗。<br>
    摇摆长街笑流云，我本长安羁旅人。丛楼参差迷归路，行者匆匆谁与群。<br>
    幸有作文与谈诗，寥落情怀有君知。负气登楼狂步韵，每被游人笑双痴。<br>
    幸有浩然共蹴鞠，轻拨慢扣自欢娱。七月流火无眠夜，同向荧屏做唏嘘。<br>
    幸有彩云喜香山，兰裳桂冠共游仙，说来红尘多趣事，笑声惊动九重天。<br>
    幸有晓艳能操琴，玉葱手指石榴裙。止如高山流如水，流水溯洄桃花林。<br>
    红衣佳人白衣友，朝与同歌暮同酒。世人谓我恋长安，其实只恋长安某。<br>
</center>



<center>
    <b><font size="5">唐多令·芦叶满汀洲</font></b><br>
    <font size="2">【作者】刘过 【朝代】宋</font><br>
       芦叶满汀洲，寒沙带浅流。二十年重过南楼。柳下系船犹未稳，能几日，又中秋。<br>
    黄鹤断矶头，故人今在否？旧江山浑是新愁。欲买桂花同载酒，终不似，少年游。<br>
</center>



<center>
    <b><font size="5">四季乱语之春-樱散零乱</font></b><br>
    <font size="2">【曲】《穿越时空的思念》【词】昭朔琰【原唱】暮落枫</font><br>
       春又来 人已去 风烟残 夕阳晚 樱花开 顷刻散 零乱。<br>
    年光逝 韶华落 飞絮转 不堪看 路漫漫 空梦断 零乱<br>
    渡忘川 彼岸 忘不掉 人长叹 古井下 月光 思念 装满<br>
    樱花瓣 飞过 风幽怨 水清寒 离伤黯 忧思转 零乱<br>
</center>



<center>
    <b><font size="5">四季乱语之春残-乱紫惜芳</font></b><br>
    <font size="2">【曲】《乱红》【词】昭朔琰【原唱】柳月庭</font><br>
       青山峰外 楼千嶂 云随雁去 诉悲凉 长烟落日 羌笛声声吹断肠 残絮翻飞归路茫<br>
    疏桐流响 卷轻霜 一树晚紫 飞何方 轻红梦断 琵琶弦弦征人望 飞花空锁恨离伤<br>
    月明倚楼 尽望乡 断桥紫苏 飞落寒江 看尽落花春残 犹道碎紫十里香 容华散尽惜流芳<br>
    疏桐流响 卷轻霜 一树晚紫 飞何方 轻红梦断 琵琶弦弦征人望 飞花空锁恨离伤<br>
    孤城青山 望归客 闲云散尽 飞鸿过 烟长日落 羌笛年年断肠歌 紫桐花里枕暮色<br>
    关山画作远山长 乱红千里青草凄凉 望遍烂漫春色 所恨年年赠离伤 月华软幽 人独来往<br>
    月明倚楼 尽望乡 断桥紫苏 飞落寒江 看尽落花春残 犹道碎紫十里香 容华散尽惜流芳<br>
</center>



<center>
    <b><font size="5">花非花</font></b><br>
    <font size="2">【作者】白居易 【朝代】唐</font><br>
       花非花，雾非雾。<br>
    夜半来，天明去。<br>
    来如春梦不多时，去似朝云无觅处。<br>
</center>



<center>
    <b><font size="5">花非花 ·花曲</font></b><br>
    <font size="2"></font><br>
       花非花，夢非夢。月半彎，琴聲動。悲歌清曲暗凋零，莫問明朝誰與共。<br>
    霜非花，霧非夢。世事薄，歡情痛。紅塵離散兩匆匆，往事遙遙魂寄送。<br>
    燭燈花，向風動。錦瑟年，殘宵送。韶光流逝影重疊，慣看霜痕濕舊夢。<br>
    風中花，夜中夢。瘦盡春，斜陽弄。烽煙殘照酒回腸，半闕清詞愁也縱。<br>
</center>



<center>
    <b><font size="5">将进酒</font></b><br>
    <font size="2">【作者】李白 【朝代】唐</font><br>
       君不见，黄河之水天上来，奔流到海不复回。<br>
    君不见，高堂明镜悲白发，朝如青丝暮成雪。<br>
    人生得意须尽欢，莫使金樽空对月。<br>
    天生我材必有用，千金散尽还复来。<br>
    烹羊宰牛且为乐，会须一饮三百杯。<br>
    岑夫子，丹丘生，将进酒，杯莫停。<br>
    与君歌一曲，请君为我倾耳听。<br>
    钟鼓馔玉不足贵，但愿长醉不复醒。<br>
    古来圣贤皆寂寞，惟有饮者留其名。<br>
    陈王昔时宴平乐，斗酒十千恣欢谑。<br>
    主人何为言少钱，径须沽取对君酌。<br>
    五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。<br>
</center>



<center>
    <b><font size="5">长恨歌</font></b><br>
    <font size="2">【作者】白居易 【朝代】唐</font><br>
    汉皇重色思倾国，御宇多年求不得。杨家有女初长成，养在深闺人未识。<br>
    天生丽质难自弃，一朝选在君王侧。回眸一笑百媚生，六宫粉黛无颜色。<br>
    春寒赐浴华清池，温泉水滑洗凝脂。侍儿扶起娇无力，始是新承恩泽时。<br>
    云鬓花颜金步摇，芙蓉帐暖度春宵。春宵苦短日高起，从此君王不早朝。<br>
    承欢侍宴无闲暇，春从春游夜专夜。后宫佳丽三千人，三千宠爱在一身。<br>
    金屋妆成娇侍夜，玉楼宴罢醉和春。姊妹弟兄皆列土，可怜光彩生门户。<br>
    遂令天下父母心，不重生男重生女。骊宫高处入青云，仙乐风飘处处闻。<br>
    缓歌慢舞凝丝竹，尽日君王看不足。渔阳鼙鼓动地来，惊破霓裳羽衣曲。<br>
    九重城阙烟尘生，千乘万骑西南行。翠华摇摇行复止，西出都门百余里。<br>
    六军不发无奈何，宛转蛾眉马前死。花钿委地无人收，翠翘金雀玉搔头。<br>
    君王掩面救不得，回看血泪相和流。黄埃散漫风萧索，云栈萦纡登剑阁。<br>
    峨嵋山下少人行，旌旗无光日色薄。蜀江水碧蜀山青，圣主朝朝暮暮情。<br>
    行宫见月伤心色，夜雨闻铃肠断声。天旋地转回龙驭，到此踌躇不能去。<br>
    马嵬坡下泥土中，不见玉颜空死处。君臣相顾尽沾衣，东望都门信马归。<br>
    归来池苑皆依旧，太液芙蓉未央柳。芙蓉如面柳如眉，对此如何不泪垂。<br>
    春风桃李花开日，秋雨梧桐叶落时。西宫南内多秋草，落叶满阶红不扫。<br>
    梨园弟子白发新，椒房阿监青娥老。夕殿萤飞思悄然，孤灯挑尽未成眠。<br>
    迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共。<br>
    悠悠生死别经年，魂魄不曾来入梦。临邛道士鸿都客，能以精诚致魂魄。<br>
    为感君王辗转思，遂教方士殷勤觅。排空驭气奔如电，升天入地求之遍。<br>
    上穷碧落下黄泉，两处茫茫皆不见。忽闻海上有仙山，山在虚无缥渺间。<br>
    楼阁玲珑五云起，其中绰约多仙子。中有一人字太真，雪肤花貌参差是。<br>
    金阙西厢叩玉扃，转教小玉报双成。闻道汉家天子使，九华帐里梦魂惊。<br>
    揽衣推枕起徘徊，珠箔银屏迤逦开。云鬓半偏新睡觉，花冠不整下堂来。<br>
    风吹仙袂飘飖举，犹似霓裳羽衣舞。玉容寂寞泪阑干，梨花一枝春带雨。<br>
    含情凝睇谢君王，一别音容两渺茫。昭阳殿里恩爱绝，蓬莱宫中日月长。<br>
    回头下望人寰处，不见长安见尘雾。惟将旧物表深情，钿合金钗寄将去。<br>
    钗留一股合一扇，钗擘黄金合分钿。但教心似金钿坚，天上人间会相见。<br>
    临别殷勤重寄词，词中有誓两心知。七月七日长生殿，夜半无人私语时。<br>
    在天愿作比翼鸟，在地愿为连理枝。天长地久有时尽，此恨绵绵无绝期。<br>
</center>


<center>
    <b><font size="5">贺新郎</font></b><br>
    <font size="2">【作者】辛弃疾 【朝代】南宋</font><br>
   <font size="2">【序】邑中园亭，仆皆为赋此词。一日，独坐停云，水声山色，竞来相娱。意溪山欲援例者，遂作数语，庶几仿佛渊明思亲友之意云。</font><br>
</center>
​    甚矣吾衰矣。怅平生、交游零落，只今馀几！白发空垂三千丈，一笑人间万事。问何物、能令公喜？我见青山多妩媚，料青山见我应如是。情与貌，略相似。
​    一尊搔首东窗里。想渊明《停云》诗就，此时风味。江左沉酣求名者，岂识浊醪妙理。回首叫、云飞风起。不恨古人吾不见，恨古人不见吾狂耳。知我者，二三子。

<center>
    <b><font size="5">宽心谣</font></b><br>
    <font size="2">【作者】赵朴初</font><br>
    日出东海落西山，愁也一天，喜也一天。<br>
    遇事不钻牛角尖，身也舒坦，心也舒坦。<br>
    每月领取养老钱，多也喜欢，少也喜欢。<br>
    少荤多素日三餐，粗也香甜，细也香甜。<br>
    新旧衣服不挑捡，好也御寒，赖也御寒。<br>
    常与知己聊聊天，古也谈谈，今也谈谈。<br>
    内孙外孙同样看，儿也心欢，女也心欢。<br>
    全家老少互慰勉，贫也相安，富也相安。<br>
    早晚操劳勤锻炼，忙也乐观，闲也乐观。<br>
    心宽体健养天年，不是神仙，胜似神仙。<br>
</center>



<center>
    <b><font size="5">观猎</font></b><br>
    <font size="2">【作者】王维</font><br>
    风劲角弓鸣，将军猎渭城。<br>
    草枯鹰眼疾，雪尽马蹄轻。（字面）<br>
    忽过新丰市，还归细柳营。<br>
    回看射雕处，千里暮云平。<br>
</center>


<center>
    <b><font size="5">国风·秦风·小戎</font></b><br>
    小戎俴收，五楘梁辀。游环胁驱，阴靷鋈续。文茵畅毂，驾我骐馵。言念君子，温其如玉。在其板屋，乱我心曲。<br>
    四牡孔阜，六辔在手。骐骝是中，騧骊是骖。龙盾之合，鋈以觼軜。言念君子，温其在邑。方何为期？胡然我念之！<br>
    俴驷孔群，厹矛鋈錞。蒙伐有苑，虎韔镂膺。交韔二弓，竹闭绲縢。言念君子，载寝载兴。厌厌良人，秩秩德音。<br>
</center>



<center>
    <b><font size="5">菩萨蛮·如今却忆江南乐</font></b><br>
    <font size="2">【作者】韦庄</font><br>
    如今却忆江南乐，当时年少春衫薄。骑马倚斜桥，满楼红袖招。<br>
    翠屏金屈曲，醉入花丛宿。此度见花枝，白头誓不归。<br>
</center>


<center>
    <b><font size="5">蝶恋花·庭院深深深几许</font></b><br>
    <font size="2">【作者】欧阳修</font><br>
    庭院深深深几许，杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。<br>
    雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。 <br>
</center>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>独角戏</title>
    <url>/2018/04/14/personal-2018-04-14-AsSingler/</url>
    <content><![CDATA[<h1 id="情话"><a href="#情话" class="headerlink" title="情话"></a>情话</h1><ul>
<li><p>你的女朋友有缺点吗？ ：有，像星星一样的多。 ：那你的女朋友有优点吗？ ：有，像太阳一样的少。 ：那你为什么还喜欢她？ ：因为太阳一出现，星星就不见了。</p>
</li>
<li><p>女孩终于鼓足勇气向男孩表白，害羞地问男孩：“你喜欢我吗？” 男孩说：“不喜欢。” 女孩伤心欲绝，转身要走。 这时男孩叫住了女孩，对她说：“傻瓜，你还没问我爱不爱你呀。” 女孩破涕为笑：“那你爱不爱我？” “不爱。”。</p>
<ul>
<li>男孩：你怎么不问问我是不是真心的 女孩：那你是真心的吗 男孩：当然啊不是啊</li>
</ul>
</li>
<li><p>如果有一天我说想你了，不是说这天我想你了，是说这天我憋不住了。</p>
</li>
<li><p>听到这音乐，第一个通宵就是在魔法密林刷级</p>
</li>
<li><p>与其说是孤独 不如坦诚的讲自己没有全心全意的与人相处 老友没有再联系 新朋友不去信任 对亲密的人说不出口 只能从陌生人身上寻找慰藉 反正也没有人知道我是谁 去哪里 跑向谁</p>
</li>
<li><p>若你身边无爱，祝你卡里有钱。</p>
</li>
<li><p>我告诉你我喜欢你，并不是一定要和你在一起，只是希望今后地你，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。</p>
</li>
<li><p>我一岁的时候五岁，你年龄是我的五倍。我四岁的时候你八岁，你年龄是我的两倍。我十六岁的时候你二十岁，你的年龄是我的1.25倍。虽然我知道我永远无法追上你，但是我一生都在向你靠近。</p>
</li>
<li><p>今天的你对我爱答不理，明天的我还来找你</p>
</li>
<li><p>她点了一个赞，你脑补出一出戏，她更新一条动态，你就像在做阅读理解，她坐在你身边，却隔着一条银河，她什么都没做，却成了你心里地最重要。</p>
</li>
<li><p>你好，同城</p>
<ul>
<li>数学里有个温柔霸道的词： 有且仅有 ； </li>
<li>还有个孤独的词： 假设存在； </li>
<li>还有个悲凉的词： 充分不必要； </li>
<li>还有一种无奈： 无限接近，永不等于；</li>
<li>最妄想的词儿： 令a和b相等；</li>
<li>还有个孤独傲慢的词： 无解； </li>
<li>还有个让人痛彻心扉的的字———略 </li>
</ul>
</li>
<li><p>相爱的人总喜欢说反话，却又渴望对方能读懂自己的心。有点像是两个人的一场美梦，彼此都害怕自己身边的人已经睡醒远去，自己还在原地做梦，所以不断的试探考验，但是如果两人都执着的要考验对方是否醒了，那两个人还会有一起做梦的可能吗？林佳和孟云都生怕自己是醒的晚被抛弃的那个，所以明明还爱着，两个人却都急匆匆地起身离开了。</p>
</li>
<li><p>初见是惊鸿一瞥，南柯一梦是你。等待是山重水复，怦然心动是你。相遇是柳暗花明，如梦初醒是你。重逢是始料未及，别来无恙是你。我喜欢你，依旧是你。</p>
</li>
<li><p>不忘人恩，不念人过。 不思人非，不计人怨。</p>
</li>
<li><p>我可以单身很久，但恋爱一定要和爱的人谈。</p>
</li>
<li><p>单是相遇便花光了我所有运气。</p>
</li>
<li><p>十年前，我有过这样一个手机，它最大容量只能存储两百条短信。每当存满了，都要精挑细选地删除我的，留住她的。那时候我多想有一个可以存储五百条短信的手机。而如今，我有了一个能无限存储短信的手机。却再也找不到一个能和我聊两百条短信的人了。</p>
<ul>
<li>因为现在都用QQ和微信了。</li>
</ul>
</li>
<li><p>爱一个人，始于颜值，陷于才华，痴于肉体，迷于声色，久于性格，终于人品。</p>
</li>
<li><p>用王家卫的台词来说，今天是我们分开的第847天，两年多的时间里，我没有爱过谁，我的手在离开你之后没有被谁牵过，我的嘴在你离开之后也没有被谁亲过，闭上眼睛，我还能感受到你的手你的唇，就离开那么一会儿，我以为我一睁开眼睛，我一叫你，你就回来了。</p>
</li>
<li><p>我自己都如此涼薄 拿什麼去溫暖別人。</p>
</li>
<li><p>你也不可能一直帮我 我怎么会不知道</p>
</li>
<li><p>你可以把一个老实人教会浪漫，但你不可能把一个花心的人永远束心</p>
</li>
<li><p>如果有人给你发了下雪的视频，你应该回复她我也想你了，因为春赏百花冬观雪，醒亦念卿，梦亦念卿</p>
</li>
<li><p>心有良人，不言于口，不形于表，亦不掩之，直言不讳，拒之坦然，得之惜之。 存人心系，大在长貌，小在言行，亦然品性，遇此之形，不急于言，拒人应礼，应人有度。</p>
</li>
<li><p>孟婆啊，如果你遇到我的妈妈，你就在她的碗里多放几块糖，她这辈子吃的苦太多了，下辈子让她吃甜的吧，把苦的放在我的碗里把，我不想让她再吃这么多的苦，我会心疼的</p>
</li>
<li><p>有没有人跟我一样？打开QQ发现没有聊天的人，于是点开看点，看一看，笑一笑，感动一下？你好陌生人，愿你天黑有灯，下雨有伞，路上有良人相伴，明天太阳依然会升起，请你不要停步，如果可以加个好友，我愿意陪你聊天。</p>
</li>
<li><p>无人与我立黄昏，无人问我粥可温，无人怜我悲与伤，无人分我乐与欢</p>
</li>
<li><p>白茶清欢无别事，我在等风也等你。清酒独酌了无趣，我在梦花也梦你</p>
</li>
<li><p>女：我结婚的时候你会来吗？</p>
<ul>
<li>男：那我劫婚，你会跟我走吗？</li>
<li>世界上最悲哀的事莫过于此，他开心幸福难过的模样你都见过，但唯独你没见过她属于你的样子</li>
</ul>
</li>
<li><p>自己喜欢的人在别人怀里，我能做什么，我能说什么，一个男人的悲剧在于如果他失败了，他不能将事情与人说，只能将愤怒屈辱不甘埋在心里</p>
</li>
<li><p>坐过最贵的“车”是爸爸的肩膀，住过最贵的“房子”是妈妈的肚子。出生时，我哭了，你们笑了；结婚时，我笑了，你们哭了。我成了你们时才知你们为何哭，为何笑</p>
</li>
<li><p>我很想恋爱，但不是因为恋爱才恋爱，我想因为那个人是你，才想恋爱，所以你没出现，我也没恋爱。</p>
</li>
<li><p>我喜欢你，像风走了八千里，不问归期。我喜欢你，像柳动蝉鸣，日落潮汐，不能自已。我喜欢你，像云漂泊九万里，不曾歇息。我喜欢你，像日落前洒下的余晖，不忍离去。我喜欢你，像太阳升了落去，无论朝夕。</p>
<ul>
<li>这句话运用排比的句式，同时也运用了比喻，句式整齐，节奏明确，真挚表达了自己的喜爱、仰慕之情。语言生动形象，读起来朗朗上口。</li>
</ul>
</li>
<li><p>聚在一起，成型，扭曲，缠绕，有时候又还原，断裂，再连接，这就是结，就是时间。——你的名字</p>
</li>
<li><p>刘涛：我一直不知道陈奕迅十年中的第一句“如果那两个字没有颤抖，我不会发现我难受”是哪两个字</p>
<ul>
<li>好胖，因为我不会发现我难瘦</li>
<li>“如果”</li>
<li>是“好的”这两个字，林夕在节目中说过的</li>
</ul>
</li>
<li><p>我见青山多妩媚，料青山见我应如是。</p>
<ul>
<li>我见众生皆草木，唯你是青山</li>
<li>众生见我皆草木，唯你视我如青山</li>
</ul>
</li>
<li><p>你是目前为止我碰到的唯一一个我追不到还会不开心的人，事情还是一样地在重复，我喜欢你的时候，你是一切，我不喜欢你了，你就什么都不是了。以前的我，也许会放大你的缺点来让自己迅速忘记，然而现在的自己已然可以将大部分错误都归到自己身上了。</p>
</li>
<li><p>我感觉从小到大我和朋友的相处总是会出现问题，一开始我都觉得是他们不好，现在想想其实因为是我吧，因为是我所以总会出现问题，有时候也控制不住自己莫名的情绪，正常人际交往都磕磕绊绊，哪还敢想两个人长时间磨合忍让，我也还是适合一个人呆着，至少情绪过后可以与自己和解。</p>
</li>
<li><p>像我这种人，不适合谈恋爱，更不适合结婚。我的情绪不太稳定，又敏感，想的太多，总是揣测对方的心意，然后又一遍遍的想是不是自己哪里出了问题。我也不擅长沟通，不知道怎么跟一个朝夕相处的人好好处理遇到的分歧和问题。我想来想去，还是独自生活更符合天性，也不会害人害己。</p>
</li>
<li><p>总会有大概合适的人。一切的事情自有道理吧。</p>
</li>
<li><p>当我说出“永远爱你”的时候，我的意思是：希望你永远都被人爱，是不是我不重要。</p>
</li>
<li><p>我其实很害怕，你会遇到一个人，可以替代我，代替我对你的那份喜欢，我虽然是独一无二的，可别人也是。</p>
</li>
<li><p>我想你一定在找文案吧。送你一句：人间忽晚，山河已秋。如果不喜欢，那就看开头的三个字吧。</p>
</li>
<li><p>既然琴瑟起，何以笙箫默。</p>
</li>
<li><p>小学时，想和喜欢的人同桌</p>
<ul>
<li>初中时，想和喜欢的人同班</li>
<li>高中时，想和喜欢的人同校</li>
<li>工作时，想和喜欢的人同城</li>
<li>年老时，想和喜欢的人同一个世界</li>
</ul>
</li>
<li><p>叮当陪了大雄80年，<br>在大雄临死前，<br>他对叮当说:<br>“我走之后你就回到属于你的地方吧！”<br>叮当同意了！<br>大雄死后…<br>叮当用时光机回到了80年前，<br>对小时候的大雄说:<br>“大雄你好，我叫叮当。” 每次看到这个段子都好感动，<br>—–人生若只如初见！<br>朋友也好，爱人也罢，如果累了，我们就回到第一天见面的时候…     我想重新认识你 从你叫什么名字开始。</p>
</li>
<li><p>汤姆：我这一生只抓你这一只老鼠，说到做到</p>
<ul>
<li>其实汤姆不是不会抓老鼠，只是不会抓杰瑞</li>
</ul>
</li>
<li><p>祝你三冬冷暖有人知，祝你头发长长，祝你狂吃不胖，祝你不败给感情，祝你嫁给爱情</p>
</li>
<li><p>愿你天黑有灯，下雨有伞，终生有人陪伴</p>
</li>
<li><p>那些翻着评论，却不评论的人，或许才是真的孤独寂寞的人，路过的陌生人，愿你贪吃不胖，愿你懒惰不丑，愿你的深情不被辜负，愿你的余生都有人</p>
</li>
<li><p>尝尽世间绚烂，难补一生心酸</p>
</li>
<li><p>过分善良就是愚蠢，过分心软就是放任，过分宽容就是纵容。 你可以做一个老实人，但你不能蠢到相信所有人。</p>
</li>
<li><p>一生一世一双人，半醉半醒半浮生</p>
</li>
<li><p>一生所寻，不过是最初的自己，愿你走出半生，归来仍是少年。</p>
</li>
<li><p>平生不会相思，才会相思，便害相思。</p>
</li>
<li><p>群处守嘴，独处守心。</p>
</li>
<li><p>最初我们来到这个世界，是因为不得不来；最终我们离开这个世界，是因为不得不走。</p>
</li>
<li><p>满目繁华何所依，<br>绮罗散尽人独立。<br>浪花扫尽千尘雪，<br>桃李无言一队春。<br>花满堵，酒满瓯，<br>世上如侬有几人！<br>一楫春风一叶舟，<br>一纶茧缕一轻钩，<br>一夜春雨一夜愁，<br>一轮明月锁清秋，<br>谁知梦，谁懂风，<br>万顷波中得自由！</p>
</li>
<li><p>不为往事扰，余生只愿笑</p>
</li>
<li><p>因为到最后你会发现，一个人的愚蠢不是几句话就能纠正的，谁也无法阻止智障坑人，正如无法阻止死神上门</p>
</li>
<li><p>茕茕白兔，东走西顾，衣不如新，人不如故</p>
</li>
<li><p>人最怕，深交后的陌生，认真后的痛苦，信任后的利用，温柔后的冷漠！</p>
<p>你好，最熟悉的陌生人</p>
</li>
<li><p>婚姻就是吵架冲出门以后，回来顺便买了个菜。</p>
</li>
<li><p>你知道吗，七年并不能忘记一个人。但一个旧细胞死亡新的细胞诞生，周围的旧细胞就会告诉这个新来的：主人之前是怎样怎样爱一个人的，就这样，即使七年后你的身体里都是新的细胞，但是他们都知道你旧的故事</p>
</li>
<li><p>从此无心爱良夜，任他明月下西楼</p>
</li>
<li><p>据说强迫症的人听歌有两种方式，一是一首单曲不断循环播放，直到听得想吐，二是随机播放，但会不断切歌。</p>
</li>
<li><p>七月有风八月有雨，九月会不会有你。</p>
</li>
<li><p>很想跟你借一个未来，有你全部的温情和热爱。</p>
</li>
<li><p>你在别人眼里可能平凡普通，但你一直是我自己唯一的信仰。</p>
</li>
<li><p>如果有一天你决定从我的生命中离开，请不要不告而别，至少好好的说一声再见。</p>
</li>
<li><p>其实没有别的什么能真正伤害你，唯一能伤害你的 是你的在意。</p>
</li>
<li><p>我以为，爱情可以填满我们心目中的遗憾。没想到，制造遗憾的偏偏就是爱情。</p>
</li>
<li><p>往后余生，洗碗是我，拖地是我，宠你也是我。</p>
</li>
<li><p>你可以帮我洗个东西吗？洗什么？喜欢我。</p>
</li>
<li><p>如果时间能重来，遇见你的瞬间，我还是会义无反顾。</p>
</li>
<li><p>遇上一个喜欢自己的人，不是什么容易的事，来日方长，你只是刚好错过一个我。</p>
</li>
<li><p>故事很长，我长话短说，我喜欢你。</p>
</li>
<li><p>因为爱，全世界都是你，喜是你悲也是你。</p>
</li>
<li><p>爱总是很美丽，结束的没道理。</p>
</li>
<li><p>曾经我一个人在世上流浪，遇见你以后，在你眼里找到了故乡。</p>
</li>
<li><p>我不清楚未来的方向，那大概是有你的地方。</p>
</li>
<li><p>怕无归期，怕空欢喜，怕来者不是你。</p>
</li>
<li><p>总有人比你好，而终无人可取代你。</p>
</li>
<li><p>很久以后才知道，原来和有些人最好的结局，就是互相杳无音信。</p>
</li>
<li><p>可惜喜欢就像乘法一样，只要一方为零，结果便为零。</p>
</li>
<li><p>如果可以，我想重新认识你，从我叫什么名字开始，然后以后的故事里，我绝对不会爱上你。</p>
</li>
<li><p>最深的孤独，是你明知道自己的渴望，却得对它装聋作哑。</p>
</li>
<li><p>忽然明白了那个叫周幽王的二百五为什么会烽火戏诸侯了，奶奶的，要是你喜欢的女孩会因此对你笑笑，踹翻全世界的事情也不是做不出来。</p>
</li>
<li><p>删去成行的字，最后打了个嗯发给你。没关系，不是所有的情绪都要告诉你，比如我的不开心，比如我好想你</p>
</li>
<li><p>人平均活到68岁，一共两万四千八百二十天，十九万个小时，三千五百万分钟，差不多二十一亿秒左右，这十秒，你在读这段话，这十秒，你只属于我，陌生人，我爱你。</p>
</li>
<li><p>我若成佛，天下无魔。我若成魔，佛奈我何。我若成仙，心游人间。我若成人，爱你万年。</p>
</li>
<li><p>上下四方谓之宇，古往今来谓之宙</p>
<ul>
<li>空间为宇，时间为宙</li>
</ul>
</li>
<li><p>我喜欢暖暖，她却喜欢凉凉</p>
<ul>
<li>真是个悲伤的故事</li>
</ul>
</li>
<li><p>小生不才，未得姑娘青睐，扰姑娘良久，姑娘勿怪，自此所有仰慕之意止于唇齿，掩于岁月，匿于年华。姑娘往北走，小生往南瞧，不再打扰姑娘，今生就此别过，望姑娘日后独善其身，遇良人，与君欢喜城，暖色度余生。</p>
</li>
<li><p>那时候，最好的朋友就在身边，喜欢的女孩近在眼前。 红衣佳人白衣友，朝与同歌暮同酒。 世人谓我恋长安，其实只恋长安某。 ，我都要成大叔了</p>
</li>
<li><p>有时候，你选择与某人保持距离，不是因为你不在乎，而是因为你清楚地知道，ta不属于你，人生遇到的每一个人，出场顺序真的很重要，很多人如果换一个时间认识，就会有不同的结局。或许，有些爱，只能止于唇齿，掩于岁月，且行且珍惜。</p>
</li>
<li><p>以前我看到：所爱隔山海，山海皆可平。</p>
<ul>
<li>那时我觉得：海有舟可渡，山有路可行</li>
<li>后来才发现：山海皆可平，难平是人心</li>
</ul>
</li>
<li><p>我之前没爱过别人，你是第一个，我怕我做得不好，让你觉得爱情不过如此</p>
</li>
<li><p>如果说以后不结婚的话，我想在一个烟火盛开的地方，生根发芽。</p>
</li>
<li><p>其实每一个人都有自己的预测，如果你去表白一个自己心仪的女孩子，其实没有那么久的考虑时间，其实那一刻你已经知道是幸福还是学会道别，我想对于自己最难的是结束自己的付出，真正的去说一句祝你幸福</p>
</li>
<li><p>你知道私人FM为什么没有倒退键只有下一首吗，因为错过了就错过了，再也回不来了。其实我想说，那你指导为什么音乐播放器都有一个最近播放的列表吗。因为只要你找的及时，那首歌一直在那里，从未离去。所以啊，人也一样， 你不去试试，怎么知道能不能成功呢。</p>
</li>
<li><p>我尊重同性恋，理解抑郁症，我会喂楼下的猫，会给老奶奶让座，会跟外卖小哥说谢谢，但是，现在我想做个有脾气的坏人了。</p>
</li>
<li><p>蛇不知己毒，人不知己罪，从古至今，时不伤人人自伤</p>
</li>
<li><p>有一种男生，不会聊天，不会撩妹，一聊天就没什么话题，很尴尬，但是内心非常想跟别人聊天，主动又不知道说什么，只有选择沉默，身边的朋友很少，但是待人很真实，对别人来说是老实巴交，追女孩没一次成功，现在还单身，却总喜欢在别人的故事里感受温暖，加油！自己，加油！这样的人</p>
</li>
<li><p>最初我买了一双鞋子，每次蹭了一点灰我都会小心翼翼地拭去，后来时间稍微久了一点，就算被别人踩了一脚，我连头都懒得低了，大抵对事对物都如此。起初她皱一下眉头你都会心疼，后来她哭你也无所谓了。</p>
<ul>
<li>那是你的鞋子不够贵或者是不够限量。还是她不够珍贵</li>
</ul>
</li>
<li><p>星河滚烫，你是人间理想。人海冷漠，你是人间炽热。皓月清凉，你是人间曙光。万物生长，你是二月朝阳。世间靡漫，你是明月繁星。满眼星河，你是清梦满船。万事浮沉，你是人间归途。众人平庸，你是人间星光。世事无常，你是满目琳琅。满树繁花，你是心之所向。</p>
</li>
<li><p>你眼中的灿烂星河，是我不曾见过的世外桃源</p>
</li>
<li><p>红桃皇后是一个头很大的皇后……这样装模做样而伪善的皇后，我一点都不喜欢。相比之下，红桃皇后，嘟着嘴巴嚷嚷说，砍掉她的头，真实而可爱多了。……不过，童话是童话，红桃皇后扮演恶人，自然要输的。</p>
</li>
<li><p>在google上输入“故事”，可以得到113000000条结果，但输入“结局”，却只能得到44900000。可见，不是每个故事都有结局。</p>
</li>
<li><p>余光中先生说月色和雪色之间你是第三种角色，于我而言你是第四种难得</p>
</li>
<li><p>村上春树写过这样一句话：如果我爱你，而你也正巧爱我，你头发乱了的时候，我会笑笑地替你拨一拨，然后手还留恋地在你发上多呆几秒。但是，如果我爱你，而不巧的，你不爱我，我只会轻轻地告诉你：你头发乱了哦~、</p>
</li>
<li><p>张爱玲说过每一个男子都有过这样的两个女人，至少两个。娶了红玫瑰，久而久之红的变了墙上地一抹蚊子血，白的还是床前明月光；娶了白玫瑰，白的便是衣服上的一粒饭黏子，红的却是心口上的一颗朱砂痣。</p>
</li>
<li><p>人在饿的时候会选择不爱的食物，会在寂寞的时候选择不爱的人，因为强扭的瓜不甜，但是解渴。</p>
</li>
<li><p>自古表白多白表，从来情书难书情。笑谈少年多年少，常与生人道人生。</p>
</li>
<li><p>你走，我不送；你来，无论多大风多大雨，我去接你。</p>
</li>
<li><p>当初走上那条相爱的路，他们谁都不知道目的地在何方，却依然坚定着信念向前走，只要对方在身边，所以去哪里都可以。年轻时，遇到让人心动的人不难，好看的皮囊，有趣的灵魂，都能令人心动不已。难的是，在心动过后，还能让彼此在长久的相守中心安，就像张家辉和关咏荷。在爱情里，他曾经很穷，穷得只能爱她，而她回报给他的，是除了他身边，她那里都不去。春来夏往，秋收冬藏，这样的爱情，来日方长。</p>
</li>
<li><p>你打瞌睡碰到我肩膀得一瞬间，我整颗心都要炸开了，虽然只是一瞬间，但至今想起来都要高兴不已。</p>
</li>
<li><p>谁曾见过风？你我皆不曾。但看木叶舞枝头（万木垂梢首），便晓风穿过。让风鼓动你的双翼，将它送去你身边。</p>
</li>
<li><p>如梦如幻月，若即若离花。</p>
</li>
<li><p>黑格尔曾经说过，历史给我们的教训是：我们从不会从历史中吸取教训。</p>
</li>
<li><p>我死后，身体将回归大地，那时，身体可触碰天际，万世仰望星空</p>
</li>
<li><p>你要做一个不动声色地大人，不准情绪化，不准偷偷想念，不准回头看。——村上春树</p>
</li>
<li><p>我熬过了所有的苦难，我已经不期待和谁在一起了。——马尔克斯</p>
</li>
<li><p>请记住那些对你好的人，因为他本可以不这样的。——宫崎骏</p>
</li>
<li><p>能离开的人，便不算是爱人。——张爱玲</p>
</li>
<li><p>幸好想念无声，否则震耳欲聋。</p>
</li>
<li><p>我只是想起了你，不是想你了</p>
</li>
<li><p>人说，林深时见鹿，海蓝时见鲸，梦醒时见你。可实际，林深时雾起，海蓝时浪涌，梦醒时也许未见鹿，未见鲸，亦未见你。但是，鹿踏雾而来，鲸随浪儿起，你没回头，又怎知我没来过</p>
</li>
<li><p>一次旅行，一次洗心，一次心动，一次亲密。哪怕再远，我都会奋不顾身放下手里的事情去找你，我不知道我有多喜欢你，但如果是去见你，我一定会用跑的。</p>
</li>
<li><p>“她割破了手指，他很紧张的跑去给她买创可贴，他是个哑巴，比划了好久，售货员还是不懂他的意思，他心急如焚地用小刀在自己手上也划了一个小口”我很喜欢这个故事，但如果爱情仅仅靠说说而已地话，那哑巴怎么办。</p>
</li>
<li><p>在有生的瞬间能遇到你，竟花光了所有的运气</p>
</li>
<li><p>海底月是天上月，眼前人是心上人</p>
</li>
<li><p>世间不如意事七八九，能与人言一二三都无</p>
</li>
</ul>
<h1 id="江湖"><a href="#江湖" class="headerlink" title="江湖"></a>江湖</h1><ul>
<li>天下英雄出我辈，一入江湖岁月催。 鸿图霸业谈笑间，不胜人生一场醉。 提剑跨骑挥鬼雨，白骨如山鸟惊飞。 尘世如潮人如水，只叹江湖几人回。 </li>
<li>何谓侠？仗剑、天涯、四海为家；可否具体？快意、恩仇、天纵潇洒；可否再具体？一人、一马、再无其它<ul>
<li>还有一个烧烤架</li>
</ul>
</li>
<li>江湖也没什么好的，也就酒还行</li>
<li>正当你背上剑决定马不停蹄一意孤行的时候，突然出现一个人，把你抱紧说：少年，我想和你分享这漫长的一生。你一激动，把剑扔了，把马烤了，一回头，人没了~</li>
<li>仙宫人竟去,空庭花乱飞,芳心向谁尽,无谓是沾衣</li>
<li>绿水本无忧，因风皱面；青山原不老，为雪白头。</li>
<li>“好想变成雪啊，这样就可以落在先生的肩上了……” “若是先生撑了伞呢？” “那就落在先生的红伞上，静载一路的月光。” “若是先生将雪拂去……” “那就任他拂去，能在他的手掌上停留一刻，便足矣。” ——《仁医》<ul>
<li>若是先生撑伞的同时快速旋转伞同时自身出了一个冰心并且以一个反方向转这样形成一股气流可以不断吹雪，加上上下横跳的走路灵巧避开所有雪呢？</li>
</ul>
</li>
<li>我倾家荡产才买了一把剑，准备喝碗酒就上路 碰巧你在邻桌笑，从此心中无江湖</li>
<li>儿女情长什么的，真的很影响大哥行走江湖</li>
<li>在古代，他们不网聊，不短信，如果你想她，就爬两座山，走五里路，去牵她的手。</li>
<li>此生来世都愿识尽世间好人，读尽世间好书，看尽世间好山水，天上风景再好，从不羡慕。</li>
<li>“何为苦涩？” “君往东，卿向西，永无相遇。” “可否具体？” “卿有情，君无意，候无佳期。” “可否再具体？” “彼岸花，花与叶，终无逢时。” “仍是不解？” “我笑着祝福你。”</li>
<li>你能渡万物轮回，能渡花草树木的枯萎，能渡恶人轮回，为什么不能渡我呢？你是世人的圣人，却唯独是我的恶人</li>
<li>进去一个寺庙，里面有个上香的人，外面是喧闹的芙蓉街，仅仅隔了一个门口，里面却非常安静。我站在里面跟小哥哥说，不能呆在里面太久了，万一被感化了，皈依我佛了怎么办？小哥哥看了我一眼：你慧根不够，怕是不能去出家。我说那你呢？我尘缘未了，也不能出家。然后我们就走了外面买了一个烤肠，好吃。</li>
<li>睡到二三更时凡荣华皆成幻境，想到一百年后无少长俱是古人</li>
<li>俺曾见金陵玉殿莺啼晓，秦淮水榭花开早，谁知道容易冰消。眼看他起朱楼，眼看他宴宾客，眼看他楼塌了。这青苔碧瓦堆，俺曾睡风流觉，将五十年兴亡看饱。</li>
<li>位卑未敢忘忧国，都道戏子无情，怎知戏子也有心</li>
<li>戏腔一开，八方来听，一方为人，三方为鬼，四方为神。凡人不看，不代表鬼神不看</li>
<li>我自谓半个活人，见山如荒骨，见海如静水，见花见草，也如死气升腾，天下万物也有白骨凋落的那一天，唯独见了你，荒骨附色，静水奔腾，花草接近新生，万物上了色，还了魂。</li>
<li>贺今朝曾经羡慕闲云野鹤，想做什么做什么，想去哪就去哪。但等他真正踏过山水，行路些许后，才发现天地山河，都比不上黎复照眉间风月，也不由地想起曾经和黎复照一起喝酒，笑说敢跟他姓的场景。 人生如一场宴会，来得人多，去的人也多，但从始至终，唯独他一直在。——观风月</li>
<li>这山河看着久了也就这模样，抵不过阿照眉目里头半分风月。——观风月</li>
<li>明月来复照，把酒贺今朝——观风月</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>程序基础（更新中）</title>
    <url>/2018/04/10/basic-2018-04-10-ProgramBasic/</url>
    <content><![CDATA[<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>在计算机系统中，数值一律用<strong>补码</strong>来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理（为了计算方便）。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。（百度百科）</p>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>举例</p>
<table>
<thead>
<tr>
<th></th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
</tr>
</thead>
<tbody><tr>
<td>正数5</td>
<td>0000 0101</td>
<td>0000 0101</td>
<td>0000 0101</td>
</tr>
<tr>
<td>负数5</td>
<td>1000 0101</td>
<td>1111 1010</td>
<td>1111 1011</td>
</tr>
</tbody></table>
<p>8位2进制数表示-128~127的范围，第一位表示符号位，1表示负数、0表示正数</p>
<p>正数三码都相同</p>
<p>负数：用绝对值的补码表示，负数=模-|负数|、-1=100-|-1|=100-001=11</p>
<ul>
<li>原码=正数最高位改为1</li>
<li>反码=正数取反，第一位符号位不变</li>
<li>补码=反码+1，即取反+1，也可以用原码-1，再取反</li>
<li>模 = 原码+补码</li>
</ul>
<p>想象成时钟，2点到4点，可以顺时针旋转2小时，也可以逆时针旋转10小时，即2=12-|-10|，12为模</p>
<p>想象成360度的圆，模代表一圈的度数：</p>
<ul>
<li>起点为0度，范围是0~359。-1度=359度，-180度=180度，模=360度=1度+359度。</li>
<li>起点为-180度，范围是-180~179。那么：-181度=179度，模=360度=181度+179度。</li>
</ul>
<p>位数越多、刻度越多：</p>
<ul>
<li>如2位：能表示-2~1的数。1=01、-1=11、-2=2=10，模=100=01+11=10+10=进一位。进一位表示：2=010、-2=110，第一位表示符号位。</li>
<li>如3位：能表示-4~3的数。1=001、-1=111、-4=4=100，模为=001+111=100+100=1000=进一位。进一位表示：4=0100、-4=1100，第一位表示符号位.模为1000</li>
<li>如8位：能表示-128~127的数。1=00000001、-1=11111111、-128=128=10000000</li>
<li>可以总结出。n为位数，-2^(n-1)=2^(n-1)，进一位：即模=</li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><p>例：二进制<code>00001000</code>转换为十进制</p>
<p><code>(2^0)*0+(2^1)*0+(2^2)*0+(2^3)*1 = 8</code></p>
<h3 id="十进制整数转二进制整数"><a href="#十进制整数转二进制整数" class="headerlink" title="十进制整数转二进制整数"></a>十进制整数转二进制整数</h3><p><strong>除2取余，逆序排列</strong>：将循环除以2，直到商为0，记录每一步的余数，将每一步的余数倒序组成二进制</p>
<p>例：十进制5转换为二进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5&#x2F;2&#x3D;2···1</span><br><span class="line">2&#x2F;2&#x3D;1···0</span><br><span class="line">1&#x2F;2&#x3D;0...1</span><br><span class="line">(5)10&#x3D;(101)2，最后商为1</span><br><span class="line"></span><br><span class="line">7&#x2F;2&#x3D;3···1</span><br><span class="line">3&#x2F;2&#x3D;1···1</span><br><span class="line">1&#x2F;2&#x3D;0···1</span><br><span class="line">(7)10&#x3D;(111)2，最后商为0</span><br></pre></td></tr></table></figure>

<h3 id="十进制小数转换成二进制小数"><a href="#十进制小数转换成二进制小数" class="headerlink" title="十进制小数转换成二进制小数"></a>十进制小数转换成二进制小数</h3><p><strong>乘2取整，顺序排列</strong>：整数部分同上，小数部分循环乘2，直到小数部分为0，记录每一步的积并取整数部分，顺序组成二进制小数部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2.25)10转为二进制</span><br><span class="line">整数转二进制</span><br><span class="line">2&#x2F;2&#x3D;1...0</span><br><span class="line">1&#x2F;2&#x3D;0...1</span><br><span class="line"></span><br><span class="line">小数转二进制</span><br><span class="line">0.25*2&#x3D;0.5 &#x2F;&#x2F;整数部分为0</span><br><span class="line">0.5*2&#x3D;1.0 &#x2F;&#x2F;整数部分为1</span><br><span class="line">2.25(10)&#x3D;(10.01)2</span><br></pre></td></tr></table></figure>

<p>同样的算法，小数部分可能永远不为0，如0.4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.2*2&#x3D;0.4  &#x2F;&#x2F;整数部分为0</span><br><span class="line">0.4*2&#x3D;0.8  &#x2F;&#x2F;整数部分为0</span><br><span class="line">0.8*2&#x3D;1.6  &#x2F;&#x2F;整数部分为1</span><br><span class="line">0.6*2&#x3D;1.2  &#x2F;&#x2F;整数部分为1</span><br><span class="line">0.2*2&#x3D;0.4  &#x2F;&#x2F;整数部分为0</span><br><span class="line">...</span><br><span class="line">结果为无限循环小数：0.001100110011...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因子中包含5才能用2进制表示</p>
</blockquote>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>&amp;：位与and，将两个数转换为二进制，每一位进行比较，如果都为1则结果为1，否则为0</li>
<li>|：位或or，将两个数转换为二进制，每一位进行比较，只要有一个为1则结果为1，否则为0</li>
<li>~：位非not，单目运算符，将每位取反，使用补码进行计算<ul>
<li>如~37，8位机器上，补码为：00100101</li>
<li>取反：11011010=-38。</li>
<li>第一位是符号位，为1表示负数，负数的原码需要计算，对负数补码进行还原。（补码取反+1，或者补码-1取反）</li>
<li>补码减1得到反码：11011001</li>
<li>反码取反得正数（负数的反码为正数取反）：00100110，即38</li>
<li>所以<del>37=</del>(00100101)补码=11011010补码=-38</li>
</ul>
</li>
<li>^：异或xor，将两个数转换为二进制，每一位进行比较，如果相同则为0，不相同则为1</li>
</ul>
<h3 id="左移（-lt-lt-）、右移（-gt-gt-）"><a href="#左移（-lt-lt-）、右移（-gt-gt-）" class="headerlink" title="左移（&lt;&lt;）、右移（&gt;&gt;）"></a>左移（&lt;&lt;）、右移（&gt;&gt;）</h3><p>左移n位相当于乘以2的n次方：把二进制的高位左移n位，溢出舍弃，右边空出来的补0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：4&lt;&lt;2 &#x3D; 4*2^2 &#x3D; 16</span><br><span class="line">&#x3D; 0000 0100 &lt;&lt; 2 &#x3D; 0001 0000 &#x3D; 16</span><br></pre></td></tr></table></figure>

<p>右移n位相当于处以2的n次方：把二进制的低位右移n位，溢出舍弃，左边空出来的补0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：4&gt;&gt;2 &#x3D; 4&#x2F;2^2 &#x3D; 1</span><br><span class="line">&#x3D; 0000 0100 &lt;&lt; 2 &#x3D; 0000 0001 &#x3D; 16</span><br></pre></td></tr></table></figure>

<h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><table>
<thead>
<tr>
<th>进制</th>
<th>缩写</th>
<th>C语言</th>
<th>Java</th>
<th>书写</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>B</td>
<td>不能表示</td>
<td>不能表示</td>
<td>括号加下标：如(11)2，缩写后缀：11B，下同</td>
</tr>
<tr>
<td>八进制</td>
<td>O</td>
<td>0开头</td>
<td>0开头</td>
<td></td>
</tr>
<tr>
<td>十进制</td>
<td>D</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>十六进制</td>
<td>H</td>
<td>0x或0X开头</td>
<td>0x开头</td>
<td></td>
</tr>
</tbody></table>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>多个并发进程因争夺系统资源而产生相互等待的现象。</p>
<h3 id="产生的条件"><a href="#产生的条件" class="headerlink" title="产生的条件"></a>产生的条件</h3><ul>
<li>互斥：一个资源每次只能被一个进程使用。</li>
<li>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。不主动释放</li>
<li>不可抢占：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><ul>
<li>打破互斥条件：允许进程同时访问某个资源</li>
<li>打破请求与保持：资源利用率低，降低并发性，不能动态分配资源<ul>
<li>一次性申请全部资源</li>
<li>进程获得运行初期需要的资源，运行过程中逐步释放掉已经用完的资源，再请求新的资源</li>
</ul>
</li>
<li>打破不可抢占：进程请求新的资源时，如果无法被满足，则释放所占有的资源，以后重新申请。</li>
<li>打破循环等待：实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源。</li>
</ul>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ul>
<li>如果一个进程的请求会导致死锁，则不启动该进程</li>
<li>如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。</li>
</ul>
<p>银行家算法</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>位（bit）是计算机存储的最小单位，字节是计算机处理数据的最小单位，1字节=8位</p>
]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>程序基础</tag>
      </tags>
  </entry>
  <entry>
    <title>党员笔记</title>
    <url>/2017/12/21/personal-2017-12-21-Party/</url>
    <content><![CDATA[<h2 id="思想汇报书写格式"><a href="#思想汇报书写格式" class="headerlink" title="思想汇报书写格式"></a>思想汇报书写格式</h2><ol>
<li><p>标题：一般在第一行居中写“思想汇报”。</p>
</li>
<li><p>称谓：一般在第二行顶格写“敬爱的党支部”或“敬爱的党组织”，后面加冒号。</p>
</li>
<li><p>正文：这是思想汇报的主要部分，一般写以下内容：</p>
<ul>
<li>对当前和一个时期党的一个时期党的中心任务或党的路线、方针、政策的看法、态度，阐明自己的观点，写清楚自己的认识或自己还有什么疑虑和理解不清楚的问题等。</li>
<li>参加重要活动或学习重要文章、文件所受的启发、教育和体会，把自己的认识、体会和收获向党组织汇报。</li>
<li>本人在政治、思想、学习、工作、作风等方面的主要表现情况。</li>
<li>对照党员的标准，找出存在问题及今后的努力方向，表明自己要求进步的决心和信心。</li>
</ul>
</li>
<li><p>结尾：在思想汇报的最后部分，可写上自己对党组织的请求和希望，一般用“恳请党组织给予批评、帮助”或“希望党组织加强对我的培养和教育”等作为结束语。</p>
</li>
<li><p>落款：在结尾的右下方要写上汇报人的姓名，并注明汇报的年月日。</p>
</li>
</ol>
<h2 id="思想汇报书写要求"><a href="#思想汇报书写要求" class="headerlink" title="思想汇报书写要求"></a>思想汇报书写要求</h2><ol>
<li>实事求是，写清自己的真情实感，切忌空话套话。</li>
<li>根据不同时期的思想认识情况，集中深刻对一两个问题谈深谈透，不要泛泛而谈。</li>
<li>要紧密联系实际，本人亲自书写，不得简单抄录党章、报告和报刊文章，也不得抄袭他人思想汇报。</li>
<li>一分为二，既要肯定自己的进步，又要找准自己的不足，敢于向党组织暴露自身的缺点和问题。</li>
<li>要按时、经常、主动、自觉地向党组织写思想汇报，一般不应由党组织、培养人提醒或督促。</li>
<li>书写过程中不得有任何勾抹迹象，字迹清晰，切忌潦草。</li>
<li>不能有错别字，注意标点符号等严格符合高考作文要求。</li>
</ol>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>一带一路，两学一做，三会一课，四个自信，四个全面，五位一体，五大发展等知识点</p>
<h2 id="评议"><a href="#评议" class="headerlink" title="评议"></a>评议</h2><p>从思想、工作、学习、生活各方面结合实际概括，并给予评价和期望</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>《寻梦环游记》观后感</title>
    <url>/2017/11/24/reader-2017-11-24-Coco/</url>
    <content><![CDATA[ <center>
     <font size="5">《寻梦环游记》</font><br>
 </center>
​    看了《寻梦环游记》，号称媲美《WALL·E》的近年来最感人的动画电影，名不虚传，很庆幸自己没有错过。看简介的时候尚觉得不以为然，以为是平平无奇的追梦励志片，却没想到出乎意料的精彩。
​    或许是从“燃烧着”的万寿菊随着吉他旋转起来的瞬间，也或许是从踏上花瓣桥的那一刻开始感到震撼。
我想大概是从“亡灵的世界并非永恒，他们靠着人们的记忆活下来。当有一天，他们不再被任何人提起，在人间再无一点痕迹，那么，他们在亡灵世界的生命也就走到了尽头”开始，想到了《龙族》中江南曾引用的一句话：“人的一生，要死去三次。第一次，当你的心跳停止，呼吸消逝，你在生物学上被宣告了死亡；第二次，当你下葬，人们穿着黑衣出席你的葬礼，他们宣告，你在这个社会上不复存在，你从人际关系网里消逝，你悄然离去；而第三次死亡，是这个世界上最后一个记得你的人，把你忘记，于是，你就真正地死去。整个宇宙都将不再和你有关。”
​    影片原本叫《DiadelosMuertos》（亡灵节），后来因涉及文化剥削改名为《Coco》，处于阴阳生死交界的曾祖母的名字，贯穿了整部片的泪点，再合适不过，也算无心插柳。译名为寻梦，故事始于家，经过奇妙的旅程，最后却回到原点。想到了《牧羊少年奇幻之旅》，少年圣地亚哥的梦始于废弃教堂的无花果树下，经过一段段奇妙和极不平凡的旅程，最后还是将回到这棵平凡的无花果树下。牧羊人就像船员或旅行推销员一样，终究会在某个村庄遇见某个人，让他们忘了四处游荡的生活多么无忧无虑。就像圣地亚哥和父亲的对话： 
​    “全世界的人都来过这个地方，来寻找新的事物，然而当他们离去的时候，基本还是跟来时同一个人呢，他们爬上高山去，看过城堡，最后还是觉得过去的比眼前好，他们或许是金头发，或许有着黑皮肤，但他们大致跟这里的人差不多” 
​    ——“但我很想去看看他们住的城市和城堡。” 
​    “那些人看了我们的地方以后说，他们很想永远住在这里。” 
​    ——“我却希望能认识他们住的地方，知道他们怎么过活。” 
​    ……  ……  …… 
​    “……尽管向原野去吧，总有一天你会明白我们的土地最肥，我们的女人最美……”。
其实梦就在家，平凡又伟大的智慧，蕴含着炼金术的哲学精髓。我们一生苦苦追寻梦想，不断跌倒爬起，不惜撞得头破血流，见过了富丽堂皇，浮世繁华，最后还是会怀念自己住过的茅屋，选择回到原点栖息。
“人真正害怕的，并不是肉体的消亡，而是畏惧被遗忘，千百年来，所有的人都在以自己的方式，想要在这个世界上留下自己存在过的证明。君王修建规模宏大的陵寝，学者著书立说传承思想，艺术家留下作品洞见自然与文明。这就是所谓的 向死而生 。但是一个普通人，他平平凡凡的一生，该怎么被记住呢？作为这个世界的大多数，多少人来了又走，匆匆忙忙，毫无痕迹。我们的故事，只有最亲近的人记得，我们的名字，也只会被他们提起……当有一天，连他们都忘了，我们就真的消失地干干净净。就算真的有灵魂尚存，也只能像埃克托一样不知魂归何处。”
“记忆，是一张连接阴阳两个世界的船票。我会一直记得你，直到在另一个世界，再次找到你。”
“一个活着的人，需要带着逝去亲人的祝福才能活下去，而一个死去的魂魄，也依赖在世的人的记忆而存在”
最后，“这首《Remember me》不是给世界的，而是给我最爱的女儿Coco”，希望你能记住我。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>道德经</title>
    <url>/2017/11/11/reader-2017-11-11-%E9%81%93%E5%BE%B7%E7%BB%8F/</url>
    <content><![CDATA[ <center>
     <font size="5">《道德经》</font><br>
     <font size="4">老子著</font>
 </center>

<p>01.道可道，非常道。名可名，非常名。无名天地之始。有名万物之母。故常无欲以观其妙。常有欲以观其徼。此两者同出而异名，同谓之玄。玄之又玄，众妙之门。</p>
<p>02.天下皆知美之为美，斯恶矣；皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相倾，音声相和，前後相随。是以圣人处无为之事，行不言之教。万物作焉而不辞。生而不有，为而不恃，功成而弗居。夫唯弗居，是以不去。</p>
<p>03.不尚贤， 使民不争。不贵难得之货，使民不为盗。不见可欲，使民心不乱。是以圣人之治，虚其心，实其腹，弱其志，强其骨；常使民无知、无欲，使夫智者不敢为也。为无为，则无不治。</p>
<p>04.道冲而用之，或不盈。渊兮似万物之宗。解其纷，和其光，同其尘，湛兮似或存。吾不知谁之子，象帝之先。</p>
<p>05.天地不仁，以万物为刍狗。圣人不仁，以百姓为刍狗。天地之间，其犹橐迭乎？虚而不屈，动而愈出。多言数穷，不如守中。</p>
<p>06.谷神不死是谓玄牝。玄牝之门是谓天地根。绵绵若存，用之不勤。</p>
<p>07.天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人後其身而身先，外其身而身存。非以其无私邪！故能成其私。</p>
<p>08.上善若水。水善利万物而不争，处众人之所恶，故几於道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。</p>
<p>09.持而盈之不如其己；揣而锐之不可长保；金玉满堂莫之能守；富贵而骄，自遗其咎。功遂身退，天之道。</p>
<p>10.载营魄抱一，能无离乎？专气致柔，能如婴儿乎？涤除玄览，能无疵乎？爱国治民，能无为乎？天门开阖，能为雌乎？明白四达，能无知乎。</p>
<p>11.三十幅共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。</p>
<p>12.五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨。是以圣人，为腹不为目，故去彼取此。</p>
<p>13.宠辱若惊，贵大患若身。何谓宠辱若惊？宠为下。得之若惊失之若惊是谓宠辱若惊。何谓贵大患若身</p>
<p>？吾所以有大患者，为吾有身，及吾无身，吾有何患。故贵以身为天下，若可寄天下。爱以身为天下，若可托天下。</p>
<p>14.视之不见名曰夷。听之不闻名曰希。抟之不得名曰微。此三者不可致诘，故混而为一。其上不皦<br>(jiǎo)，其下不昧，绳绳不可名，复归於无物。是谓无状之状，无物之象，是谓惚恍。迎之不见其首，随之不见其後。执古之道以御今之有。能知古始，是谓道纪。</p>
<p>15.古之善为士者，微妙玄通，深不可识。夫唯不可识，故强为之容。豫兮若冬涉川；犹兮若畏四邻；俨兮其若容；涣兮若冰之将释；敦兮其若朴；旷兮其若谷；混兮其若浊；澹兮其若海；飉(liáo,风的声音)兮若无止。孰能浊以静之徐清。孰能安以动之徐生。保此道者不欲盈。夫唯不盈故能蔽而新成。</p>
<p>16.致虚极守静笃。万物并作，吾以观复。夫物芸芸各复归其根。归根曰静，是谓复命；复命曰常，知常曰明。不知常，妄作凶。知常容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。</p>
<p>17.太上，下知有之。其次，亲而誉之。其次，畏之。其次，侮之。信不足焉，有不信焉。悠兮其贵言，功成事遂，百姓皆谓∶我自然。</p>
<p>18.大道废有仁义；慧智出有大伪；六亲不和有孝慈；国家昏乱有忠臣。</p>
<p>19.绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有；此三者，以为文不足。故令有所属，见素抱朴少私寡欲。</p>
<p>20.绝学无忧，唯之与阿，相去几何？善之与恶，相去若何？人之所畏，不可不畏。荒兮其未央哉！众人熙熙如享太牢、如春登台。我独泊兮其未兆，如婴儿之未孩；儡儡(lěi,羸弱)兮若无所归。众人皆有馀，而</p>
<p>我独若遗。我愚人之心也哉！沌沌兮。俗人昭昭，我独昏昏；俗人察察，我独闷闷。众人皆有以，而我独顽且鄙。我独异於人，而贵食母。</p>
<p>21.孔德之容惟道是从。道之为物惟恍惟惚。惚兮恍兮其中有象。恍兮惚兮其中有物。窈兮冥兮其中有精。其精甚真。其中有信。自古及今，其名不去以阅众甫。吾何以知众甫之状哉！以此。</p>
<p>22.曲则全，枉则直，洼则盈，敝则新少则得，多则惑。是以圣人抱一为天下式。不自见故明；不自是故彰；不自伐故有功；不自矜故长；夫唯不争，故天下莫能与之争。古之所谓∶曲则全者」岂虚言哉！诚全而归之。</p>
<p>23.希言自然。故飘风不终朝，骤雨不终日。孰为此者？天地。天地尚不能久，而况於人乎？故从事於道者，同於道。德者同於德。失者同於失。同於道者道亦乐得之；同於德者德亦乐得之；同於失者失於乐得之信不足焉有不信焉。</p>
<p>24.企者不立；跨者不行。自见者不明；自是者不彰。自伐者无功；自矜者不长。其在道也曰∶馀食赘形。物或恶之，故有道者不处。</p>
<p>25.有物混成先天地生。寂兮寥兮独立不改，周行而不殆，可以为天下母。吾不知其名，强字之曰道。强为之名曰大。大曰逝，逝曰远，远曰反。故道大、天大、地大、人亦大。域中有大，而人居其一焉。人法地，地法天，天法道，道法自然。</p>
<p>26.重为轻根，静为躁君。是以君子终日行不离轻重。虽有荣观燕处超然。奈何万乘之主而以身轻天下。轻则失根，躁则失君。</p>
<p>27.善行无辙迹。善言无瑕谪。善数不用筹策。善闭无关楗而不可开。善结无绳约而不可解。是以圣人常善救人，故无弃人。常善救物，故无弃物。是谓袭明。故善人者不善人之师。不善人者善人之资。不贵其师、不爱其资，虽智大迷，是谓要妙。</p>
<p>28.知其雄，守其雌，为天下溪。为天下溪，常德不离，复归於婴儿。知其白，守其黑，为天下式。为天下式，常德不忒，复归於无极。知其荣，守其辱，为天下谷。为天下谷，常德乃足，复归於朴。朴散则为器，圣人用之则为官长。故大制不割。</p>
<p>29.将欲取天下而为之，吾见其不得已。天下神器，不可为也，为者败之，执者失之。夫物或行或随、或觑或吹、或强或羸、或挫或隳。是以圣人去甚、去奢、去泰。</p>
<p>30.以道佐人主者，不以兵强天下。其事好还。师之所处荆棘生焉。军之後必有凶年。善有果而已，不敢以取强。果而勿矜。果而勿伐。果而勿骄。果而不得已。果而勿强。物壮则老，是谓不道，不道早已。</p>
<p>31.夫佳兵者不祥之器，物或恶之，故有道者不处。君子居则贵左，用兵则贵右。兵者不祥之器，非君子之器，不得已而用之，恬淡为上。胜而不美，而美之者，是乐杀人。夫乐杀人者，则不可得志於天下矣。吉事尚左，凶事尚右。偏将军居左，上将军居右。言以丧礼处之。杀人之众，以悲哀泣之，战胜以丧礼处之。</p>
<p>32.道常无名。朴虽小天下莫能臣也。侯王若能守之，万物将自宾。天地相合以降甘露，民莫之令而自均。始制有名，名亦既有，夫亦将知止，知止可以不殆。譬道之在天下，犹川谷之於江海。</p>
<p>33.知人者智，自知者明。胜人者有力，自胜者强。知足者富。强行者有志。不失其所者久。死而不亡者，寿。</p>
<p>34.大道泛兮，其可左右。万物恃之以生而不辞，功成而不名有。衣养万物而不为主，常无欲可名於小。万物归焉，而不为主，可名为大。以其终不自为大，故能成其大。</p>
<p>35.执大象天下往。往而不害安平太。乐与饵，过客止。道之出口淡乎其无味。视之不足见。听之不足闻。用之不足既。</p>
<p>36.将欲歙之，必固张之。将欲弱之，必固强之。将欲废之，必固兴之。将欲取之，必固与之。是谓微明。柔弱胜刚强。鱼不可脱於渊，国之利器不可以示人。</p>
<p>37.道常无为，而无不为。侯王若能守之，万物将自化。化而欲作，吾将镇之以无名之朴。无名之朴，夫亦将无欲。不欲以静，天下将自定。</p>
<p>38.上德不德是以有德。下德不失德是以无德。上德无为而无以为。下德无为而有以为。上仁为之而无以为。上义为之而有以为。上礼为之而莫之以应，则攘臂而扔之。故失道而後德。失德而後仁。失仁而後义</p>
<p>。失义而後礼。夫礼者忠信之薄而乱之首。前识者，道之华而愚之始。是以大丈夫，处其厚不居其薄。处其实，不居其华。故去彼取此。</p>
<p>39.昔之得一者。天得一以清。地得一以宁。神得一以灵。谷得一以盈。万物得一以生。侯王得一以为天下贞。其致之。天无以清将恐裂。地无以宁将恐废。神无以灵将恐歇。谷无以盈将恐竭。万物无以生将恐灭。侯王无以贞将恐蹶。故贵以贱为本，高以下为基。是以侯王自称孤、寡、不谷。此非以贱为本邪？非乎。至誉无誉。不欲琭琭如玉，珞珞如石。</p>
<p>40.反者道之动。弱者道之用。天下万物生於有，有生於无。</p>
<p>41.上士闻道勤而行之。中士闻道若存若亡。下士闻道大笑之。不笑不足以为道。故建言有之。明道若昧。进道若退。夷道若纇。上德若谷。大白若辱。广德若不足。建德若偷。质真若渝。大方无隅。大器晚成。大音希声。大象无形。道隐无名。夫唯道善贷且成。</p>
<p>42.道生一。一生二。二生三。三生万物。万物负阴而抱阳，冲气以为和。人之所恶，唯孤、寡不谷，而王公以为称，故物或损之而益，或益之而损。人之所教，我亦教之，强梁者，不得其死。吾将以为教父。</p>
<p>43.天下之至柔，驰骋天下之至坚。无有入无间，吾是以知无为之有益。不言之教，无为之益天下希及之。</p>
<p>44.名与身孰亲。身与货孰多。得与亡孰病。是故甚爱必大费。多藏必厚亡。知足不辱。知止不殆。可以长久。</p>
<p>45.大成若缺，其用不弊。大盈若冲，其用不穷。大直若屈。大巧若拙。大辩若讷。静胜躁，寒胜热。清静为天下正。</p>
<p>46.天下有道，却走马以粪。天下无道，戎马生於郊。祸莫大於不知足。咎莫大於欲得。故知足之足常足矣。</p>
<p>47.不出户知天下。不窥牖见天道。其出弥远，其知弥少。是以圣人不行而知。不见而明。不为而成。</p>
<p>48.为学日益。为道日损。损之又损，以至於无为。无为而不为。取天下常以无事，及其有事，不足以取天下。</p>
<p>49.圣人无常心。以百姓心为心。善者吾善之。不善者吾亦善之，德善。信者吾信之。不信者吾亦信之，德信。圣人在天下，歙歙(xīxī,无所偏执的样子)焉，为天下浑其心。百姓皆注其耳目，圣人皆孩之。</p>
<p>50.出生入死。生之徒，十有三。死之徒，十有三。人之生，动之於死地，亦十有三。夫何故？以其生生之厚。盖闻善摄生者，陆行不遇凶虎，入军不被甲兵。凶无所投其角。虎无所用其爪。兵无所容其刃。夫何故？以其无死地。</p>
<p>51.道生之，德畜之，物形之，势成之。是以万物莫不尊道，而贵德。道之尊，德之贵，夫莫之命而常自然。故道生之，德畜之。长之育之。亭之毒之。养之覆之。生而不有，为而不恃，长而不宰。是谓玄德。</p>
<p>52.天下有始，以为天下母。既得其母，以知其子。既知其子，复守其母，没身不殆。塞其兑，闭其门，终身不勤。开其兑，济其事，终身不救。见其小曰明，守柔曰强。用其光，复归其明，无遗身殃。是为习常。</p>
<p>53.使我介然有知，行於大道，唯施是畏。大道甚夷，而人好径。朝甚除，田甚芜，仓甚虚。服文彩，带利剑，厌饮食，财货有馀。是谓盗夸。非道也哉。</p>
<p>54.善建者不拔。善抱者不脱。子孙以祭祀不辍。修之於身其德乃真。修之於家其德乃馀。修之於乡其德乃长。修之於邦其德乃丰。修之於天下其德乃普。故以身观身，以家观家，以乡观乡，以邦观邦，以天下观天下。吾何以知天下然哉？以此。</p>
<p>55.含德之厚比於赤子。毒虫不螫，猛兽不据，攫鸟不抟。骨弱筋柔而握固。未知牝牡之合而全作，精之至也。终日号而不嗄，和之至也。知和曰常。知常曰明。益生曰祥。心使气曰强。物壮则老。谓之不道，不道早已。</p>
<p>56.知者不言。言者不知。挫其锐，解其纷，和其光，同其尘，是谓玄同。故不可得而亲。不可得而疏。不可得而利。不可得而害。不可得而贵。不可得而贱。故为天下贵。</p>
<p>57.以正治国，以奇用兵，以无事取天下。吾何以知其然哉？以此。天下多忌讳而民弥贫。民多利器国家滋昏。人多伎巧奇物泫起。法令滋彰盗贼多有。故圣人云我无为而民自化。我好静而民自正。我无事而民自富。我无欲而民自朴。</p>
<p>58.其政闷闷，其民淳淳。其政察察，其民缺缺。祸尚福之所倚。福尚祸之所伏。孰知其极，其无正。正复为奇，善复为妖。人之迷其日固久。是以圣人方而不割。廉而不刿。直而不肆。光而不耀。</p>
<p>59.治人事天莫若啬。夫唯啬是谓早服。早服谓之重积德。重积德则无不克。无不克则莫知其极。莫知其极可以有国。有国之母可以长久。是谓深根固柢，长生久视之道。</p>
<p>60.治大国若烹小鲜。以道莅天下，其迨ㄞ哄非其鬼不神，其神不伤人。非其神不伤人，圣人亦不伤人。夫两不相伤，故德交归焉。</p>
<p>61.大国者下流，天下之交。天下之牝。牝常以静胜牡。以静为下。故大国以下小国，则取小国。小国以下大国，则取大国。故或下以取，或下而取。大国不过欲兼畜人。小国不过欲入事人。夫两者各得所欲，大者宜为下。</p>
<p>62.道者万物之奥。善人之宝，不善人之所保。美言可以市尊。美行可以加人。人之不善，何弃之有。故立天子、置三公，虽有拱璧以先驷马，不如坐进此道。古之所以贵此道者何。不曰∶求以得，有罪以免邪？故为天下贵。</p>
<p>63.为无为，事无事，味无味。大小多少，报怨以德。图难於其易，为大於其细。天下难事必作於易。天下大事必作於细。是以圣人终不为大，故能成其大。夫轻诺必寡信。多易必多难。是以圣人犹难之，故终无难矣。</p>
<p>64.其安易持，其未兆易谋。其脆易泮，其微易散。为之於未有，治之於未乱。合抱之木生於毫末。九层之台起於累土。千里之行始於足下。为者败之，执者失之。是以圣人无为故无败，无执故无失。民之从事常於几成而败之。慎终如始则无败事。是以圣人欲不欲，不贵难得之货。学不学，复众人之所过，以辅万物之自然而不敢为。</p>
<p>65.古之善为道者，非以明民，将以愚之。民之难治，以其智多。故以智治国，国之贼。不以智治国，国之福。知此两者，亦稽式。常知稽式，是谓玄德。玄德深矣、远矣！与物反矣。然後乃至大顺。</p>
<p>66.江海之所以能为百谷王者，以其善下之，故能为百谷王。是以圣人欲上民，必以言下之。欲先民，必以身後之。是以圣人处上而民不重，处前而民不害。是以天下乐推而不厌。以其不争，故天下莫能与之争。</p>
<p>67.天下皆谓我道大似不肖。夫唯大故似不肖。若肖，久矣！其细也夫。我有三宝持而保之∶一曰慈， 二曰俭，三曰不敢为天下先。慈故能勇，俭故能广，不敢为天下先故能成器长。今舍慈且勇，舍俭且广，舍後且先，死矣！夫慈以战则胜，以守则固。天将救之以慈卫之。</p>
<p>68.善为士者不武。善战者不怒。善胜敌者不与。善用人者为之下。是谓不争之德。是谓用人之力。是谓配天之极。</p>
<p>69.用兵有言，吾不敢为主而为客。不敢进寸而退尺。是谓行无行。攘无臂。扔无敌。执无兵。祸莫大於轻敌。轻敌几丧吾宝。故抗兵相加哀者胜矣。</p>
<p>70.吾言甚易知、甚易行。天下莫能知、莫能行。言有宗、事有君。夫唯无知，是以我不知。知我者希，则我者贵。是以圣被褐怀玉。</p>
<p>71.知不知上，不知知病。夫唯病病，是以不病。圣人不病，以其病病。夫唯病病，是以不病。</p>
<p>72.民不畏威，则大威至。无狎其所居，无厌其所生。夫唯不厌，是以不厌。是以圣人自知不自见。自爱不自贵。故去彼取此。</p>
<p>73.勇於敢则杀。勇於不敢则活。此两者或利或害。天之所恶孰知其故。天之道不争而善胜。不言而善应。不召而自来。繟(chǎn,舒缓)然而善谋。天网恢恢疏而不失。</p>
<p>74.民不畏死，奈何以死惧之。若使民常畏死，而为奇者，吾得执而杀之，孰敢。常有司杀者杀。夫代司杀者杀，是谓代大匠斫。夫代大匠斫者，希有不伤其手矣。</p>
<p>75.民之饥以其上食税之多，是以饥。民之难治以其上之有为，是以难治。民之轻死以其求生之厚，是以轻死。夫唯无以生为者，是贤於贵生。</p>
<p>76.人之生也柔弱，其死也坚强。草木之生也柔脆，其死也枯槁。故坚强者死之徒，柔弱者生之徒。是以兵强则灭，木强则折。强大处下，柔弱处上。</p>
<p>77.天之道其犹张弓与。高者抑之，下者举之。有馀者损之，不足者补之。天之道，损有馀而补不足。人之道，则不然，损不足以奉有馀。孰能有馀以奉天下，唯有道者。是以圣人为而不恃，功成而不处。其不欲见贤邪！</p>
<p>78.天下莫柔弱於水。而攻坚强者，莫之能胜。以其无以易之。弱之胜强。柔之胜刚。天下莫不知莫能行。是以圣人云，受国之垢是谓社稷主。受国不祥是为天下王。正言若反。</p>
<p>79.和大怨必有馀怨，安可以为善。是以圣人执左契，而不责於人。有德司契，无德司彻。天道无亲常与善人。</p>
<p>80.小国寡民。使有什伯之器而不用。使民重死而不远徙。虽有舟舆无所乘之。虽有甲兵无所陈之。使民复结绳而用之。甘其食、美其服、安其居、乐其俗。邻国相望，鸡犬之声相闻。民至老死不相往来。</p>
<p>81.信言不美。美言不信。善者不辩。辩者不善。知者不博。博者不知。圣人不积。既以为人己愈有。既以与人己愈多。天之道利而不害。圣人之道为而不争。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
</search>
